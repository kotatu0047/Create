!function(t){var l={};function e(n){if(l[n])return l[n].exports;var c=l[n]={i:n,l:!1,exports:{}};return t[n].call(c.exports,c,c.exports,e),c.l=!0,c.exports}e.m=t,e.c=l,e.d=function(t,l,n){e.o(t,l)||Object.defineProperty(t,l,{enumerable:!0,get:n})},e.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},e.t=function(t,l){if(1&l&&(t=e(t)),8&l)return t;if(4&l&&"object"==typeof t&&t&&t.__esModule)return t;var n=Object.create(null);if(e.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:t}),2&l&&"string"!=typeof t)for(var c in t)e.d(n,c,function(l){return t[l]}.bind(null,c));return n},e.n=function(t){var l=t&&t.__esModule?function(){return t.default}:function(){return t};return e.d(l,"a",l),l},e.o=function(t,l){return Object.prototype.hasOwnProperty.call(t,l)},e.p="/js/",e(e.s=0)}([function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: ./node_modules/@createjs/core/src/events/Event.js\n/**\n * @license Event\n * Visit http://createjs.com/ for documentation, updates and examples.\n *\n * Copyright (c) 2017 gskinner.com, inc.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the "Software"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * Contains properties and methods shared by all events for use with {@link core.EventDispatcher}.\n * Note that Event objects are often reused, so you should never\n * rely on an event object\'s state outside of the call stack it was received in.\n *\n * @memberof core\n * @example\n * const evt = new Event("myEvent");\n * const dispatcher = new EventDispatcher();\n * dispatcher.on("myEvent", event => console.log(event.type));\n * dispatcher.dispatchEvent(evt); // logs "myEvent"\n *\n * @param {string} type The event type.\n * @param {boolean} [bubbles=false] Indicates whether the event will bubble through the display list.\n * @param {boolean} [cancelable=false] Indicates whether the default behaviour of this event can be cancelled.\n */\nclass Event {\n\n\tconstructor (type, bubbles = false, cancelable = false) {\n\t\t/**\n\t\t * The type of event.\n\t\t * @type string\n\t\t */\n\t\tthis.type = type;\n\n\t\t/**\n\t\t * The object that generated an event.\n\t\t *\n\t\t * @type Object\n\t\t * @default null\n\t\t * @readonly\n\t\t */\n\t\tthis.target = null;\n\n\t\t/**\n\t\t * The current target that a bubbling event is being dispatched from. For non-bubbling events, this will\n\t\t * always be the same as target. For example, if childObj.parent = parentObj, and a bubbling event\n\t\t * is generated from childObj, then a listener on parentObj would receive the event with\n\t\t * target=childObj (the original target) and currentTarget=parentObj (where the listener was added).\n\t\t *\n\t\t * @type Object\n\t\t * @default null\n\t\t * @readonly\n\t\t */\n\t\tthis.currentTarget = null;\n\n\t\t/**\n\t\t * For bubbling events, this indicates the current event phase:\n\t\t * <OL>\n\t\t * \t<LI> capture phase: starting from the top parent to the target</LI>\n\t\t * \t<LI> at target phase: currently being dispatched from the target</LI>\n\t\t * \t<LI> bubbling phase: from the target to the top parent</LI>\n\t\t * </OL>\n\t\t *\n\t\t * @type number\n\t\t * @default 0\n\t\t * @readonly\n\t\t */\n\t\tthis.eventPhase = 0;\n\n\t\t/**\n\t\t * Indicates whether the event will bubble through the display list.\n\t\t *\n\t\t * @type boolean\n\t\t * @readonly\n\t\t */\n\t\tthis.bubbles = bubbles;\n\n\t\t/**\n\t\t * Indicates whether the default behaviour of this event can be cancelled via {@link core.Event#preventDefault}.\n\t\t *\n\t\t * @type boolean\n\t\t * @readonly\n\t\t */\n\t\tthis.cancelable = cancelable;\n\n\t\t/**\n\t\t * The epoch time at which this event was created.\n\t\t *\n\t\t * @type number\n\t\t * @readonly\n\t\t */\n\t\tthis.timeStamp = new Date().getTime();\n\n\t\t/**\n\t\t * Indicates if {@link core.Event#preventDefault} has been called on this event.\n\t\t *\n\t\t * @type boolean\n\t\t * @default false\n\t\t * @readonly\n\t\t */\n\t\tthis.defaultPrevented = false;\n\n\t\t/**\n\t\t * Indicates if {@link core.Event#stopPropagation} or {@link core.Event#stopImmediatePropagation} has been called on this event.\n\t\t *\n\t\t * @type boolean\n\t\t * @default false\n\t\t * @readonly\n\t\t */\n\t\tthis.propagationStopped = false;\n\n\t\t/**\n\t\t * Indicates if {@link core.Event#stopImmediatePropagation} has been called on this event.\n\t\t *\n\t\t * @type boolean\n\t\t * @default false\n\t\t * @readonly\n\t\t */\n\t\tthis.immediatePropagationStopped = false;\n\n\t\t/**\n\t\t * Indicates if {@link core.Event#remove} has been called on this event.\n\t\t *\n\t\t * @type boolean\n\t\t * @default false\n\t\t * @readonly\n\t\t */\n\t\tthis.removed = false;\n\t}\n\n\t/**\n\t * Sets {@link core.Event#defaultPrevented} to true if the event is cancelable.\n\t * Mirrors the DOM level 2 event standard. In general, cancelable events that have `preventDefault()` called will\n\t * cancel the default behaviour associated with the event.\n\t * @return {core.Event} this, chainable\n\t */\n\tpreventDefault () {\n\t\tthis.defaultPrevented = this.cancelable;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sets {@link core.Event#propagationStopped} to true.\n\t * Mirrors the DOM event standard.\n\t * @return {core.Event} this, chainable\n\t */\n\tstopPropagation () {\n\t\tthis.propagationStopped = true;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sets {@link core.Event#propagationStopped} and {@link core.Event#immediatePropagationStopped} to true.\n\t * Mirrors the DOM event standard.\n\t * @return {core.Event} this, chainable\n\t */\n\tstopImmediatePropagation () {\n\t\tthis.immediatePropagationStopped = this.propagationStopped = true;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Causes the active listener to be removed via removeEventListener();\n\t *\n\t * @example\n\t * myBtn.addEventListener("click", event => {\n\t *   event.remove(); // removes this listener.\n\t * });\n\t *\n\t * @return {core.Event} this, chainable\n\t */\n\tremove () {\n\t\tthis.removed = true;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns a clone of the Event instance.\n\t *\n\t * @return {core.Event} a clone of the Event instance.\n\t */\n\tclone () {\n\t\tconst event = new Event(this.type, this.bubbles, this.cancelable);\n\t\tfor (let n in this) {\n\t\t\tif (this.hasOwnProperty(n)) {\n\t\t\t\tevent[n] = this[n];\n\t\t\t}\n\t\t}\n\t\treturn event;\n\t}\n\n\t/**\n\t * Provides a return {core.Event} this, chainable shortcut method for setting a number of properties on the instance.\n\t *\n\t * @param {Object} props A generic object containing properties to copy to the instance.\n\t * @return {core.Event} this, chainable\n\t */\n\tset (props) {\n\t\tfor (let n in props) { this[n] = props[n]; }\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns a string representation of this object.\n\t *\n\t * @return {string} A string representation of the instance.\n\t */\n\ttoString () {\n\t\treturn `[${this.constructor.name} (type=${this.type})]`;\n\t}\n\n}\n\n/* harmony default export */ var events_Event = (Event);\n\n// CONCATENATED MODULE: ./node_modules/@createjs/core/src/events/EventDispatcher.js\n/**\n * @license EventDispatcher\n * Visit http://createjs.com/ for documentation, updates and examples.\n *\n * Copyright (c) 2017 gskinner.com, inc.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the "Software"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n\n\n/**\n * EventDispatcher provides methods for managing queues of event listeners and dispatching events.\n *\n * You can either extend EventDispatcher or mix its methods into an existing prototype or instance by using the\n * EventDispatcher {@link core.EventDispatcher.initialize} method.\n *\n * Together with the CreateJS Event class, EventDispatcher provides an extended event model that is based on the\n * DOM Level 2 event model, including addEventListener, removeEventListener, and dispatchEvent. It supports\n * bubbling / capture, preventDefault, stopPropagation, stopImmediatePropagation, and handleEvent.\n *\n * EventDispatcher also exposes a {@link core.EventDispatcher#on} method, which makes it easier\n * to create scoped listeners, listeners that only run once, and listeners with associated arbitrary data. The\n * {@link core.EventDispatcher#off} method is merely an alias to {@link core.EventDispatcher#removeEventListener}.\n *\n * Another addition to the DOM Level 2 model is the {@link core.EventDispatcher#removeAllEventListeners}\n * method, which can be used to listeners for all events, or listeners for a specific event. The Event object also\n * includes a {@link core.Event#remove} method which removes the active listener.\n *\n * @memberof core\n * @example\n * // add EventDispatcher capabilities to the "MyClass" class.\n * EventDispatcher.initialize(MyClass.prototype);\n *\n * // Add an event.\n * instance.addEventListener("eventName", event => console.log(event.target + " was clicked."));\n *\n * // scope ("this") can be be a challenge with events.\n * // using the {@link core.EventDispatcher#on} method to subscribe to events simplifies this.\n * instance.addEventListener("click", event => console.log(instance === this)); // false, scope is ambiguous.\n * instance.on("click", event => console.log(instance === this)); // true, `on` uses dispatcher scope by default.\n */\nclass EventDispatcher_EventDispatcher {\n\n\t/**\n\t * Static initializer to mix EventDispatcher methods into a target object or prototype.\n\t *\n\t * @static\n\t * @example\n\t * EventDispatcher.initialize(MyClass.prototype); // add to the prototype of the class\n\t * EventDispatcher.initialize(myInstance); // add to a specific instance\n\t *\n\t * @param {Object} target The target object to inject EventDispatcher methods into.\n\t */\n\tstatic initialize (target) {\n\t\tconst p = EventDispatcher_EventDispatcher.prototype;\n\t\ttarget.addEventListener = p.addEventListener;\n\t\ttarget.on = p.on;\n\t\ttarget.removeEventListener = target.off = p.removeEventListener;\n\t\ttarget.removeAllEventListeners = p.removeAllEventListeners;\n\t\ttarget.hasEventListener = p.hasEventListener;\n\t\ttarget.dispatchEvent = p.dispatchEvent;\n\t\ttarget._dispatchEvent = p._dispatchEvent;\n\t\ttarget.willTrigger = p.willTrigger;\n\t}\n\n\tconstructor () {\n\t\t/**\n\t\t * @private\n\t\t * @default null\n\t\t * @type Object\n\t\t */\n\t\tthis._listeners = null;\n\n\t\t/**\n\t\t * @private\n\t\t * @default null\n\t\t * @type Object\n\t\t */\n\t\tthis._captureListeners = null;\n\t}\n\n\t/**\n\t * Adds the specified event listener. Note that adding multiple listeners to the same function will result in\n\t * multiple callbacks getting fired.\n\t *\n\t * @example\n\t * displayObject.addEventListener("click", event => console.log(\'clicked\', event));\n\t *\n\t * @param {string} type The string type of the event.\n\t * @param {Function|Object} listener An object with a handleEvent method, or a function that will be called when the event is dispatched.\n\t * @param {boolean} [useCapture=false] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.\n\t * @return {Function|Object} Returns the listener for chaining or assignment.\n\t */\n\taddEventListener (type, listener, useCapture = false) {\n\t\tlet listeners;\n\t\tif (useCapture) {\n\t\t\tlisteners = this._captureListeners = this._captureListeners || {};\n\t\t} else {\n\t\t\tlisteners = this._listeners = this._listeners || {};\n\t\t}\n\t\tlet arr = listeners[type];\n\t\tif (arr) {\n\t\t\tthis.removeEventListener(type, listener, useCapture);\n\t\t\tarr = listeners[type]; // remove may have deleted the array\n\t\t}\n\t\tif (arr) { arr.push(listener);  }\n\t\telse { listeners[type] = [listener]; }\n\t\treturn listener;\n\t}\n\n\t/**\n\t * A shortcut method for using addEventListener that makes it easier to specify an execution scope, have a listener\n\t * only run once, associate arbitrary data with the listener, and remove the listener.\n\t *\n\t * This method works by creating an anonymous wrapper function and subscribing it with `addEventListener`.\n\t * The wrapper function is returned for use with `removeEventListener` (or `off`).\n\t *\n\t * To remove a listener added with `on`, you must pass in the returned wrapper function as the listener, or use\n\t * {@link core.Event#remove}. Likewise, each time you call `on` a NEW wrapper function is subscribed, so multiple calls\n\t * to `on` with the same params will create multiple listeners.\n\t *\n\t * @example\n\t * const listener = myBtn.on("click", handleClick, null, false, { count: 3 });\n\t * function handleClick (evt, data) {\n\t *   data.count -= 1;\n\t *   console.log(this == myBtn); // true - scope defaults to the dispatcher\n\t *   if (data.count == 0) {\n\t *     alert("clicked 3 times!");\n\t *     myBtn.off("click", listener);\n\t *     // alternately: evt.remove();\n\t *   }\n\t * }\n\t *\n\t * @param {string} type The string type of the event.\n\t * @param {Function|Object} listener An object with a handleEvent method, or a function that will be called when the event is dispatched.\n\t * @param {Object} [scope=null] The scope to execute the listener in. Defaults to the dispatcher/currentTarget for function listeners, and to the listener itself for object listeners (ie. using handleEvent).\n\t * @param {boolean} [once=false] If true, the listener will remove itself after the first time it is triggered.\n\t * @param {*} [data={}] Arbitrary data that will be included as the second parameter when the listener is called.\n\t * @param {boolean} [useCapture=false] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.\n\t * @return {Function} Returns the anonymous function that was created and assigned as the listener. This is needed to remove the listener later using .removeEventListener.\n\t */\n\ton (type, listener, scope = null, once = false, data = {}, useCapture = false) {\n\t\tif (listener.handleEvent) {\n\t\t\tscope = scope || listener;\n\t\t\tlistener = listener.handleEvent;\n\t\t}\n\t\tscope = scope || this;\n\t\treturn this.addEventListener(type, evt => {\n\t\t\tlistener.call(scope, evt, data);\n\t\t\tonce && evt.remove();\n\t\t}, useCapture);\n\t}\n\n\t/**\n\t * Removes the specified event listener.\n\t *\n\t * You must pass the exact function reference used when the event was added. If a proxy\n\t * function, or function closure is used as the callback, the proxy/closure reference must be used - a new proxy or\n\t * closure will not work.\n\t *\n\t * @example\n\t * displayObject.removeEventListener("click", handleClick);\n\t *\n\t * @param {string} type The string type of the event.\n\t * @param {Function|Object} listener The listener function or object.\n\t * @param {boolean} [useCapture=false] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.\n\t */\n\tremoveEventListener (type, listener, useCapture = false) {\n\t\tconst listeners = useCapture ? this._captureListeners : this._listeners;\n\t\tif (!listeners) { return; }\n\t\tconst arr = listeners[type];\n\t\tif (!arr) { return; }\n\t\tconst l = arr.length;\n\t\tfor (let i = 0; i < l; i++) {\n\t\t\tif (arr[i] === listener) {\n\t\t\t\tif (l === 1) { delete(listeners[type]); } // allows for faster checks.\n\t\t\t\telse { arr.splice(i, 1); }\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * A shortcut to the removeEventListener method, with the same parameters and return value. This is a companion to the\n\t * `on` method.\n\t *\n\t * To remove a listener added with `on`, you must pass in the returned wrapper function as the listener. See\n\t * {@link core.EventDispatcher#on} for an example.\n\t *\n\t * @param {string} type The string type of the event.\n\t * @param {Function|Object} listener The listener function or object.\n\t * @param {boolean} [useCapture=false] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.\n\t */\n\toff (type, listener, useCapture = false) {\n\t\tthis.removeEventListener(type, listener, useCapture);\n\t}\n\n\t/**\n\t * Removes all listeners for the specified type, or all listeners of all types.\n\t *\n\t * @example\n\t * // remove all listeners\n\t * displayObject.removeAllEventListeners();\n\t *\n\t * // remove all click listeners\n\t * displayObject.removeAllEventListeners("click");\n\t *\n\t * @param {string} [type=null] The string type of the event. If omitted, all listeners for all types will be removed.\n\t */\n\tremoveAllEventListeners (type = null) {\n\t\tif (type) {\n\t\t\tif (this._listeners) { delete(this._listeners[type]); }\n\t\t\tif (this._captureListeners) { delete(this._captureListeners[type]); }\n\t\t} else {\n\t\t\tthis._listeners = this._captureListeners = null;\n\t\t}\n\t}\n\n\t/**\n\t * Dispatches the specified event to all listeners.\n\t *\n\t * @example\n\t * // use a string event\n\t * this.dispatchEvent("complete")\n\t *\n\t * // use an Event instance\n\t * const event = new createjs.Event("progress");\n\t * this.dispatchEvent(event);\n\t *\n\t * @param {Object|Event|string} eventObj An object with a "type" property, or a string type.\n\t * While a generic object will work, it is recommended to use a CreateJS Event instance. If a string is used,\n\t * dispatchEvent will construct an Event instance if necessary with the specified type. This latter approach can\n\t * be used to avoid event object instantiation for non-bubbling events that may not have any listeners.\n\t * @param {boolean} [bubbles=false] Specifies the `bubbles` value when a string was passed to eventObj.\n\t * @param {boolean} [cancelable=false] Specifies the `cancelable` value when a string was passed to eventObj.\n\t * @return {boolean} Returns false if `preventDefault()` was called on a cancelable event, true otherwise.\n\t */\n\tdispatchEvent (eventObj, bubbles = false, cancelable = false) {\n\t\tif (typeof eventObj === "string") {\n\t\t\t// skip everything if there\'s no listeners and it doesn\'t bubble:\n\t\t\tconst listeners = this._listeners;\n\t\t\tif (!bubbles && (!listeners || !listeners[eventObj])) { return true; }\n\t\t\teventObj = new events_Event(eventObj, bubbles, cancelable);\n\t\t} else if (eventObj.target && eventObj.clone) {\n\t\t\t// redispatching an active event object, so clone it:\n\t\t\teventObj = eventObj.clone();\n\t\t}\n\n\t\t// TODO: it would be nice to eliminate this. Maybe in favour of evtObj instanceof Event? Or !!evtObj.createEvent\n\t\ttry { eventObj.target = this; } catch (e) {} // try/catch allows redispatching of native events\n\n\t\tif (!eventObj.bubbles || !this.parent) {\n\t\t\tthis._dispatchEvent(eventObj, 2);\n\t\t} else {\n\t\t\tlet top = this;\n\t\t\tconst list = [top];\n\t\t\twhile (top.parent) { list.push(top = top.parent); }\n\t\t\tconst l = list.length;\n\t\t\tlet i;\n\n\t\t\t// capture & atTarget\n\t\t\tfor (i = l - 1; i >= 0 && !eventObj.propagationStopped; i--) {\n\t\t\t\tlist[i]._dispatchEvent(eventObj, 1+(i==0));\n\t\t\t}\n\t\t\t// bubbling\n\t\t\tfor (i = 1; i < l && !eventObj.propagationStopped; i++) {\n\t\t\t\tlist[i]._dispatchEvent(eventObj, 3);\n\t\t\t}\n\t\t}\n\t\treturn !eventObj.defaultPrevented;\n\t}\n\n\t/**\n\t * Indicates whether there is at least one listener for the specified event type.\n\t *\n\t * @param {string} type The string type of the event.\n\t * @return {boolean} Returns true if there is at least one listener for the specified event.\n\t */\n\thasEventListener (type) {\n\t\tconst listeners = this._listeners, captureListeners = this._captureListeners;\n\t\treturn !!((listeners && listeners[type]) || (captureListeners && captureListeners[type]));\n\t}\n\n\t/**\n\t * Indicates whether there is at least one listener for the specified event type on this object or any of its\n\t * ancestors (parent, parent\'s parent, etc). A return value of true indicates that if a bubbling event of the\n\t * specified type is dispatched from this object, it will trigger at least one listener.\n\t *\n\t * This is similar to {@link core.EventDispatcher#hasEventListener}, but it searches the entire\n\t * event flow for a listener, not just this object.\n\t *\n\t * @param {string} type The string type of the event.\n\t * @return {boolean} Returns `true` if there is at least one listener for the specified event.\n\t */\n\twillTrigger (type) {\n\t\tlet o = this;\n\t\twhile (o) {\n\t\t\tif (o.hasEventListener(type)) { return true; }\n\t\t\to = o.parent;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @return {String} a string representation of the instance.\n\t */\n\ttoString () {\n\t\treturn `[${this.constructor.name + this.name ? ` ${this.name}` : ""}]`;\n\t}\n\n\t/**\n\t * @private\n\t * @param {Object|Event|string} eventObj\n\t * @param {Object} eventPhase\n\t */\n\t_dispatchEvent (eventObj, eventPhase) {\n\t\tconst listeners = eventPhase === 1 ? this._captureListeners : this._listeners;\n\t\tif (eventObj && listeners) {\n\t\t\tlet arr = listeners[eventObj.type];\n\t\t\tlet l;\n\t\t\tif (!arr || (l = arr.length) === 0) { return; }\n\t\t\ttry { eventObj.currentTarget = this; } catch (e) {}\n\t\t\ttry { eventObj.eventPhase = eventPhase; } catch (e) {}\n\t\t\teventObj.removed = false;\n\n\t\t\tarr = arr.slice(); // to avoid issues with items being removed or added during the dispatch\n\t\t\tfor (let i = 0; i < l && !eventObj.immediatePropagationStopped; i++) {\n\t\t\t\tlet o = arr[i];\n\t\t\t\tif (o.handleEvent) { o.handleEvent(eventObj); }\n\t\t\t\telse { o(eventObj); }\n\t\t\t\tif (eventObj.removed) {\n\t\t\t\t\tthis.off(eventObj.type, o, eventPhase === 1);\n\t\t\t\t\teventObj.removed = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\n\n/* harmony default export */ var events_EventDispatcher = (EventDispatcher_EventDispatcher);\n\n// CONCATENATED MODULE: ./node_modules/@createjs/core/src/utils/Ticker.js\n/**\n * @license Ticker\n * Visit http://createjs.com/ for documentation, updates and examples.\n *\n * Copyright (c) 2017 gskinner.com, inc.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the "Software"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n\n\n\n/**\n * The Ticker provides a centralized tick or heartbeat broadcast at a set interval. Listeners can subscribe to the tick\n * event to be notified when a set time interval has elapsed.\n *\n * Note that the interval that the tick event is called is a target interval, and may be broadcast at a slower interval\n * when under high CPU load. The Ticker class uses a static interface (ex. `Ticker.framerate = 30;`) and\n * can not be instantiated.\n *\n * @todo Pass timingMode, maxDelta, paused values as instantiation arguments?\n *\n * @memberof core\n * @example\n * Ticker.addEventListener("tick", event => {\n *   // Actions carried out each tick (aka frame)\n *   if (!event.paused) {\n *     // Actions carried out when the Ticker is not paused.\n *   }\n * });\n * @example\n * // Ticker export explanation\n * import Ticker, { Ticker as TickerClass, getTicker } from "@createjs/core";\n * Ticker.name, Ticker.RAF // -> createjs.global, undefined\n * TickerClass.RAF // -> raf\n * Ticker === getTicker("createjs.global") // -> true\n *\n * @extends core.EventDispatcher\n * @param {string} name The name assigned to this instance.\n */\nclass Ticker_Ticker extends events_EventDispatcher {\n\n\t/**\n\t * In this mode, Ticker uses the requestAnimationFrame API, but attempts to synch the ticks to target framerate. It\n\t * uses a simple heuristic that compares the time of the RAF return to the target time for the current frame and\n\t * dispatches the tick when the time is within a certain threshold.\n\t *\n\t * This mode has a higher variance for time between frames than {{#crossLink "Ticker/TIMEOUT:property"}}{{/crossLink}},\n\t * but does not require that content be time based as with {{#crossLink "Ticker/RAF:property"}}{{/crossLink}} while\n\t * gaining the benefits of that API (screen synch, background throttling).\n\t *\n\t * Variance is usually lowest for framerates that are a divisor of the RAF frequency. This is usually 60, so\n\t * framerates of 10, 12, 15, 20, and 30 work well.\n\t *\n\t * Falls back to {{#crossLink "Ticker/TIMEOUT:property"}}{{/crossLink}} if the requestAnimationFrame API is not\n\t * supported.\n\t *\n\t * @static\n\t * @type {string}\n\t * @default "synched"\n\t * @readonly\n\t */\n\tstatic get RAF_SYNCHED () { return "synched"; }\n\n\t/**\n\t * In this mode, Ticker passes through the requestAnimationFrame heartbeat, ignoring the target framerate completely.\n\t * Because requestAnimationFrame frequency is not deterministic, any content using this mode should be time based.\n\t * You can leverage {@link core.Ticker#getTime} and the {@link core.Ticker#event:tick}\n\t * event object\'s "delta" properties to make this easier.\n\t *\n\t * Falls back on {@link core.Ticker.TIMEOUT} if the requestAnimationFrame API is not supported.\n\t *\n\t * @static\n\t * @type {string}\n\t * @default "raf"\n\t * @readonly\n\t */\n\tstatic get RAF () { return "raf"; }\n\n\t/**\n\t * In this mode, Ticker uses the setTimeout API. This provides predictable, adaptive frame timing, but does not\n\t * provide the benefits of requestAnimationFrame (screen synch, background throttling).\n\t *\n\t * @static\n\t * @type {string}\n\t * @default "timeout"\n\t * @readonly\n\t */\n\tstatic get TIMEOUT () { return "timeout"; }\n\n\tconstructor (name) {\n\t\tsuper();\n\n\t\t/**\n\t\t * The name of this instance.\n\t\t * @type {string}\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * Specifies the timing api (setTimeout or requestAnimationFrame) and mode to use.\n\t\t *\n\t\t * @see {@link core.Ticker.TIMEOUT}\n\t\t * @see {@link core.Ticker.RAF}\n\t\t * @see {@link core.Ticker.RAF_SYNCHED}\n\t\t *\n\t\t * @type {string}\n\t\t * @default Ticker.TIMEOUT\n\t\t */\n\t\tthis.timingMode = Ticker_Ticker.TIMEOUT;\n\n\t\t/**\n\t\t * Specifies a maximum value for the delta property in the tick event object. This is useful when building time\n\t\t * based animations and systems to prevent issues caused by large time gaps caused by background tabs, system sleep,\n\t\t * alert dialogs, or other blocking routines. Double the expected frame duration is often an effective value\n\t\t * (ex. maxDelta=50 when running at 40fps).\n\t\t *\n\t\t * This does not impact any other values (ex. time, runTime, etc), so you may experience issues if you enable maxDelta\n\t\t * when using both delta and other values.\n\t\t *\n\t\t * If 0, there is no maximum.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.maxDelta = 0;\n\n\t\t/**\n\t\t * When the ticker is paused, all listeners will still receive a tick event, but the `paused` property\n\t\t * of the event will be `true`. Also, while paused the `runTime` will not increase.\n\t\t *\n\t\t * @example\n\t\t * Ticker.addEventListener("tick", event => console.log(event.paused, Ticker.getTime(false), Ticker.getTime(true)));\n\t\t * Ticker.paused = true;\n\t\t *\n\t\t * @see {@link core.Ticker#event:tick}\n\t\t * @see {@link core.Ticker#getTime}\n\t\t * @see {@link core.Ticker#getEventTime}\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.paused = false;\n\n\t\t/**\n\t\t * @private\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis._inited = false;\n\n\t\t/**\n\t\t * @private\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis._startTime = 0;\n\n\t\t/**\n\t\t * @private\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis._pausedTime = 0;\n\n\t\t/**\n\t\t * The number of ticks that have passed.\n\t\t *\n\t\t * @private\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis._ticks = 0;\n\n\t\t/**\n\t\t * The number of ticks that have passed while Ticker has been paused.\n\t\t *\n\t\t * @private\n\t\t * @type {number}\n\t\t * @default\n\t\t */\n\t\tthis._pausedTicks = 0;\n\n\t\t/**\n\t\t * @private\n\t\t * @type {number}\n\t\t * @default\n\t\t */\n\t\tthis._interval = 50;\n\n\t\t/**\n\t\t * @private\n\t\t * @type {number}\n\t\t * @default\n\t\t */\n\t\tthis._lastTime = 0;\n\n\t\t/**\n\t\t * @private\n\t\t * @type {Array}\n\t\t * @default null\n\t\t */\n\t\tthis._times = null;\n\n\t\t/**\n\t\t * @private\n\t\t * @type {Array}\n\t\t * @default null\n\t\t */\n\t\tthis._tickTimes = null;\n\n\t\t/**\n\t\t * Stores the timeout or requestAnimationFrame id.\n\t\t *\n\t\t * @private\n\t\t * @type {number}\n\t\t * @default null\n\t\t */\n\t\tthis._timerId = null;\n\n\t\t/**\n\t\t * True if currently using requestAnimationFrame, false if using setTimeout. This may be different than timingMode\n\t\t * if that property changed and a tick hasn\'t fired.\n\t\t *\n\t\t * @private\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis._raf = true;\n\t}\n\n\t/**\n\t * Indicates the target time (in milliseconds) between ticks. Default is 50 (20 FPS).\n\t * Note that actual time between ticks may be more than specified depending on CPU load.\n\t * This property is ignored if the ticker is using the `RAF` timing mode.\n\t *\n\t * @type {number}\n\t */\n\tget interval () { return this._interval; }\n\tset interval (interval) {\n\t\tthis._interval = interval;\n\t\tif (!this._inited) { return; }\n\t\tthis._setupTick();\n\t}\n\n\t/**\n\t * Indicates the target frame rate in frames per second (FPS). Effectively just a shortcut to `interval`, where\n\t * `framerate == 1000/interval`.\n\t *\n\t * @type {number}\n\t */\n\tget framerate () { return 1000 / this._interval; }\n\tset framerate (framerate) { this.interval = 1000 / framerate; }\n\n\t/**\n\t * Starts the tick. This is called automatically when the first listener is added.\n\t */\n\tinit () {\n\t\tif (this._inited) { return; }\n\t\tthis._inited = true;\n\t\tthis._times = [];\n\t\tthis._tickTimes = [];\n\t\tthis._startTime = this._getTime();\n\t\tthis._times.push(this._lastTime = 0);\n\t\tthis._setupTick();\n\t}\n\n\t/**\n\t * Stops the Ticker and removes all listeners. Use init() to restart the Ticker.\n\t */\n\treset () {\n\t\tif (this._raf) {\n\t\t\tlet f = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame || window.msCancelAnimationFrame;\n\t\t\tf && f(this._timerId);\n\t\t} else {\n\t\t\tclearTimeout(this._timerId);\n\t\t}\n\t\tthis.removeAllEventListeners("tick");\n\t\tthis._timerId = this._times = this._tickTimes = null;\n\t\tthis._startTime = this._lastTime = this._ticks = 0;\n\t\tthis._inited = false;\n\t}\n\n\t/**\n\t * Init the Ticker instance if it hasn\'t been already.\n\t */\n\taddEventListener (type, listener, useCapture) {\n\t\t!this._inited && this.init();\n\t\treturn super.addEventListener(type, listener, useCapture);\n\t}\n\n\t/**\n\t * Returns the average time spent within a tick. This can vary significantly from the value provided by getMeasuredFPS\n\t * because it only measures the time spent within the tick execution stack.\n\t *\n\t * Example 1: With a target FPS of 20, getMeasuredFPS() returns 20fps, which indicates an average of 50ms between\n\t * the end of one tick and the end of the next. However, getMeasuredTickTime() returns 15ms. This indicates that\n\t * there may be up to 35ms of "idle" time between the end of one tick and the start of the next.\n\t *\n\t * Example 2: With a target FPS of 30, getFPS() returns 10fps, which indicates an average of 100ms between the end of\n\t * one tick and the end of the next. However, getMeasuredTickTime() returns 20ms. This would indicate that something\n\t * other than the tick is using ~80ms (another script, DOM rendering, etc).\n\t *\n\t * @param {number} [ticks=null] The number of previous ticks over which to measure the average time spent in a tick.\n\t * Defaults to the number of ticks per second. To get only the last tick\'s time, pass in 1.\n\t * @return {number} The average time spent in a tick in milliseconds.\n\t */\n\tgetMeasuredTickTime (ticks = null) {\n\t\tconst times = this._tickTimes;\n\t\tif (!times || times.length < 1) { return -1; }\n\t\t// by default, calculate average for the past ~1 second:\n\t\tticks = Math.min(times.length, ticks || (this.framerate | 0));\n\t\treturn times.reduce((a, b) => a + b, 0) / ticks;\n\t}\n\n\t/**\n\t * Returns the actual frames / ticks per second.\n\t *\n\t * @param {number} [ticks=null] The number of previous ticks over which to measure the actual frames / ticks per second.\n\t * Defaults to the number of ticks per second.\n\t * @return {number} The actual frames / ticks per second. Depending on performance, this may differ\n\t * from the target frames per second.\n\t */\n\tgetMeasuredFPS (ticks = null) {\n\t\tconst times = this._times;\n\t\tif (!times || times.length < 2) { return -1; }\n\t\t// by default, calculate fps for the past ~1 second:\n\t\tticks = Math.min(times.length - 1, ticks || (this.framerate | 0));\n\t\treturn 1000 / ((times[0] - times[ticks]) / ticks);\n\t}\n\n\t/**\n\t * Returns the number of milliseconds that have elapsed since Ticker was initialized via {@link core.Ticker#init}.\n\t * Returns -1 if Ticker has not been initialized. For example, you could use\n\t * this in a time synchronized animation to determine the exact amount of time that has elapsed.\n\t *\n\t * @param {boolean} [runTime=false] If true only time elapsed while Ticker was not paused will be returned.\n\t * If false, the value returned will be total time elapsed since the first tick event listener was added.\n\t * @return {number} Number of milliseconds that have elapsed since Ticker was initialized or -1.\n\t */\n\tgetTime (runTime = false) {\n\t\treturn this._startTime ? this._getTime() - (runTime ? this._pausedTime : 0) : -1;\n\t}\n\n\t/**\n\t * Similar to {@link core.Ticker#getTime}, but returns the time on the most recent {@link core.Ticker#event:tick}\n\t * event object.\n\t *\n\t * @param {boolean} [runTime=false] If true, the runTime property will be returned instead of time.\n\t * @returns {number} The time or runTime property from the most recent tick event or -1.\n\t */\n\tgetEventTime (runTime = false) {\n\t\treturn this._startTime ? (this._lastTime || this._startTime) - (runTime ? this._pausedTime : 0) : -1;\n\t}\n\n\t/**\n\t * Returns the number of ticks that have been broadcast by Ticker.\n\t *\n\t * @param {boolean} [pauseable=false] Indicates whether to include ticks that would have been broadcast\n\t * while Ticker was paused. If true only tick events broadcast while Ticker is not paused will be returned.\n\t * If false, tick events that would have been broadcast while Ticker was paused will be included in the return\n\t * value.\n\t * @return {number} of ticks that have been broadcast.\n\t */\n\tgetTicks (pauseable = false) {\n\t\treturn this._ticks - (pauseable ? this._pausedTicks : 0);\n\t}\n\n\t/**\n\t * @private\n\t */\n\t_handleSynch () {\n\t\tthis._timerId = null;\n\t\tthis._setupTick();\n\n\t\t// run if enough time has elapsed, with a little bit of flexibility to be early:\n\t\tif (this._getTime() - this._lastTime >= (this._interval - 1) * 0.97) {\n\t\t\tthis._tick();\n\t\t}\n\t}\n\n\t/**\n\t * @private\n\t */\n\t_handleRAF () {\n\t\tthis._timerId = null;\n\t\tthis._setupTick();\n\t\tthis._tick();\n\t}\n\n\t/**\n\t * @private\n\t */\n\t_handleTimeout () {\n\t\tthis._timerId = null;\n\t\tthis._setupTick();\n\t\tthis._tick();\n\t}\n\n\t/**\n\t * @private\n\t */\n\t_setupTick () {\n\t\tif (this._timerId != null) { return; } // avoid duplicates\n\t\tconst mode = this.timingMode || (this._raf && Ticker_Ticker.RAF);\n\t\tif (mode === Ticker_Ticker.RAF_SYNCHED || mode === Ticker_Ticker.RAF) {\n\t\t\tconst f = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame;\n\t\t\tif (f) {\n\t\t\t\tthis._timerId = f(mode === Ticker_Ticker.RAF ? this._handleRAF.bind(this) : this._handleSynch.bind(this));\n\t\t\t\tthis._raf = true;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tthis._raf = false;\n\t\tthis._timerId = setTimeout(this._handleTimeout.bind(this), this._interval);\n\t}\n\n\t/**\n\t * @private\n\t * @emits core.Ticker#event:tick\n\t */\n\t_tick () {\n\t\tconst paused = this.paused, time = this._getTime(), elapsedTime = time - this._lastTime;\n\t\tthis._lastTime = time;\n\t\tthis._ticks++;\n\n\t\tif (paused) {\n\t\t\tthis._pausedTicks++;\n\t\t\tthis._pausedTime += elapsedTime;\n\t\t}\n\n\t\tif (this.hasEventListener("tick")) {\n\t\t\tconst event = new events_Event("tick");\n\t\t\tconst maxDelta = this.maxDelta;\n\t\t\tevent.delta = (maxDelta && elapsedTime > maxDelta) ? maxDelta : elapsedTime;\n\t\t\tevent.paused = paused;\n\t\t\tevent.time = time;\n\t\t\tevent.runTime = time - this._pausedTime;\n\t\t\tthis.dispatchEvent(event);\n\t\t}\n\n\t\tthis._tickTimes.unshift(this._getTime() - time);\n\t\twhile (this._tickTimes.length > 100) { this._tickTimes.pop(); }\n\n\t\tthis._times.unshift(time);\n\t\twhile (this._times.length > 100) { this._times.pop(); }\n\t}\n\n\t/**\n\t * @private\n\t */\n\t_getTime () {\n\t\tconst now = window.performance && window.performance.now;\n\t\treturn ((now && now.call(performance)) || (new Date().getTime())) - this._startTime;\n\t}\n\n\tstatic on (type, listener, scope, once, data, useCapture) { return _instance.on(type, listener, scope, once, data, useCapture); }\n\tstatic removeEventListener (type, listener, useCapture) { _instance.removeEventListener(type, listener, useCapture); }\n\tstatic off (type, listener, useCapture) { _instance.off(type, listener, useCapture); }\n\tstatic removeAllEventListeners (type) { _instance.removeAllEventListeners(type); }\n\tstatic dispatchEvent (eventObj, bubbles, cancelable) { return _instance.dispatchEvent(eventObj, bubbles, cancelable); }\n\tstatic hasEventListener (type) { return _instance.hasEventListener(type); }\n\tstatic willTrigger (type) { return _instance.willTrigger(type); }\n\tstatic toString () { return _instance.toString(); }\n\tstatic init () { _instance.init(); }\n\tstatic reset () { _instance.reset(); }\n\tstatic addEventListener (type, listener, useCapture) { _instance.addEventListener(type, listener, useCapture); }\n\tstatic getMeasuredTickTime (ticks) { return _instance.getMeasuredTickTime(ticks); }\n\tstatic getMeasuredFPS (ticks) { return _instance.getMeasuredFPS(ticks); }\n\tstatic getTime (runTime) { return _instance.getTime(runTime); }\n\tstatic getEventTime (runTime) { return _instance.getEventTime(runTime); }\n\tstatic getTicks (pauseable) { return _instance.getTicks(pauseable); }\n\n\tstatic get interval () { return _instance.interval; }\n\tstatic set interval (interval) { _instance.interval = interval; }\n\tstatic get framerate () { return _instance.framerate; }\n\tstatic set framerate (framerate) { _instance.framerate = framerate; }\n\tstatic get name () { return _instance.name; }\n\tstatic set name (name) { _instance.name = name; }\n\tstatic get timingMode () { return _instance.timingMode; }\n\tstatic set timingMode (timingMode) { _instance.timingMode = timingMode; }\n\tstatic get maxDelta () { return _instance.maxDelta; }\n\tstatic set maxDelta (maxDelta) { _instance.maxDelta = maxDelta; }\n\tstatic get paused () { return _instance.paused; }\n\tstatic set paused (paused) { _instance.paused = paused; }\n\n}\n\n/**\n * Dispatched each tick. The event will be dispatched to each listener even when the Ticker has been paused.\n *\n * @example\n * Ticker.addEventListener("tick", event => console.log("Paused:", event.paused, event.delta));\n *\n * @event core.Ticker#tick\n * @type {Object}\n * @property {Object} target The object that dispatched the event.\n * @property {string} type The event type.\n * @property {boolean} paused Indicates whether the ticker is currently paused.\n * @property {number} delta The time elapsed in ms since the last tick.\n * @property {number} time The total time in ms since Ticker was initialized.\n * @property {number} runTime The total time in ms that Ticker was not paused since it was initialized. For example,\n * you could determine the amount of time that the Ticker has been paused since initialization with `time-runTime`.\n * @since 0.6.0\n */\n\n/* harmony default export */ var utils_Ticker = (Ticker_Ticker);\n\n// the default Ticker instance\nconst _instance = new Ticker_Ticker("createjs.global");\n\n// CONCATENATED MODULE: ./node_modules/@createjs/core/src/main.js\n/**\n * The core classes of CreateJS.\n * @namespace core\n *\n * @example\n * import { EventDispatcher, Event } from "@createjs/core";\n * const dispatcher = new EventDispatcher();\n * dispatcher.on("myEvent", foo);\n * dispatcher.dispatchEvent(new Event("myEvent"));\n * // foo() is called.\n */\n\n// events\n\n\n// utils\n\n\n// CONCATENATED MODULE: ./node_modules/@createjs/easeljs/src/display/StageGL.js\n/**\n * @license\n *\n * StageGL\n * Visit http://createjs.com/ for documentation, updates and examples.\n *\n * Copyright (c) 2017 gskinner.com, inc.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the "Software"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\nclass StageGL {\n\tconstructor () {\n\t\tthrow new Error(`\n\t\t\tStageGL is not currently supported on the EaselJS 2.0 branch.\n\t\t\tEnd of Q1 2018 is targetted for StageGL support.\n\t\t\tFollow @CreateJS on Twitter for updates.\n\t\t`);\n\t}\n}\n\n/* harmony default export */ var display_StageGL = (StageGL);\n\n// CONCATENATED MODULE: ./node_modules/@createjs/easeljs/src/display/Shadow.js\n/**\n * @license Shadow\n * Visit http://createjs.com/ for documentation, updates and examples.\n *\n * Copyright (c) 2017 gskinner.com, inc.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the "Software"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * This class encapsulates the properties required to define a shadow to apply to a {@link easeljs.DisplayObject}\n * via its `shadow` property.\n *\n * @memberof easeljs\n * @example\n * img.shadow = new Shadow("#000000", 5, 5, 10);\n *\n * @param {String} [color=black] The color of the shadow. This can be any valid CSS color value.\n * @param {Number} [offsetX=0] The x offset of the shadow in pixels.\n * @param {Number} [offsetY=0] The y offset of the shadow in pixels.\n * @param {Number} [blur=0] The size of the blurring effect.\n */\nclass Shadow {\n\n\tconstructor (color = "black", offsetX = 0, offsetY = 0, blur = 0) {\n\t\t/**\n\t\t * The color of the shadow. This can be any valid CSS color value.\n\t\t * @type {String}\n\t\t * @default black\n\t\t */\n\t\tthis.color = color;\n\n\t\t/**\n\t\t * The x offset of the shadow.\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.offsetX = offsetX;\n\n\t\t/**\n\t\t * The y offset of the shadow.\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.offsetY = offsetY;\n\n\t\t/**\n\t\t * The blur of the shadow.\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.blur = blur;\n\t}\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @return {String}\n\t */\n\ttoString () {\n\t\treturn `[${this.constructor.name}]`;\n\t}\n\n\t/**\n\t * Returns a clone of this Shadow instance.\n\t * @return {Shadow} A clone of the current Shadow instance.\n\t */\n\tclone () {\n\t\treturn new Shadow(this.color, this.offsetX, this.offsetY, this.blur);\n\t}\n\n}\n\n/**\n * An identity shadow object (all properties are set to 0).\n * @type {easeljs.Shadow}\n * @static\n * @readonly\n */\nShadow.identity = new Shadow("transparent");\n\n// CONCATENATED MODULE: ./node_modules/@createjs/easeljs/src/utils/uid.js\n/**\n * @license uid\n * Visit http://createjs.com/ for documentation, updates and examples.\n *\n * Copyright (c) 2017 gskinner.com, inc.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the "Software"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/** @ignore */\nlet _nextId = 0;\n\n/**\n * Global utility for generating sequential unique ID numbers.\n *\n * @memberof easeljs\n * @name easeljs.uid\n * @example\n * import { uid } from "@createjs/easeljs";\n * var ids = [];\n * while (ids.length <= 3) {\n *   ids.push(uid());\n * }\n * // ids == [0, 1, 2, 3]\n */\nfunction uid () {\n\treturn _nextId++;\n}\n\n// CONCATENATED MODULE: ./node_modules/@createjs/easeljs/src/geom/Point.js\n/**\n * @license Point\n * Visit http://createjs.com/ for documentation, updates and examples.\n *\n * Copyright (c) 2017 gskinner.com, inc.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the "Software"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * Represents a point on a 2 dimensional x / y coordinate system.\n *\n * @memberof easeljs\n * @example\n * let point = new Point(0, 100);\n *\n * @param {Number} [x] X position.\n * @param {Number} [y] Y position.\n */\nclass Point {\n\n\tconstructor (x, y) {\n\t\tthis.setValues(x, y);\n\n\t\t// assigned in the setValues method.\n\t\t/**\n\t\t * X position.\n\t\t * @property x\n\t\t * @type {Number}\n\t\t */\n\n\t\t/**\n\t\t * Y position.\n\t\t * @property y\n\t\t * @type {Number}\n\t\t */\n\t}\n\n\t/**\n\t * Sets the specified values on this instance.\n\t * @param {Number} [x=0] X position.\n\t * @param {Number} [y=0] Y position.\n\t * @return {easeljs.Point} This instance. Useful for chaining method calls.\n\t * @chainable\n\t*/\n\tsetValues (x = 0, y = 0) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Copies all properties from the specified point to this point.\n\t * @param {easeljs.Point} point The point to copy properties from.\n\t * @return {easeljs.Point} This point. Useful for chaining method calls.\n\t * @chainable\n\t*/\n\tcopy (point) {\n\t\tthis.x = point.x;\n\t\tthis.y = point.y;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns a clone of the Point instance.\n\t * @return {easeljs.Point} a clone of the Point instance.\n\t */\n\tclone () {\n\t\treturn new Point(this.x, this.y);\n\t}\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @return {String} a string representation of the instance.\n\t */\n\ttoString () {\n\t\treturn `[${this.constructor.name} (x=${this.x} y=${this.y})]`;\n\t}\n\n}\n\n// CONCATENATED MODULE: ./node_modules/@createjs/easeljs/src/geom/Matrix2D.js\n/**\n * @license Matrix2D\n * Visit http://createjs.com/ for documentation, updates and examples.\n *\n * Copyright (c) 2017 gskinner.com, inc.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the "Software"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n\n\n/**\n * Represents an affine transformation matrix, and provides tools for constructing and concatenating matrices.\n *\n * <pre>\n * This matrix can be visualized as:\n *\n * \t[ a  c  tx\n * \t  b  d  ty\n * \t  0  0  1  ]\n *\n * Note the locations of b and c.\n * </pre>\n *\n * @param {Number} [a] Specifies the a property for the new matrix.\n * @param {Number} [b] Specifies the b property for the new matrix.\n * @param {Number} [c] Specifies the c property for the new matrix.\n * @param {Number} [d] Specifies the d property for the new matrix.\n * @param {Number} [tx] Specifies the tx property for the new matrix.\n * @param {Number} [ty] Specifies the ty property for the new matrix.\n */\nclass Matrix2D_Matrix2D {\n\n\tconstructor (a, b, c, d, tx, ty) {\n\t\tthis.setValues(a, b, c, d, tx, ty);\n\n\t\t// assigned in the setValues method.\n\t\t/**\n\t\t * Position (0, 0) in a 3x3 affine transformation matrix.\n\t\t * @property a\n\t\t * @type {Number}\n\t\t */\n\n\t\t/**\n\t\t * Position (0, 1) in a 3x3 affine transformation matrix.\n\t\t * @property b\n\t\t * @type {Number}\n\t\t */\n\n\t\t/**\n\t\t * Position (1, 0) in a 3x3 affine transformation matrix.\n\t\t * @property c\n\t\t * @type {Number}\n\t\t */\n\n\t\t/**\n\t\t * Position (1, 1) in a 3x3 affine transformation matrix.\n\t\t * @property d\n\t\t * @type {Number}\n\t\t */\n\n\t\t/**\n\t\t * Position (2, 0) in a 3x3 affine transformation matrix.\n\t\t * @property tx\n\t\t * @type {Number}\n\t\t */\n\n\t\t/**\n\t\t * Position (2, 1) in a 3x3 affine transformation matrix.\n\t\t * @property ty\n\t\t * @type {Number}\n\t\t */\n\t}\n\n\t/**\n\t * Sets the specified values on this instance.\n\t * @param {Number} [a=1] Specifies the a property for the new matrix.\n\t * @param {Number} [b=0] Specifies the b property for the new matrix.\n\t * @param {Number} [c=0] Specifies the c property for the new matrix.\n\t * @param {Number} [d=1] Specifies the d property for the new matrix.\n\t * @param {Number} [tx=0] Specifies the tx property for the new matrix.\n\t * @param {Number} [ty=0] Specifies the ty property for the new matrix.\n\t * @return {Matrix2D} This instance. Useful for chaining method calls.\n\t * @chainable\n\t*/\n\tsetValues (a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0) {\n\t\t// don\'t forget to update docs in the constructor if these change:\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t\tthis.c = c;\n\t\tthis.d = d;\n\t\tthis.tx = tx;\n\t\tthis.ty = ty;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Appends the specified matrix properties to this matrix. All parameters are required.\n\t * This is the equivalent of multiplying `(this matrix) * (specified matrix)`.\n\t * @param {Number} a\n\t * @param {Number} b\n\t * @param {Number} c\n\t * @param {Number} d\n\t * @param {Number} tx\n\t * @param {Number} ty\n\t * @return {easeljs.Matrix2D} This matrix. Useful for chaining method calls.\n\t * @chainable\n\t */\n\tappend (a, b, c, d, tx, ty) {\n\t\tlet a1 = this.a;\n\t\tlet b1 = this.b;\n\t\tlet c1 = this.c;\n\t\tlet d1 = this.d;\n\t\tif (a != 1 || b != 0 || c != 0 || d != 1) {\n\t\t\tthis.a  = a1*a+c1*b;\n\t\t\tthis.b  = b1*a+d1*b;\n\t\t\tthis.c  = a1*c+c1*d;\n\t\t\tthis.d  = b1*c+d1*d;\n\t\t}\n\t\tthis.tx = a1*tx+c1*ty+this.tx;\n\t\tthis.ty = b1*tx+d1*ty+this.ty;\n\t\treturn this;\n\t};\n\n\t/**\n\t * Prepends the specified matrix properties to this matrix.\n\t * This is the equivalent of multiplying `(specified matrix) * (this matrix)`.\n\t * @param {Number} a\n\t * @param {Number} b\n\t * @param {Number} c\n\t * @param {Number} d\n\t * @param {Number} tx\n\t * @param {Number} ty\n\t * @return {easeljs.Matrix2D} This matrix. Useful for chaining method calls.\n\t * @chainable\n\t */\n\tprepend (a, b, c, d, tx, ty) {\n\t\tlet a1 = this.a;\n\t\tlet c1 = this.c;\n\t\tlet tx1 = this.tx;\n\n\t\tthis.a  = a*a1+c*this.b;\n\t\tthis.b  = b*a1+d*this.b;\n\t\tthis.c  = a*c1+c*this.d;\n\t\tthis.d  = b*c1+d*this.d;\n\t\tthis.tx = a*tx1+c*this.ty+tx;\n\t\tthis.ty = b*tx1+d*this.ty+ty;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Appends the specified matrix to this matrix.\n\t * This is the equivalent of multiplying `(this matrix) * (specified matrix)`.\n\t * @param {easeljs.Matrix2D} matrix\n\t * @return {easeljs.Matrix2D} This matrix. Useful for chaining method calls.\n\t * @chainable\n\t */\n\tappendMatrix (matrix) {\n\t\treturn this.append(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);\n\t}\n\n\t/**\n\t * Prepends the specified matrix to this matrix.\n\t * This is the equivalent of multiplying `(specified matrix) * (this matrix)`.\n\t *\n\t * @example <caption>Calculate the combined transformation for a child object</caption>\n\t * let o = displayObject;\n\t * let mtx = o.getMatrix();\n\t * while (o = o.parent) {\n\t * \t // prepend each parent\'s transformation in turn:\n\t * \t o.prependMatrix(o.getMatrix());\n\t * }\n\t *\n\t * @param {easeljs.Matrix2D} matrix\n\t * @return {easeljs.Matrix2D} This matrix. Useful for chaining method calls.\n\t * @chainable\n\t */\n\tprependMatrix (matrix) {\n\t\treturn this.prepend(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);\n\t}\n\n\t/**\n\t * Generates matrix properties from the specified display object transform properties, and appends them to this matrix.\n\t *\n\t * @example <caption>Generate a matrix representing the transformations of a display object</caption>\n\t * let mtx = new Matrix2D();\n\t * mtx.appendTransform(o.x, o.y, o.scaleX, o.scaleY, o.rotation);\n\t *\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} scaleX\n\t * @param {Number} scaleY\n\t * @param {Number} rotation\n\t * @param {Number} skewX\n\t * @param {Number} skewY\n\t * @param {Number} [regX]\n\t * @param {Number} [regY]\n\t * @return {easeljs.Matrix2D} This matrix. Useful for chaining method calls.\n\t * @chainable\n\t */\n\tappendTransform (x, y, scaleX, scaleY, rotation, skewX, skewY, regX, regY) {\n\t\tlet r, cos, sin;\n\t\tif (rotation%360) {\n\t\t\tr = rotation*Matrix2D_Matrix2D.DEG_TO_RAD;\n\t\t\tcos = Math.cos(r);\n\t\t\tsin = Math.sin(r);\n\t\t} else {\n\t\t\tcos = 1;\n\t\t\tsin = 0;\n\t\t}\n\n\t\tif (skewX || skewY) {\n\t\t\t// TODO: can this be combined into a single append operation?\n\t\t\tskewX *= Matrix2D_Matrix2D.DEG_TO_RAD;\n\t\t\tskewY *= Matrix2D_Matrix2D.DEG_TO_RAD;\n\t\t\tthis.append(Math.cos(skewY), Math.sin(skewY), -Math.sin(skewX), Math.cos(skewX), x, y);\n\t\t\tthis.append(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, 0, 0);\n\t\t} else {\n\t\t\tthis.append(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, x, y);\n\t\t}\n\n\t\tif (regX || regY) {\n\t\t\t// append the registration offset:\n\t\t\tthis.tx -= regX*this.a+regY*this.c;\n\t\t\tthis.ty -= regX*this.b+regY*this.d;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Generates matrix properties from the specified display object transform properties, and prepends them to this matrix.\n\t *\n\t * Note that the above example would not account for {@link easeljs.DisplayObject#transformMatrix} values.\n\t * See {@link easeljs.Matrix2D#prependMatrix} for an example that does.\n\t *\n\t * @example <caption>Calculate the combined transformation for a child object</caption>\n\t * let o = displayObject;\n\t * let mtx = new Matrix2D();\n\t * do  {\n\t * \t // prepend each parent\'s transformation in turn:\n\t * \t mtx.prependTransform(o.x, o.y, o.scaleX, o.scaleY, o.rotation, o.skewX, o.skewY, o.regX, o.regY);\n\t * } while (o = o.parent);\n\t *\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} scaleX\n\t * @param {Number} scaleY\n\t * @param {Number} rotation\n\t * @param {Number} skewX\n\t * @param {Number} skewY\n\t * @param {Number} [regX]\n\t * @param {Number} [regY]\n\t * @return {easeljs.Matrix2D} This matrix. Useful for chaining method calls.\n\t */\n\tprependTransform (x, y, scaleX, scaleY, rotation, skewX, skewY, regX, regY) {\n\t\tlet r, cos, sin;\n\t\tif (rotation%360) {\n\t\t\tr = rotation*Matrix2D_Matrix2D.DEG_TO_RAD;\n\t\t\tcos = Math.cos(r);\n\t\t\tsin = Math.sin(r);\n\t\t} else {\n\t\t\tcos = 1;\n\t\t\tsin = 0;\n\t\t}\n\n\t\tif (regX || regY) {\n\t\t\t// prepend the registration offset:\n\t\t\tthis.tx -= regX; this.ty -= regY;\n\t\t}\n\t\tif (skewX || skewY) {\n\t\t\t// TODO: can this be combined into a single prepend operation?\n\t\t\tskewX *= Matrix2D_Matrix2D.DEG_TO_RAD;\n\t\t\tskewY *= Matrix2D_Matrix2D.DEG_TO_RAD;\n\t\t\tthis.prepend(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, 0, 0);\n\t\t\tthis.prepend(Math.cos(skewY), Math.sin(skewY), -Math.sin(skewX), Math.cos(skewX), x, y);\n\t\t} else {\n\t\t\tthis.prepend(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, x, y);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Applies a clockwise rotation transformation to the matrix.\n\t * @param {Number} angle The angle to rotate by, in degrees. To use a value in radians, multiply it by `Math.PI/180`.\n\t * @return {easeljs.Matrix2D} This matrix. Useful for chaining method calls.\n\t * @chainable\n\t */\n\trotate (angle) {\n\t\tangle *= Matrix2D_Matrix2D.DEG_TO_RAD;\n\t\tlet cos = Math.cos(angle);\n\t\tlet sin = Math.sin(angle);\n\n\t\tlet a1 = this.a;\n\t\tlet b1 = this.b;\n\n\t\tthis.a = a1*cos+this.c*sin;\n\t\tthis.b = b1*cos+this.d*sin;\n\t\tthis.c = -a1*sin+this.c*cos;\n\t\tthis.d = -b1*sin+this.d*cos;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Applies a skew transformation to the matrix.\n\t * @param {Number} skewX The amount to skew horizontally in degrees. To use a value in radians, multiply it by `Math.PI/180`.\n\t * @param {Number} skewY The amount to skew vertically in degrees.\n\t * @return {easeljs.Matrix2D} This matrix. Useful for chaining method calls.\n\t * @chainable\n\t*/\n\tskew (skewX, skewY) {\n\t\tskewX *= Matrix2D_Matrix2D.DEG_TO_RAD;\n\t\tskewY *= Matrix2D_Matrix2D.DEG_TO_RAD;\n\t\tthis.append(Math.cos(skewY), Math.sin(skewY), -Math.sin(skewX), Math.cos(skewX), 0, 0);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Applies a scale transformation to the matrix.\n\t * @param {Number} x The amount to scale horizontally. E.G. a value of 2 will double the size in the X direction, and 0.5 will halve it.\n\t * @param {Number} y The amount to scale vertically.\n\t * @return {easeljs.Matrix2D} This matrix. Useful for chaining method calls.\n\t * @chainable\n\t */\n\tscale (x, y) {\n\t\tthis.a *= x;\n\t\tthis.b *= x;\n\t\tthis.c *= y;\n\t\tthis.d *= y;\n\t\t//this.tx *= x;\n\t\t//this.ty *= y;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Translates the matrix on the x and y axes.\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @return {easeljs.Matrix2D} This matrix. Useful for chaining method calls.\n\t * @chainable\n\t */\n\ttranslate (x, y) {\n\t\tthis.tx += this.a*x + this.c*y;\n\t\tthis.ty += this.b*x + this.d*y;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sets the properties of the matrix to those of an identity matrix (one that applies a null transformation).\n\t * @return {easeljs.Matrix2D} This matrix. Useful for chaining method calls.\n\t * @chainable\n\t */\n\tidentity () {\n\t\tthis.a = this.d = 1;\n\t\tthis.b = this.c = this.tx = this.ty = 0;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Inverts the matrix, causing it to perform the opposite transformation.\n\t * @return {easeljs.Matrix2D} This matrix. Useful for chaining method calls.\n\t * @chainable\n\t */\n\tinvert () {\n\t\tlet a1 = this.a;\n\t\tlet b1 = this.b;\n\t\tlet c1 = this.c;\n\t\tlet d1 = this.d;\n\t\tlet tx1 = this.tx;\n\t\tlet n = a1*d1-b1*c1;\n\n\t\tthis.a = d1/n;\n\t\tthis.b = -b1/n;\n\t\tthis.c = -c1/n;\n\t\tthis.d = a1/n;\n\t\tthis.tx = (c1*this.ty-d1*tx1)/n;\n\t\tthis.ty = -(a1*this.ty-b1*tx1)/n;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns true if the matrix is an identity matrix.\n\t * @return {Boolean}\n\t */\n\tisIdentity () {\n\t\treturn this.tx === 0 && this.ty === 0 && this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1;\n\t}\n\n\t/**\n\t * Returns true if this matrix is equal to the specified matrix (all property values are equal).\n\t * @param {easeljs.Matrix2D} matrix The matrix to compare.\n\t * @return {Boolean}\n\t */\n\tequals (matrix) {\n\t\treturn this.tx === matrix.tx && this.ty === matrix.ty && this.a === matrix.a && this.b === matrix.b && this.c === matrix.c && this.d === matrix.d;\n\t}\n\n\t/**\n\t * Transforms a point according to this matrix.\n\t * @param {Number} x The x component of the point to transform.\n\t * @param {Number} y The y component of the point to transform.\n\t * @param {easeljs.Point | Object} [pt] An object to copy the result into. If omitted a generic object with x/y properties will be returned.\n\t * @return {easeljs.Point} This matrix. Useful for chaining method calls.\n\t */\n\ttransformPoint (x, y, pt = new Point()) {\n\t\tpt.x = x*this.a+y*this.c+this.tx;\n\t\tpt.y = x*this.b+y*this.d+this.ty;\n\t\treturn pt;\n\t}\n\n\t/**\n\t * Decomposes the matrix into transform properties (x, y, scaleX, scaleY, and rotation). Note that these values\n\t * may not match the transform properties you used to generate the matrix, though they will produce the same visual\n\t * results.\n\t * @param {Object} [target] The object to apply the transform properties to. If null, then a new object will be returned.\n\t * @return {Object} The target, or a new generic object with the transform properties applied.\n\t*/\n\tdecompose (target = {}) {\n\t\t// TODO: it would be nice to be able to solve for whether the matrix can be decomposed into only scale/rotation even when scale is negative\n\t\ttarget.x = this.tx;\n\t\ttarget.y = this.ty;\n\t\ttarget.scaleX = Math.sqrt(this.a * this.a + this.b * this.b);\n\t\ttarget.scaleY = Math.sqrt(this.c * this.c + this.d * this.d);\n\n\t\tlet skewX = Math.atan2(-this.c, this.d);\n\t\tlet skewY = Math.atan2(this.b, this.a);\n\n\t\tlet delta = Math.abs(1-skewX/skewY);\n\t\tif (delta < 0.00001) { // effectively identical, can use rotation:\n\t\t\ttarget.rotation = skewY/Matrix2D_Matrix2D.DEG_TO_RAD;\n\t\t\tif (this.a < 0 && this.d >= 0) {\n\t\t\t\ttarget.rotation += (target.rotation <= 0) ? 180 : -180;\n\t\t\t}\n\t\t\ttarget.skewX = target.skewY = 0;\n\t\t} else {\n\t\t\ttarget.skewX = skewX/Matrix2D_Matrix2D.DEG_TO_RAD;\n\t\t\ttarget.skewY = skewY/Matrix2D_Matrix2D.DEG_TO_RAD;\n\t\t}\n\t\treturn target;\n\t}\n\n\t/**\n\t * Copies all properties from the specified matrix to this matrix.\n\t * @param {easeljs.Matrix2D} matrix The matrix to copy properties from.\n\t * @return {easeljs.Matrix2D} This matrix. Useful for chaining method calls.\n\t * @chainable\n\t*/\n\tcopy (matrix) {\n\t\treturn this.setValues(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);\n\t}\n\n\t/**\n\t * Returns a clone of the Matrix2D instance.\n\t * @return {easeljs.Matrix2D} a clone of the Matrix2D instance.\n\t */\n\tclone () {\n\t\treturn new Matrix2D_Matrix2D(this.a, this.b, this.c, this.d, this.tx, this.ty);\n\t}\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @return {String} a string representation of the instance.\n\t */\n\ttoString () {\n\t\treturn `[${this.constructor.name} (a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty})]`;\n\t}\n\n}\n\n/**\n * Multiplier for converting degrees to radians. Used internally by Matrix2D.\n * @static\n * @type {Number}\n * @readonly\n */\nMatrix2D_Matrix2D.DEG_TO_RAD = Math.PI/180;\n/**\n * An identity matrix, representing a null transformation.\n * @static\n * @type {easeljs.Matrix2D}\n * @readonly\n */\nMatrix2D_Matrix2D.identity = new Matrix2D_Matrix2D();\n\n// CONCATENATED MODULE: ./node_modules/@createjs/easeljs/src/geom/DisplayProps.js\n/**\n * @license DisplayProps\n * Visit http://createjs.com/ for documentation, updates and examples.\n *\n * Copyright (c) 2017 gskinner.com, inc.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the "Software"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n\n\n/**\n * Used for calculating and encapsulating display related properties.\n * @memberof easeljs\n * @param {Number} [visible] Visible value.\n * @param {Number} [alpha] Alpha value.\n * @param {Number} [shadow] A Shadow instance or null.\n * @param {Number} [compositeOperation] A compositeOperation value or null.\n * @param {Number} [matrix] A transformation matrix. Defaults to a new identity matrix.\n */\nclass DisplayProps_DisplayProps {\n\n\tconstructor (visible, alpha, shadow, compositeOperation, matrix) {\n\t\tthis.setValues(visible, alpha, shadow, compositeOperation, matrix);\n\n\t\t// assigned in the setValues method.\n\t\t/**\n\t\t * Property representing the alpha that will be applied to a display object.\n\t\t * @property alpha\n\t\t * @type {Number}\n\t\t */\n\n\t\t/**\n\t\t * Property representing the shadow that will be applied to a display object.\n\t\t * @property shadow\n\t\t * @type {easeljs.Shadow}\n\t\t */\n\n\t\t/**\n\t\t * Property representing the compositeOperation that will be applied to a display object.\n\t\t * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Compositing}\n\t\t * @property compositeOperation\n\t\t * @type {String}\n\t\t */\n\n\t\t/**\n\t\t * Property representing the value for visible that will be applied to a display object.\n\t\t * @property visible\n\t\t * @type {Boolean}\n\t\t */\n\n\t\t/**\n\t\t * The transformation matrix that will be applied to a display object.\n\t\t * @property matrix\n\t\t * @type {easeljs.Matrix2D}\n\t\t */\n\t}\n\n\t/**\n\t * Reinitializes the instance with the specified values.\n\t * @param {Number} [visible=true] Visible value.\n\t * @param {Number} [alpha=1] Alpha value.\n\t * @param {Number} [shadow] A Shadow instance or null.\n\t * @param {Number} [compositeOperation] A compositeOperation value or null.\n\t * @param {Number} [matrix] A transformation matrix. Defaults to an identity matrix.\n\t * @return {easeljs.DisplayProps} This instance. Useful for chaining method calls.\n\t * @chainable\n\t*/\n\tsetValues (visible = true, alpha = 1, shadow, compositeOperation, matrix) {\n\t\tthis.visible = visible;\n\t\tthis.alpha = alpha;\n\t\tthis.shadow = shadow;\n\t\tthis.compositeOperation = compositeOperation;\n\t\tthis.matrix = matrix || (this.matrix&&this.matrix.identity()) || new Matrix2D_Matrix2D();\n\t\treturn this;\n\t}\n\n\t/**\n\t * Appends the specified display properties. This is generally used to apply a child\'s properties its parent\'s.\n\t * @param {Boolean} visible desired visible value\n\t * @param {Number} alpha desired alpha value\n\t * @param {easeljs.Shadow} shadow desired shadow value\n\t * @param {String} compositeOperation desired composite operation value\n\t * @param {easeljs.Matrix2D} [matrix] a Matrix2D instance\n\t * @return {easeljs.DisplayProps} This instance. Useful for chaining method calls.\n\t * @chainable\n\t*/\n\tappend (visible, alpha, shadow, compositeOperation, matrix) {\n\t\tthis.alpha *= alpha;\n\t\tthis.shadow = shadow || this.shadow;\n\t\tthis.compositeOperation = compositeOperation || this.compositeOperation;\n\t\tthis.visible = this.visible && visible;\n\t\tmatrix&&this.matrix.appendMatrix(matrix);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Prepends the specified display properties. This is generally used to apply a parent\'s properties to a child\'s.\n\t * For example, to get the combined display properties that would be applied to a child, you could use:\n\t *\n\t * @example\n\t * let o = displayObject;\n\t * let props = new DisplayProps();\n\t * do {\n\t * \t // prepend each parent\'s props in turn:\n\t * \t props.prepend(o.visible, o.alpha, o.shadow, o.compositeOperation, o.getMatrix());\n\t * } while (o = o.parent);\n\t *\n\t * @param {Boolean} visible desired visible value\n\t * @param {Number} alpha desired alpha value\n\t * @param {easeljs.Shadow} shadow desired shadow value\n\t * @param {String} compositeOperation desired composite operation value\n\t * @param {easeljs.Matrix2D} [matrix] a Matrix2D instance\n\t * @return {easeljs.DisplayProps} This instance. Useful for chaining method calls.\n\t * @chainable\n\t*/\n\tprepend (visible, alpha, shadow, compositeOperation, matrix) {\n\t\tthis.alpha *= alpha;\n\t\tthis.shadow = this.shadow || shadow;\n\t\tthis.compositeOperation = this.compositeOperation || compositeOperation;\n\t\tthis.visible = this.visible && visible;\n\t\tmatrix&&this.matrix.prependMatrix(matrix);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Resets this instance and its matrix to default values.\n\t * @return {easeljs.DisplayProps} This instance. Useful for chaining method calls.\n\t * @chainable\n\t*/\n\tidentity () {\n\t\tthis.visible = true;\n\t\tthis.alpha = 1;\n\t\tthis.shadow = this.compositeOperation = null;\n\t\tthis.matrix.identity();\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns a clone of the DisplayProps instance. Clones the associated matrix.\n\t * @return {easeljs.DisplayProps} a clone of the DisplayProps instance.\n\t */\n\tclone () {\n\t\treturn new DisplayProps_DisplayProps(this.alpha, this.shadow, this.compositeOperation, this.visible, this.matrix.clone());\n\t}\n\n}\n\n// CONCATENATED MODULE: ./node_modules/@createjs/easeljs/src/geom/Rectangle.js\n/**\n * @license Rectangle\n * Visit http://createjs.com/ for documentation, updates and examples.\n *\n * Copyright (c) 2017 gskinner.com, inc.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the "Software"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * Represents a rectangle as defined by the points (x, y) and (x+width, y+height).\n * Used by {@link easeljs.DisplayObjects#getBounds}.\n *\n * @memberof easeljs\n * @example\n * let rect = new Rectangle(0, 0, 100, 100);\n *\n * @param {Number} [x] X position.\n * @param {Number} [y] Y position.\n * @param {Number} [width] The width of the Rectangle.\n * @param {Number} [height] The height of the Rectangle.\n */\nclass Rectangle {\n\n\tconstructor (x, y, width, height) {\n\t\tthis.setValues(x, y, width, height);\n\n\t\t// assigned in the setValues method.\n\t\t/**\n\t\t * X position.\n\t\t * @property x\n\t\t * @type {Number}\n\t\t */\n\n\t\t/**\n\t\t * Y position.\n\t\t * @property y\n\t\t * @type {Number}\n\t\t */\n\n\t\t/**\n\t\t * Width.\n\t\t * @property width\n\t\t * @type {Number}\n\t\t */\n\n\t\t/**\n\t\t * Height.\n\t\t * @property height\n\t\t * @type {Number}\n\t\t */\n\t}\n\n\t/**\n\t * Sets the specified values on this instance.\n\t * @param {Number} [x=0] X position.\n\t * @param {Number} [y=0] Y position.\n\t * @param {Number} [width=0] The width of the Rectangle.\n\t * @param {Number} [height=0] The height of the Rectangle.\n\t * @return {easeljs.Rectangle} This instance. Useful for chaining method calls.\n\t * @chainable\n\t*/\n\tsetValues (x = 0, y = 0, width = 0, height = 0) {\n\t\t// don\'t forget to update docs in the constructor if these change:\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Extends the rectangle\'s bounds to include the described point or rectangle.\n\t * @param {Number} x X position of the point or rectangle.\n\t * @param {Number} y Y position of the point or rectangle.\n\t * @param {Number} [width=0] The width of the rectangle.\n\t * @param {Number} [height=0] The height of the rectangle.\n\t * @return {easeljs.Rectangle} This instance. Useful for chaining method calls.\n\t * @chainable\n\t*/\n\textend (x, y, width = 0, height = 0) {\n\t\tif (x+width > this.x+this.width) { this.width = x+width-this.x; }\n\t\tif (y+height > this.y+this.height) { this.height = y+height-this.y; }\n\t\tif (x < this.x) { this.width += this.x-x; this.x = x; }\n\t\tif (y < this.y) { this.height += this.y-y; this.y = y; }\n\t\treturn this;\n\t}\n\n\t/**\n\t * Adds the specified padding to the rectangle\'s bounds.\n\t * @param {Number} top\n\t * @param {Number} left\n\t * @param {Number} bottom\n\t * @param {Number} right\n\t * @return {easeljs.Rectangle} This instance. Useful for chaining method calls.\n\t * @chainable\n\t*/\n\tpad (top, left, bottom, right) {\n\t\tthis.x -= left;\n\t\tthis.y -= top;\n\t\tthis.width += left+right;\n\t\tthis.height += top+bottom;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Copies all properties from the specified rectangle to this rectangle.\n\t * @param {easeljs.Rectangle} rectangle The rectangle to copy properties from.\n\t * @return {easeljs.Rectangle} This rectangle. Useful for chaining method calls.\n\t * @chainable\n\t*/\n\tcopy (rect) {\n\t\treturn this.setValues(rect.x, rect.y, rect.width, rect.height);\n\t}\n\n\t/**\n\t * Returns true if this rectangle fully encloses the described point or rectangle.\n\t * @param {Number} x X position of the point or rectangle.\n\t * @param {Number} y Y position of the point or rectangle.\n\t * @param {Number} [width=0] The width of the rectangle.\n\t * @param {Number} [height=0] The height of the rectangle.\n\t * @return {Boolean} True if the described point or rectangle is contained within this rectangle.\n\t*/\n\tcontains (x, y, width = 0, height = 0) {\n\t\treturn (x >= this.x && x+width <= this.x+this.width && y >= this.y && y+height <= this.y+this.height);\n\t}\n\n\t/**\n\t * Returns a new rectangle which contains this rectangle and the specified rectangle.\n\t * @param {easeljs.Rectangle} rect The rectangle to calculate a union with.\n\t * @return {easeljs.Rectangle} A new rectangle describing the union.\n\t*/\n\tunion (rect) {\n\t\treturn this.clone().extend(rect.x, rect.y, rect.width, rect.height);\n\t}\n\n\t/**\n\t * Returns a new rectangle which describes the intersection (overlap) of this rectangle and the specified rectangle,\n\t * or null if they do not intersect.\n\t * @param {easeljs.Rectangle} rect The rectangle to calculate an intersection with.\n\t * @return {easeljs.Rectangle} A new rectangle describing the intersection or null.\n\t*/\n\tintersection (rect) {\n\t\tlet x1 = rect.x, y1 = rect.y, x2 = x1+rect.width, y2 = y1+rect.height;\n\t\tif (this.x > x1) { x1 = this.x; }\n\t\tif (this.y > y1) { y1 = this.y; }\n\t\tif (this.x + this.width < x2) { x2 = this.x + this.width; }\n\t\tif (this.y + this.height < y2) { y2 = this.y + this.height; }\n\t\treturn (x2 <= x1 || y2 <= y1) ? null : new Rectangle(x1, y1, x2-x1, y2-y1);\n\t}\n\n\t/**\n\t * Returns true if the specified rectangle intersects (has any overlap) with this rectangle.\n\t * @param {easeljs.Rectangle} rect The rectangle to compare.\n\t * @return {Boolean} True if the rectangles intersect.\n\t*/\n\tintersects (rect) {\n\t\treturn (rect.x <= this.x+this.width && this.x <= rect.x+rect.width && rect.y <= this.y+this.height && this.y <= rect.y + rect.height);\n\t}\n\n\t/**\n\t * Returns true if the width or height are equal or less than 0.\n\t * @return {Boolean} True if the rectangle is empty.\n\t*/\n\tisEmpty () {\n\t\treturn this.width <= 0 || this.height <= 0;\n\t}\n\n\t/**\n\t * Returns a clone of the Rectangle instance.\n\t * @return {easeljs.Rectangle} a clone of the Rectangle instance.\n\t */\n\tclone () {\n\t\treturn new Rectangle(this.x, this.y, this.width, this.height);\n\t}\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @return {String} a string representation of the instance.\n\t */\n\ttoString () {\n\t\treturn `[${this.constructor.name} (x=${this.x} y=${this.y} width=${this.width} height=${this.height})]`;\n\t}\n\n}\n\n// CONCATENATED MODULE: ./node_modules/@createjs/easeljs/src/filters/Filter.js\n/**\n * @license Filter\n * Visit http://createjs.com/ for documentation, updates and examples.\n *\n * Copyright (c) 2017 gskinner.com, inc.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the "Software"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * Base class that all filters should inherit from. Filters need to be applied to objects that have been cached using\n * the {@link easeljs.DisplayObject#cache} method. If an object changes, please cache it again, or use\n * {@link easeljs.DisplayObject#updateCache}. Note that the filters must be applied before caching.\n *\n * Note that each filter can implement a {@link easeljs.Filter#getBounds} method, which returns the\n * margins that need to be applied in order to fully display the filter. For example, the {@link easeljs.BlurFilter}\n * will cause an object to feather outwards, resulting in a margin around the shape.\n *\n * <h4>EaselJS Filters</h4>\n * EaselJS comes with a number of pre-built filters:\n * <ul>\n *   <li>{@link easeljs.AlphaMapFilter}: Map a greyscale image to the alpha channel of a display object</li>\n *   <li>{@link easeljs.AlphaMaskFilter}: Map an image\'s alpha channel to the alpha channel of a display object</li>\n *   <li>{@link easeljs.BlurFilter}: Apply vertical and horizontal blur to a display object</li>\n *   <li>{@link easeljs.ColorFilter}: Color transform a display object</li>\n *   <li>{@link easeljs.ColorMatrixFilter}: Transform an image using a {{#crossLink "ColorMatrix"}}{{/crossLink}}</li>\n * </ul>\n *\n * @memberof easeljs\n * @example\n * shape.filters = [\n *   new createjs.ColorFilter(0, 0, 0, 1, 255, 0, 0),\n *   new createjs.BlurFilter(5, 5, 10)\n * ];\n * shape.cache(0, 0, 100, 100);\n */\nclass Filter {\n\n\tconstructor () {\n\t\t/**\n\t\t * A flag stating that this filter uses a context draw mode and cannot be batched into imageData processing.\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.usesContext = false;\n\n\t\t/**\n\t\t * Another filter that is required to act as part of this filter and created and managed under the hood.\n\t\t * @private\n\t\t * @type {easeljs.Filter}\n\t\t * @default null\n\t\t */\n\t\tthis._multiPass = null;\n\n\t\t/**\n\t\t * Pre-processing shader code, will be parsed before being fed in.\n\t\t * This should be based upon StageGL.SHADER_VERTEX_BODY_REGULAR\n\t\t * @virtual\n\t\t * @type {String}\n\t\t * @readonly\n\t\t */\n\t\tthis.VTX_SHADER_BODY = null;\n\n\t\t/**\n\t\t * Pre-processing shader code, will be parsed before being fed in.\n\t\t * This should be based upon StageGL.SHADER_FRAGMENT_BODY_REGULAR\n\t\t * @virtual\n\t\t * @type {String}\n\t\t * @readonly\n\t\t */\n\t\tthis.FRAG_SHADER_BODY = null;\n\t}\n\n\t/**\n\t * Provides padding values for this filter. That is, how much the filter will extend the visual bounds of an object it is applied to.\n\t * @abstract\n\t * @param {easeljs.Rectangle} [rect] If specified, the provided Rectangle instance will be expanded by the padding amounts and returned.\n\t * @return {easeljs.Rectangle} If a `rect` param was provided, it is returned. If not, either a new rectangle with the padding values, or null if no padding is required for this filter.\n\t */\n\tgetBounds (rect) { }\n\n\t/**\n\t * @virtual\n\t * @abstract\n\t * @param {WebGLContext} gl The context associated with the stage performing the render.\n\t * @param {easeljs.StageGL} stage The stage instance that will be rendering.\n\t * @param {ShaderProgram} shaderProgram The compiled shader that is going to be sued to perform the render.\n\t */\n\tshaderParamSetup (gl, stage, shaderProgram) { }\n\n\t/**\n\t * Applies the filter to the specified context.\n\t * @param {CanvasRenderingContext2D} ctx The 2D context to use as the source.\n\t * @param {Number} x The x position to use for the source rect.\n\t * @param {Number} y The y position to use for the source rect.\n\t * @param {Number} width The width to use for the source rect.\n\t * @param {Number} height The height to use for the source rect.\n\t * @param {CanvasRenderingContext2D} [targetCtx] The 2D context to draw the result to. Defaults to the context passed to ctx.\n\t * @param {Number} [targetX] The x position to draw the result to. Defaults to the value passed to x.\n\t * @param {Number} [targetY] The y position to draw the result to. Defaults to the value passed to y.\n\t * @return {Boolean} If the filter was applied successfully.\n\t */\n\tapplyFilter (ctx, x, y, width, height, targetCtx, targetX, targetY) {\n\t\t// this is the default behaviour because most filters access pixel data. It is overridden when not needed.\n\t\ttargetCtx = targetCtx || ctx;\n\t\tif (targetX == null) { targetX = x; }\n\t\tif (targetY == null) { targetY = y; }\n\t\ttry {\n\t\t\tlet imageData = ctx.getImageData(x, y, width, height);\n\t\t\tif (this._applyFilter(imageData)) {\n\t\t\t\ttargetCtx.putImageData(imageData, targetX, targetY);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} catch (e) {}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @return {String} a string representation of the instance.\n\t */\n\ttoString () {\n\t\treturn `[${this.constructor.name}]`;\n\t}\n\n\t/**\n\t * Returns a clone of this Filter instance.\n\t * @return {easeljs.Filter} A clone of the current Filter instance.\n\t */\n\tclone () {\n\t\treturn new Filter();\n\t}\n\n\t/**\n\t * @abstract\n\t * @param {ImageData} imageData Target ImageData instance.\n\t * @return {Boolean}\n\t */\n\t_applyFilter (imageData) { }\n\n}\n\n// CONCATENATED MODULE: ./node_modules/@createjs/easeljs/src/filters/BitmapCache.js\n/**\n * @license BitmapCache\n * Visit http://createjs.com/ for documentation, updates and examples.\n *\n * Copyright (c) 2017 gskinner.com, inc.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the "Software"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n\n\n\n\n/**\n * The BitmapCache is an internal representation of all the cache properties and logic required in order to "cache"\n * an object. This information and functionality used to be located on a {@link easeljs.DisplayObject#cache}\n * method in {@link easeljs.DisplayObject}, but was moved to its own class.\n *\n * Caching in this context is purely visual, and will render the DisplayObject out into an image to be used instead\n * of the object. The actual cache itself is still stored on the target with the {@link easeljs.DisplayObject#cacheCanvas}.\n *\n * Working with a singular image like a {@link easeljs.Bitmap}, there is little benefit to performing\n * a cache operation, as it is already a single image. Caching is best done on containers that have multiple complex\n * parts that do not change often, so that rendering the image will improve overall rendering speed. A cached object\n * will not visually update until explicitly told to do so with a call to {@link easeljs.Stage#update},\n * much like a Stage. If a cache is being updated every frame, it is likely not improving rendering performance.\n * Caches are best used when updates will be sparse.\n *\n * Caching is also a co-requisite for applying filters to prevent expensive filters running constantly without need.\n * The BitmapCache is also responsible for applying filters to objects, and reads each {@link easeljs.Filter}.\n * Real-time Filters are not recommended when dealing with a Context2D canvas if performance is a concern. For best\n * performance and to still allow for some visual effects, use a {{#crossLink "DisplayObject/compositeOperation:property"}}{{/crossLink}}\n * when possible.\n *\n * @memberof easeljs\n * @extends easeljs.Filter\n */\nclass BitmapCache_BitmapCache extends Filter {\n\n\tconstructor () {\n\t\tsuper();\n\n\t\t/**\n\t\t * Width of the cache relative to the target object.\n\t\t * @protected\n\t\t * @type {Number}\n\t\t * @default undefined\n\t\t */\n\t\tthis.width = undefined;\n\n\t\t/**\n\t\t * Height of the cache relative to the target object.\n\t\t * @protected\n\t\t * @type {Number}\n\t\t * @default undefined\n\t\t */\n\t\tthis.height = undefined;\n\n\t\t/**\n\t\t * Horizontal position of the cache relative to the target\'s origin.\n\t\t * @protected\n\t\t * @type {Number}\n\t\t * @default undefined\n\t\t */\n\t\tthis.x = undefined;\n\n\t\t/**\n\t\t * Vertical position of the cache relative to target\'s origin.\n\t\t * @protected\n\t\t * @type {Number}\n\t\t * @default undefined\n\t\t */\n\t\tthis.y = undefined;\n\n\t\t/**\n\t\t * The internal scale of the cache image, does not affects display size. This is useful to both increase and\n\t\t * decrease render quality. Objects with increased scales are more likely to look good when scaled up. Objects\n\t\t * with decreased scales can save on rendering performance.\n\t\t * @protected\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t */\n\t\tthis.scale = 1;\n\n\t\t/**\n\t\t * The relative offset of the {@link easeljs.BitmapCache#x} position, used for drawing\n\t\t * into the cache with the correct offsets. Re-calculated every update call before drawing.\n\t\t * @protected\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.offX = 0;\n\n\t\t/**\n\t\t * The relative offset of the {@link easeljs.BitmapCache#y} position, used for drawing\n\t\t * into the cache with the correct offsets. Re-calculated every update call before drawing.\n\t\t * @protected\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.offY = 0;\n\n\t\t/**\n\t\t * Track how many times the cache has been updated, mostly used for preventing duplicate cacheURLs. This can be\n\t\t * useful to see if a cache has been updated.\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.cacheID = 0;\n\n\t\t/**\n\t\t * Relative offset of the x position, used for drawing the cache into other scenes.\n\t\t * Re-calculated every update call before drawing.\n\t\t * @protected\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t * @todo Is this description right? Its the same as offX.\n\t\t */\n\t\tthis._filterOffX = 0;\n\n\t\t/**\n\t\t * Relative offset of the y position, used for drawing into the cache into other scenes.\n\t\t * Re-calculated every update call before drawing.\n\t\t * @protected\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t * @todo Is this description right? Its the same as offY.\n\t\t */\n\t\tthis._filterOffY = 0;\n\n\t\t/**\n\t\t * The cacheID when a DataURL was requested.\n\t\t * @protected\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis._cacheDataURLID = 0;\n\n\t\t/**\n\t\t * The cache\'s DataURL, generated on-demand using the getter.\n\t\t * @protected\n\t\t * @type {String}\n\t\t * @default null\n\t\t */\n\t\tthis._cacheDataURL = null;\n\n\t\t/**\n\t\t * Internal tracking of final bounding width, approximately `width*scale;` however, filters can complicate the actual value.\n\t\t * @protected\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis._drawWidth = 0;\n\n\t\t/**\n\t\t * Internal tracking of final bounding height, approximately `height*scale;` however, filters can complicate the actual value.\n\t\t * @protected\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis._drawHeight = 0;\n\n\t\t/**\n\t\t * Internal tracking of the last requested bounds, may happen repeadtedly so stored to avoid object creation.\n\t\t * @protected\n\t\t * @type {easeljs.Rectangle}\n\t\t * @default easeljs.Rectangle\n\t\t */\n\t\tthis._boundRect = new Rectangle();\n\n\t}\n\n\t/**\n\t * Returns the bounds that surround all applied filters. This relies on each filter to describe how it changes bounds.\n\t * @param {easeljs.DisplayObject} target The object to check the filter bounds for.\n\t * @param {easeljs.Rectangle} [output] Calculated bounds will be applied to this rect.\n\t * @return {easeljs.Rectangle}\n\t * @static\n\t */\n\tstatic getFilterBounds (target, output = new Rectangle()) {\n\t\tlet filters = target.filters;\n\t\tlet filterCount = filters && filters.length;\n\t\tif (!!filterCount <= 0) { return output; }\n\n\t\tfor (let i=0; i<filterCount; i++) {\n\t\t\tlet f = filters[i];\n\t\t\tif (!f || !f.getBounds) { continue; }\n\t\t\tlet test = f.getBounds();\n\t\t\tif (!test) { continue; }\n\t\t\tif (i==0) {\n\t\t\t\toutput.setValues(test.x, test.y, test.width, test.height);\n\t\t\t} else {\n\t\t\t\toutput.extend(test.x, test.y, test.width, test.height);\n\t\t\t}\n\t\t}\n\n\t\treturn output;\n\t}\n\n\t/**\n\t * Directly called via {@link easeljs.DisplayObject#cache}. Creates and sets properties needed\n\t * for a cache to function, and performs the initial update.\n\t * @param {easeljs.DisplayObject} target The DisplayObject this cache is linked to.\n\t * @param {Number} [x=0] The x coordinate origin for the cache region.\n\t * @param {Number} [y=0] The y coordinate origin for the cache region.\n\t * @param {Number} [width=1] The width of the cache region.\n\t * @param {Number} [height=1] The height of the cache region.\n\t * @param {Number} [scale=1] The scale at which the cache will be created. For example, if you cache a vector shape\n\t * using `myShape.cache(0,0,100,100,2)`, then the resulting cacheCanvas will be 200x200 pixels. This lets you scale\n\t * and rotate cached elements with greater fidelity.\n\t * @param {Object} [options] When using things like {@link easeljs.StageGL} there may be\n\t * extra caching opportunities or requirements.\n\t */\n\tdefine (target, x = 0, y = 0, width = 1, height = 1, scale = 1, options) {\n\t\tif (!target) { throw "No symbol to cache"; }\n\t\tthis._options = options;\n\t\tthis._useWebGL = options !== undefined;\n\t\tthis.target = target;\n\n\t\tthis.width = width >= 1 ? width : 1;\n\t\tthis.height = height >= 1 ? height : 1;\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.scale = scale;\n\n\t\tthis.update();\n\t}\n\n\t/**\n\t * Directly called via {@link easeljs.DisplayObject#updateCache}, but also internally. This\n\t * has the dual responsibility of making sure the surface is ready to be drawn to, and performing the draw. For\n\t * full details of each behaviour, check the protected functions {@link easeljs.BitmapCache#_updateSurface}\n\t * and {@link easeljs.BitmapCache#_drawToCache} respectively.\n\t * @param {String} [compositeOperation] The DisplayObject this cache is linked to.\n\t */\n\tupdate (compositeOperation) {\n\t\tif (!this.target) { throw "define() must be called before update()"; }\n\n\t\tlet filterBounds = BitmapCache_BitmapCache.getFilterBounds(this.target);\n\t\tlet surface = this.target.cacheCanvas;\n\n\t\tthis._drawWidth = Math.ceil(this.width*this.scale) + filterBounds.width;\n\t\tthis._drawHeight = Math.ceil(this.height*this.scale) + filterBounds.height;\n\n\t\tif (!surface || this._drawWidth != surface.width || this._drawHeight != surface.height) {\n\t\t\tthis._updateSurface();\n\t\t}\n\n\t\tthis._filterOffX = filterBounds.x;\n\t\tthis._filterOffY = filterBounds.y;\n\t\tthis.offX = this.x*this.scale + this._filterOffX;\n\t\tthis.offY = this.y*this.scale + this._filterOffY;\n\n\t\tthis._drawToCache(compositeOperation);\n\n\t\tthis.cacheID = this.cacheID?this.cacheID+1:1;\n\t}\n\n\t/**\n\t * Reset and release all the properties and memory associated with this cache.\n\t */\n\trelease () {\n\t\tlet stage = this.target.stage;\n\t\tif (this._useWebGL && this._webGLCache) {\n\t\t\t// if it isn\'t cache controlled clean up after yourself\n\t\t\tif (!this._webGLCache.isCacheControlled) {\n\t\t\t\tif (this.__lastRT) { this.__lastRT = undefined; }\n\t\t\t\tif (this.__rtA) { this._webGLCache._killTextureObject(this.__rtA); }\n\t\t\t\tif (this.__rtB) { this._webGLCache._killTextureObject(this.__rtB); }\n\t\t\t\tif (this.target && this.target.cacheCanvas) { this._webGLCache._killTextureObject(this.target.cacheCanvas); }\n\t\t\t}\n\t\t\t// set the context to none and let the garbage collector get the rest when the canvas itself gets removed\n\t\t\tthis._webGLCache = false;\n\t\t} else if (stage instanceof display_StageGL) {\n\t\t\tstage.releaseTexture(this.target.cacheCanvas);\n\t\t}\n\t\tthis.target = this.target.cacheCanvas = null;\n\t\tthis.cacheID = this._cacheDataURLID = this._cacheDataURL = undefined;\n\t\tthis.width = this.height = this.x = this.y = this.offX = this.offY = 0;\n\t\tthis.scale = 1;\n\t}\n\n\t/**\n\t * Returns a data URL for the cache, or `null` if this display object is not cached.\n\t * Uses {@link easeljs.BitmapCache#cacheID} to ensure a new data URL is not generated if the\n\t * cache has not changed.\n\t * @return {String} The image data url for the cache.\n\t */\n\tgetCacheDataURL () {\n\t\tlet cacheCanvas = this.target && this.target.cacheCanvas;\n\t\tif (!cacheCanvas) { return null; }\n\t\tif (this.cacheID != this._cacheDataURLID) {\n\t\t\tthis._cacheDataURLID = this.cacheID;\n\t\t\tthis._cacheDataURL = cacheCanvas.toDataURL?cacheCanvas.toDataURL():null;\t// incase function is\n\t\t}\n\t\treturn this._cacheDataURL;\n\t}\n\n\t/**\n\t * Use context2D drawing commands to display the cache canvas being used.\n\t * @param {CanvasRenderingContext2D} ctx The context to draw into.\n\t * @return {Boolean} Whether the draw was handled successfully.\n\t */\n\tdraw (ctx) {\n\t\tif (!this.target) { return false; }\n\t\tctx.drawImage(\n\t\t\tthis.target.cacheCanvas,\n\t\t\tthis.x + (this._filterOffX/this.scale),\n\t\t\tthis.y + (this._filterOffY/this.scale),\n\t\t\tthis._drawWidth/this.scale,\n\t\t\tthis._drawHeight/this.scale\n\t\t);\n\t\treturn true;\n\t}\n\n\t/**\n\t * Determine the bounds of the shape in local space.\n\t * @returns {easeljs.Rectangle}\n\t */\n\tgetBounds () {\n\t\tconst scale = this.scale;\n\t\treturn this._boundRect.setValue(\n\t\t\tthis._filterOffX/scale,\n\t\t\tthis._filterOffY/scale,\n\t\t\tthis.width/scale,\n\t\t\tthis.height/scale\n\t\t);\n\t}\n\n\t/**\n\t * Basic context2D caching works by creating a new canvas element and setting its physical size. This function will\n\t * create and or size the canvas as needed.\n\t * @protected\n\t */\n\t_updateSurface () {\n\t\tlet surface;\n\t\tif (!this._useWebGL) {\n\t\t\tsurface = this.target.cacheCanvas;\n\t\t\t// create it if it\'s missing\n\t\t\tif (!surface) {\n\t\t\t\tsurface = this.target.cacheCanvas = window.createjs&&createjs.createCanvas?createjs.createCanvas():document.createElement("canvas");\n\t\t\t}\n\t\t\t// now size it\n\t\t\tsurface.width = this._drawWidth;\n\t\t\tsurface.height = this._drawHeight;\n\t\t\t// skip the webgl-only updates\n\t\t\treturn;\n\t\t}\n\n\t\t// create it if it\'s missing\n\t\tif (!this._webGLCache) {\n\t\t\tif (this._options.useGL === "stage") {\n\t\t\t\tif(!(this.target.stage != null && this.target.stage.isWebGL)) {\n\t\t\t\t\tthrow `Cannot use \'stage\' for cache because the object\'s parent stage is ${this.target.stage != null ? "non WebGL." : "not set, please addChild to the correct stage."}`;\n\t\t\t\t}\n\t\t\t\tthis.target.cacheCanvas = true; // will be replaced with RenderTexture, temporary positive value for old "isCached" checks\n\t\t\t\tthis._webGLCache = this.target.stage;\n\t\t\t} else if (this._options.useGL === "new") {\n\t\t\t\tthis.target.cacheCanvas = document.createElement("canvas"); // we can turn off autopurge because we wont be making textures here\n\t\t\t\tthis._webGLCache = new display_StageGL(this.target.cacheCanvas, {antialias: true, transparent: true, autoPurge: -1});\n\t\t\t\tthis._webGLCache.isCacheControlled = true;    // use this flag to control stage sizing and final output\n\t\t\t} else {\n\t\t\t\tthrow "Invalid option provided to useGL, expected [\'stage\', \'new\', StageGL, undefined], got "+ this._options.useGL;\n\t\t\t}\n\t\t}\n\n\t\t// now size render surfaces\n\t\tlet stageGL = this._webGLCache;\n\t\tsurface = this.target.cacheCanvas;\n\n\t\t// if we have a dedicated stage we\'ve gotta size it\n\t\tif (stageGL.isCacheControlled) {\n\t\t\tsurface.width = this._drawWidth;\n\t\t\tsurface.height = this._drawHeight;\n\t\t\tstageGL.updateViewport(this._drawWidth, this._drawHeight);\n\t\t}\n\t\tif (this.target.filters) {\n\t\t\t// with filters we can\'t tell how many we\'ll need but the most we\'ll ever need is two, so make them now\n\t\t\tstageGL.getTargetRenderTexture(this.target, this._drawWidth,this._drawHeight);\n\t\t\tstageGL.getTargetRenderTexture(this.target, this._drawWidth,this._drawHeight);\n\t\t} else if (!stageGL.isCacheControlled) {\n\t\t\t// without filters then we only need one RenderTexture, and that\'s only if its not a dedicated stage\n\t\t\tstageGL.getTargetRenderTexture(this.target, this._drawWidth,this._drawHeight);\n\t\t}\n\t}\n\n\t/**\n\t * Perform the cache draw out for context 2D now that the setup properties have been performed.\n\t * @protected\n\t */\n\t_drawToCache (compositeOperation) {\n\t\tlet target = this.target;\n\t\tlet surface = target.cacheCanvas;\n\t\tlet webGL = this._webGLCache;\n\n\t\tif (!this._useWebGL || !webGL) {\n\t\t\tlet ctx = surface.getContext("2d");\n\n\t\t\tif (!compositeOperation) {\n\t\t\t\tctx.clearRect(0, 0, this._drawWidth+1, this._drawHeight+1);\n\t\t\t}\n\n\t\t\tctx.save();\n\t\t\tctx.globalCompositeOperation = compositeOperation;\n\t\t\tctx.setTransform(this.scale,0,0,this.scale, -this._filterOffX,-this._filterOffY);\n\t\t\tctx.translate(-this.x, -this.y);\n\t\t\ttarget.draw(ctx, true);\n\t\t\tctx.restore();\n\n\t\t\tif (target.filters && target.filters.length) {\n\t\t\t\tthis._applyFilters(target);\n\t\t\t}\n\t\t\tsurface._invalid = true;\n\t\t\treturn;\n\t\t}\n\n\t\tthis._webGLCache.cacheDraw(target, target.filters, this);\n\t\t// NOTE: we may of swapped around which element the surface is, so we re-fetch it\n\t\tsurface = this.target.cacheCanvas;\n\t\tsurface.width = this._drawWidth;\n\t\tsurface.height = this._drawHeight;\n\t\tsurface._invalid = true;\n\t}\n\n\t/**\n\t * Work through every filter and apply its individual transformation to it.\n\t * @protected\n\t */\n\t_applyFilters () {\n\t\tlet surface = this.target.cacheCanvas;\n\t\tlet filters = this.target.filters;\n\n\t\tlet w = this._drawWidth;\n\t\tlet h = this._drawHeight;\n\n\t\t// setup\n\t\tlet data = surface.getContext("2d").getImageData(0,0, w,h);\n\n\t\t// apply\n\t\tlet l = filters.length;\n\t\tfor (let i=0; i<l; i++) {\n\t\t\tfilters[i]._applyFilter(data);\n\t\t}\n\n\t\t//done\n\t\tsurface.getContext("2d").putImageData(data, 0,0);\n\t}\n\n}\n\n/**\n * Functionality injected to {@link easeljs.BitmapCache}. Ensure StageGL is loaded after all other\n * standard EaselJS classes are loaded but before making any DisplayObject instances for injection to take full effect.\n * Replaces the context2D cache draw with the option for WebGL or context2D drawing.\n * If options is set to "true" a StageGL is created and contained on the object for use when rendering a cache.\n * If options is a StageGL instance it will not create an instance but use the one provided.\n * If possible it is best to provide the StageGL instance that is a parent to this DisplayObject for performance reasons.\n * A StageGL cache does not infer the ability to draw objects a StageGL cannot currently draw,\n * i.e. do not use a WebGL context cache when caching a Shape, Text, etc.\n *\n * You can make your own StageGL and have it render to a canvas if you set ".isCacheControlled" to true on your stage.\n * You may wish to create your own StageGL instance to control factors like background color/transparency, AA, and etc.\n * You must set "options" to its own stage if you wish to use the fast Render Textures available only to StageGLs.\n * If you use WebGL cache on a container with Shapes you will have to cache each shape individually before the container,\n * otherwise the WebGL cache will not render the shapes.\n *\n * @name easeljs.BitmapCache#cache\n *\n * @example <caption>WebGL cache with 2d context</caption>\n * let stage = new Stage();\n * let bmp = new Bitmap(src);\n * bmp.cache(0, 0, bmp.width, bmp.height, 1, true); // no StageGL to use, so make one\n * let shape = new Shape();\n * shape.graphics.clear().fill("red").drawRect(0,0,20,20);\n * shape.cache(0, 0, 20, 20, 1); // cannot use WebGL cache\n *\n * @example <caption>WebGL cache with WebGL context</caption>\n * let stageGL = new StageGL();\n * let bmp = new Bitmap(src);\n * bmp.cache(0, 0, bmp.width, bmp.height, 1, stageGL); // use our StageGL to cache\n * let shape = new Shape();\n * shape.graphics.clear().fill("red").drawRect(0,0,20,20);\n * shape.cache(0, 0, 20, 20, 1); // cannot use WebGL cache\n *\n * @param {Number} x The x coordinate origin for the cache region.\n * @param {Number} y The y coordinate origin for the cache region.\n * @param {Number} width The width of the cache region.\n * @param {Number} height The height of the cache region.\n * @param {Number} [scale=1] The scale at which the cache will be created. For example, if you cache a vector shape using\n * \tmyShape.cache(0,0,100,100,2) then the resulting cacheCanvas will be 200x200 px. This lets you scale and rotate\n * \tcached elements with greater fidelity.\n * @param {Boolean | easeljs.StageGL} [options] Select whether to use context 2D, or WebGL rendering, and whether to make a new stage instance or use an existing one.\n */\n\n// CONCATENATED MODULE: ./node_modules/@createjs/easeljs/src/display/DisplayObject.js\n/**\n * @license DisplayObject\n * Visit http://createjs.com/ for documentation, updates and examples.\n *\n * Copyright (c) 2017 gskinner.com, inc.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the "Software"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n\n\n\n\n\n\n\n\n\n/**\n * DisplayObject is an abstract class that should not be constructed directly. Instead construct subclasses such as\n * {@link easeljs.Container}, {@link easeljs.Bitmap}, and {@link easeljs.Shape}.\n * DisplayObject is the base class for all display classes in the EaselJS library. It defines the core properties and\n * methods that are shared between all display objects, such as transformation properties (x, y, scaleX, scaleY, etc),\n * caching, and mouse handlers.\n *\n * @memberof easeljs\n * @extends EventDispatcher\n */\nclass DisplayObject_DisplayObject extends events_EventDispatcher {\n\n\tconstructor () {\n\t\tsuper();\n\n\t\t/**\n\t\t * The alpha (transparency) for this display object. 0 is fully transparent, 1 is fully opaque.\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t */\n\t\tthis.alpha = 1;\n\n\t\t/**\n\t\t * If a cache is active, this returns the canvas that holds the image of this display object.\n\t\t * Use this to display the result of a cache. This will be a HTMLCanvasElement unless special cache rules have been deliberately enabled for this cache.\n\t\t * @see {@link easeljs.DisplayObject#cache}\n\t\t * @type {HTMLCanvasElement | Object}\n\t\t * @default null\n\t\t * @readonly\n\t\t */\n\t\tthis.cacheCanvas = null;\n\n\t\t/**\n\t\t * If a cache has been made, this returns the class that is managing the cacheCanvas and its properties.\n\t\t * @see {@link easeljs.BitmapCache}\n\t\t * @type {easeljs.BitmapCache}\n\t\t * @default null\n\t\t * @readonly\n\t\t */\n\t\tthis.bitmapCache = null;\n\n\t\t/**\n\t\t * Unique ID for this display object. Makes display objects easier for some uses.\n\t\t * @type {Number}\n\t\t */\n\t\tthis.id = uid();\n\n\t\t/**\n\t\t * Indicates whether to include this object when running mouse interactions. Setting this to `false` for children\n\t\t * of a {@link easeljs.Container} will cause events on the Container to not fire when that child is\n\t\t * clicked. Setting this property to `false` does not prevent the {@link easeljs.Container#getObjectsUnderPoint}\n\t\t * method from returning the child.\n\t\t *\n\t\t * <strong>Note:</strong> In EaselJS 0.7.0, the `mouseEnabled` property will not work properly with nested Containers.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.mouseEnabled = true;\n\n\t\t/**\n\t\t * If false, the tick will not run on this display object (or its children). This can provide some performance benefits.\n\t\t * In addition to preventing the {@link core.Ticker#event:tick} event from being dispatched, it will also prevent tick related updates\n\t\t * on some display objects (ex. Sprite & MovieClip frame advancing, DOMElement visibility handling).\n\t\t * @type Boolean\n\t\t * @default true\n\t\t */\n\t\tthis.tickEnabled = true;\n\n\t\t/**\n\t\t * An optional name for this display object. Included in {@link easeljs.DisplayObject#toString}. Useful for debugging.\n\t\t * @type {String}\n\t\t * @default null\n\t\t */\n\t\tthis.name = null;\n\n\t\t/**\n\t\t * A reference to the {@link easeljs.Container} or {@link easeljs.Stage} object that\n\t\t * contains this display object, or null if it has not been added to one.\n\t\t * @type {easeljs.Container}\n\t\t * @default null\n\t\t * @readonly\n\t\t */\n\t\tthis.parent = null;\n\n\t\t/**\n\t\t * The left offset for this display object\'s registration point. For example, to make a 100x100px Bitmap rotate\n\t\t * around its center, you would set regX and {@link easeljs.DisplayObject#regY} to 50.\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.regX = 0;\n\n\t\t/**\n\t\t * The y offset for this display object\'s registration point. For example, to make a 100x100px Bitmap rotate around\n\t\t * its center, you would set {@link easeljs.DisplayObject#regX} and regY to 50.\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.regY = 0;\n\n\t\t/**\n\t\t * The rotation in degrees for this display object.\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.rotation = 0;\n\n\t\t/**\n\t\t * The factor to stretch this display object horizontally. For example, setting scaleX to 2 will stretch the display\n\t\t * object to twice its nominal width. To horizontally flip an object, set the scale to a negative number.\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t */\n\t\tthis.scaleX = 1;\n\n\t\t/**\n\t\t * The factor to stretch this display object vertically. For example, setting scaleY to 0.5 will stretch the display\n\t\t * object to half its nominal height. To vertically flip an object, set the scale to a negative number.\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t */\n\t\tthis.scaleY = 1;\n\n\t\t/**\n\t\t * The factor to skew this display object horizontally.\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.skewX = 0;\n\n\t\t/**\n\t\t * The factor to skew this display object vertically.\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.skewY = 0;\n\n\t\t/**\n\t\t * A shadow object that defines the shadow to render on this display object. Set to `null` to remove a shadow. If\n\t\t * null, this property is inherited from the parent container.\n\t\t * @type {easeljs.Shadow}\n\t\t * @default null\n\t\t */\n\t\tthis.shadow = null;\n\n\t\t/**\n\t\t * Indicates whether this display object should be rendered to the canvas and included when running the Stage\n\t\t * {@link easeljs.Stage#getObjectsUnderPoint} method.\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.visible = true;\n\n\t\t/**\n\t\t * The x (horizontal) position of the display object, relative to its parent.\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.x = 0;\n\n\t\t/**\n\t\t * The y (vertical) position of the display object, relative to its parent.\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.y = 0;\n\n\t\t/**\n\t\t * If set, defines the transformation for this display object, overriding all other transformation properties\n\t\t * (x, y, rotation, scale, skew).\n\t\t * @type {easeljs.Matrix2D}\n\t\t * @default null\n\t\t */\n\t\tthis.transformMatrix = null;\n\n\t\t/**\n\t\t * The composite operation indicates how the pixels of this display object will be composited with the elements\n\t\t * behind it. If `null`, this property is inherited from the parent container.\n\t\t * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#compositing "WHATWG spec on compositing"}\n\t\t * @type {String}\n\t\t * @default null\n\t\t */\n\t\tthis.compositeOperation = null;\n\n\t\t/**\n\t\t * Indicates whether the display object should be drawn to a whole pixel when {@link easeljs.Stage#snapToPixelEnabled} is true.\n\t\t * To enable/disable snapping on whole categories of display objects, set this value on the prototype (Ex. Text.prototype.snapToPixel = true).\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.snapToPixel = true;\n\n\t\t/**\n\t\t * An array of Filter objects to apply to this display object. Filters are only applied / updated when {@link easeljs.DisplayObject#cache}\n\t\t * or {@link easeljs.DisplayObject#updateCache} is called on the display object, and only apply to the area that is cached.\n\t\t * @type {Array<easeljs.Filter>}\n\t\t * @default null\n\t\t */\n\t\tthis.filters = null;\n\n\t\t/**\n\t\t * A Shape instance that defines a vector mask (clipping path) for this display object.  The shape\'s transformation\n\t\t * will be applied relative to the display object\'s parent coordinates (as if it were a child of the parent).\n\t\t * @type {easeljs.Shape}\n\t\t * @default null\n\t\t */\n\t\tthis.mask = null;\n\n\t\t/**\n\t\t * A display object that will be tested when checking mouse interactions or testing {@link easeljs.Container#getObjectsUnderPoint}.\n\t\t * The hit area will have its transformation applied relative to this display object\'s coordinate space (as though\n\t\t * the hit test object were a child of this display object and relative to its regX/Y). The hitArea will be tested\n\t\t * using only its own `alpha` value regardless of the alpha value on the target display object, or the target\'s\n\t\t * ancestors (parents).\n\t\t *\n\t\t * If set on a {@link easeljs.Container}, children of the Container will not receive mouse events.\n\t\t * This is similar to setting {@link easeljs.DisplayObject#mouseChildren} to false.\n\t\t *\n\t\t * Note that hitArea is NOT currently used by the `hitTest()` method, nor is it supported for {@link easeljs.Stage}.\n\t\t *\n\t\t * @type {easeljs.DisplayObject}\n\t\t * @default null\n\t\t */\n\t\tthis.hitArea = null;\n\n\t\t/**\n\t\t * A CSS cursor (ex. "pointer", "help", "text", etc) that will be displayed when the user hovers over this display\n\t\t * object. You must enable mouseover events using the {@link easeljs.Stage#enableMouseOver} method to\n\t\t * use this property. Setting a non-null cursor on a Container will override the cursor set on its descendants.\n\t\t *\n\t\t * @type {String}\n\t\t * @default null\n\t\t */\n\t\tthis.cursor = null;\n\n\t\t/**\n\t\t * @protected\n\t\t * @type {easeljs.DisplayProps}\n\t\t */\n\t\tthis._props = new DisplayProps_DisplayProps();\n\n\t\t/**\n\t\t * @protected\n\t\t * @type {easeljs.Rectangle}\n\t\t */\n\t\tthis._rectangle = new Rectangle();\n\n\t\t/**\n\t\t * @protected\n\t\t * @type {easeljs.Rectangle}\n\t\t * @default null\n\t\t */\n\t\tthis._bounds = null;\n\n\t\t/**\n\t\t * Where StageGL should look for required display properties, matters only for leaf display objects. Containers\n\t\t * or cached objects won\'t use this property, it\'s for native display of terminal elements.\n\t\t * @protected\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis._webGLRenderStyle = DisplayObject_DisplayObject._StageGL_NONE;\n\t}\n\n\t/**\n\t * Returns the {@link easeljs.Stage} instance that this display object will be rendered on, or null if it has not been added to one.\n\t * @type {Stage}\n\t * @readonly\n\t */\n\tget stage () {\n\t\t// uses dynamic access to avoid circular dependencies;\n\t\tlet o = this;\n\t\twhile (o.parent) { o = o.parent; }\n\t\tif (/^\\[Stage(GL)?(\\s\\(name=\\w+\\))?\\]$/.test(o.toString())) { return o; }\n\t\treturn null;\n\t}\n\n\t/**\n\t * Set both the {@link easeljs.DisplayObject#scaleX} and the {@link easeljs.DisplayObject#scaleY} property to the same value.\n\t * Note that when you get the value, if the `scaleX` and `scaleY` are different values, it will return only the `scaleX`.\n\t * @type {Number}\n\t * @default 1\n\t */\n\tset scale (value) { this.scaleX = this.scaleY = value; }\n\tget scale () { return this.scaleX; }\n\n\t/**\n\t * Returns true or false indicating whether the display object would be visible if drawn to a canvas.\n\t * This does not account for whether it would be visible within the boundaries of the stage.\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas\n\t */\n\tisVisible () {\n\t\treturn !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0);\n\t}\n\n\t/**\n\t * Alias for drawCache(). Used by grandchildren (or deeper) in their draw method to directly\n\t * call {@link easeljs.DisplayObject#drawCache}, bypassing their parent(s).\n\t *\n\t * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.\n\t * @param {Boolean} [ignoreCache=false] Indicates whether the draw operation should ignore any current cache. For example,\n\t * used for drawing the cache (to prevent it from simply drawing an existing cache back into itself).\n\t * @return {Boolean}\n\t */\n\tdraw (ctx, ignoreCache = false) {\n\t\treturn this.drawCache(ctx, ignoreCache);\n\t}\n\n\t/**\n\t * Draws the display object into the specified context ignoring its visible, alpha, shadow, and transform.\n\t * Returns `true` if the draw was handled (useful for overriding functionality).\n\t *\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.\n\t * @param {Boolean} [ignoreCache=false] Indicates whether the draw operation should ignore any current cache. For example,\n\t * used for drawing the cache (to prevent it from simply drawing an existing cache back into itself).\n\t * @return {Boolean}\n\t */\n\tdrawCache (ctx, ignoreCache = false) {\n\t\tlet cache = this.bitmapCache;\n\t\tif (cache && !ignoreCache) {\n\t\t\treturn cache.draw(ctx);\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Applies this display object\'s transformation, alpha, globalCompositeOperation, clipping path (mask), and shadow\n\t * to the specified context. This is typically called prior to {@link easeljs.DisplayObject#draw}.\n\t * @param {CanvasRenderingContext2D} ctx The canvas 2D to update.\n\t */\n\tupdateContext (ctx) {\n\t\tlet o=this, mask=o.mask, mtx=o._props.matrix;\n\n\t\tif (mask && mask.graphics && !mask.graphics.isEmpty()) {\n\t\t\tmask.getMatrix(mtx);\n\t\t\tctx.transform(mtx.a, mtx.b, mtx.c, mtx.d, mtx.tx, mtx.ty);\n\n\t\t\tmask.graphics.drawAsPath(ctx);\n\t\t\tctx.clip();\n\n\t\t\tmtx.invert();\n\t\t\tctx.transform(mtx.a,  mtx.b, mtx.c, mtx.d, mtx.tx, mtx.ty);\n\t\t}\n\n\t\tthis.getMatrix(mtx);\n\t\tlet tx = mtx.tx, ty = mtx.ty;\n\t\tif (DisplayObject_DisplayObject._snapToPixelEnabled && o.snapToPixel) {\n\t\t\ttx = tx + (tx < 0 ? -0.5 : 0.5) | 0;\n\t\t\tty = ty + (ty < 0 ? -0.5 : 0.5) | 0;\n\t\t}\n\t\tctx.transform(mtx.a,  mtx.b, mtx.c, mtx.d, tx, ty);\n\t\tctx.globalAlpha *= o.alpha;\n\t\tif (o.compositeOperation) { ctx.globalCompositeOperation = o.compositeOperation; }\n\t\tif (o.shadow) { this._applyShadow(ctx, o.shadow); }\n\t}\n\n\t/**\n\t * Draws the display object into a new element, which is then used for subsequent draws. Intended for complex content\n\t * that does not change frequently (ex. a Container with many children that do not move, or a complex vector Shape),\n\t * this can provide for much faster rendering because the content does not need to be re-rendered each tick. The\n\t * cached display object can be moved, rotated, faded, etc freely, however if its content changes, you must manually\n\t * update the cache by calling `updateCache()` again. You must specify the cached area via the x, y, w,\n\t * and h parameters. This defines the rectangle that will be rendered and cached using this display object\'s coordinates.\n\t *\n\t * Note that filters need to be defined <em>before</em> the cache is applied or you will have to call updateCache after\n\t * application. Check out the {@link easeljs.Filter} class for more information. Some filters\n\t * (ex. {@link easeljs.BlurFilter}) may not work as expected in conjunction with the scale param.\n\t *\n\t * Usually, the resulting cacheCanvas will have the dimensions width*scale by height*scale, however some filters (ex. BlurFilter)\n\t * will add padding to the canvas dimensions.\n\t *\n\t * Actual implementation of the caching mechanism can change with a {@link easeljs.StageGL} and so\n\t * all caching and filter behaviour has been moved to the {@link easeljs.BitmapCache}\n\t *\n\t * @example\n\t * // If you defined a Shape that drew a circle at 0, 0 with a radius of 25:\n\t * var shape = new createjs.Shape();\n\t * shape.graphics.beginFill("#ff0000").drawCircle(0, 0, 25);\n\t * shape.cache(-25, -25, 50, 50);\n\t *\n\t * @param {Number} x The x coordinate origin for the cache region.\n\t * @param {Number} y The y coordinate origin for the cache region.\n\t * @param {Number} width The width of the cache region.\n\t * @param {Number} height The height of the cache region.\n\t * @param {Number} [scale=1] The scale at which the cache will be created. For example, if you cache a vector shape using\n\t * \tmyShape.cache(0,0,100,100,2) then the resulting cacheCanvas will be 200x200 px. This lets you scale and rotate\n\t * \tcached elements with greater fidelity. Default is 1.\n\t * @param {Object} [options] When using alternate displays there may be extra caching opportunities or needs.\n\t */\n\tcache (x, y, width, height, scale = 1, options) {\n\t\tif (!this.bitmapCache) {\n\t\t\tthis.bitmapCache = new BitmapCache_BitmapCache();\n\t\t}\n\t\tthis.bitmapCache.define(this, x, y, width, height, scale, options);\n\t}\n\n\t/**\n\t * Redraws the display object to its cache. Calling updateCache without an active cache will throw an error.\n\t * If compositeOperation is null the current cache will be cleared prior to drawing. Otherwise the display object\n\t * will be drawn over the existing cache using the specified compositeOperation.\n\t *\n\t * Actual implementation of the caching mechanism can change with a {@link easeljs.StageGL} and so\n\t * all caching and filter behaviour has been moved to the {@link easeljs.BitmapCache}\n\t *\n\t * @example\n\t * // clear current graphics\n\t * shapeInstance.clear();\n\t * // draw new instructions\n\t * shapeInstance.setStrokeStyle(3).beginStroke("#FF0000").moveTo(100, 100).lineTo(200,200);\n\t * // update cache, drawing new line on top of old one\n\t * shapeInstance.updateCache();\n\t *\n\t * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#compositing "WHATWG spec on compositing"}\n\t * @param {String} compositeOperation The compositeOperation to use, or null to clear the cache and redraw it.\n\t */\n\tupdateCache (compositeOperation) {\n\t\tif (!this.bitmapCache) {\n\t\t\tthrow "No cache found. cache() must be called before updateCache()";\n\t\t}\n\t\tthis.bitmapCache.update(compositeOperation);\n\t}\n\n\t/**\n\t * Clears the current cache.\n\t * @see {@link easeljs.DisplayObject.#cache}\n\t */\n\tuncache () {\n\t\tif (this.bitmapCache) {\n\t\t\tthis.bitmapCache.release();\n\t\t\tthis.bitmapCache = undefined;\n\t\t}\n\t}\n\n\t/**\n\t * Returns a data URL for the cache, or null if this display object is not cached.\n\t * Only generated if the cache has changed, otherwise returns last result.\n\t * @return {String} The image data url for the cache.\n\t */\n\tgetCacheDataURL () {\n\t\treturn this.bitmapCache ? this.bitmapCache.getDataURL() : null;\n\t}\n\n\t/**\n\t * Transforms the specified x and y position from the coordinate space of the display object\n\t * to the global (stage) coordinate space. For example, this could be used to position an HTML label\n\t * over a specific point on a nested display object. Returns a Point instance with x and y properties\n\t * correlating to the transformed coordinates on the stage.\n\t *\n\t * @example\n\t * displayObject.x = 300;\n\t * displayObject.y = 200;\n\t * stage.addChild(displayObject);\n\t * let point = displayObject.localToGlobal(100, 100);\n\t * // Results in x=400, y=300\n\t *\n\t * @param {Number} x The x position in the source display object to transform.\n\t * @param {Number} y The y position in the source display object to transform.\n\t * @param {easeljs.Point | Object} [pt=Point] An object to copy the result into. If omitted a new Point object with x/y properties will be returned.\n\t * @return {easeljs.Point} A Point instance with x and y properties correlating to the transformed coordinates\n\t * on the stage.\n\t */\n\tlocalToGlobal (x, y, pt = new Point()) {\n\t\treturn this.getConcatenatedMatrix(this._props.matrix).transformPoint(x, y, pt);\n\t}\n\n\t/**\n\t * Transforms the specified x and y position from the global (stage) coordinate space to the\n\t * coordinate space of the display object. For example, this could be used to determine\n\t * the current mouse position within the display object. Returns a Point instance with x and y properties\n\t * correlating to the transformed position in the display object\'s coordinate space.\n\t *\n\t * @example\n\t * displayObject.x = 300;\n\t * displayObject.y = 200;\n\t * stage.addChild(displayObject);\n\t * let point = displayObject.globalToLocal(100, 100);\n\t * // Results in x=-200, y=-100\n\t *\n\t * @param {Number} x The x position on the stage to transform.\n\t * @param {Number} y The y position on the stage to transform.\n\t * @param {easeljs.Point | Object} [pt=Point] An object to copy the result into. If omitted a new Point object with x/y properties will be returned.\n\t * @return {easeljs.Point} A Point instance with x and y properties correlating to the transformed position in the\n\t * display object\'s coordinate space.\n\t */\n\tglobalToLocal (x, y, pt = new Point()) {\n\t\treturn this.getConcatenatedMatrix(this._props.matrix).invert().transformPoint(x, y, pt);\n\t}\n\n\t/**\n\t * Transforms the specified x and y position from the coordinate space of this display object to the coordinate\n\t * space of the target display object. Returns a Point instance with x and y properties correlating to the\n\t * transformed position in the target\'s coordinate space. Effectively the same as using the following code with\n\t * {@link easeljs.DisplayObject#localToGlobal} and {@link easeljs.DisplayObject#globalToLocal}.\n\t *\n\t * @example\n\t * // long way\n\t * let pt = this.localToGlobal(x, y);\n\t * pt = target.globalToLocal(pt.x, pt.y);\n\t * // shorthand\n\t * let pt = this.localToLocal(x, y, target);\n\t *\n\t * @param {Number} x The x position in the source display object to transform.\n\t * @param {Number} y The y position on the source display object to transform.\n\t * @param {easeljs.DisplayObject} target The target display object to which the coordinates will be transformed.\n\t * @param {easeljs.Point | Object} [pt] An object to copy the result into. If omitted a new Point object with x/y properties will be returned.\n\t * @return {easeljs.Point} Returns a Point instance with x and y properties correlating to the transformed position\n\t * in the target\'s coordinate space.\n\t */\n\tlocalToLocal (x, y, target, pt) {\n\t\tpt = this.localToGlobal(x, y, pt);\n\t\treturn target.globalToLocal(pt.x, pt.y, pt);\n\t}\n\n\t/**\n\t * Shortcut method to quickly set the transform properties on the display object. All parameters are optional.\n\t * Omitted parameters will have the default value set.\n\t *\n\t * @example\n\t * displayObject.setTransform(100, 100, 2, 2);\n\t *\n\t * @param {Number} [x=0] The horizontal translation (x position) in pixels\n\t * @param {Number} [y=0] The vertical translation (y position) in pixels\n\t * @param {Number} [scaleX=1] The horizontal scale, as a percentage of 1\n\t * @param {Number} [scaleY=1] the vertical scale, as a percentage of 1\n\t * @param {Number} [rotation=0] The rotation, in degrees\n\t * @param {Number} [skewX=0] The horizontal skew factor\n\t * @param {Number} [skewY=0] The vertical skew factor\n\t * @param {Number} [regX=0] The horizontal registration point in pixels\n\t * @param {Number} [regY=0] The vertical registration point in pixels\n\t * @return {easeljs.DisplayObject} Returns this instance. Useful for chaining commands.\n\t*/\n\tsetTransform (x=0, y=0, scaleX=1, scaleY=1, rotation=0, skewX=0, skewY=0, regX=0, regY=0) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.scaleX = scaleX;\n\t\tthis.scaleY = scaleY;\n\t\tthis.rotation = rotation;\n\t\tthis.skewX = skewX;\n\t\tthis.skewY = skewY;\n\t\tthis.regX = regX;\n\t\tthis.regY = regY;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns a matrix based on this object\'s current transform.\n\t * @param {easeljs.Matrix2D} [matrix] A Matrix2D object to populate with the calculated values. If null, a new Matrix object is returned.\n\t * @return {easeljs.Matrix2D} A matrix representing this display object\'s transform.\n\t */\n\tgetMatrix (matrix) {\n\t\tlet o = this, mtx = matrix&&matrix.identity() || new Matrix2D_Matrix2D();\n\t\treturn o.transformMatrix ?  mtx.copy(o.transformMatrix) : mtx.appendTransform(o.x, o.y, o.scaleX, o.scaleY, o.rotation, o.skewX, o.skewY, o.regX, o.regY);\n\t}\n\n\t/**\n\t * Generates a Matrix2D object representing the combined transform of the display object and all of its\n\t * parent Containers up to the highest level ancestor (usually the {@link easeljs.Stage}). This can\n\t * be used to transform positions between coordinate spaces, such as with {@link easeljs.DisplayObject#localToGlobal}\n\t * and {@link easeljs.DisplayObject#globalToLocal}.\n\t *\n\t * @param {easeljs.Matrix2D} [matrix] A Matrix2D object to populate with the calculated values. If null, a new Matrix2D object is returned.\n\t * @return {easeljs.Matrix2D} The combined matrix.\n\t */\n\tgetConcatenatedMatrix (matrix) {\n\t\tlet o = this, mtx = this.getMatrix(matrix);\n\t\twhile (o = o.parent) {\n\t\t\tmtx.prependMatrix(o.getMatrix(o._props.matrix));\n\t\t}\n\t\treturn mtx;\n\t}\n\n\t/**\n\t * Generates a DisplayProps object representing the combined display properties of the  object and all of its\n\t * parent Containers up to the highest level ancestor (usually the {@link easeljs.Stage}).\n\t * @param {easeljs.DisplayProps} [props] A DisplayProps object to populate with the calculated values. If null, a new DisplayProps object is returned.\n\t * @return {easeljs.DisplayProps} The combined display properties.\n\t */\n\tgetConcatenatedDisplayProps (props) {\n\t\tprops = props ? props.identity() : new DisplayProps_DisplayProps();\n\t\tlet o = this, mtx = o.getMatrix(props.matrix);\n\t\tdo {\n\t\t\tprops.prepend(o.visible, o.alpha, o.shadow, o.compositeOperation);\n\n\t\t\t// we do this to avoid problems with the matrix being used for both operations when o._props.matrix is passed in as the props param.\n\t\t\t// this could be simplified (ie. just done as part of the prepend above) if we switched to using a pool.\n\t\t\tif (o != this) { mtx.prependMatrix(o.getMatrix(o._props.matrix)); }\n\t\t} while (o = o.parent);\n\t\treturn props;\n\t}\n\n\t/**\n\t * Tests whether the display object intersects the specified point in local coordinates (ie. draws a pixel with alpha > 0 at\n\t * the specified position). This ignores the alpha, shadow, hitArea, mask, and compositeOperation of the display object.\n\t *\n\t * Please note that shape-to-shape collision is not currently supported by EaselJS.\n\t *\n\t * @example\n\t * stage.addEventListener("stagemousedown", event => {\n\t *   let hit = shape.hitTest(event.stageX, event.stageY);\n\t *   // hit == true when shape is clicked\n\t * });\n\t *\n\t * @param {Number} x The x position to check in the display object\'s local coordinates.\n\t * @param {Number} y The y position to check in the display object\'s local coordinates.\n\t * @return {Boolean} A Boolean indicating whether a visible portion of the DisplayObject intersect the specified\n\t * local Point.\n\t*/\n\thitTest (x, y) {\n\t\tlet ctx = DisplayObject_DisplayObject._hitTestContext;\n\t\tctx.setTransform(1, 0, 0, 1, -x, -y);\n\t\tthis.draw(ctx);\n\n\t\tlet hit = this._testHit(ctx);\n\t\tctx.setTransform(1, 0, 0, 1, 0, 0);\n\t\tctx.clearRect(0, 0, 2, 2);\n\t\treturn hit;\n\t}\n\n\t/**\n\t * Provides a chainable shortcut method for setting a number of properties on the instance.\n\t *\n\t * @example\n\t * let graphics = new Graphics().beginFill("#ff0000").drawCircle(0, 0, 25);\n\t * let shape = stage.addChild(new Shape()).set({ graphics, x: 100, y: 100, alpha: 0.5 });\n\t *\n\t * @param {Object} props A generic object containing properties to copy to the DisplayObject instance.\n\t * @return {easeljs.DisplayObject} Returns the instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t*/\n\tset (props) {\n\t\tfor (let n in props) { this[n] = props[n]; }\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns a rectangle representing this object\'s bounds in its local coordinate system (ie. with no transformation).\n\t * Objects that have been cached will return the bounds of the cache.\n\t *\n\t * Not all display objects can calculate their own bounds (ex. Shape). For these objects, you can use\n\t * {@link easeljs.DisplayObject#setBounds} so that they are included when calculating Container bounds.\n\t *\n\t * <table>\n\t * \t<tr><td><b>All</b></td><td>\n\t * \t\tAll display objects support setting bounds manually using setBounds(). Likewise, display objects that\n\t * \t\thave been cached using cache() will return the bounds of their cache. Manual and cache bounds will override\n\t * \t\tthe automatic calculations listed below.\n\t * \t</td></tr>\n\t * \t<tr><td><b>Bitmap</b></td><td>\n\t * \t\tReturns the width and height of the sourceRect (if specified) or image, extending from (x=0,y=0).\n\t * \t</td></tr>\n\t * \t<tr><td><b>Sprite</b></td><td>\n\t * \t\tReturns the bounds of the current frame. May have non-zero x/y if a frame registration point was specified\n\t * \t\tin the spritesheet data. See also {@link easeljs.SpriteSheet#getFrameBounds}\n\t * \t</td></tr>\n\t * \t<tr><td><b>Container</b></td><td>\n\t * \t\tReturns the aggregate (combined) bounds of all children that return a non-null value from getBounds().\n\t * \t</td></tr>\n\t * \t<tr><td><b>Shape</b></td><td>\n\t * \t\tDoes not currently support automatic bounds calculations. Use setBounds() to manually define bounds.\n\t * \t</td></tr>\n\t * \t<tr><td><b>Text</b></td><td>\n\t * \t\tReturns approximate bounds. Horizontal values (x/width) are quite accurate, but vertical values (y/height) are\n\t * \t\tnot, especially when using textBaseline values other than "top".\n\t * \t</td></tr>\n\t * \t<tr><td><b>BitmapText</b></td><td>\n\t * \t\tReturns approximate bounds. Values will be more accurate if spritesheet frame registration points are close\n\t * \t\tto (x=0,y=0).\n\t * \t</td></tr>\n\t* </table>\n\t *\n\t * @example\n\t * /* Bounds can be expensive to calculate for some objects (ex. text, or containers with many children), and\n\t * are recalculated each time you call getBounds(). You can prevent recalculation on static objects by setting the\n\t * bounds explicitly. *\\/\n\t * let bounds = obj.getBounds();\n\t * obj.setBounds(bounds.x, bounds.y, bounds.width, bounds.height);\n\t * // getBounds will now use the set values, instead of recalculating\n\t *\n\t * @example\n\t * // To reduce memory impact, the returned Rectangle instance may be reused internally\n\t * let bounds = obj.getBounds().clone();\n\t * // OR:\n\t * rect.copy(obj.getBounds());\n\t *\n\t * @return {easeljs.Rectangle} A Rectangle instance representing the bounds, or null if bounds are not available for this object.\n\t */\n\tgetBounds () {\n\t\tif (this._bounds) { return this._rectangle.copy(this._bounds); }\n\t\tlet cacheCanvas = this.cacheCanvas;\n\t\tif (cacheCanvas) {\n\t\t\tlet scale = this._cacheScale;\n\t\t\treturn this._rectangle.setValues(this._cacheOffsetX, this._cacheOffsetY, cacheCanvas.width/scale, cacheCanvas.height/scale);\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Returns a rectangle representing this object\'s bounds in its parent\'s coordinate system (ie. with transformations applied).\n\t * Objects that have been cached will return the transformed bounds of the cache.\n\t *\n\t * Not all display objects can calculate their own bounds (ex. Shape). For these objects, you can use\n\t * {@link easeljs.DisplayObject#setBounds} so that they are included when calculating Container bounds.\n\t *\n\t * To reduce memory impact, the returned Rectangle instance may be reused internally; clone the instance or copy its\n\t * values if you need to retain it.\n\t *\n\t * Container instances calculate aggregate bounds for all children that return bounds via getBounds.\n\t * @return {easeljs.Rectangle} A Rectangle instance representing the bounds, or null if bounds are not available for this object.\n\t */\n\tgetTransformedBounds () {\n\t\treturn this._getBounds();\n\t}\n\n\t/**\n\t * Allows you to manually specify the bounds of an object that either cannot calculate their own bounds (ex. Shape &\n\t * Text) for future reference, or so the object can be included in Container bounds. Manually set bounds will always\n\t * override calculated bounds.\n\t *\n\t * The bounds should be specified in the object\'s local (untransformed) coordinates. For example, a Shape instance\n\t * with a 25px radius circle centered at 0,0 would have bounds of (-25, -25, 50, 50).\n\t *\n\t * @param {Number} x The x origin of the bounds. Pass null to remove the manual bounds.\n\t * @param {Number} y The y origin of the bounds.\n\t * @param {Number} width The width of the bounds.\n\t * @param {Number} height The height of the bounds.\n\t */\n\tsetBounds (x, y, width, height) {\n\t\tif (x == null) { this._bounds = null; }\n\t\tthis._bounds = (this._bounds || new Rectangle()).setValues(x, y, width, height);\n\t}\n\n\t/**\n\t * Returns a clone of this DisplayObject. Some properties that are specific to this instance\'s current context are\n\t * reverted to their defaults (for example .parent). Caches are not maintained across clones, and some elements\n\t * are copied by reference (masks, individual filter instances, hit area)\n\t *\n\t * @return {easeljs.DisplayObject} A clone of the current DisplayObject instance.\n\t */\n\tclone () {\n\t\treturn this._cloneProps(new DisplayObject_DisplayObject());\n\t}\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @return {String} a string representation of the instance.\n\t */\n\ttoString () {\n\t\treturn `[${this.constructor.name}${this.name ? ` (name=${this.name})` : ""}]`;\n\t}\n\n\t/**\n\t * @protected\n\t * @param {easeljs.DisplayObject} o The DisplayObject instance which will have properties from the current DisplayObject\n\t * instance copied into.\n\t * @return {easeljs.DisplayObject} o\n\t */\n\t_cloneProps (o) {\n\t\to.alpha = this.alpha;\n\t\to.mouseEnabled = this.mouseEnabled;\n\t\to.tickEnabled = this.tickEnabled;\n\t\to.name = this.name;\n\t\to.regX = this.regX;\n\t\to.regY = this.regY;\n\t\to.rotation = this.rotation;\n\t\to.scaleX = this.scaleX;\n\t\to.scaleY = this.scaleY;\n\t\to.shadow = this.shadow;\n\t\to.skewX = this.skewX;\n\t\to.skewY = this.skewY;\n\t\to.visible = this.visible;\n\t\to.x  = this.x;\n\t\to.y = this.y;\n\t\to.compositeOperation = this.compositeOperation;\n\t\to.snapToPixel = this.snapToPixel;\n\t\to.filters = this.filters==null?null:this.filters.slice(0);\n\t\to.mask = this.mask;\n\t\to.hitArea = this.hitArea;\n\t\to.cursor = this.cursor;\n\t\to._bounds = this._bounds;\n\t\treturn o;\n\t}\n\n\t/**\n\t * @protected\n\t * @param {CanvasRenderingContext2D} ctx\n\t * @param {easeljs.Shadow} [shadow=Shadow]\n\t */\n\t_applyShadow (ctx, shadow = Shadow.identity) {\n\t\tshadow = shadow;\n\t\tctx.shadowColor = shadow.color;\n\t\tctx.shadowOffsetX = shadow.offsetX;\n\t\tctx.shadowOffsetY = shadow.offsetY;\n\t\tctx.shadowBlur = shadow.blur;\n\t}\n\n\t/**\n\t * @protected\n\t * @param {Object} evtObj An event object that will be dispatched to all tick listeners. This object is reused between dispatchers to reduce construction & GC costs.\n\t */\n\t_tick (evtObj) {\n\t\t// because tick can be really performance sensitive, check for listeners before calling dispatchEvent.\n\t\tlet ls = this._listeners;\n\t\tif (ls && ls["tick"]) {\n\t\t\t// reset & reuse the event object to avoid construction / GC costs:\n\t\t\tevtObj.target = null;\n\t\t\tevtObj.propagationStopped = evtObj.immediatePropagationStopped = false;\n\t\t\tthis.dispatchEvent(evtObj);\n\t\t}\n\t}\n\n\t/**\n\t * @protected\n\t * @param {CanvasRenderingContext2D} ctx\n\t * @return {Boolean}\n\t */\n\t_testHit (ctx) {\n\t\ttry {\n\t\t\treturn ctx.getImageData(0, 0, 1, 1).data[3] > 1;\n\t\t} catch (e) {\n\t\t\tif (!DisplayObject_DisplayObject.suppressCrossDomainErrors) {\n\t\t\t\tthrow "An error has occurred. This is most likely due to security restrictions on reading canvas pixel data with local or cross-domain images.";\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * @protected\n\t * @param {easeljs.Matrix2D} matrix\n\t * @param {Boolean} ignoreTransform If true, does not apply this object\'s transform.\n\t * @return {easeljs.Rectangle}\n\t */\n\t_getBounds (matrix, ignoreTransform) {\n\t\treturn this._transformBounds(this.getBounds(), matrix, ignoreTransform);\n\t}\n\n\t/**\n\t * @protected\n\t * @param {easeljs.Rectangle} bounds\n\t * @param {easeljs.Matrix2D} matrix\n\t * @param {Boolean} ignoreTransform\n\t * @return {easeljs.Rectangle}\n\t */\n\t_transformBounds (bounds, matrix, ignoreTransform) {\n\t\tif (!bounds) { return bounds; }\n\t\tlet { x, y, width, height } = bounds;\n\t\tlet mtx = this._props.matrix;\n\t\tmtx = ignoreTransform ? mtx.identity() : this.getMatrix(mtx);\n\n\t\tif (x || y) { mtx.appendTransform(0,0,1,1,0,0,0,-x,-y); } // TODO: simplify this.\n\t\tif (matrix) { mtx.prependMatrix(matrix); }\n\n\t\tlet x_a = width*mtx.a, x_b = width*mtx.b;\n\t\tlet y_c = height*mtx.c, y_d = height*mtx.d;\n\t\tlet tx = mtx.tx, ty = mtx.ty;\n\n\t\tlet minX = tx, maxX = tx, minY = ty, maxY = ty;\n\n\t\tif ((x = x_a + tx) < minX) { minX = x; } else if (x > maxX) { maxX = x; }\n\t\tif ((x = x_a + y_c + tx) < minX) { minX = x; } else if (x > maxX) { maxX = x; }\n\t\tif ((x = y_c + tx) < minX) { minX = x; } else if (x > maxX) { maxX = x; }\n\n\t\tif ((y = x_b + ty) < minY) { minY = y; } else if (y > maxY) { maxY = y; }\n\t\tif ((y = x_b + y_d + ty) < minY) { minY = y; } else if (y > maxY) { maxY = y; }\n\t\tif ((y = y_d + ty) < minY) { minY = y; } else if (y > maxY) { maxY = y; }\n\n\t\treturn bounds.setValues(minX, minY, maxX-minX, maxY-minY);\n\t}\n\n\t/**\n\t * Indicates whether the display object has any mouse event listeners or a cursor.\n\t * @protected\n\t * @return {Boolean}\n\t */\n\t_hasMouseEventListener () {\n\t\tlet evts = DisplayObject_DisplayObject._MOUSE_EVENTS;\n\t\tfor (let i=0, l=evts.length; i<l; i++) {\n\t\t\tif (this.hasEventListener(evts[i])) { return true; }\n\t\t}\n\t\treturn !!this.cursor;\n\t}\n\n}\n\n{\n\tlet canvas = window.createjs && createjs.createCanvas?createjs.createCanvas():document.createElement("canvas"); // prevent errors on load in browsers without canvas.\n\tif (canvas.getContext) {\n\t\t/**\n\t\t * @type {HTMLCanvasElement | Object}\n\t\t * @static\n\t\t */\n\t\tDisplayObject_DisplayObject._hitTestCanvas = canvas;\n\t\t/**\n\t\t * @type {CanvasRenderingContext2D}\n\t\t * @static\n\t\t */\n\t\tDisplayObject_DisplayObject._hitTestContext = canvas.getContext("2d");\n\t\tcanvas.width = canvas.height = 1;\n\t}\n}\n\n/**\n * Listing of mouse event names. Used in _hasMouseEventListener.\n * @static\n * @type {Array<String>}\n * @readonly\n */\nDisplayObject_DisplayObject._MOUSE_EVENTS = ["click","dblclick","mousedown","mouseout","mouseover","pressmove","pressup","rollout","rollover"];\n\n/**\n * Suppresses errors generated when using features like hitTest, mouse events, and {{#crossLink "getObjectsUnderPoint"}}{{/crossLink}}\n * with cross domain content.\n * @static\n * @type {Boolean}\n * @default false\n */\nDisplayObject_DisplayObject.suppressCrossDomainErrors = false;\n\n/**\n * @static\n * @type {Boolean}\n * @default false\n */\nDisplayObject_DisplayObject.snapToPixelEnabled = false;\n\n/**\n * Enum like property for determining StageGL render lookup, i.e. where to expect properties.\n * @static\n * @type {Number}\n */\nDisplayObject_DisplayObject._StageGL_NONE = 0;\n\n/**\n * Enum like property for determining StageGL render lookup, i.e. where to expect properties.\n * @static\n * @type {Number}\n */\nDisplayObject_DisplayObject._StageGL_SPRITE = 1;\n\n/**\n * Enum like property for determining StageGL render lookup, i.e. where to expect properties.\n * @static\n * @type {Number}\n */\nDisplayObject_DisplayObject._StageGL_BITMAP = 2;\n\n/**\n * Dispatched when the user presses their left mouse button over the display object.\n * @see {@link easeljs.MouseEvent}\n * @event easeljs.DisplayObject#mousedown\n * @since 0.6.0\n */\n\n/**\n * Dispatched when the user presses their left mouse button and then releases it while over the display object.\n * @see {@link easeljs.MouseEvent}\n * @event easeljs.DisplayObject#click\n * @since 0.6.0\n */\n\n/**\n * Dispatched when the user double clicks their left mouse button over this display object.\n * @see {@link easeljs.MouseEvent}\n * @event easeljs.DisplayObject#dblclick\n * @since 0.6.0\n */\n\n/**\n * Dispatched when the user\'s mouse enters this display object. This event must be enabled using\n * {@link easeljs.Stage#enableMouseOver}.\n * @see {@link easeljs.DisplayObject#event:rollover}\n * @see {@link easeljs.MouseEvent}\n * @event easeljs.DisplayObject#mouseover\n * @since 0.6.0\n */\n\n/**\n * Dispatched when the user\'s mouse leaves this display object. This event must be enabled using\n * {@link easeljs.Stage#enableMouseOver}.\n * @see {@link easeljs.DisplayObject#event:rollout}\n * @see {@link easeljs.MouseEvent}\n * @event easeljs.DisplayObject#mouseout\n * @since 0.6.0\n */\n\n/**\n * This event is similar to {@link easeljs.DisplayObject#event:mouseover}, with the following\n * differences: it does not bubble, and it considers {@link easeljs.Container} instances as an\n * aggregate of their content.\n *\n * For example, myContainer contains two overlapping children: shapeA and shapeB. The user moves their mouse over\n * shapeA and then directly on to shapeB. With a listener for {@link easeljs.DisplayObject#event:mouseover} on\n * myContainer, two events would be received, each targeting a child element:\n * <ol>\n *   <li>when the mouse enters shapeA (target=shapeA)</li>\n *   <li>when the mouse enters shapeB (target=shapeB)</li>\n * </ol>\n * However, with a listener for "rollover" instead, only a single event is received when the mouse first enters\n * the aggregate myContainer content (target=myContainer).\n *\n * This event must be enabled using {@link easeljs.Stage#enableMouseOver}.\n * @see {@link easeljs.MouseEvent}\n * @event easeljs.DisplayObject#rollover\n * @since 0.7.0\n */\n\n/**\n * This event is similar to {@link easeljs.DisplayObject#event:mouseout}, with the following\n * differences: it does not bubble, and it considers {@link easeljs.Container} instances as an\n * aggregate of their content.\n *\n * For example, myContainer contains two overlapping children: shapeA and shapeB. The user moves their mouse over\n * shapeA, then directly on to shapeB, then off both. With a listener for {@link easeljs.DisplayObject#event:mouseout}\n * on myContainer, two events would be received, each targeting a child element:<OL>\n * <LI>when the mouse leaves shapeA (target=shapeA)</LI>\n * <LI>when the mouse leaves shapeB (target=shapeB)</LI>\n * </OL>\n * However, with a listener for "rollout" instead, only a single event is received when the mouse leaves\n * the aggregate myContainer content (target=myContainer).\n *\n * This event must be enabled using {@link easeljs.Stage#enableMouseOver}.\n * @see {@link easeljs.MouseEvent}\n * @event easeljs.DisplayObject#rollout\n * @since 0.7.0\n */\n\n/**\n * After a {@link easeljs.DisplayObject#event:mousedown} occurs on a display object, a pressmove\n * event will be generated on that object whenever the mouse moves until the mouse press is released. This can be\n * useful for dragging and similar operations.\n * @event easeljs.DisplayObject#pressmove\n * @since 0.7.0\n */\n\n/**\n * After a {@link easeljs.DisplayObject#event:mousedown} occurs on a display object, a pressup event\n * will be generated on that object when that mouse press is released. This can be useful for dragging and similar\n * operations.\n * @event easeljs.DisplayObject#pressup\n * @since 0.7.0\n */\n\n/**\n * Dispatched when the display object is added to a parent container.\n * @event easeljs.DisplayObject#added\n */\n\n/**\n * Dispatched when the display object is removed from its parent container.\n * @event easeljs.DisplayObject#removed\n */\n\n/**\n * Dispatched on each display object on a stage whenever the stage updates. This occurs immediately before the\n * rendering (draw) pass. When {@link easeljs.Stage#update} is called, first all display objects on\n * the stage dispatch the tick event, then all of the display objects are drawn to stage. Children will have their\n * tick event dispatched in order of their depth prior to the event being dispatched on their parent.\n * @event easeljs.DisplayObject#tick\n * @param {Object} target The object that dispatched the event.\n * @param {String} type The event type.\n * @param {Array} params An array containing any arguments that were passed to the Stage.update() method.\n * @since 0.6.0\n */\n\n// CONCATENATED MODULE: ./node_modules/@createjs/easeljs/src/display/Container.js\n/**\n * @license Container\n * Visit http://createjs.com/ for documentation, updates and examples.\n *\n * Copyright (c) 2017 gskinner.com, inc.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the "Software"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n\n\n/**\n * A Container is a nestable display list that allows you to work with compound display elements. For  example you could\n * group arm, leg, torso and head {{#crossLink "Bitmap"}}{{/crossLink}} instances together into a Person Container, and\n * transform them as a group, while still being able to move the individual parts relative to each other. Children of\n * containers have their `transform` and `alpha` properties concatenated with their parent\n * Container.\n *\n * For example, a {{#crossLink "Shape"}}{{/crossLink}} with x=100 and alpha=0.5, placed in a Container with `x=50`\n * and `alpha=0.7` will be rendered to the canvas at `x=150` and `alpha=0.35`.\n * Containers have some overhead, so you generally shouldn\'t create a Container to hold a single child.\n *\n * @memberof easeljs\n * @extends easeljs.DisplayObject\n * @example\n * import { Container } from "@createjs/easeljs";\n * const container = new Container();\n * container.addChild(bitmapInstance, shapeInstance);\n * container.x = 100;\n */\nclass Container_Container extends DisplayObject_DisplayObject {\n\n\tconstructor () {\n\t\tsuper();\n\n\t\t/**\n\t\t * The array of children in the display list. You should usually use the child management methods such as\n\t\t * {@link easeljs.Container#addChild}, {@link easeljs.Container#removeChild}, {@link easeljs.Container#swapChildren},\n\t\t * etc, rather than accessing this directly, but it is included for advanced uses.\n\t\t * @type {Array}\n\t\t * @default []\n\t\t */\n\t\tthis.children = [];\n\n\t\t/**\n\t\t * Indicates whether the children of this container are independently enabled for mouse/pointer interaction.\n\t\t * If false, the children will be aggregated under the container - for example, a click on a child shape would\n\t\t * trigger a click event on the container.\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.mouseChildren = true;\n\n\t\t/**\n\t\t * If false, the tick will not be propagated to children of this Container. This can provide some performance benefits.\n\t\t * In addition to preventing the {@link core.Ticker#event:tick} event from being dispatched, it will also prevent tick related updates\n\t\t * on some display objects (ex. Sprite & MovieClip frame advancing, DOMElement visibility handling).\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.tickChildren = true;\n\t}\n\n\t/**\n\t * Returns the number of children in the container.\n\t * @type {Number}\n\t * @readonly\n\t */\n\tget numChildren () {\n\t\treturn this.children.length;\n\t}\n\n\tisVisible () {\n\t\tlet hasContent = this.cacheCanvas || this.children.length;\n\t\treturn !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0 && hasContent);\n\t}\n\n\tdraw (ctx, ignoreCache = false) {\n\t\tif (super.draw(ctx, ignoreCache)) { return true; }\n\n\t\t// this ensures we don\'t have issues with display list changes that occur during a draw:\n\t\tlet list = this.children.slice();\n\t\tfor (let i=0,l=list.length; i<l; i++) {\n\t\t\tlet child = list[i];\n\t\t\tif (!child.isVisible()) { continue; }\n\n\t\t\t// draw the child:\n\t\t\tctx.save();\n\t\t\tchild.updateContext(ctx);\n\t\t\tchild.draw(ctx);\n\t\t\tctx.restore();\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Adds a child to the top of the display list.\n\t *\n\t * @example\n\t * container.addChild(bitmapInstance);\n\t * // You can also add multiple children at once:\n\t * container.addChild(bitmapInstance, shapeInstance, textInstance);\n\t *\n\t * @param {...easeljs.DisplayObject} children The display object(s) to add.\n\t * @return {easeljs.DisplayObject} The child that was added, or the last child if multiple children were added.\n\t */\n\taddChild (...children) {\n\t\tconst l = children.length;\n\t\tif (l === 0) { return null; }\n\t\tlet child = children[0];\n\t\tif (l > 1) {\n\t\t\tfor (let i = 0; i < l; i++) { child = this.addChild(children[i]); }\n\t\t\treturn child;\n\t\t}\n    // Note: a lot of duplication with addChildAt, but push is WAY faster than splice.\n    let parent = child.parent, silent = parent === this;\n    parent && parent._removeChildAt(parent.children.indexOf(child), silent);\n\t\tchild.parent = this;\n\t\tthis.children.push(child);\n    if (!silent) { child.dispatchEvent("added"); }\n\t\treturn child;\n\t}\n\n\t/**\n\t * Adds a child to the display list at the specified index, bumping children at equal or greater indexes up one, and\n\t * setting its parent to this container.\n\t *\n\t * @example\n\t * container.addChildAt(child1, index);\n\t * // You can also add multiple children, such as:\n\t * container.addChildAt(child1, child2, ..., index);\n\t * // The index must be between 0 and numChildren. For example, to add myShape under otherShape in the display list, you could use:\n\t * container.addChildAt(myShape, container.getChildIndex(otherShape));\n\t * // This would also bump otherShape\'s index up by one. Fails silently if the index is out of range.\n\t *\n\t * @param {...easeljs.DisplayObject} children The display object(s) to add.\n\t * @param {Number} index The index to add the child at.\n\t * @return {easeljs.DisplayObject} Returns the last child that was added, or the last child if multiple children were added.\n\t */\n\taddChildAt (...children) {\n\t\tconst l = children.length;\n    if (l === 0) { return null; }\n    let index = children.pop();\n\t\tif (index < 0 || index > this.children.length) { return children[l - 2]; }\n\t\tif (l > 2) {\n\t\t\tfor (let i = 0; i < l - 1; i++) { this.addChildAt(children[i], index++); }\n\t\t\treturn children[l - 2];\n\t\t}\n\t\tlet child = children[0];\n    let parent = child.parent, silent = parent === this;\n    parent && parent._removeChildAt(parent.children.indexOf(child), silent);\n\t\tchild.parent = this;\n\t\tthis.children.splice(index++, 0, child);\n    if (!silent) { child.dispatchEvent("added"); }\n\t\treturn child;\n\t}\n\n\t/**\n\t * Removes the specified child from the display list. Note that it is faster to use removeChildAt() if the index is\n\t * already known.\n\t *\n\t * @example\n\t * container.removeChild(child);\n\t * // You can also remove multiple children:\n\t * container.removeChild(child1, child2, ...);\n\t *\n\t * @param {...easeljs.DisplayObject} children The display object(s) to remove.\n\t * @return {Boolean} true if the child (or children) was removed, or false if it was not in the display list.\n\t */\n\tremoveChild (...children) {\n\t\tconst l = children.length;\n    if (l === 0) { return true; }\n\t\tif (l > 1) {\n\t\t\tlet good = true;\n\t\t\tfor (let i = 0; i < l; i++) { good = good && this.removeChild(children[i]); }\n\t\t\treturn good;\n\t\t}\n\t\treturn this._removeChildAt(this.children.indexOf(children[0]));\n\t}\n\n\t/**\n\t * Removes the child at the specified index from the display list, and sets its parent to null.\n\t *\n\t * @example\n\t * container.removeChildAt(2);\n\t * // You can also remove multiple children:\n\t * container.removeChildAt(2, 7, ...)\n\t *\n\t * @param {...Number} indexes The indexes of children to remove.\n\t * @return {Boolean} true if the child (or children) was removed, or false if any index was out of range.\n\t */\n\tremoveChildAt (...indexes) {\n\t\tconst l = indexes.length;\n    if (l === 0) { return true; }\n\t\tif (l > 1) {\n\t\t\tindexes.sort((a, b) => b - a);\n\t\t\tlet good = true;\n\t\t\tfor (let i = 0; i < l; i++) { good = good && this._removeChildAt(indexes[i]); }\n\t\t\treturn good;\n\t\t}\n\t\treturn this._removeChildAt(indexes[0]);\n\t}\n\n\t/**\n\t * Removes all children from the display list.\n\t */\n\tremoveAllChildren () {\n\t\tlet kids = this.children;\n\t\twhile (kids.length) { this._removeChildAt(0); }\n\t}\n\n\t/**\n\t * Returns the child at the specified index.\n\t * @param {Number} index The index of the child to return.\n\t * @return {easeljs.DisplayObject} The child at the specified index. Returns null if there is no child at the index.\n\t */\n\tgetChildAt (index) {\n\t\treturn this.children[index];\n\t}\n\n\t/**\n\t * Returns the child with the specified name.\n\t * @param {String} name The name of the child to return.\n\t * @return {easeljs.DisplayObject} The child with the specified name.\n\t */\n\tgetChildByName (name) {\n\t\tlet kids = this.children;\n\t\tconst l = kids.length;\n\t\tfor (let i = 0; i < l; i++) {\n\t\t\tif (kids[i].name === name) { return kids[i]; }\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Performs an array sort operation on the child list.\n\t *\n\t * @example\n\t * // Display children with a higher y in front.\n\t * container.sortChildren((obj1, obj2, options) => {\n\t * \t if (obj1.y > obj2.y) { return 1; }\n\t *   if (obj1.y < obj2.y) { return -1; }\n\t *   return 0;\n\t * });\n\t *\n\t * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort}\n\t * @param {Function} sortFunction the function to use to sort the child list.\n\t */\n\tsortChildren (sortFunction) {\n\t\tthis.children.sort(sortFunction);\n\t}\n\n\t/**\n\t * Returns the index of the specified child in the display list, or -1 if it is not in the display list.\n\t * @param {easeljs.DisplayObject} child The child to return the index of.\n\t * @return {Number} The index of the specified child. -1 if the child is not found.\n\t */\n\tgetChildIndex (child) {\n\t\treturn this.children.indexOf(child);\n\t}\n\n\t/**\n\t * Swaps the children at the specified indexes. Fails silently if either index is out of range.\n\t * @param {Number} index1\n\t * @param {Number} index2\n\t */\n\tswapChildrenAt (index1, index2) {\n\t\tlet kids = this.children;\n\t\tlet o1 = kids[index1];\n\t\tlet o2 = kids[index2];\n\t\tif (!o1 || !o2) { return; }\n\t\tkids[index1] = o2;\n\t\tkids[index2] = o1;\n\t};\n\n\t/**\n\t * Swaps the specified children\'s depth in the display list. Fails silently if either child is not a child of this\n\t * Container.\n\t * @param {easeljs.DisplayObject} child1\n\t * @param {easeljs.DisplayObject} child2\n\t */\n\tswapChildren (child1, child2) {\n\t\tlet kids = this.children;\n\t\tconst l = kids.length;\n\t\tlet index1,index2;\n\t\tfor (var i = 0; i < l; i++) {\n\t\t\tif (kids[i] === child1) { index1 = i; }\n\t\t\tif (kids[i] === child2) { index2 = i; }\n\t\t\tif (index1 != null && index2 != null) { break; }\n\t\t}\n\t\tif (i === l) { return; } // TODO: throw error?\n\t\tkids[index1] = child2;\n\t\tkids[index2] = child1;\n\t}\n\n\t/**\n\t * Changes the depth of the specified child. Fails silently if the child is not a child of this container, or the index is out of range.\n\t * @param {easeljs.DisplayObject} child\n\t * @param {Number} index\n\t */\n\tsetChildIndex (child, index) {\n\t\tlet kids = this.children;\n\t\tconst l = kids.length;\n\t\tif (child.parent != this || index < 0 || index >= l) { return; }\n\t\tfor (var i = 0; i < l; i++) {\n\t\t\tif (kids[i] === child) { break; }\n\t\t}\n\t\tif (i === l || i === index) { return; }\n\t\tkids.splice(i, 1);\n\t\tkids.splice(index, 0, child);\n\t}\n\n\t/**\n\t * Returns true if the specified display object either is this container or is a descendent (child, grandchild, etc)\n\t * of this container.\n\t * @param {easeljs.DisplayObject} child The DisplayObject to be checked.\n\t * @return {Boolean} true if the specified display object either is this container or is a descendent.\n\t */\n\tcontains (child) {\n\t\twhile (child) {\n\t\t\tif (child === this) { return true; }\n\t\t\tchild = child.parent;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Tests whether the display object intersects the specified local point (ie. draws a pixel with alpha > 0 at the\n\t * specified position). This ignores the alpha, shadow and compositeOperation of the display object, and all\n\t * transform properties including regX/Y.\n\t * @param {Number} x The x position to check in the display object\'s local coordinates.\n\t * @param {Number} y The y position to check in the display object\'s local coordinates.\n\t * @return {Boolean} A Boolean indicating whether there is a visible section of a DisplayObject that overlaps the specified\n\t * coordinates.\n\t */\n\thitTest (x, y) {\n\t\t// TODO: optimize to use the fast cache check where possible.\n\t\treturn this.getObjectUnderPoint(x, y) != null;\n\t}\n\n\t/**\n\t * Returns an array of all display objects under the specified coordinates that are in this container\'s display\n\t * list. This routine ignores any display objects with {@link easeljs.DisplayObject#mouseEnabled} set to `false`.\n\t * The array will be sorted in order of visual depth, with the top-most display object at index 0.\n\t * This uses shape based hit detection, and can be an expensive operation to run, so it is best to use it carefully.\n\t * For example, if testing for objects under the mouse, test on tick (instead of on {@link easeljs.DisplayObject#event:mousemove}),\n\t * and only if the mouse\'s position has changed.\n\t *\n\t * <ul>\n\t *   <li>By default (mode=0) this method evaluates all display objects.</li>\n\t *   <li>By setting the `mode` parameter to `1`, the {@link easeljs.DisplayObject#mouseEnabled}\n\t *       and {@link easeljs.DisplayObject#mouseChildren} properties will be respected.</li>\n\t *   <li>Setting the `mode` to `2` additionally excludes display objects that do not have active mouse event\n\t *       listeners or a {@link easeljs.DisplayObject#cursor} property. That is, only objects\n\t *       that would normally intercept mouse interaction will be included. This can significantly improve performance\n\t *       in some cases by reducing the number of display objects that need to be tested.</li>\n\t * </ul>\n\t *\n\t * This method accounts for both {@link easeljs.DisplayObject#hitArea} and {@link easeljs.DisplayObject#mask}.\n\t *\n\t * @param {Number} x The x position in the container to test.\n\t * @param {Number} y The y position in the container to test.\n\t * @param {Number} [mode=0] The mode to use to determine which display objects to include. 0-all, 1-respect mouseEnabled/mouseChildren, 2-only mouse opaque objects.\n\t * @return {Array<easeljs.DisplayObject>} An array of DisplayObjects under the specified coordinates.\n\t */\n\tgetObjectsUnderPoint (x, y, mode = 0) {\n\t\tlet arr = [];\n\t\tlet pt = this.localToGlobal(x, y);\n\t\tthis._getObjectsUnderPoint(pt.x, pt.y, arr, mode > 0, mode === 1);\n\t\treturn arr;\n\t}\n\n\t/**\n\t * Similar to {@link easeljs.Container#getObjectsUnderPoint}, but returns only the top-most display\n\t * object. This runs significantly faster than `getObjectsUnderPoint()`, but is still potentially an expensive\n\t * operation.\n\t *\n\t * @param {Number} x The x position in the container to test.\n\t * @param {Number} y The y position in the container to test.\n\t * @param {Number} [mode=0] The mode to use to determine which display objects to include.  0-all, 1-respect mouseEnabled/mouseChildren, 2-only mouse opaque objects.\n\t * @return {easeljs.DisplayObject} The top-most display object under the specified coordinates.\n\t */\n\tgetObjectUnderPoint (x, y, mode = 0) {\n\t\tlet pt = this.localToGlobal(x, y);\n\t\treturn this._getObjectsUnderPoint(pt.x, pt.y, null, mode > 0, mode === 1);\n\t}\n\n\tgetBounds () {\n\t\treturn this._getBounds(null, true);\n\t}\n\n\tgetTransformedBounds () {\n\t\treturn this._getBounds();\n\t}\n\n\t/**\n\t * Returns a clone of this Container. Some properties that are specific to this instance\'s current context are\n\t * reverted to their defaults (for example `.parent`).\n\t * @param {Boolean} [recursive=false] If true, all of the descendants of this container will be cloned recursively. If false, the\n\t * properties of the container will be cloned, but the new instance will not have any children.\n\t * @return {easeljs.Container} A clone of the current Container instance.\n\t */\n\tclone (recursive = false) {\n\t\tlet o = this._cloneProps(new Container_Container());\n\t\tif (recursive) { this._cloneChildren(o); }\n\t\treturn o;\n\t}\n\n\t_tick (evtObj) {\n\t\tif (this.tickChildren) {\n\t\t\tfor (let i = this.children.length - 1; i >= 0; i--) {\n\t\t\t\tlet child = this.children[i];\n\t\t\t\tif (child.tickEnabled && child._tick) { child._tick(evtObj); }\n\t\t\t}\n\t\t}\n\t\tsuper._tick(evtObj);\n\t}\n\n\t/**\n\t * Recursively clones all children of this container, and adds them to the target container.\n\t * @protected\n\t * @param {easeljs.Container} o The target container.\n\t */\n\t_cloneChildren (o) {\n\t\tif (o.children.length) { o.removeAllChildren(); }\n\t\tlet arr = o.children;\n\t\tconst l = this.children.length;\n\t\tfor (let i = 0; i < l; i++) {\n\t\t\tlet clone = this.children[i].clone(true);\n\t\t\tclone.parent = o;\n\t\t\tarr.push(clone);\n\t\t}\n\t}\n\n  /**\n   * Removes the child at the specified index from the display list, and sets its parent to null.\n   * Used by `removeChildAt`, `addChild`, and `addChildAt`.\n   *\n   * @protected\n   * @param {Number} index The index of the child to remove.\n   * @param {Boolean} [silent=false] Prevents dispatch of `removed` event if true.\n   * @return {Boolean} true if the child (or children) was removed, or false if any index was out of range.\n   */\n  _removeChildAt (index, silent = false) {\n\t\tif (index < 0 || index > this.children.length - 1) { return false; }\n\t\tlet child = this.children[index];\n\t\tif (child) { child.parent = null; }\n\t\tthis.children.splice(index, 1);\n\t\tif (!silent) { child.dispatchEvent("removed"); }\n\t\treturn true;\n  }\n\n\t/**\n\t * @protected\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Array} arr\n\t * @param {Boolean} mouse If true, it will respect mouse interaction properties like mouseEnabled, mouseChildren, and active listeners.\n\t * @param {Boolean} activeListener If true, there is an active mouse event listener on a parent object.\n\t * @param {Number} [currentDepth=0] Indicates the current depth of the search.\n\t * @return {easeljs.DisplayObject}\n\t */\n\t_getObjectsUnderPoint (x, y, arr, mouse, activeListener, currentDepth = 0) {\n\t\tif (!currentDepth && !this._testMask(this, x, y)) { return null; }\n\t\tlet mtx, ctx = DisplayObject_DisplayObject._hitTestContext;\n\t\tactiveListener = activeListener || (mouse && this._hasMouseEventListener());\n\n\t\t// draw children one at a time, and check if we get a hit:\n\t\tlet children = this.children;\n\t\tconst l = children.length;\n\t\tfor (let i = l - 1; i >= 0; i--) {\n\t\t\tlet child = children[i];\n\t\t\tlet hitArea = child.hitArea;\n\t\t\tif (!child.visible || (!hitArea && !child.isVisible()) || (mouse && !child.mouseEnabled)) { continue; }\n\t\t\tif (!hitArea && !this._testMask(child, x, y)) { continue; }\n\n\t\t\t// if a child container has a hitArea then we only need to check its hitArea, so we can treat it as a normal DO:\n\t\t\tif (!hitArea && child instanceof Container_Container) {\n\t\t\t\tlet result = child._getObjectsUnderPoint(x, y, arr, mouse, activeListener, currentDepth + 1);\n\t\t\t\tif (!arr && result) { return (mouse && !this.mouseChildren) ? this : result; }\n\t\t\t} else {\n\t\t\t\tif (mouse && !activeListener && !child._hasMouseEventListener()) { continue; }\n\n\t\t\t\t// TODO: can we pass displayProps forward, to avoid having to calculate this backwards every time? It\'s kind of a mixed bag. When we\'re only hunting for DOs with event listeners, it may not make sense.\n\t\t\t\tlet props = child.getConcatenatedDisplayProps(child._props);\n\t\t\t\tmtx = props.matrix;\n\n\t\t\t\tif (hitArea) {\n\t\t\t\t\tmtx.appendMatrix(hitArea.getMatrix(hitArea._props.matrix));\n\t\t\t\t\tprops.alpha = hitArea.alpha;\n\t\t\t\t}\n\n\t\t\t\tctx.globalAlpha = props.alpha;\n\t\t\t\tctx.setTransform(mtx.a, mtx.b, mtx.c, mtx.d, mtx.tx-x, mtx.ty-y);\n\t\t\t\t(hitArea || child).draw(ctx);\n\t\t\t\tif (!this._testHit(ctx)) { continue; }\n\t\t\t\tctx.setTransform(1, 0, 0, 1, 0, 0);\n\t\t\t\tctx.clearRect(0, 0, 2, 2);\n\t\t\t\tif (arr) { arr.push(child); }\n\t\t\t\telse { return (mouse && !this.mouseChildren) ? this : child; }\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * @protected\n\t * @param {easeljs.DisplayObject} target\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @return {Boolean} Indicates whether the x/y is within the masked region.\n\t */\n\t_testMask (target, x, y) {\n\t\tlet mask = target.mask;\n\t\tif (!mask || !mask.graphics || mask.graphics.isEmpty()) { return true; }\n\n\t\tlet mtx = this._props.matrix, parent = target.parent;\n\t\tmtx = parent ? parent.getConcatenatedMatrix(mtx) : mtx.identity();\n\t\tmtx = mask.getMatrix(mask._props.matrix).prependMatrix(mtx);\n\n\t\tlet ctx = DisplayObject_DisplayObject._hitTestContext;\n\t\tctx.setTransform(mtx.a, mtx.b, mtx.c, mtx.d, mtx.tx-x, mtx.ty-y);\n\n\t\t// draw the mask as a solid fill:\n\t\tmask.graphics.drawAsPath(ctx);\n\t\tctx.fillStyle = "#000";\n\t\tctx.fill();\n\n\t\tif (!this._testHit(ctx)) { return false; }\n\t\tctx.setTransform(1, 0, 0, 1, 0, 0);\n\t\tctx.clearRect(0, 0, 2, 2);\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * @protected\n\t * @param {easeljs.Matrix2D} matrix\n\t * @param {Boolean} ignoreTransform If true, does not apply this object\'s transform.\n\t * @return {easeljs.Rectangle}\n\t */\n\t_getBounds (matrix, ignoreTransform) {\n\t\tlet bounds = super.getBounds();\n\t\tif (bounds) { return this._transformBounds(bounds, matrix, ignoreTransform); }\n\n\t\tlet mtx = this._props.matrix;\n\t\tmtx = ignoreTransform ? mtx.identity() : this.getMatrix(mtx);\n\t\tif (matrix) { mtx.prependMatrix(matrix); }\n\n\t\tconst l = this.children.length;\n\t\tlet rect = null;\n\t\tfor (let i = 0; i < l; i++) {\n\t\t\tlet child = this.children[i];\n\t\t\tif (!child.visible || !(bounds = child._getBounds(mtx))) { continue; }\n\t\t\tif (rect) { rect.extend(bounds.x, bounds.y, bounds.width, bounds.height); }\n\t\t\telse { rect = bounds.clone(); }\n\t\t}\n\t\treturn rect;\n\t}\n\n}\n\n// CONCATENATED MODULE: ./node_modules/@createjs/easeljs/src/events/MouseEvent.js\n/**\n * @license MouseEvent\n * Visit http://createjs.com/ for documentation, updates and examples.\n *\n * Copyright (c) 2017 gskinner.com, inc.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the "Software"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n\n\n/**\n * Passed as the parameter to all mouse/pointer/touch related events. For a listing of mouse events and their properties,\n * see the {@link easeljs.DisplayObject} and {@link easeljs.Stage} event listings.\n * @memberof easeljs\n * @extends core.Event\n * @param {String} type The event type.\n * @param {Boolean} bubbles Indicates whether the event will bubble through the display list.\n * @param {Boolean} cancelable Indicates whether the default behaviour of this event can be cancelled.\n * @param {Number} stageX The normalized x position relative to the stage.\n * @param {Number} stageY The normalized y position relative to the stage.\n * @param {easeljs.MouseEvent} nativeEvent The native DOM event related to this mouse event.\n * @param {Number} pointerID The unique id for the pointer.\n * @param {Boolean} primary Indicates whether this is the primary pointer in a multitouch environment.\n * @param {Number} rawX The raw x position relative to the stage.\n * @param {Number} rawY The raw y position relative to the stage.\n * @param {easeljs.DisplayObject} relatedTarget The secondary target for the event.\n */\nclass MouseEvent_MouseEvent extends events_Event {\n\n\tconstructor (type, bubbles, cancelable, stageX, stageY, nativeEvent, pointerID, primary, rawX, rawY, relatedTarget) {\n\t\tsuper(type, bubbles, cancelable);\n\n// public properties:\n\t\t/**\n\t\t * The normalized x position on the stage. This will always be within the range 0 to stage width.\n\t\t * @type {Number}\n\t\t*/\n\t\tthis.stageX = stageX;\n\n\t\t/**\n\t\t * The normalized y position on the stage. This will always be within the range 0 to stage height.\n\t\t * @type {Number}\n\t\t */\n\t\tthis.stageY = stageY;\n\n\t\t/**\n\t\t * The raw x position relative to the stage. Normally this will be the same as the stageX value, unless\n\t\t * stage.mouseMoveOutside is true and the pointer is outside of the stage bounds.\n\t\t * @type {Number}\n\t\t*/\n\t\tthis.rawX = (rawX==null)?stageX:rawX;\n\n\t\t/**\n\t\t * The raw y position relative to the stage. Normally this will be the same as the stageY value, unless\n\t\t * stage.mouseMoveOutside is true and the pointer is outside of the stage bounds.\n\t\t * @type {Number}\n\t\t*/\n\t\tthis.rawY = (rawY==null)?stageY:rawY;\n\n\t\t/**\n\t\t * The native MouseEvent generated by the browser. The properties and API for this\n\t\t * event may differ between browsers. This property will be null if the\n\t\t * EaselJS property was not directly generated from a native MouseEvent.\n\t\t * @type {HTMLMouseEvent}\n\t\t */\n\t\tthis.nativeEvent = nativeEvent;\n\n\t\t/**\n\t\t * The unique id for the pointer (touch point or cursor). This will be either -1 for the mouse, or the system\n\t\t * supplied id value.\n\t\t * @type {Number}\n\t\t */\n\t\tthis.pointerID = pointerID;\n\n\t\t/**\n\t\t * Indicates whether this is the primary pointer in a multitouch environment. This will always be true for the mouse.\n\t\t * For touch pointers, the first pointer in the current stack will be considered the primary pointer.\n\t\t * @type {Boolean}\n\t\t */\n\t\tthis.primary = !!primary;\n\n\t\t/**\n\t\t * The secondary target for the event, if applicable. This is used for mouseout/rollout\n\t\t * events to indicate the object that the mouse entered from, mouseover/rollover for the object the mouse exited,\n\t\t * and stagemousedown/stagemouseup events for the object that was the under the cursor, if any.\n\t\t *\n\t\t * Only valid interaction targets will be returned (ie. objects with mouse listeners or a cursor set).\n\t\t * @type {easeljs.DisplayObject}\n\t\t */\n\t\tthis.relatedTarget = relatedTarget;\n\t}\n\n\t/**\n\t * Returns the x position of the mouse in the local coordinate system of the current target (ie. the dispatcher).\n\t * @type {Number}\n\t * @readonly\n\t */\n\tget localX () {\n\t\treturn this.currentTarget.globalToLocal(this.rawX, this.rawY).x;\n\t}\n\n\t/**\n\t * Returns the y position of the mouse in the local coordinate system of the current target (ie. the dispatcher).\n\t * @type {Number}\n\t * @readonly\n\t */\n\tget localY () {\n\t\treturn this.currentTarget.globalToLocal(this.rawX, this.rawY).y;\n\t}\n\n\t/**\n\t * Indicates whether the event was generated by a touch input (versus a mouse input).\n\t * @type {Boolean}\n\t * @readonly\n\t */\n\tget isTouch () {\n\t\treturn this.pointerID !== -1;\n\t}\n\n\t/**\n\t * Returns a clone of the MouseEvent instance.\n\t * @return {easeljs.MouseEvent} a clone of the MouseEvent instance.\n\t */\n\tclone () {\n\t\treturn new MouseEvent_MouseEvent(this.type, this.bubbles, this.cancelable, this.stageX, this.stageY, this.nativeEvent, this.pointerID, this.primary, this.rawX, this.rawY);\n\t}\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @return {String} a string representation of the instance.\n\t */\n\ttoString () {\n\t\treturn `[${this.constructor.name} (type=${this.type} stageX=${this.stageX} stageY=${this.stageY})]`;\n\t}\n\n}\n\n// CONCATENATED MODULE: ./node_modules/@createjs/easeljs/src/display/Stage.js\n/**\n * @license Stage\n * Visit http://createjs.com/ for documentation, updates and examples.\n *\n * Copyright (c) 2017 gskinner.com, inc.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the "Software"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n\n\n\n\n\n/**\n * A stage is the root level {@link easeljs.Container} for a display list. Each time its {@link easeljs.Stage#tick}\n * method is called, it will render its display list to its target canvas.\n *\n * @memberof easeljs\n * @extends easeljs.Container\n * @example\n * let stage = new Stage("canvasElementId");\n * let image = new Bitmap("imagePath.png");\n * stage.addChild(image);\n * Ticker.addEventListener("tick", event => {\n *   image.x += 10;\n * \t stage.update();\n * });\n *\n * @param {HTMLCanvasElement | String | Object} canvas A canvas object that the Stage will render to, or the string id\n * of a canvas object in the current document.\n */\nclass Stage_Stage extends Container_Container {\n\n\tconstructor (canvas) {\n\t\tsuper();\n\n\t\t/**\n\t\t * Indicates whether the stage should automatically clear the canvas before each render. You can set this to `false`\n\t\t * to manually control clearing (for generative art, or when pointing multiple stages at the same canvas for\n\t\t * example).\n\t\t *\n\t\t * @example\n\t\t * let stage = new Stage("canvasId");\n\t\t * stage.autoClear = false;\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.autoClear = true;\n\n\t\t/**\n\t\t * The canvas the stage will render to. Multiple stages can share a single canvas, but you must disable autoClear for all but the\n\t\t * first stage that will be ticked (or they will clear each other\'s render).\n\t\t *\n\t\t * When changing the canvas property you must disable the events on the old canvas, and enable events on the\n\t\t * new canvas or mouse events will not work as expected.\n\t\t *\n\t\t * @example\n\t\t * stage.enableDOMEvents(false);\n\t\t * stage.canvas = anotherCanvas;\n\t\t * stage.enableDOMEvents(true);\n\t\t *\n\t\t * @type {HTMLCanvasElement | Object}\n\t\t */\n\t\tthis.canvas = (typeof canvas === "string") ? document.getElementById(canvas) : canvas;\n\n\t\t/**\n\t\t * The current mouse X position on the canvas. If the mouse leaves the canvas, this will indicate the most recent\n\t\t * position over the canvas, and mouseInBounds will be set to false.\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t * @readonly\n\t\t */\n\t\tthis.mouseX = 0;\n\n\t\t/**\n\t\t * The current mouse Y position on the canvas. If the mouse leaves the canvas, this will indicate the most recent\n\t\t * position over the canvas, and mouseInBounds will be set to false.\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t * @readonly\n\t\t */\n\t\tthis.mouseY = 0;\n\n\t\t/**\n\t\t * Specifies the area of the stage to affect when calling update. This can be use to selectively\n\t\t * re-draw specific regions of the canvas. If null, the whole canvas area is drawn.\n\t\t * @type {easeljs.Rectangle}\n\t\t */\n\t\tthis.drawRect = null;\n\n\t\t/**\n\t\t * Indicates whether display objects should be rendered on whole pixels. You can set the {@link easeljs.DisplayObject.snapToPixelEnabled}\n\t\t * property of display objects to false to enable/disable this behaviour on a per instance basis.\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.snapToPixelEnabled = false;\n\n\t\t/**\n\t\t * Indicates whether the mouse is currently within the bounds of the canvas.\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.mouseInBounds = false;\n\n\t\t/**\n\t\t * If true, tick callbacks will be called on all display objects on the stage prior to rendering to the canvas.\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.tickOnUpdate = true;\n\n\t\t/**\n\t\t * If true, mouse move events will continue to be called when the mouse leaves the target canvas.\n\t\t * See {@link easeljs.Stage#mouseInBounds}, and {@link easeljs.MouseEvent} x/y/rawX/rawY.\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.mouseMoveOutside = false;\n\n\n\t\t/**\n\t\t * Prevents selection of other elements in the html page if the user clicks and drags, or double clicks on the canvas.\n\t\t * This works by calling `preventDefault()` on any mousedown events (or touch equivalent) originating on the canvas.\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.preventSelection = true;\n\n\t\t/**\n\t\t * The hitArea property is not supported for Stage.\n\t\t * @property hitArea\n\t\t * @override\n\t\t * @default null\n\t\t * @private\n\t\t */\n\n\t\t/**\n\t\t * Holds objects with data for each active pointer id. Each object has the following properties:\n\t\t * x, y, event, target, overTarget, overX, overY, inBounds, posEvtObj (native event that last updated position)\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis._pointerData = {};\n\n\t\t/**\n\t\t * Number of active pointers.\n\t\t * @type {Number}\n\t\t * @private\n\t\t */\n\t\tthis._pointerCount = 0;\n\n\t\t/**\n\t\t * The ID of the primary pointer.\n\t\t * @type {String}\n\t\t * @private\n\t\t */\n\t\tthis._primaryPointerID = null;\n\n\t\t/**\n\t\t * @protected\n\t\t * @type {Number}\n\t\t */\n\t\tthis._mouseOverIntervalID = null;\n\n\t\t/**\n\t\t * @protected\n\t\t * @type {easeljs.Stage}\n\t\t */\n\t\tthis._nextStage = null;\n\n\t\t/**\n\t\t * @protected\n\t\t * @type {easeljs.Stage}\n\t\t */\n\t\tthis._prevStage = null;\n\n\t\tthis.enableDOMEvents(true);\n\t}\n\n\t/**\n\t * Specifies a target stage that will have mouse/touch interactions relayed to it after this stage handles them.\n\t * This can be useful in cases where you have multiple layered canvases and want user interactions\n\t * events to pass through.\n\t *\n\t * MouseOver, MouseOut, RollOver, and RollOut interactions are also passed through using the mouse over settings\n\t * of the top-most stage, but are only processed if the target stage has mouse over interactions enabled.\n\t * Considerations when using roll over in relay targets:\n\t * <ol>\n\t *   <li> The top-most (first) stage must have mouse over interactions enabled (via enableMouseOver)</li>\n\t *   <li> All stages that wish to participate in mouse over interaction must enable them via enableMouseOver</li>\n\t *   <li> All relay targets will share the frequency value of the top-most stage</li>\n\t * </ol>\n\t *\n\t * @example <caption>Relay mouse events from topStage to bottomStage</caption>\n\t * topStage.nextStage = bottomStage;\n\t *\n\t * @example <caption>Disable DOM events</caption>\n\t * stage.enableDOMEvents(false);\n\t *\n\t * @type {easeljs.Stage}\n\t */\n\tget nextStage () { return this._nextStage; }\n\tset nextStage (stage) {\n\t\tif (this._nextStage) { this._nextStage._prevStage = null; }\n\t\tif (stage) { stage._prevStage = this; }\n\t\tthis._nextStage = stage;\n\t}\n\n// public methods:\n\t/**\n\t * Each time the update method is called, the stage will call {@link easeljs.Stage#tick}\n\t * unless {@link easeljs.Stage#tickOnupdate} is set to false,\n\t * and then render the display list to the canvas.\n\t *\n\t * @param {Object} [props] Props object to pass to `tick()`. Should usually be a {@link core.Ticker} event object, or similar object with a delta property.\n\t */\n\tupdate (props) {\n\t\tif (!this.canvas) { return; }\n\t\tif (this.tickOnUpdate) { this.tick(props); }\n\t\tif (this.dispatchEvent("drawstart", false, true) === false) { return; }\n\t\tDisplayObject_DisplayObject._snapToPixelEnabled = this.snapToPixelEnabled;\n\t\tlet r = this.drawRect, ctx = this.canvas.getContext("2d");\n\t\tctx.setTransform(1, 0, 0, 1, 0, 0);\n\t\tif (this.autoClear) {\n\t\t\tif (r) { ctx.clearRect(r.x, r.y, r.width, r.height); }\n\t\t\telse { ctx.clearRect(0, 0, this.canvas.width+1, this.canvas.height+1); }\n\t\t}\n\t\tctx.save();\n\t\tif (this.drawRect) {\n\t\t\tctx.beginPath();\n\t\t\tctx.rect(r.x, r.y, r.width, r.height);\n\t\t\tctx.clip();\n\t\t}\n\t\tthis.updateContext(ctx);\n\t\tthis.draw(ctx, false);\n\t\tctx.restore();\n\t\tthis.dispatchEvent("drawend");\n\t}\n\n\t/**\n\t * Propagates a tick event through the display list. This is automatically called by {@link easeljs.Stage#update}\n\t * unless {@link easeljs.Stage#tickOnUpdate} is set to false.\n\t *\n\t * If a props object is passed to `tick()`, then all of its properties will be copied to the event object that is\n\t * propagated to listeners.\n\t *\n\t * Some time-based features in EaselJS (for example {@link easeljs.Sprite#framerate} require that\n\t * a {@link core.Ticker#event:tick} event object (or equivalent object with a delta property) be\n\t * passed as the `props` parameter to `tick()`.\n\t *\n\t * @example\n\t * Ticker.on("tick", (evt) => {\n\t *   // clone the event object from Ticker, and add some custom data to it:\n\t * \t let data = evt.clone().set({ greeting: "hello", name: "world" });\n\t * \t // pass it to stage.update():\n\t * \t stage.update(data); // subsequently calls tick() with the same param\n\t * });\n\t *\n\t * shape.on("tick", (evt) => {\n\t *   console.log(evt.delta); // the delta property from the Ticker tick event object\n\t * \t console.log(evt.greeting, evt.name); // custom data: "hello world"\n\t * });\n\t *\n\t * @emits easeljs.Stage#event:tickstart\n\t * @emits easeljs.Stage#event:tickend\n\t * @param {Object} [props] An object with properties that should be copied to the event object. Should usually be a Ticker event object, or similar object with a delta property.\n\t */\n\ttick (props) {\n\t\tif (!this.tickEnabled || this.dispatchEvent("tickstart", false, true) === false) { return; }\n\t\tlet evtObj = new events_Event("tick");\n\t\tif (props) {\n\t\t\tfor (let n in props) {\n\t\t\t\tif (props.hasOwnProperty(n)) { evtObj[n] = props[n]; }\n\t\t\t}\n\t\t}\n\t\tthis._tick(evtObj);\n\t\tthis.dispatchEvent("tickend");\n\t}\n\n\t/**\n\t * Default event handler that calls the Stage {@link easeljs.Stage#update} method when a {@link easeljs.DisplayObject#event:tick}\n\t * event is received. This allows you to register a Stage instance as a event listener on {@link core.Ticker} directly.\n\t * Note that if you subscribe to ticks using this pattern, then the tick event object will be passed through to\n\t * display object tick handlers, instead of `delta` and `paused` parameters.\n\t */\n\thandleEvent (evt) {\n\t\tif (evt.type === "tick") { this.update(evt); }\n\t}\n\n\t/**\n\t * Clears the target canvas. Useful if {@link easeljs.State#autoClear} is set to `false`.\n\t */\n\tclear () {\n\t\tif (!this.canvas) { return; }\n\t\tlet ctx = this.canvas.getContext("2d");\n\t\tctx.setTransform(1, 0, 0, 1, 0, 0);\n\t\tctx.clearRect(0, 0, this.canvas.width+1, this.canvas.height+1);\n\t}\n\n\t/**\n\t * Returns a data url that contains a Base64-encoded image of the contents of the stage. The returned data url can\n\t * be specified as the src value of an image element.\n\t *\n\t * @param {String} [backgroundColor] The background color to be used for the generated image. Any valid CSS color\n\t * value is allowed. The default value is a transparent background.\n\t * @param {String} [mimeType="image/png"] The MIME type of the image format to be create. If an unknown MIME type\n\t * is passed in, or if the browser does not support the specified MIME type, the default value will be used.\n\t * @return {String} a Base64 encoded image.\n\t */\n\ttoDataURL (backgroundColor, mimeType = "image/png") {\n\t\tlet data, ctx = this.canvas.getContext(\'2d\'), w = this.canvas.width, h = this.canvas.height;\n\n\t\tif (backgroundColor) {\n\t\t\tdata = ctx.getImageData(0, 0, w, h);\n\t\t\tvar compositeOperation = ctx.globalCompositeOperation;\n\t\t\tctx.globalCompositeOperation = "destination-over";\n\n\t\t\tctx.fillStyle = backgroundColor;\n\t\t\tctx.fillRect(0, 0, w, h);\n\t\t}\n\n\t\tlet dataURL = this.canvas.toDataURL(mimeType);\n\n\t\tif (backgroundColor) {\n\t\t\tctx.putImageData(data, 0, 0);\n\t\t\tctx.globalCompositeOperation = compositeOperation;\n\t\t}\n\n\t\treturn dataURL;\n\t}\n\n\t/**\n\t * Enables or disables (by passing a frequency of 0) mouse over {@link easeljs.DisplayObject#event:mouseover}\n\t * and {@link easeljs.DisplayObject#event:mouseout} and roll over events {@link easeljs.DisplayObject#event:rollover}\n\t * and {@link easeljs.DisplayObject#event:rollout} for this stage\'s display list. These events can\n\t * be expensive to generate, so they are disabled by default. The frequency of the events can be controlled\n\t * independently of mouse move events via the optional `frequency` parameter.\n\t *\n\t * @example\n\t * const stage = new Stage("canvasId");\n\t * stage.enableMouseOver(10); // 10 updates per second\n\t *\n\t * @param {Number} [frequency=20] Optional param specifying the maximum number of times per second to broadcast\n\t * mouse over/out events. Set to 0 to disable mouse over events completely. Maximum is 50. A lower frequency is less\n\t * responsive, but uses less CPU.\n\t */\n\tenableMouseOver (frequency = 20) {\n\t\tif (this._mouseOverIntervalID) {\n\t\t\tclearInterval(this._mouseOverIntervalID);\n\t\t\tthis._mouseOverIntervalID = null;\n\t\t\tif (frequency === 0) {\n\t\t\t\tthis._testMouseOver(true);\n\t\t\t}\n\t\t}\n\t\tif (frequency <= 0) { return; }\n\t\tthis._mouseOverIntervalID = setInterval(() => this._testMouseOver(), 1000/Math.min(50,frequency));\n\t}\n\n\t/**\n\t * Enables or disables the event listeners that stage adds to DOM elements (window, document and canvas). It is good\n\t * practice to disable events when disposing of a Stage instance, otherwise the stage will continue to receive\n\t * events from the page.\n\t * When changing the canvas property you must disable the events on the old canvas, and enable events on the\n\t * new canvas or mouse events will not work as expected.\n\t *\n\t * @example\n\t * stage.enableDOMEvents(false);\n\t * stage.canvas = anotherCanvas;\n\t * stage.enableDOMEvents(true);\n\t *\n\t * @param {Boolean} [enable=true] Indicates whether to enable or disable the events.\n\t */\n\tenableDOMEvents (enable = true) {\n\t\tlet ls = this._eventListeners;\n\t\tif (!enable && ls) {\n\t\t\tfor (let n in ls) {\n\t\t\t\tlet o = ls[n];\n\t\t\t\to.t.removeEventListener(n, o.f, false);\n\t\t\t}\n\t\t\tthis._eventListeners = null;\n\t\t} else if (enable && !ls && this.canvas) {\n\t\t\tlet t = window.addEventListener ? window : document;\n\t\t\tls = this._eventListeners = {\n\t\t\t\tmouseup: {t, f:e => this._handleMouseUp(e) },\n\t\t\t\tmousemove: {t, f:e => this._handleMouseMove(e) },\n\t\t\t\tdblclick: {t:this.canvas, f:e => this._handleDoubleClick(e) },\n\t\t\t\tmousedown: {t:this.canvas, f:e => this._handleMouseDown(e) }\n\t\t\t};\n\t\t\tfor (let n in ls) {\n\t\t\t\tlet o = ls[n];\n\t\t\t\to.t.addEventListener && o.t.addEventListener(n, o.f, false);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Stage instances cannot be cloned.\n\t * @throws Stage cannot be cloned\n\t * @override\n\t */\n\tclone () {\n\t\tthrow "Stage cannot be cloned.";\n\t}\n\n\t/**\n\t * @protected\n\t * @param {HTMLElement} e\n\t * @returns {Object}\n\t */\n\t_getElementRect (e) {\n\t\tlet bounds;\n\t\ttry { bounds = e.getBoundingClientRect(); } // this can fail on disconnected DOM elements in IE9\n\t\tcatch (err) { bounds = {top:e.offsetTop, left:e.offsetLeft, width:e.offsetWidth, height:e.offsetHeight}; }\n\n\t\tlet offX = (window.pageXOffset || document.scrollLeft || 0) - (document.clientLeft || document.body.clientLeft || 0);\n\t\tlet offY = (window.pageYOffset || document.scrollTop || 0) - (document.clientTop  || document.body.clientTop  || 0);\n\n\t\tlet styles = window.getComputedStyle ? getComputedStyle(e, null) : e.currentStyle; // IE <9 compatibility.\n\t\tlet padL = parseInt(styles.paddingLeft)+parseInt(styles.borderLeftWidth);\n\t\tlet padT = parseInt(styles.paddingTop)+parseInt(styles.borderTopWidth);\n\t\tlet padR = parseInt(styles.paddingRight)+parseInt(styles.borderRightWidth);\n\t\tlet padB = parseInt(styles.paddingBottom)+parseInt(styles.borderBottomWidth);\n\n\t\t// note: in some browsers bounds properties are read only.\n\t\treturn {\n\t\t\tleft: bounds.left+offX+padL,\n\t\t\tright: bounds.right+offX-padR,\n\t\t\ttop: bounds.top+offY+padT,\n\t\t\tbottom: bounds.bottom+offY-padB\n\t\t};\n\t}\n\n\t/**\n\t * @protected\n\t * @param {Number} id\n\t * @returns {Object}\n\t */\n\t_getPointerData (id) {\n\t\tlet data = this._pointerData[id];\n\t\tif (!data) { data = this._pointerData[id] = {x:0, y:0}; }\n\t\treturn data;\n\t}\n\n\t/**\n\t * @protected\n\t * @param {easeljs.MouseEvent} [e=window.event]\n\t */\n\t_handleMouseMove (e = window.event) {\n\t\tthis._handlePointerMove(-1, e, e.pageX, e.pageY);\n\t}\n\n\t/**\n\t * @emits {@link easeljs.DisplayObject#event:mouseleave}\n\t * @emits {@link easeljs.DisplayObject#event:mouseenter}\n\t * @emits {@link easeljs.DisplayObject#event:pressmove}\n\t * @emits {@link easeljs.Stage#event:stagemousemove}\n\t * @protected\n\t * @param {Number} id\n\t * @param {easeljs.MouseEvent | Event} e\n\t * @param {Number} pageX\n\t * @param {Number} pageY\n\t * @param {easeljs.Stage} owner Indicates that the event has already been captured & handled by the indicated stage.\n\t */\n\t_handlePointerMove (id, e, pageX, pageY, owner) {\n\t\tif (this._prevStage && owner === undefined) { return; } // redundant listener.\n\t\tif (!this.canvas) { return; }\n\t\tlet nextStage=this._nextStage, o=this._getPointerData(id);\n\n\t\tlet inBounds = o.inBounds;\n\t\tthis._updatePointerPosition(id, e, pageX, pageY);\n\t\tif (inBounds || o.inBounds || this.mouseMoveOutside) {\n\t\t\tif (id === -1 && o.inBounds === !inBounds) {\n\t\t\t\tthis._dispatchMouseEvent(this, (inBounds ? "mouseleave" : "mouseenter"), false, id, o, e);\n\t\t\t}\n\n\t\t\tthis._dispatchMouseEvent(this, "stagemousemove", false, id, o, e);\n\t\t\tthis._dispatchMouseEvent(o.target, "pressmove", true, id, o, e);\n\t\t}\n\n\t\tnextStage&&nextStage._handlePointerMove(id, e, pageX, pageY, null);\n\t}\n\n\t/**\n\t * @protected\n\t * @param {Number} id\n\t * @param {easeljs.MouseEvent | Event} e\n\t * @param {Number} pageX\n\t * @param {Number} pageY\n\t */\n\t_updatePointerPosition (id, e, pageX, pageY) {\n\t\tlet rect = this._getElementRect(this.canvas);\n\t\tpageX -= rect.left;\n\t\tpageY -= rect.top;\n\n\t\tlet w = this.canvas.width;\n\t\tlet h = this.canvas.height;\n\t\tpageX /= (rect.right-rect.left)/w;\n\t\tpageY /= (rect.bottom-rect.top)/h;\n\t\tlet o = this._getPointerData(id);\n\t\tif (o.inBounds = (pageX >= 0 && pageY >= 0 && pageX <= w-1 && pageY <= h-1)) {\n\t\t\to.x = pageX;\n\t\t\to.y = pageY;\n\t\t} else if (this.mouseMoveOutside) {\n\t\t\to.x = pageX < 0 ? 0 : (pageX > w-1 ? w-1 : pageX);\n\t\t\to.y = pageY < 0 ? 0 : (pageY > h-1 ? h-1 : pageY);\n\t\t}\n\n\t\to.posEvtObj = e;\n\t\to.rawX = pageX;\n\t\to.rawY = pageY;\n\n\t\tif (id === this._primaryPointerID || id === -1) {\n\t\t\tthis.mouseX = o.x;\n\t\t\tthis.mouseY = o.y;\n\t\t\tthis.mouseInBounds = o.inBounds;\n\t\t}\n\t}\n\n\t/**\n\t * @protected\n\t * @param {easeljs.MouseEvent} e\n\t */\n\t_handleMouseUp (e) {\n\t\tthis._handlePointerUp(-1, e, false);\n\t}\n\n\t/**\n\t * @emits {@link easeljs.Stage#event:stagemouseup}\n\t * @emits {@link easeljs.DisplayObject#event:click}\n\t * @emits {@link easeljs.DisplayObject#event:pressup}\n\t * @protected\n\t * @param {Number} id\n\t * @param {easeljs.MouseEvent | Event} e\n\t * @param {Boolean} clear\n\t * @param {easeljs.Stage} owner Indicates that the event has already been captured & handled by the indicated stage.\n\t */\n\t_handlePointerUp (id, e, clear, owner) {\n\t\tlet nextStage = this._nextStage, o = this._getPointerData(id);\n\t\tif (this._prevStage && owner === undefined) { return; } // redundant listener.\n\n\t\tlet target=null, oTarget = o.target;\n\t\tif (!owner && (oTarget || nextStage)) { target = this._getObjectsUnderPoint(o.x, o.y, null, true); }\n\n\t\tif (o.down) { this._dispatchMouseEvent(this, "stagemouseup", false, id, o, e, target); o.down = false; }\n\n\t\tif (target === oTarget) { this._dispatchMouseEvent(oTarget, "click", true, id, o, e); }\n\t\tthis._dispatchMouseEvent(oTarget, "pressup", true, id, o, e);\n\n\t\tif (clear) {\n\t\t\tif (id==this._primaryPointerID) { this._primaryPointerID = null; }\n\t\t\tdelete(this._pointerData[id]);\n\t\t} else { o.target = null; }\n\n\t\tnextStage&&nextStage._handlePointerUp(id, e, clear, owner || target && this);\n\t}\n\n\t/**\n\t * @protected\n\t * @param {easeljs.MouseEvent} e\n\t */\n\t_handleMouseDown (e) {\n\t\tthis._handlePointerDown(-1, e, e.pageX, e.pageY);\n\t}\n\n\t/**\n\t * @emits {@link easeljs.Stage#event:stagemousedown}\n\t * @emits {@link easeljs.DisplayObject#event:mousedown}\n\t * @protected\n\t * @param {Number} id\n\t * @param {easeljs.MouseEvent | Event} e\n\t * @param {Number} pageX\n\t * @param {Number} pageY\n\t * @param {easeljs.Stage} owner Indicates that the event has already been captured & handled by the indicated stage.\n\t */\n\t_handlePointerDown (id, e, pageX, pageY, owner) {\n\t\tif (this.preventSelection) { e.preventDefault(); }\n\t\tif (this._primaryPointerID == null || id === -1) { this._primaryPointerID = id; } // mouse always takes over.\n\n\t\tif (pageY != null) { this._updatePointerPosition(id, e, pageX, pageY); }\n\t\tlet target = null, nextStage = this._nextStage, o = this._getPointerData(id);\n\t\tif (!owner) { target = o.target = this._getObjectsUnderPoint(o.x, o.y, null, true); }\n\n\t\tif (o.inBounds) { this._dispatchMouseEvent(this, "stagemousedown", false, id, o, e, target); o.down = true; }\n\t\tthis._dispatchMouseEvent(target, "mousedown", true, id, o, e);\n\n\t\tnextStage&&nextStage._handlePointerDown(id, e, pageX, pageY, owner || target && this);\n\t}\n\n\t/**\n\t * @emits {@link easeljs.DisplayObject#event:mouseout}\n\t * @emits {@link easeljs.DisplayObject#event:rollout}\n\t * @emits {@link easeljs.DisplayObject#event:rollover}\n\t * @emits {@link easeljs.DisplayObject#event:mouseover}\n\t * @param {Boolean} clear If true, clears the mouseover / rollover (ie. no target)\n\t * @param {easeljs.Stage} owner Indicates that the event has already been captured & handled by the indicated stage.\n\t * @param {easeljs.Stage} eventTarget The stage that the cursor is actively over.\n\t * @protected\n\t */\n\t_testMouseOver (clear, owner, eventTarget) {\n\t\tif (this._prevStage && owner === undefined) { return; } // redundant listener.\n\n\t\tlet nextStage = this._nextStage;\n\t\tif (!this._mouseOverIntervalID) {\n\t\t\t// not enabled for mouseover, but should still relay the event.\n\t\t\tnextStage&&nextStage._testMouseOver(clear, owner, eventTarget);\n\t\t\treturn;\n\t\t}\n\t\tlet o = this._getPointerData(-1);\n\t\t// only update if the mouse position has changed. This provides a lot of optimization, but has some trade-offs.\n\t\tif (!o || (!clear && this.mouseX === this._mouseOverX && this.mouseY === this._mouseOverY && this.mouseInBounds)) { return; }\n\n\t\tlet e = o.posEvtObj;\n\t\tlet isEventTarget = eventTarget || e&&(e.target === this.canvas);\n\t\tlet target=null, common = -1, cursor="";\n\n\t\tif (!owner && (clear || this.mouseInBounds && isEventTarget)) {\n\t\t\ttarget = this._getObjectsUnderPoint(this.mouseX, this.mouseY, null, true);\n\t\t\tthis._mouseOverX = this.mouseX;\n\t\t\tthis._mouseOverY = this.mouseY;\n\t\t}\n\n\t\tlet oldList = this._mouseOverTarget||[];\n\t\tlet oldTarget = oldList[oldList.length-1];\n\t\tlet list = this._mouseOverTarget = [];\n\n\t\t// generate ancestor list and check for cursor:\n\t\tlet t = target;\n\t\twhile (t) {\n\t\t\tlist.unshift(t);\n\t\t\tif (!cursor) { cursor = t.cursor; }\n\t\t\tt = t.parent;\n\t\t}\n\t\tthis.canvas.style.cursor = cursor;\n\t\tif (!owner && eventTarget) { eventTarget.canvas.style.cursor = cursor; }\n\n\t\t// find common ancestor:\n\t\tfor (let i=0,l=list.length; i<l; i++) {\n\t\t\tif (list[i] != oldList[i]) { break; }\n\t\t\tcommon = i;\n\t\t}\n\n\t\tif (oldTarget != target) {\n\t\t\tthis._dispatchMouseEvent(oldTarget, "mouseout", true, -1, o, e, target);\n\t\t}\n\n\t\tfor (let i=oldList.length-1; i>common; i--) {\n\t\t\tthis._dispatchMouseEvent(oldList[i], "rollout", false, -1, o, e, target);\n\t\t}\n\n\t\tfor (let i=list.length-1; i>common; i--) {\n\t\t\tthis._dispatchMouseEvent(list[i], "rollover", false, -1, o, e, oldTarget);\n\t\t}\n\n\t\tif (oldTarget != target) {\n\t\t\tthis._dispatchMouseEvent(target, "mouseover", true, -1, o, e, oldTarget);\n\t\t}\n\n\t\tnextStage&&nextStage._testMouseOver(clear, owner || target && this, eventTarget || isEventTarget && this);\n\t}\n\n\t/**\n\t * @emits {@link easeljs.DisplayObject#event:dblclick}\n\t * @protected\n\t * @param {easeljs.MouseEvent} e\n\t * @param {easeljs.Stage} owner Indicates that the event has already been captured & handled by the indicated stage.\n\t */\n\t_handleDoubleClick (e, owner) {\n\t\tlet target=null, nextStage=this._nextStage, o=this._getPointerData(-1);\n\t\tif (!owner) {\n\t\t\ttarget = this._getObjectsUnderPoint(o.x, o.y, null, true);\n\t\t\tthis._dispatchMouseEvent(target, "dblclick", true, -1, o, e);\n\t\t}\n\t\tnextStage&&nextStage._handleDoubleClick(e, owner || target && this);\n\t}\n\n\t/**\n\t * @protected\n\t * @param {easeljs.DisplayObject} target\n\t * @param {String} type\n\t * @param {Boolean} bubbles\n\t * @param {Number} pointerId\n\t * @param {Object} o\n\t * @param {easeljs.MouseEvent} [nativeEvent]\n\t * @param {easeljs.DisplayObject} [relatedTarget]\n\t */\n\t_dispatchMouseEvent (target, type, bubbles, pointerId, o, nativeEvent, relatedTarget) {\n\t\t// TODO: might be worth either reusing MouseEvent instances, or adding a willTrigger method to avoid GC.\n\t\tif (!target || (!bubbles && !target.hasEventListener(type))) { return; }\n\t\t/*\n\t\t// TODO: account for stage transformations?\n\t\tthis._mtx = this.getConcatenatedMatrix(this._mtx).invert();\n\t\tlet pt = this._mtx.transformPoint(o.x, o.y);\n\t\tlet evt = new MouseEvent(type, bubbles, false, pt.x, pt.y, nativeEvent, pointerId, pointerId==this._primaryPointerID || pointerId==-1, o.rawX, o.rawY);\n\t\t*/\n\t\tlet evt = new MouseEvent_MouseEvent(type, bubbles, false, o.x, o.y, nativeEvent, pointerId, pointerId === this._primaryPointerID || pointerId === -1, o.rawX, o.rawY, relatedTarget);\n\t\ttarget.dispatchEvent(evt);\n\t}\n\n}\n\n/**\n * Dispatched when the user moves the mouse over the canvas.\n * @see {@link easeljs.MouseEvent}\n * @event easeljs.Stage#stagemousemove\n * @since 0.6.0\n */\n/**\n * Dispatched when the user presses their left mouse button on the canvas.\n * You can use {@link easeljs.Stage#mouseInBounds} to check whether the mouse is currently within the stage bounds.\n * @see {@link easeljs.MouseEvent}\n * @event easeljs.Stage#stagemousedown\n * @since 0.6.0\n */\n/**\n * Dispatched when the user the user presses somewhere on the stage, then releases the mouse button anywhere that the page can detect it (this varies slightly between browsers).\n * You can use {@link easeljs.Stage#mouseInBounds} to check whether the mouse is currently within the stage bounds.\n * @see {@link easeljs.MouseEvent}\n * @event easeljs.Stage#stagemouseup\n * @since 0.6.0\n */\n/**\n * Dispatched when the mouse moves from within the canvas area (mouseInBounds === true) to outside it (mouseInBounds === false).\n * This is currently only dispatched for mouse input (not touch).\n * @see {@link easeljs.MouseEvent}\n * @event easeljs.Stage#mouseleave\n * @since 0.7.0\n */\n/**\n * Dispatched when the mouse moves into the canvas area (mouseInBounds === false) from outside it (mouseInBounds === true).\n * This is currently only dispatched for mouse input (not touch).\n * @see {@link easeljs.MouseEvent}\n * @event easeljs.Stage#mouseenter\n * @since 0.7.0\n */\n/**\n * Dispatched each update immediately before the tick event is propagated through the display list.\n * You can call preventDefault on the event object to cancel propagating the tick event.\n * @event easeljs.Stage#tickstart\n * @since 0.7.0\n */\n/**\n * Dispatched each update immediately after the tick event is propagated through the display list. Does not fire if\n * tickOnUpdate is false. Precedes the "drawstart" event.\n * @event easeljs.Stage#tickend\n * @since 0.7.0\n */\n/**\n * Dispatched each update immediately before the canvas is cleared and the display list is drawn to it.\n * You can call preventDefault on the event object to cancel the draw.\n * @event easeljs.Stage#drawstart\n * @since 0.7.0\n */\n/**\n * Dispatched each update immediately after the display list is drawn to the canvas and the canvas context is restored.\n * @event easeljs.Stage#drawend\n * @since 0.7.0\n */\n\n// CONCATENATED MODULE: ./node_modules/@createjs/easeljs/src/utils/Canvas.js\n/**\r\n * @license Canvas\r\n * Visit http://createjs.com/ for documentation, updates and examples.\r\n *\r\n * Copyright (c) 2017 gskinner.com, inc.\r\n *\r\n * Permission is hereby granted, free of charge, to any person\r\n * obtaining a copy of this software and associated documentation\r\n * files (the "Software"), to deal in the Software without\r\n * restriction, including without limitation the rights to use,\r\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the\r\n * Software is furnished to do so, subject to the following\r\n * conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\r\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\r\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\r\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\r\n * OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\n/**\r\n * Global utility for creating canvases.\r\n * @memberof easeljs\n * @name easeljs.createCanvas\n * @param {Number} [width=1]\n * @param {Number} [height=1]\r\n */\r\nfunction createCanvas(width=1, height=1) {\n\tlet c;\n\tif (window.createjs !== undefined && window.createjs.createCanvas !== undefined) {\n\t\tc = window.createjs.createCanvas();\n\t}\n\tif (window.document !== undefined && window.document.createElement !== undefined) {\n\t\tc = document.createElement("canvas");\n\t}\n\tif (c !== undefined) {\n\t\tc.width = width;\n\t\tc.height = height;\n\t\treturn c;\n\t}\n\n\tthrow "Canvas not supported in this environment.";\r\n}\r\n\n// CONCATENATED MODULE: ./node_modules/@createjs/easeljs/src/utils/VideoBuffer.js\n/**\n * @license VideoBuffer\n * Visit http://createjs.com/ for documentation, updates and examples.\n *\n * Copyright (c) 2010 gskinner.com, inc.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the "Software"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n\n\n/**\n * When an HTML video seeks, including when looping, there is an indeterminate period before a new frame is available.\n * This can result in the video blinking or flashing when it is drawn to a canvas. The VideoBuffer class resolves\n * this issue by drawing each frame to an off-screen canvas and preserving the prior frame during a seek.\n *\n * @example\n * let buffer = new VideoBuffer(video);\n * let bitmap = new Bitmap(buffer);\n *\n * @param {HTMLVideoElement} video The HTML video element to buffer.\n */\nclass VideoBuffer_VideoBuffer {\n\n  constructor (video) {\n\n  \t/**\n  \t * Used by Bitmap to determine when the video buffer is ready to be drawn. Not intended for general use.\n  \t * @protected\n  \t * @type {Number}\n  \t */\n  \tthis.readyState = video.readyState;\n\n  \t/**\n  \t * @protected\n  \t * @type {HTMLVideoElement}\n  \t */\n  \tthis._video = video;\n\n  \t/**\n  \t * @protected\n  \t * @type {HTMLCanvasElement}\n  \t */\n  \tthis._canvas = null;\n\n  \t/**\n  \t * @protected\n  \t * @type {Number}\n  \t * @default -1\n  \t */\n  \tthis._lastTime = -1;\n\n  \tif (this.readyState < 2) {\n      video.addEventListener("canplaythrough", this._videoReady.bind(this));\n    }\n    // {once: true} isn\'t supported everywhere, but its a non-critical optimization here.\n  }\n\n  /**\n   * Gets an HTML canvas element showing the current video frame, or the previous frame if in a seek / loop.\n   * Primarily for use by {@link easeljs.Bitmap}.\n   */\n  getImage () {\n  \tif (this.readyState < 2) { return; }\n  \tlet canvas = this._canvas, video = this._video;\n  \tif (!canvas) {\n\t\t\tcanvas = this._canvas = createCanvas();\n  \t\tcanvas.width = video.videoWidth;\n  \t\tcanvas.height = video.videoHeight;\n  \t}\n  \tif (video.readyState >= 2 && video.currentTime !== this._lastTime) {\n  \t\tconst ctx = canvas.getContext("2d");\n  \t\tctx.clearRect(0, 0, canvas.width, canvas.height);\n  \t\tctx.drawImage(video, 0, 0, canvas.width, canvas.height);\n  \t\tthis._lastTime = video.currentTime;\n  \t}\n  \treturn canvas;\n  }\n\n  /**\n   * @protected\n   */\n  _videoReady () {\n  \tthis.readyState = 2;\n  }\n\n}\n\n// CONCATENATED MODULE: ./node_modules/@createjs/easeljs/src/display/Bitmap.js\n/**\n * @license Bitmap\n * Visit http://createjs.com/ for documentation, updates and examples.\n *\n * Copyright (c) 2017 gskinner.com, inc.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the "Software"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n\n\n\n/**\n * A Bitmap represents an Image, Canvas, or Video in the display list. A Bitmap can be instantiated using an existing\n * HTML element, or a string.\n *\n * <strong>Notes:</strong>\n * <ol>\n *     <li>When using a video source that may loop or seek, use a {@link easeljs.VideoBuffer} object to\n *      blinking / flashing.\n *     <li>When a string path or image tag that is not yet loaded is used, the stage may need to be redrawn before it\n *      will be displayed.</li>\n *     <li>Bitmaps with an SVG source currently will not respect an alpha value other than 0 or 1. To get around this,\n *     the Bitmap can be cached.</li>\n *     <li>Bitmaps with an SVG source will taint the canvas with cross-origin data, which prevents interactivity. This\n *     happens in all browsers except recent Firefox builds.</li>\n *     <li>Images loaded cross-origin will throw cross-origin security errors when interacted with using a mouse, using\n *     methods such as `getObjectUnderPoint`, or using filters, or caching. You can get around this by setting\n *     `crossOrigin` flags on your images before passing them to EaselJS, eg: `img.crossOrigin="Anonymous";`</li>\n * </ol>\n *\n * @memberof easeljs\n * @extends easeljs.DisplayObject\n * @example\n * const bitmap = new Bitmap("imagePath.jpg");\n *\n * @param {CanvasImageSource | String | Object} imageOrUri The source image to display. This can be a CanvasImageSource\n * (image, video, canvas), an object with a `getImage` method that returns a CanvasImageSource, or a string URL to an image.\n * If the latter, a new Image instance with the URL as its src will be used.\n */\nclass Bitmap_Bitmap extends DisplayObject_DisplayObject {\n\n\tconstructor (imageOrUri) {\n\t\tsuper();\n\n\t\t/**\n\t\t * The source image to display. This can be a CanvasImageSource\n\t\t * (image, video, canvas), an object with a `getImage` method that returns a CanvasImageSource, or a string URL to an image.\n\t\t * If the latter, a new Image instance with the URL as its src will be used.\n\t\t * @property image\n\t\t * @type {CanvasImageSource | Object}\n\t\t */\n\t\tif (typeof imageOrUri === "string") {\n\t\t\tthis.image = document.createElement("img");\n\t\t\tthis.image.src = imageOrUri;\n\t\t} else {\n\t\t\tthis.image = imageOrUri;\n\t\t}\n\n\t\t/**\n\t\t * Specifies an area of the source image to draw. If omitted, the whole image will be drawn.\n\t\t * Note that video sources must have a width / height set to work correctly with `sourceRect`.\n\t\t * @type {easeljs.Rectangle}\n\t\t * @default null\n\t\t */\n\t\tthis.sourceRect = null;\n\n\t\t/**\n\t\t * Set as compatible with WebGL.\n\t\t * @protected\n\t\t * @type {Number}\n\t\t */\n\t\tthis._webGLRenderStyle = DisplayObject_DisplayObject._StageGL_BITMAP;\n\t}\n\n\tisVisible () {\n\t\tlet image = this.image;\n\t\tlet hasContent = this.cacheCanvas || (image && (image.naturalWidth || image.getContext || image.readyState >= 2));\n\t\treturn !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0 && hasContent);\n\t}\n\n\tdraw (ctx, ignoreCache = false) {\n\t\tif (super.draw(ctx, ignoreCache)) { return true; }\n\t\tlet img = this.image, rect = this.sourceRect;\n\t\tif (img instanceof VideoBuffer_VideoBuffer) { img = img.getImage(); }\n\t\tif (img == null) { return true; }\n\t\tif (rect) {\n\t\t\t// some browsers choke on out of bound values, so we\'ll fix them:\n\t\t\tlet x1 = rect.x, y1 = rect.y, x2 = x1 + rect.width, y2 = y1 + rect.height, x = 0, y = 0, w = img.width, h = img.height;\n\t\t\tif (x1 < 0) { x -= x1; x1 = 0; }\n\t\t\tif (x2 > w) { x2 = w; }\n\t\t\tif (y1 < 0) { y -= y1; y1 = 0; }\n\t\t\tif (y2 > h) { y2 = h; }\n\t\t\tctx.drawImage(img, x1, y1, x2-x1, y2-y1, x, y, x2-x1, y2-y1);\n\t\t} else {\n\t\t\tctx.drawImage(img, 0, 0);\n\t\t}\n\t\treturn true;\n\t}\n\n\t// Note, the doc sections below document using the specified APIs (from DisplayObject) from\n\t// Bitmap. This is why they have no method implementations.\n\n\t/**\n\t * Because the content of a Bitmap is already in a simple format, cache is unnecessary for Bitmap instances.\n\t * You should <b>not</b> cache Bitmap instances as it can degrade performance.\n\t *\n\t * <strong>However: If you want to use a filter on a Bitmap, you <em>MUST</em> cache it, or it will not work.</strong>\n\t * To see the API for caching, please visit the {@link easeljs.DisplayObject#cache} method.\n\t *\n\t * @alias easeljs.Bitmap#cache\n\t */\n\n\t/**\n\t * Because the content of a Bitmap is already in a simple format, cache is unnecessary for Bitmap instances.\n\t * You should <b>not</b> cache Bitmap instances as it can degrade performance.\n\t *\n\t * <strong>However: If you want to use a filter on a Bitmap, you <em>MUST</em> cache it, or it will not work.</strong>\n\t * To see the API for caching, please visit the {@link easeljs.DisplayObject#cache} method.\n\t *\n\t * @alias easeljs.Bitmap#updateCache\n\t */\n\n\t/**\n\t * Because the content of a Bitmap is already in a simple format, cache is unnecessary for Bitmap instances.\n\t * You should <b>not</b> cache Bitmap instances as it can degrade performance.\n\t *\n\t * <strong>However: If you want to use a filter on a Bitmap, you <em>MUST</em> cache it, or it will not work.</strong>\n\t * To see the API for caching, please visit the {@link easeljs.DisplayObject#cache} method.\n\t *\n\t * @alias easeljs.Bitmap#uncache\n\t */\n\n\tgetBounds () {\n\t\tlet rect = super.getBounds();\n\t\tif (rect) { return rect; }\n\t\tlet image = this.image, o = this.sourceRect || image;\n\t\tlet hasContent = (image && (image.naturalWidth || image.getContext || image.readyState >= 2));\n\t\treturn hasContent ? this._rectangle.setValues(0, 0, o.width, o.height) : null;\n\t}\n\n\t/**\n\t * Returns a clone of the Bitmap instance.\n\t * @param {Boolean} [node] Whether the underlying DOM element should be cloned as well.\n\t * @return {easeljs.Bitmap} A clone of the Bitmap instance.\n\t */\n\tclone (node) {\n\t\tlet img = this.image;\n\t\tif (img != null && node != null) { img = img.cloneNode(); }\n\t\tlet bmp = new Bitmap_Bitmap(img);\n\t\tif (this.sourceRect) { bmp.sourceRect = this.sourceRect.clone(); }\n\t\tthis._cloneProps(bmp);\n\t\treturn bmp;\n\t}\n\n}\n\n// CONCATENATED MODULE: ./node_modules/@createjs/easeljs/src/display/Sprite.js\n/**\n * @license Sprite\n * Visit http://createjs.com/ for documentation, updates and examples.\n *\n * Copyright (c) 2017 gskinner.com, inc.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the "Software"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n\n\n\n/**\n * Displays a frame or sequence of frames (ie. an animation) from a SpriteSheet instance. A sprite sheet is a series of\n * images (usually animation frames) combined into a single image. For example, an animation consisting of 8 100x100\n * images could be combined into a 400x200 sprite sheet (4 frames across by 2 high). You can display individual frames,\n * play frames as an animation, and even sequence animations together.\n *\n * @memberof easeljs\n * @extends easeljs.DisplayObject\n * @example\n * let sprite = new Sprite(spriteSheet);\n * sprite.gotoAndStop("frameName");\n *\n * Until {@link easeljs.Sprite#gotoAndStop} or {@link easeljs.Sprite#gotoAndPlay} is called,\n * only the first defined frame defined in the sprite sheet will be displayed.\n *\n * @see {@link easeljs.SpriteSheet "More information on setting up frames and animations."}\n * @param {SpriteSheet} spriteSheet The SpriteSheet instance to play back. This includes the source image(s), frame\n * dimensions, and frame data.\n * @param {String | Number} [frameOrAnimation] The frame number or animation to play initially.\n */\nclass Sprite_Sprite extends DisplayObject_DisplayObject {\n\n\tconstructor (spriteSheet, frameOrAnimation) {\n\t\tsuper();\n\n\t\t/**\n\t\t * The frame index that will be drawn when draw is called. Note that with some {@link easeljs.SpriteSheet}\n\t\t * definitions, this will advance non-sequentially. This will always be an integer value.\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t * @readonly\n\t\t */\n\t\tthis.currentFrame = 0;\n\n\t\t/**\n\t\t * Returns the name of the currently playing animation.\n\t\t * @type {String}\n\t\t * @readonly\n\t\t */\n\t\tthis.currentAnimation = null;\n\n\t\t/**\n\t\t * Prevents the animation from advancing each tick automatically. For example, you could create a sprite\n\t\t * sheet of icons, set paused to true, and display the appropriate icon by setting `currentFrame`.\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.paused = true;\n\n\t\t/**\n\t\t * The SpriteSheet instance to play back. This includes the source image, frame dimensions, and frame data.\n\t\t * @type {easeljs.SpriteSheet}\n\t\t * @readonly\n\t\t */\n\t\tthis.spriteSheet = spriteSheet;\n\n\t\t/**\n\t\t * Specifies the current frame index within the currently playing animation. When playing normally, this will increase\n\t\t * from 0 to n-1, where n is the number of frames in the current animation.\n\t\t * This could be a non-integer value if using time-based playback, or if the animation\'s speed is not an integer.\n\t\t * @see {@link easeljs.Sprite#framerate}\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.currentAnimationFrame = 0;\n\n\t\t/**\n\t\t * By default Sprite instances advance one frame per tick. Specifying a framerate for the Sprite (or its related\n\t\t * SpriteSheet) will cause it to advance based on elapsed time between ticks as appropriate to maintain the target\n\t\t * framerate.\n\t\t *\n\t\t * For example, if a Sprite with a framerate of 10 is placed on a Stage being updated at 40fps, then the Sprite will\n\t\t * advance roughly one frame every 4 ticks. This will not be exact, because the time between each tick will\n\t\t * vary slightly between frames.\n\t\t *\n\t\t * This feature is dependent on the tick event object (or an object with an appropriate "delta" property) being\n\t\t * passed into {@link easeljs.Stage#update}.\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.framerate = 0;\n\n\t\t/**\n\t\t * Current animation object.\n\t\t * @protected\n\t\t * @type {Object}\n\t\t * @default null\n\t\t */\n\t\tthis._animation = null;\n\n\t\t/**\n\t\t * Current frame index.\n\t\t * @protected\n\t\t * @type {Number}\n\t\t * @default null\n\t\t */\n\t\tthis._currentFrame = null;\n\n\t\t/**\n\t\t * Skips the next auto advance. Used by gotoAndPlay to avoid immediately jumping to the next frame\n\t\t * @protected\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis._skipAdvance = false;\n\n\t\t/**\n\t\t * Set as compatible with WebGL.\n\t\t * @protected\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t */\n\t\tthis._webGLRenderStyle = DisplayObject_DisplayObject._StageGL_SPRITE;\n\n\t\tif (frameOrAnimation != null) {\n\t\t\tthis.gotoAndPlay(frameOrAnimation);\n\t\t}\n\t}\n\n\tisVisible () {\n\t\tlet hasContent = this.cacheCanvas || this.spriteSheet.complete;\n\t\treturn !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0 && hasContent);\n\t}\n\n\tdraw (ctx, ignoreCache) {\n\t\tif (super.draw(ctx, ignoreCache)) { return true; }\n\t\tthis._normalizeFrame();\n\t\tlet o = this.spriteSheet.getFrame(this._currentFrame|0);\n\t\tif (!o) { return false; }\n\t\tlet rect = o.rect;\n\t\tif (rect.width && rect.height) { ctx.drawImage(o.image, rect.x, rect.y, rect.width, rect.height, -o.regX, -o.regY, rect.width, rect.height); }\n\t\treturn true;\n\t}\n\n\t// Note, the doc sections below document using the specified APIs (from DisplayObject) from\n\t// Bitmap. This is why they have no method implementations.\n\n\t/**\n\t * Because the content of a Sprite is already in a raster format, cache is unnecessary for Sprite instances.\n\t * You should not cache Sprite instances as it can degrade performance.\n\t * @name easeljs.Sprite#cache\n\t */\n\n\t/**\n\t * Because the content of a Sprite is already in a raster format, cache is unnecessary for Sprite instances.\n\t * You should not cache Sprite instances as it can degrade performance.\n\t * @name easeljs.Sprite#updateCache\n\t */\n\n\t/**\n\t * Because the content of a Sprite is already in a raster format, cache is unnecessary for Sprite instances.\n\t * You should not cache Sprite instances as it can degrade performance.\n\t * @name easeljs.Sprite#uncache\n\t */\n\n\t/**\n\t * Play (unpause) the current animation. The Sprite will be paused if either {@link easeljs.Sprite#stop}\n\t * or {@link easeljs.Sprite#gotoAndStop} is called. Single frame animations will remain unchanged.\n\t */\n\tplay () {\n\t\tthis.paused = false;\n\t}\n\n\t/**\n\t * Stop playing a running animation. The Sprite will be playing if {@link easeljs.Sprite#gotoAndPlay} is called.\n\t * Note that calling `gotoAndPlay()` or {@link easeljs.Sprite#play} will resume playback.\n\t */\n\tstop () {\n\t\tthis.paused = true;\n\t}\n\n\t/**\n\t * Sets paused to false and plays the specified animation name, named frame, or frame number.\n\t * @param {String | Number} frameOrAnimation The frame number or animation name that the playhead should move to\n\t * and begin playing.\n\t */\n\tgotoAndPlay (frameOrAnimation) {\n\t\tthis.paused = false;\n\t\tthis._skipAdvance = true;\n\t\tthis._goto(frameOrAnimation);\n\t}\n\n\t/**\n\t * Sets paused to true and seeks to the specified animation name, named frame, or frame number.\n\t * @param {String | Number} frameOrAnimation The frame number or animation name that the playhead should move to\n\t * and stop.\n\t */\n\tgotoAndStop (frameOrAnimation) {\n\t\tthis.paused = true;\n\t\tthis._goto(frameOrAnimation);\n\t}\n\n\t/**\n\t * Advances the playhead. This occurs automatically each tick by default.\n\t * @param {Number} [time] The amount of time in ms to advance by. Only applicable if framerate is set on the Sprite\n\t * or its SpriteSheet.\n\t*/\n\tadvance (time) {\n\t\tlet fps = this.framerate || this.spriteSheet.framerate;\n\t\tlet t = (fps && time != null) ? time/(1000/fps) : 1;\n\t\tthis._normalizeFrame(t);\n\t}\n\n\t/**\n\t * Returns a {@link easeljs.Rectangle} instance defining the bounds of the current frame relative to\n\t * the origin. For example, a 90 x 70 frame with `regX=50` and `regY=40` would return a\n\t * rectangle with [x=-50, y=-40, width=90, height=70]. This ignores transformations on the display object.\n\t *\n\t * @see {@link easeljs.SpriteSheet#frameBounds}\n\t * @return {easeljs.Rectangle} A Rectangle instance. Returns null if the frame does not exist, or the image is not fully loaded.\n\t */\n\tgetBounds () {\n\t\t// TODO: should this normalizeFrame?\n\t\treturn super.getBounds() || this.spriteSheet.getFrameBounds(this.currentFrame, this._rectangle);\n\t}\n\n\t/**\n\t * Returns a clone of the Sprite instance. Note that the same SpriteSheet is shared between cloned instances.\n\t * @return {easeljs.Sprite} a clone of the Sprite instance.\n\t */\n\tclone () {\n\t\treturn this._cloneProps(new Sprite_Sprite(this.spriteSheet));\n\t}\n\n\t/**\n\t * @param {easeljs.Sprite} o\n\t * @return {easeljs.Sprite} o\n\t * @protected\n\t */\n\t_cloneProps (o) {\n\t\tsuper._cloneProps(o);\n\t\to.currentFrame = this.currentFrame;\n\t\to.currentAnimation = this.currentAnimation;\n\t\to.paused = this.paused;\n\t\to.currentAnimationFrame = this.currentAnimationFrame;\n\t\to.framerate = this.framerate;\n\n\t\to._animation = this._animation;\n\t\to._currentFrame = this._currentFrame;\n\t\to._skipAdvance = this._skipAdvance;\n\t\treturn o;\n\t}\n\n\t_tick (evtObj) {\n\t\tif (!this.paused) {\n\t\t\tif (!this._skipAdvance) { this.advance(evtObj&&evtObj.delta); }\n\t\t\tthis._skipAdvance = false;\n\t\t}\n\t\tsuper._tick(evtObj);\n\t}\n\n\t/**\n\t * Normalizes the current frame, advancing animations and dispatching callbacks as appropriate.\n\t * @protected\n\t * @param {Number} [frameDelta=0]\n\t */\n\t_normalizeFrame (frameDelta = 0) {\n\t\tlet animation = this._animation;\n\t\tlet paused = this.paused;\n\t\tlet frame = this._currentFrame;\n\n\t\tif (animation) {\n\t\t\tlet speed = animation.speed || 1;\n\t\t\tlet animFrame = this.currentAnimationFrame;\n\t\t\tlet l = animation.frames.length;\n\t\t\tif (animFrame + frameDelta * speed >= l) {\n\t\t\t\tlet next = animation.next;\n\t\t\t\tif (this._dispatchAnimationEnd(animation, frame, paused, next, l - 1)) {\n\t\t\t\t\t// something changed in the event stack, so we shouldn\'t make any more changes here.\n\t\t\t\t\treturn;\n\t\t\t\t} else if (next) {\n\t\t\t\t\t// sequence. Automatically calls _normalizeFrame again with the remaining frames.\n\t\t\t\t\treturn this._goto(next, frameDelta - (l - animFrame) / speed);\n\t\t\t\t} else {\n\t\t\t\t\t// end.\n\t\t\t\t\tthis.paused = true;\n\t\t\t\t\tanimFrame = animation.frames.length - 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tanimFrame += frameDelta * speed;\n\t\t\t}\n\t\t\tthis.currentAnimationFrame = animFrame;\n\t\t\tthis._currentFrame = animation.frames[animFrame | 0]\n\t\t} else {\n\t\t\tframe = (this._currentFrame += frameDelta);\n\t\t\tlet l = this.spriteSheet.getNumFrames();\n\t\t\tif (frame >= l && l > 0) {\n\t\t\t\tif (!this._dispatchAnimationEnd(animation, frame, paused, l - 1)) {\n\t\t\t\t\t// looped.\n\t\t\t\t\tif ((this._currentFrame -= l) >= l) { return this._normalizeFrame(); }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tframe = this._currentFrame | 0;\n\t\tif (this.currentFrame != frame) {\n\t\t\tthis.currentFrame = frame;\n\t\t\tthis.dispatchEvent("change");\n\t\t}\n\t};\n\n\t/**\n\t * Dispatches the "animationend" event. Returns true if a handler changed the animation (ex. calling {@link easlejs.Sprite#stop},\n\t * {@link easeljs.Sprite#gotoAndPlay}, etc.)\n\t * @param animation\n\t * @param frame\n\t * @param paused\n\t * @param next\n\t * @param end\n\t * @private\n\t */\n\t_dispatchAnimationEnd (animation, frame, paused, next, end) {\n\t\tlet name = animation ? animation.name : null;\n\t\tif (this.hasEventListener("animationend")) {\n\t\t\tlet evt = new events_Event("animationend");\n\t\t\tevt.name = name;\n\t\t\tevt.next = next;\n\t\t\tthis.dispatchEvent(evt);\n\t\t}\n\t\t// did the animation get changed in the event stack?:\n\t\tlet changed = (this._animation != animation || this._currentFrame != frame);\n\t\t// if the animation hasn\'t changed, but the sprite was paused, then we want to stick to the last frame:\n\t\tif (!changed && !paused && this.paused) { this.currentAnimationFrame = end; changed = true; }\n\t\treturn changed;\n\t}\n\n\t/**\n\t * Moves the playhead to the specified frame number or animation.\n\t * @param {String | Number} frameOrAnimation The frame number or animation that the playhead should move to.\n\t * @param {Number} [frame=0] The frame of the animation to go to. Defaults to 0.\n\t * @protected\n\t */\n\t_goto (frameOrAnimation, frame = 0) {\n\t\tthis.currentAnimationFrame = 0;\n\t\tif (isNaN(frameOrAnimation)) {\n\t\t\tlet data = this.spriteSheet.getAnimation(frameOrAnimation);\n\t\t\tif (data) {\n\t\t\t\tthis._animation = data;\n\t\t\t\tthis.currentAnimation = frameOrAnimation;\n\t\t\t\tthis._normalizeFrame(frame);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.currentAnimation = this._animation = null;\n\t\t\tthis._currentFrame = frameOrAnimation;\n\t\t\tthis._normalizeFrame();\n\t\t}\n\t}\n\n}\n\n/**\n * Dispatched when an animation reaches its ends.\n * @event easeljs.Sprite#animationend\n * @property {Object} target The object that dispatched the event.\n * @property {String} type The event type.\n * @property {String} name The name of the animation that just ended.\n * @property {String} next The name of the next animation that will be played, or null. This will be the same as name if the animation is looping.\n * @since 0.6.0\n */\n\n/**\n * Dispatched any time the current frame changes. For example, this could be due to automatic advancement on a tick,\n * or calling gotoAndPlay() or gotoAndStop().\n * @event easeljs.Sprite#change\n * @property {Object} target The object that dispatched the event.\n * @property {String} type The event type.\n */\n\n// CONCATENATED MODULE: ./node_modules/@createjs/easeljs/src/display/BitmapText.js\n/**\n * @license BitmapText\n * Visit http://createjs.com/ for documentation, updates and examples.\n *\n * Copyright (c) 2017 gskinner.com, inc.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the "Software"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n\n\n\n/**\n * Displays text using bitmap glyphs defined in a sprite sheet. Multi-line text is supported using new line characters,\n * but automatic wrapping is not supported. See the {@link easeljs.BitmapText#spriteSheet} property for more information on defining glyphs.\n *\n * <strong>Important:</strong> While BitmapText extends Container, it is not designed to be used as one.\n * As such, methods like addChild and removeChild are disabled.\n *\n * @memberof easeljs\n * @extends easeljs.Container\n *\n * @param {String} [text=""] The text to display.\n * @param {SpriteSheet} [spriteSheet=null] The spritesheet that defines the character glyphs.\n */\nclass BitmapText_BitmapText extends Container_Container {\n\n\tconstructor (text = "", spriteSheet = null) {\n\t\tsuper();\n\n\t\t/**\n\t\t * The text to display.\n\t\t * @type {String}\n\t\t * @default ""\n\t\t */\n\t\tthis.text = text;\n\n\t\t/**\n\t\t * A SpriteSheet instance that defines the glyphs for this bitmap text. Each glyph/character\n\t\t * should have a single frame animation defined in the sprite sheet named the same as\n\t\t * corresponding character.\n\t\t *\n\t\t * @example\n\t\t * // the following animation definition would indicate that the frame at index 0 of the spritesheet should be drawn for the "A" character.\n\t\t * "A": {frames: [0]}\n\t\t * // The short form is also acceptable:\n\t\t * "A": 0\n\t\t *\n\t\t * Note that if a character in the text is not found in the sprite sheet, it will also\n\t\t * try to use the alternate case (upper or lower).\n\t\t *\n\t\t * @see {@link easeljs.SpriteSheet}\n\t\t * @type {easeljs.SpriteSheet}\n\t\t * @default null\n\t\t */\n\t\tthis.spriteSheet = spriteSheet;\n\n\t\t/**\n\t\t * The height of each line of text. If 0, then it will use a line height calculated\n\t\t * by checking for the height of the "1", "T", or "L" character (in that order). If\n\t\t * those characters are not defined, it will use the height of the first frame of the\n\t\t * sprite sheet.\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.lineHeight = 0;\n\n\t\t/**\n\t\t * This spacing (in pixels) will be added after each character in the output.\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.letterSpacing = 0;\n\n\t\t/**\n\t\t * If a space character is not defined in the sprite sheet, then empty pixels equal to\n\t\t * spaceWidth will be inserted instead. If 0, then it will use a value calculated\n\t\t * by checking for the width of the "1", "l", "E", or "A" character (in that order). If\n\t\t * those characters are not defined, it will use the width of the first frame of the\n\t\t * sprite sheet.\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.spaceWidth = 0;\n\n\t \t/**\n\t\t * @type {Object}\n\t\t * @protected\n\t\t */\n\t\tthis._oldProps = {text:0,spriteSheet:0,lineHeight:0,letterSpacing:0,spaceWidth:0};\n\n\t\t/**\n\t\t * Used to track the object which this class attached listeners to, helps optimize listener attachment.\n\t\t * @type {easeljs.Stage}\n\t\t * @protected\n\t\t */\n\t\tthis._oldStage = null;\n\n\t\t/**\n\t\t * The event listener proxy triggered drawing draw for special circumstances.\n\t\t * @type {Function}\n\t\t * @protected\n\t\t */\n\t\tthis._drawAction = null;\n\n\t}\n\n\tdraw (ctx, ignoreCache) {\n\t\tif (this.drawCache(ctx, ignoreCache)) { return; }\n\t\tthis._updateState();\n\t\tsuper.draw(ctx, ignoreCache);\n\t}\n\n\tgetBounds () {\n\t\tthis._updateText();\n\t\treturn super.getBounds();\n\t}\n\n\tisVisible () {\n\t\tlet hasContent = this.cacheCanvas || (this.spriteSheet && this.spriteSheet.complete && this.text);\n\t\treturn !!(this.visible && this.alpha > 0 && this.scaleX !== 0 && this.scaleY !== 0 && hasContent);\n\t}\n\n\tclone () {\n\t\treturn this._cloneProps(new BitmapText_BitmapText(this.text, this.spriteSheet));\n\t}\n\n\t/**\n\t * <strong>Disabled in BitmapText.</strong>\n\t */\n\taddChild () {}\n\n\t/**\n\t * <strong>Disabled in BitmapText.</strong>\n\t */\n\taddChildAt () {}\n\n\t/**\n\t * <strong>Disabled in BitmapText.</strong>\n\t */\n\tremoveChild () {}\n\n\t/**\n\t * <strong>Disabled in BitmapText.</strong>\n\t */\n\tremoveChildAt () {}\n\n\t/**\n\t * <strong>Disabled in BitmapText.</strong>\n\t */\n\tremoveAllChildren () {}\n\n\t_updateState () {\n\t\tthis._updateText();\n\t}\n\n \t/**\n\t * @param {easeljs.BitmapText} o\n\t * @return {easeljs.BitmapText}\n\t * @protected\n\t */\n\t_cloneProps (o) {\n\t\tsuper._cloneProps(o);\n\t\to.lineHeight = this.lineHeight;\n\t\to.letterSpacing = this.letterSpacing;\n\t\to.spaceWidth = this.spaceWidth;\n\t\treturn o;\n\t}\n\n\t/**\n\t * @param {String} character\n\t * @param {easeljs.SpriteSheet} spriteSheet\n\t * @return {Number}\n\t * @protected\n\t */\n\t_getFrameIndex (character, spriteSheet) {\n\t\tlet c, o = spriteSheet.getAnimation(character);\n\t\tif (!o) {\n\t\t\t(character != (c = character.toUpperCase())) || (character != (c = character.toLowerCase())) || (c = null);\n\t\t\tif (c) { o = spriteSheet.getAnimation(c); }\n\t\t}\n\t\treturn o && o.frames[0];\n\t}\n\n\t/**\n\t * @param {String} character\n\t * @param {easeljs.SpriteSheet} spriteSheet\n\t * @return {Object}\n\t * @protected\n\t */\n\t_getFrame (character, spriteSheet) {\n\t\tlet index = this._getFrameIndex(character, spriteSheet);\n\t\treturn index == null ? index : spriteSheet.getFrame(index);\n\t}\n\n\t/**\n\t * @param {easeljs.SpriteSheet} ss\n\t * @return {Number}\n\t * @protected\n\t */\n\t_getLineHeight (ss) {\n\t\tlet frame = this._getFrame("1", ss) || this._getFrame("T", ss) || this._getFrame("L", ss) || ss.getFrame(0);\n\t\treturn frame ? frame.rect.height : 1;\n\t}\n\n\t/**\n\t * @param {easeljs.SpriteSheet} ss\n\t * @return {Number}\n\t * @protected\n\t */\n\t_getSpaceWidth (ss) {\n\t\tlet frame = this._getFrame("1", ss) || this._getFrame("l", ss) || this._getFrame("e", ss) || this._getFrame("a", ss) || ss.getFrame(0);\n\t\treturn frame ? frame.rect.width : 1;\n\t}\n\n\t_tick (evtObj) {\n\t\tlet stage = this.stage;\n\t\tstage && stage.on("drawstart", this._updateText, this, true);\n\t\tsuper._tick(evtObj);\n\t}\n\n\t/**\n\t * @protected\n\t */\n\t_updateText () {\n\t\tlet x = 0, y = 0, o = this._oldProps, change = false, spaceW = this.spaceWidth, lineH = this.lineHeight, ss = this.spriteSheet;\n\t\tlet pool = BitmapText_BitmapText._spritePool, kids = this.children, childIndex = 0, numKids = kids.length, sprite;\n\n\t\tfor (let n in o) {\n\t\t\tif (o[n] != this[n]) {\n\t\t\t\to[n] = this[n];\n\t\t\t\tchange = true;\n\t\t\t}\n\t\t}\n\t\tif (!change) { return; }\n\n\t\tlet hasSpace = !!this._getFrame(" ", ss);\n\t\tif (!hasSpace && !spaceW) { spaceW = this._getSpaceWidth(ss); }\n\t\tif (!lineH) { lineH = this._getLineHeight(ss); }\n\n\t\tfor (let i = 0, l = this.text.length; i < l; i++) {\n\t\t\tlet character = this.text.charAt(i);\n\t\t\tif (character === " " && !hasSpace) {\n\t\t\t\tx += spaceW;\n\t\t\t\tcontinue;\n\t\t\t} else if (character === "\\n" || character === "\\r") {\n\t\t\t\tif (character === "\\r" && this.text.charAt(i+1) === "\\n") { i++; } // crlf\n\t\t\t\tx = 0;\n\t\t\t\ty += lineH;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlet index = this._getFrameIndex(character, ss);\n\t\t\tif (index == null) { continue; }\n\n\t\t\tif (childIndex < numKids) {\n\t\t\t\tsprite = kids[childIndex];\n\t\t\t} else {\n\t\t\t\tkids.push(sprite = pool.length ? pool.pop() : new Sprite_Sprite());\n\t\t\t\tsprite.parent = this;\n\t\t\t\tnumKids++;\n\t\t\t}\n\t\t\tsprite.spriteSheet = ss;\n\t\t\tsprite.gotoAndStop(index);\n\t\t\tsprite.x = x;\n\t\t\tsprite.y = y;\n\t\t\tchildIndex++;\n\n\t\t\tx += sprite.getBounds().width + this.letterSpacing;\n\t\t}\n\n\t\twhile (numKids > childIndex) {\n\t\t\t // faster than removeChild.\n\t\t\tpool.push(sprite = kids.pop());\n\t\t\tsprite.parent = null;\n\t\t\tnumKids--;\n\t\t}\n\t\tif (pool.length > BitmapText_BitmapText.maxPoolSize) { pool.length = BitmapText_BitmapText.maxPoolSize; }\n\t}\n\n}\n\n/**\n * BitmapText uses Sprite instances to draw text. To reduce the creation and destruction of instances (and thus garbage collection), it maintains\n * an internal object pool of sprite instances to reuse. Increasing this value can cause more sprites to be\n * retained, slightly increasing memory use, but reducing instantiation.\n * @type {Number}\n * @static\n * @default 100\n */\nBitmapText_BitmapText.maxPoolSize = 100;\n/**\n * Sprite object pool.\n * @type {Array}\n * @static\n * @private\n * @readonly\n */\nBitmapText_BitmapText._spritePool = [];\n\n// CONCATENATED MODULE: ./node_modules/@createjs/easeljs/src/display/DOMElement.js\n/**\n * @license DOMElement\n * Visit http://createjs.com/ for documentation, updates and examples.\n *\n * Copyright (c) 2017 gskinner.com, inc.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the "Software"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n\n\n\n/**\n * <b>This class is still experimental, and more advanced use is likely to be buggy. Please report bugs.</b>\n *\n * A DOMElement allows you to associate a HTMLElement with the display list. It will be transformed\n * within the DOM as though it is child of the {{#crossLink "Container"}}{{/crossLink}} it is added to. However, it is\n * not rendered to canvas, and as such will retain whatever z-index it has relative to the canvas (ie. it will be\n * drawn in front of or behind the canvas).\n *\n * The position of a DOMElement is relative to their parent node in the DOM. It is recommended that\n * the DOM Object be added to a div that also contains the canvas so that they share the same position\n * on the page.\n *\n * DOMElement is useful for positioning HTML elements over top of canvas content, and for elements\n * that you want to display outside the bounds of the canvas. For example, a tooltip with rich HTML\n * content.\n *\n * <h4>Mouse Interaction</h4>\n *\n * DOMElement instances are not full EaselJS display objects, and do not participate in EaselJS mouse\n * events or support methods like hitTest. To get mouse events from a DOMElement, you must instead add handlers to\n * the htmlElement (note, this does not support EventDispatcher)\n *\n *      var domElement = new createjs.DOMElement(htmlElement);\n *      domElement.htmlElement.onclick = function() {\n *          console.log("clicked");\n *      }\n *\n * <strong>Important:</strong> This class needs to be notified it is about to be drawn, this will happen automatically\n * if you call stage.update, calling stage.draw or disabling tickEnabled will miss important steps and it will render\n * stale information.\n *\n * @memberof easeljs\n * @extends DisplayObject\n * @param {HTMLElement | String} htmlElement A reference or id for the DOM element to manage.\n */\nclass DOMElement_DOMElement extends DisplayObject_DisplayObject {\n\n\tconstructor (htmlElement) {\n\t\tsuper();\n\n\t\tif (typeof htmlElement === "string") { htmlElement = document.getElementById(htmlElement); }\n\t\tthis.mouseEnabled = false;\n\n\t\tlet style = htmlElement.style;\n\t\tstyle.position = "absolute";\n\t\tstyle.transformOrigin = style.WebkitTransformOrigin = style.msTransformOrigin = style.MozTransformOrigin = style.OTransformOrigin = "0% 0%";\n\n\t\t/**\n\t\t * The DOM object to manage.\n\t\t * @type {HTMLElement}\n\t\t */\n\t\tthis.htmlElement = htmlElement;\n\n\t\t/**\n\t\t * @type {easeljs.Matrix2D}\n\t\t * @default null\n\t\t * @protected\n\t\t */\n\t\tthis._oldProps = null;\n\n\t\t/**\n\t\t * Used to track the object which this class attached listeners to, helps optimize listener attachment.\n\t\t * @type {easeljs.Stage}\n\t\t * @default null\n\t\t * @protected\n\t\t */\n\t\tthis._oldStage = null;\n\t\t/**\n\t\t * The event listener proxy triggered drawing draw for special circumstances.\n\t\t * @type {Function}\n\t\t * @default null\n\t\t * @protected\n\t\t */\n\t\tthis._drawAction = null;\n\t}\n\n\tisVisible () {\n\t\treturn this.htmlElement != null;\n\t}\n\n\tdraw (ctx, ignoreCache) {\n\t\t// this relies on the _tick method because draw isn\'t called if the parent is not visible.\n\t\t// the actual update happens in _handleDrawEnd\n\t\treturn true;\n\t}\n\n\t/**\n\t * Disabled in DOMElement.\n\t */\n\tcache () {}\n\n\t/**\n\t * Disabled in DOMElement.\n\t */\n\tuncache () {}\n\n\t/**\n\t * Disabled in DOMElement.\n\t */\n\tupdateCache () {}\n\n\t/**\n\t * Disabled in DOMElement.\n\t */\n\thitTest () {}\n\n\t/**\n\t * Disabled in DOMElement.\n\t */\n\tlocalToGlobal () {}\n\n\t/**\n\t * Disabled in DOMElement.\n\t */\n\tglobalToLocal () {}\n\n\t/**\n\t * Disabled in DOMElement.\n\t */\n\tlocalToLocal () {}\n\n\t/**\n\t * DOMElement cannot be cloned.\n\t * @throws DOMElement cannot be cloned\n\t */\n\tclone () {\n\t\tthrow "DOMElement cannot be cloned.";\n\t}\n\n\t_tick (evtObj) {\n\t\tlet stage = this.stage;\n\t\tif (stage != null && stage !== this._oldStage) {\n\t\t\tthis._drawAction && stage.off("drawend", this._drawAction);\n\t\t\tthis._drawAction = stage.on("drawend", this._handleDrawEnd, this);\n\t\t\tthis._oldStage = stage;\n\t\t}\n\t\tsuper._tick(evtObj);\n\t}\n\n\t/**\n\t * @param {core.Event} evt\n\t * @protected\n\t */\n\t_handleDrawEnd (evt) {\n\t\tlet o = this.htmlElement;\n\t\tif (!o) { return; }\n\t\tlet style = o.style;\n\n\t\tlet props = this.getConcatenatedDisplayProps(this._props), mtx = props.matrix;\n\n\t\tlet visibility = props.visible ? "visible" : "hidden";\n\t\tif (visibility != style.visibility) { style.visibility = visibility; }\n\t\tif (!props.visible) { return; }\n\n\t\tlet oldProps = this._oldProps, oldMtx = oldProps&&oldProps.matrix;\n\t\tlet n = 10000; // precision\n\n\t\tif (!oldMtx || !oldMtx.equals(mtx)) {\n\t\t\tlet str = "matrix(" + (mtx.a*n|0)/n +","+ (mtx.b*n|0)/n +","+ (mtx.c*n|0)/n +","+ (mtx.d*n|0)/n +","+ (mtx.tx+0.5|0);\n\t\t\tstyle.transform = style.WebkitTransform = style.OTransform = style.msTransform = str +","+ (mtx.ty+0.5|0) +")";\n\t\t\tstyle.MozTransform = str +"px,"+ (mtx.ty+0.5|0) +"px)";\n\t\t\tif (!oldProps) { oldProps = this._oldProps = new DisplayProps_DisplayProps(true, null); }\n\t\t\toldProps.matrix.copy(mtx);\n\t\t}\n\n\t\tif (oldProps.alpha != props.alpha) {\n\t\t\tstyle.opacity = ""+(props.alpha*n|0)/n;\n\t\t\toldProps.alpha = props.alpha;\n\t\t}\n\t}\n\n}\n\n/**\n * Interaction events should be added to `htmlElement`, and not the DOMElement instance, since DOMElement instances\n * are not full EaselJS display objects and do not participate in EaselJS mouse events.\n * @event easeljs.DOMElement#click\n */\n\n/**\n * Interaction events should be added to `htmlElement`, and not the DOMElement instance, since DOMElement instances\n * are not full EaselJS display objects and do not participate in EaselJS mouse events.\n * @event easeljs.DOMElement#dblClick\n */\n\n/**\n * Interaction events should be added to `htmlElement`, and not the DOMElement instance, since DOMElement instances\n * are not full EaselJS display objects and do not participate in EaselJS mouse events.\n * @event easeljs.DOMElement#mousedown\n */\n\n/**\n * Interaction events should be added to `htmlElement`, and not the DOMElement instance, since DOMElement instances\n * are not full EaselJS display objects and do not participate in EaselJS mouse events.\n * @event easeljs.DOMElement#mouseover\n */\n\n/**\n * Disabled in DOMElement.\n * @event easeljs.DOMElement#tick\n */\n\n// CONCATENATED MODULE: ./node_modules/@createjs/easeljs/src/display/Graphics.js\n/**\n * @license Graphics\n * Visit http://createjs.com/ for documentation, updates and examples.\n *\n * Copyright (c) 2017 gskinner.com, inc.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the "Software"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n\n\n/**\n * The Graphics class exposes an easy to use API for generating vector drawing instructions and drawing them to a\n * specified context. Note that you can use Graphics without any dependency on the EaselJS framework by calling {@link easeljs.Graphics#draw}\n * directly, or it can be used with the {@link easeljs.Shape} object to draw vector graphics within the\n * context of an EaselJS display list.\n *\n * There are two approaches to working with Graphics object: calling methods on a Graphics instance (the "Graphics API"), or\n * instantiating Graphics command objects and adding them to the graphics queue via {@link easeljs.Graphics#append}.\n * The former abstracts the latter, simplifying beginning and ending paths, fills, and strokes.\n *\n * <h4>Tiny API</h4>\n * The Graphics class also includes a "tiny API", which is one or two-letter methods that are shortcuts for all of the\n * Graphics methods. These methods are great for creating compact instructions, and is used by the Toolkit for CreateJS\n * to generate readable code. All tiny methods are marked as protected, so you can view them by enabling protected\n * descriptions in the docs.\n *\n * <table>\n *     <tr><td><b>Tiny</b></td><td><b>Method</b></td><td><b>Tiny</b></td><td><b>Method</b></td></tr>\n *     <tr><td>mt</td><td>{@link easeljs.Graphics#moveTo}</td>\n *     <td>lt</td> <td>{@link easeljs.Graphics#lineTo}</td></tr>\n *     <tr><td>a/at</td><td>{@link easeljs.Graphics#arc} / {@link easeljs.Graphics#arcTo}</td>\n *     <td>bt</td><td>{@link easeljs.Graphics#bezierCurveTo}</td></tr>\n *     <tr><td>qt</td><td>{@link easeljs.Graphics#quadraticCurveTo} (also curveTo)</td>\n *     <td>r</td><td>{@link easeljs.Graphics#rect}</td></tr>\n *     <tr><td>cp</td><td>{@link easeljs.Graphics#closePath}</td>\n *     <td>c</td><td>{@link easeljs.Graphics#clear}</td></tr>\n *     <tr><td>f</td><td>{@link easeljs.Graphics#beginFill}</td>\n *     <td>lf</td><td>{@link easeljs.Graphics#beginLinearGradientFill}</td></tr>\n *     <tr><td>rf</td><td>{@link easeljs.Graphics#beginRadialGradientFill}</td>\n *     <td>bf</td><td>{@link easeljs.Graphics#beginBitmapFill}</td></tr>\n *     <tr><td>ef</td><td>{@link easeljs.Graphics#endFill}</td>\n *     <td>ss / sd</td><td>{@link easeljs.Graphics#setStrokeStyle} / {@link easeljs.Graphics#setStrokeDash}</td></tr>\n *     <tr><td>s</td><td>{@link easeljs.Graphics#beginStroke}</td>\n *     <td>ls</td><td>{@link easeljs.Graphics#beginLinearGradientStroke}</td></tr>\n *     <tr><td>rs</td><td>{@link easeljs.Graphics#beginRadialGradientStroke}</td>\n *     <td>bs</td><td>{@link easeljs.Graphics#beginBitmapStroke}</td></tr>\n *     <tr><td>es</td><td>{@link easeljs.Graphics#endStroke}</td>\n *     <td>dr</td><td>{@link easeljs.Graphics#drawRect}</td></tr>\n *     <tr><td>rr</td><td>{@link easeljs.Graphics#drawRoundRect}</td>\n *     <td>rc</td><td>{@link easeljs.Graphics#drawRoundRectComplex}</td></tr>\n *     <tr><td>dc</td><td>{@link easeljs.Graphics#drawCircle}</td>\n *     <td>de</td><td>{@link easeljs.Graphics#drawEllipse}</td></tr>\n *     <tr><td>dp</td><td>{@link easeljs.Graphics#drawPolyStar}</td>\n *     <td>p</td><td>{@link easeljs.Graphics#decodePath}</td></tr>\n * </table>\n *\n * @example\n * var g = new createjs.Graphics();\n * g.setStrokeStyle(1);\n * g.beginStroke("#000000");\n * g.beginFill("red");\n * g.drawCircle(0,0,30);\n *\n * @example\n * // All drawing methods in Graphics return the Graphics instance, so they can be chained together.\n * graphics.beginStroke("red").beginFill("blue").drawRect(20, 20, 100, 50);\n *\n * @example\n * // Each graphics API call generates a command object (see below). The last command to be created can be accessed via .command\n * let fillCommand = graphics.beginFill("red").command;\n * fillCommand.style = "blue";\n * // or change it to a bitmap fill:\n * fillCommand.bitmap(img);\n *\n * @example\n * // For more direct control of rendering, you can instantiate and append command objects to the graphics queue directly.\n * // In this case, you need to manage path creation manually, and ensure that fill/stroke is applied to a defined path:\n *\n * // start a new path. Graphics.beginCmd is a reusable BeginPath instance:\n * graphics.append(Graphics.beginCmd);\n * // we need to define the path before applying the fill:\n * let circle = new Graphics.Circle(0,0,30);\n * graphics.append(circle);\n * // fill the path we just defined:\n * let fill = new Graphics.Fill("red");\n * graphics.append(fill);\n *\n * // These approaches can be used together, for example to insert a custom command:\n * graphics.beginFill("red");\n * let customCommand = new CustomSpiralCommand(etc);\n * graphics.append(customCommand);\n * graphics.beginFill("blue");\n * graphics.drawCircle(0, 0, 30);\n *\n * @example <caption>Using the Tiny API</caption>\n * graphics.s("red").f("blue").r(20, 20, 100, 50);\n *\n * @see {@link easeljs.Graphics#append}\n * @memberof easeljs\n */\nclass Graphics {\n\n\tconstructor () {\n\t\t/**\n\t\t * Holds a reference to the last command that was created or appended. For example, you could retain a reference\n\t\t * to a Fill command in order to dynamically update the color later by using:\n\t\t *\n\t\t * @example\n\t\t * let fill = graphics.beginFill("red").command;\n\t\t * // update color later:\n\t\t * fill.style = "yellow";\n\t\t *\n\t\t * @type {Object}\n\t\t * @default null\n\t\t */\n\t\tthis.command = null;\n\n\n\t// private properties\n\t\t/**\n\t\t * @protected\n\t\t * @type {easeljs.Graphics.Stroke}\n\t\t */\n\t\tthis._stroke = null;\n\n\t\t/**\n\t\t * @protected\n\t\t * @type {easeljs.Graphics.StrokeStyle}\n\t\t */\n\t\tthis._strokeStyle = null;\n\n\t\t/**\n\t\t * @protected\n\t\t * @type {easeljs.Graphics.StrokeStyle}\n\t\t */\n\t\tthis._oldStrokeStyle = null;\n\n\t\t/**\n\t\t * @protected\n\t\t * @type {easeljs.Graphics.StrokeDash}\n\t\t */\n\t\tthis._strokeDash = null;\n\n\t\t/**\n\t\t * @protected\n\t\t * @type {easeljs.Graphics.StrokeDash}\n\t\t */\n\t\tthis._oldStrokeDash = null;\n\n\t\t/**\n\t\t * @protected\n\t\t * @type {easeljs.Graphics.Fill}\n\t\t */\n\t\tthis._fill = null;\n\n\t\t/**\n\t\t * @protected\n\t\t * @type {Boolean}\n\t\t */\n\t\tthis._strokeIgnoreScale = false;\n\n\t\t/**\n\t\t * Indicates the last instruction index that was committed.\n\t\t * @protected\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis._commitIndex = 0;\n\n\t\t/**\n\t\t * @protected\n\t\t * @type {Array}\n\t\t */\n\t\tthis._instructions = [];\n\n\t\t/**\n\t\t * Uncommitted instructions.\n\t\t * @protected\n\t\t * @type {Array}\n\t\t */\n\t\tthis._activeInstructions = [];\n\n\t\t/**\n\t\t * This indicates that there have been changes to the activeInstruction list since the last updateInstructions call.\n\t\t * @protected\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis._dirty = false;\n\n\t\t/**\n\t\t * Index to draw from if a store operation has happened.\n\t\t * @protected\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis._storeIndex = 0;\n\n\t\t/**\n\t\t * Maps the familiar ActionScript `curveTo()` method to the functionally similar {@link easeljs.Graphics#quadraticCurveTo} method.\n\t\t * @param {Number} cpx\n\t\t * @param {Number} cpy\n\t\t * @param {Number} x\n\t\t * @param {Number} y\n\t\t * @return {easeljs.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t\t * @chainable\n\t\t */\n\t\tthis.curveTo = this.quadraticCurveTo;\n\n\t\t/**\n\t\t * Maps the familiar ActionScript `drawRect()` method to the functionally similar {@link easeljs.Graphics#rect} method.\n\t\t * @param {Number} x\n\t\t * @param {Number} y\n\t\t * @param {Number} w Width of the rectangle\n\t\t * @param {Number} h Height of the rectangle\n\t\t * @return {easeljs.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t\t * @chainable\n\t\t */\n\t\tthis.drawRect = this.rect;\n\n\t\t// tiny api\n\t\tthis.mt = this.moveTo;\n\t\tthis.lt = this.lineTo;\n\t\tthis.at = this.arcTo;\n\t\tthis.bt = this.bezierCurveTo;\n\t\tthis.qt = this.quadraticCurveTo;\n\t\tthis.a = this.arc;\n\t\tthis.r = this.rect;\n\t\tthis.cp = this.closePath;\n\t\tthis.c = this.clear;\n\t\tthis.f = this.beginFill;\n\t\tthis.lf = this.beginLinearGradientFill;\n\t\tthis.rf = this.beginRadialGradientFill;\n\t\tthis.bf = this.beginBitmapFill;\n\t\tthis.ef = this.endFill;\n\t\tthis.ss = this.setStrokeStyle;\n\t\tthis.sd = this.setStrokeDash;\n\t\tthis.s = this.beginStroke;\n\t\tthis.ls = this.beginLinearGradientStroke;\n\t\tthis.rs = this.beginRadialGradientStroke;\n\t\tthis.bs = this.beginBitmapStroke;\n\t\tthis.es = this.endStroke;\n\t\tthis.dr = this.drawRect;\n\t\tthis.rr = this.drawRoundRect;\n\t\tthis.rc = this.drawRoundRectComplex;\n\t\tthis.dc = this.drawCircle;\n\t\tthis.de = this.drawEllipse;\n\t\tthis.dp = this.drawPolyStar;\n\t\tthis.p = this.decodePath;\n\n\t\tthis.clear();\n\t}\n\n\t/**\n\t * Returns a CSS compatible color string based on the specified RGB numeric color values in the format\n\t * "rgba(255,255,255,1.0)", or if alpha is null then in the format "rgb(255,255,255)".\n\t * It also supports passing a single hex color value as the first param, and an optional alpha value as the second\n\t * param.\n\t *\n\t * @example\n\t * Graphics.getRGB(50, 100, 150, 0.5); // rgba(50,100,150,0.5)\n\t * Graphics.getRGB(0xFF00FF, 0.2); // rgba(255,0,255,0.2)\n\t *\n\t * @static\n\t * @param {Number} r The red component for the color, between 0 and 0xFF (255).\n\t * @param {Number} g The green component for the color, between 0 and 0xFF (255).\n\t * @param {Number} b The blue component for the color, between 0 and 0xFF (255).\n\t * @param {Number} [alpha] The alpha component for the color where 0 is fully transparent and 1 is fully opaque.\n\t * @return {String} A CSS compatible color string based on the specified RGB numeric color values in the format\n\t * "rgba(255,255,255,1.0)", or if alpha is null then in the format "rgb(255,255,255)".\n\t */\n\tstatic getRGB (r, g, b, alpha) {\n\t\tif (r != null && b == null) {\n\t\t\talpha = g;\n\t\t\tb = r&0xFF;\n\t\t\tg = r>>8&0xFF;\n\t\t\tr = r>>16&0xFF;\n\t\t}\n\t\tif (alpha == null) {\n\t\t\treturn `rgb(${r},${g},${b})`;\n\t\t} else {\n\t\t\treturn `rgba(${r},${g},${b},${alpha})`;\n\t\t}\n\t}\n\n\t/**\n\t * Returns a CSS compatible color string based on the specified HSL numeric color values in the format "hsla(360,100,100,1.0)",\n\t * or if alpha is null then in the format "hsl(360,100,100)".\n\t *\n\t * @example\n\t * Graphics.getHSL(150, 100, 70); // hsl(150,100,70)\n\t *\n\t * @static\n\t * @param {Number} hue The hue component for the color, between 0 and 360.\n\t * @param {Number} saturation The saturation component for the color, between 0 and 100.\n\t * @param {Number} lightness The lightness component for the color, between 0 and 100.\n\t * @param {Number} [alpha] The alpha component for the color where 0 is fully transparent and 1 is fully opaque.\n\t * @return {String} A CSS compatible color string based on the specified HSL numeric color values in the format\n\t * "hsla(360,100,100,1.0)", or if alpha is null then in the format "hsl(360,100,100)".\n\t */\n\tstatic getHSL (hue, saturation, lightness, alpha) {\n\t\tif (alpha == null) {\n\t\t\treturn `hsl(${hue % 360},${saturation}%,${lightness}%)`;\n\t\t} else {\n\t\t\treturn `hsl(${hue % 360},${saturation}%,${lightness}%,${alpha})`;\n\t\t}\n\t}\n\n\t/**\n\t * Returns the graphics instructions array. Each entry is a graphics command object (ex. Graphics.Fill, Graphics.Rect)\n\t * Modifying the returned array directly is not recommended, and is likely to result in unexpected behaviour.\n\t *\n\t * This property is mainly intended for introspection of the instructions (ex. for graphics export).\n\t * @type {Array}\n\t * @readonly\n\t */\n\tget instructions () {\n\t\tthis._updateInstructions();\n\t\treturn this._instructions;\n\t}\n\n\t/**\n\t * Returns true if this Graphics instance has no drawing commands.\n\t * @return {Boolean} Returns true if this Graphics instance has no drawing commands.\n\t */\n\tisEmpty () {\n\t\treturn !(this._instructions.length || this._activeInstructions.length);\n\t}\n\n\t/**\n\t * Draws the display object into the specified context ignoring its visible, alpha, shadow, and transform.\n\t * Returns true if the draw was handled (useful for overriding functionality).\n\t *\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t *\n\t * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.\n\t * @param {Object} data Optional data that is passed to graphics command exec methods. When called from a Shape instance, the shape passes itself as the data parameter. This can be used by custom graphic commands to insert contextual data.\n\t */\n\tdraw (ctx, data) {\n\t\tthis._updateInstructions();\n\t\tlet instr = this._instructions;\n\t\tconst l = instr.length;\n\t\tfor (let i = this._storeIndex; i < l; i++) {\n\t\t\tinstr[i].exec(ctx, data);\n\t\t}\n\t}\n\n\t/**\n\t * Draws only the path described for this Graphics instance, skipping any non-path instructions, including fill and\n\t * stroke descriptions. Used for `DisplayObject.mask` to draw the clipping path, for example.\n\t *\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t *\n\t * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.\n\t */\n\tdrawAsPath (ctx) {\n\t\tthis._updateInstructions();\n\t\tlet instr, instrs = this._instructions;\n\t\tconst l = instrs.length;\n\t\tfor (let i = this._storeIndex; i < l; i++) {\n\t\t\t// the first command is always a beginPath command.\n\t\t\tif ((instr = instrs[i]).path !== false) { instr.exec(ctx); }\n\t\t}\n\t}\n\n\t/**\n\t * Moves the drawing point to the specified position.\n\t * A tiny API method "mt" also exists.\n\t * @param {Number} x The x coordinate the drawing point should move to.\n\t * @param {Number} y The y coordinate the drawing point should move to.\n\t * @return {easeljs.Graphics} The Graphics instance the method is called on (useful for chaining calls).\n\t * @chainable\n\t */\n\tmoveTo (x, y) {\n\t\treturn this.append(new MoveTo(x,y), true);\n\t}\n\n\t/**\n\t * Draws a line from the current drawing point to the specified position, which become the new current drawing\n\t * point. Note that you *must* call {@link easeljs.Graphics#moveTo} before the first `lineTo()`.\n\t * A tiny API method "lt" also exists.\n\t * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#complex-shapes-(paths) "WHATWG spec"}\n\t * @param {Number} x The x coordinate the drawing point should draw to.\n\t * @param {Number} y The y coordinate the drawing point should draw to.\n\t * @return {easeljs.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t */\n\tlineTo (x, y) {\n\t\treturn this.append(new LineTo(x,y));\n\t}\n\n\t/**\n\t * Draws an arc with the specified control points and radius.\n\t * A tiny API method "at" also exists.\n\t * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-arcto "WHATWG spec"}\n\t * @param {Number} x1\n\t * @param {Number} y1\n\t * @param {Number} x2\n\t * @param {Number} y2\n\t * @param {Number} radius\n\t * @return {easeljs.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t */\n\tarcTo (x1, y1, x2, y2, radius) {\n\t\treturn this.append(new ArcTo(x1, y1, x2, y2, radius));\n\t}\n\n\t/**\n\t * Draws an arc defined by the radius, startAngle and endAngle arguments, centered at the position (x, y).\n\t * A tiny API method "a" also exists.\n\t *\n\t * @example\n\t * // draw a full circle with a radius of 20 centered at (100, 100)\n\t * arc(100, 100, 20, 0, Math.PI*2);\n\t *\n\t * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-arc "WHATWG spec"}\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} radius\n\t * @param {Number} startAngle Measured in radians.\n\t * @param {Number} endAngle Measured in radians.\n\t * @param {Boolean} anticlockwise\n\t * @return {easeljs.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t */\n\tarc (x, y, radius, startAngle, endAngle, anticlockwise) {\n\t\treturn this.append(new Arc(x, y, radius, startAngle, endAngle, anticlockwise));\n\t}\n\n\t/**\n\t * Draws a quadratic curve from the current drawing point to (x, y) using the control point (cpx, cpy).\n\t * A tiny API method "qt" also exists.\n\t * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-quadraticcurveto "WHATWG spec"}\n\t * @param {Number} cpx\n\t * @param {Number} cpy\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @return {easeljs.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t */\n\tquadraticCurveTo (cpx, cpy, x, y) {\n\t\treturn this.append(new QuadraticCurveTo(cpx, cpy, x, y));\n\t}\n\n\t/**\n\t * Draws a bezier curve from the current drawing point to (x, y) using the control points (cp1x, cp1y) and (cp2x, cp2y).\n\t * A tiny API method "bt" also exists.\n\t * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-beziercurveto "WHATWG spec"}\n\t * @param {Number} cp1x\n\t * @param {Number} cp1y\n\t * @param {Number} cp2x\n\t * @param {Number} cp2y\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @return {easeljs.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t */\n\tbezierCurveTo (cp1x, cp1y, cp2x, cp2y, x, y) {\n\t\treturn this.append(new BezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y));\n\t}\n\n\t/**\n\t * Draws a rectangle at (x, y) with the specified width and height using the current fill and/or stroke.\n\t * A tiny API method "r" also exists.\n\t * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-rect "WHATWG spec"}\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} w Width of the rectangle\n\t * @param {Number} h Height of the rectangle\n\t * @return {easeljs.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t */\n\trect (x, y, w, h) {\n\t\treturn this.append(new Rect(x, y, w, h));\n\t}\n\n\t/**\n\t * Closes the current path, effectively drawing a line from the current drawing point to the first drawing point specified\n\t * since the fill or stroke was last set.\n\t * A tiny API method "cp" also exists.\n\t * @return {easeljs.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t */\n\tclosePath () {\n\t\treturn this._activeInstructions.length ? this.append(new ClosePath()) : this;\n\t}\n\n\t/**\n\t * Clears all drawing instructions, effectively resetting this Graphics instance. Any line and fill styles will need\n\t * to be redefined to draw shapes following a clear call.\n\t * A tiny API method "c" also exists.\n\t * @return {easeljs.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t */\n\tclear () {\n\t\tthis._instructions.length = this._activeInstructions.length = this._commitIndex = 0;\n\t\tthis._strokeStyle = this._oldStrokeStyle = this._stroke = this._fill = this._strokeDash = this._oldStrokeDash = null;\n\t\tthis._dirty = this._strokeIgnoreScale = false;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Begins a fill with the specified color. This ends the current sub-path.\n\t * A tiny API method "f" also exists.\n\t * @param {String} color A CSS compatible color value (ex. "red", "#FF0000", or "rgba(255,0,0,0.5)"). Setting to\n\t * null will result in no fill.\n\t * @return {easeljs.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t */\n\tbeginFill (color) {\n\t\treturn this._setFill(color ? new Fill(color) : null);\n\t}\n\n\t/**\n\t * Begins a linear gradient fill defined by the line (x0, y0) to (x1, y1).\n\t * A tiny API method "lf" also exists.\n\t *\n\t * @example <caption>Define a black to white vertical gradient ranging from 20px to 120px, and draw a square to display it</caption>\n\t * graphics.beginLinearGradientFill(["#000","#FFF"], [0, 1], 0, 20, 0, 120).drawRect(20, 20, 120, 120);\n\t *\n\t * @param {Array} colors An array of CSS compatible color values. For example, ["#F00","#00F"] would define a gradient\n\t * drawing from red to blue.\n\t * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1, 0.9] would draw\n\t * the first color to 10% then interpolating to the second color at 90%.\n\t * @param {Number} x0 The position of the first point defining the line that defines the gradient direction and size.\n\t * @param {Number} y0 The position of the first point defining the line that defines the gradient direction and size.\n\t * @param {Number} x1 The position of the second point defining the line that defines the gradient direction and size.\n\t * @param {Number} y1 The position of the second point defining the line that defines the gradient direction and size.\n\t * @return {easeljs.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t */\n\tbeginLinearGradientFill (colors, ratios, x0, y0, x1, y1) {\n\t\treturn this._setFill(new Fill().linearGradient(colors, ratios, x0, y0, x1, y1));\n\t}\n\n\t/**\n\t * Begins a radial gradient fill. This ends the current sub-path.\n\t * A tiny API method "rf" also exists.\n\t *\n\t * @example <caption>Define a red to blue radial gradient centered at (100, 100), with a radius of 50, and draw a circle to display it</caption>\n\t * graphics.beginRadialGradientFill(["#F00","#00F"], [0, 1], 100, 100, 0, 100, 100, 50).drawCircle(100, 100, 50);\n\t *\n\t * @param {Array} colors An array of CSS compatible color values. For example, ["#F00","#00F"] would define\n\t * a gradient drawing from red to blue.\n\t * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1,\n\t * 0.9] would draw the first color to 10% then interpolating to the second color at 90%.\n\t * @param {Number} x0 Center position of the inner circle that defines the gradient.\n\t * @param {Number} y0 Center position of the inner circle that defines the gradient.\n\t * @param {Number} r0 Radius of the inner circle that defines the gradient.\n\t * @param {Number} x1 Center position of the outer circle that defines the gradient.\n\t * @param {Number} y1 Center position of the outer circle that defines the gradient.\n\t * @param {Number} r1 Radius of the outer circle that defines the gradient.\n\t * @return {easeljs.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t */\n\tbeginRadialGradientFill (colors, ratios, x0, y0, r0, x1, y1, r1) {\n\t\treturn this._setFill(new Fill().radialGradient(colors, ratios, x0, y0, r0, x1, y1, r1));\n\t}\n\n\t/**\n\t * Begins a pattern fill using the specified image. This ends the current sub-path.\n\t * A tiny API method "bf" also exists.\n\t * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} image The Image, Canvas, or Video object to use\n\t * as the pattern. Must be loaded prior to creating a bitmap fill, or the fill will be empty.\n\t * @param {String} repetition Optional. Indicates whether to repeat the image in the fill area. One of "repeat",\n\t * "repeat-x", "repeat-y", or "no-repeat". Defaults to "repeat". Note that Firefox does not support "repeat-x" or\n\t * "repeat-y" (latest tests were in FF 20.0), and will default to "repeat".\n\t * @param {easeljs.Matrix2D} matrix Optional. Specifies a transformation matrix for the bitmap fill. This transformation\n\t * will be applied relative to the parent transform.\n\t * @return {easeljs.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t */\n\tbeginBitmapFill (image, repetition, matrix) {\n\t\treturn this._setFill(new Fill(null, matrix).bitmap(image, repetition));\n\t}\n\n\t/**\n\t * Ends the current sub-path, and begins a new one with no fill. Functionally identical to `beginFill(null)`.\n\t * A tiny API method "ef" also exists.\n\t * @return {easeljs.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t */\n\tendFill () {\n\t\treturn this.beginFill();\n\t}\n\n\t/**\n\t * Sets the stroke style.\n\t * A tiny API method "ss" also exists.\n\t *\n\t * @example\n\t * graphics.setStrokeStyle(8,"round").beginStroke("#F00");\n\t *\n\t * @param {Number} thickness The width of the stroke.\n\t * @param {String | Number} [caps=0] Indicates the type of caps to use at the end of lines. One of butt,\n\t * round, or square. Defaults to "butt". Also accepts the values 0 (butt), 1 (round), and 2 (square) for use with\n\t * the tiny API.\n\t * @param {String | Number} [joints=0] Specifies the type of joints that should be used where two lines meet.\n\t * One of bevel, round, or miter. Defaults to "miter". Also accepts the values 0 (miter), 1 (round), and 2 (bevel)\n\t * for use with the tiny API.\n\t * @param {Number} [miterLimit=10] If joints is set to "miter", then you can specify a miter limit ratio which\n\t * controls at what point a mitered joint will be clipped.\n\t * @param {Boolean} [ignoreScale=false] If true, the stroke will be drawn at the specified thickness regardless\n\t * of active transformations.\n\t * @return {easeljs.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t */\n\tsetStrokeStyle (thickness, caps = 0, joints = 0, miterLimit = 10, ignoreScale = false) {\n\t\tthis._updateInstructions(true);\n\t\tthis._strokeStyle = this.command = new StrokeStyle(thickness, caps, joints, miterLimit, ignoreScale);\n\n\t\t// ignoreScale lives on Stroke, not StrokeStyle, so we do a little trickery:\n\t\tif (this._stroke) { this._stroke.ignoreScale = ignoreScale; }\n\t\tthis._strokeIgnoreScale = ignoreScale;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sets or clears the stroke dash pattern.\n\t * A tiny API method `sd` also exists.\n\t *\n\t * @example\n\t * graphics.setStrokeDash([20, 10], 0);\n\t *\n\t * @param {Array} [segments] An array specifying the dash pattern, alternating between line and gap.\n\t * For example, `[20,10]` would create a pattern of 20 pixel lines with 10 pixel gaps between them.\n\t * Passing null or an empty array will clear the existing stroke dash.\n\t * @param {Number} [offset=0] The offset of the dash pattern. For example, you could increment this value to create a "marching ants" effect.\n\t * @return {easeljs.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t */\n\tsetStrokeDash (segments, offset = 0) {\n\t\tthis._updateInstructions(true);\n\t\tthis._strokeDash = this.command = new StrokeDash(segments, offset);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Begins a stroke with the specified color. This ends the current sub-path.\n\t * A tiny API method "s" also exists.\n\t *\n\t * @param {String} color A CSS compatible color value (ex. "#FF0000", "red", or "rgba(255,0,0,0.5)"). Setting to\n\t * null will result in no stroke.\n\t * @return {easeljs.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t */\n\tbeginStroke (color) {\n\t\treturn this._setStroke(color ? new Stroke(color) : null);\n\t}\n\n\t/**\n\t * Begins a linear gradient stroke defined by the line (x0, y0) to (x1, y1). This ends the current sub-path.\n\t * A tiny API method "ls" also exists.\n\t *\n\t * @example <caption>Define a black to white vertical gradient ranging from 20px to 120px, and draw a square to display it</caption>\n\t * graphics.setStrokeStyle(10)\n\t *   .beginLinearGradientStroke(["#000","#FFF"], [0, 1], 0, 20, 0, 120)\n\t *   .drawRect(20, 20, 120, 120);\n\t *\n\t * @param {Array<String>} colors An array of CSS compatible color values. For example, ["#F00","#00F"] would define\n\t * a gradient drawing from red to blue.\n\t * @param {Array<Number>} ratios An array of gradient positions which correspond to the colors. For example, [0.1,\n\t * 0.9] would draw the first color to 10% then interpolating to the second color at 90%.\n\t * @param {Number} x0 The position of the first point defining the line that defines the gradient direction and size.\n\t * @param {Number} y0 The position of the first point defining the line that defines the gradient direction and size.\n\t * @param {Number} x1 The position of the second point defining the line that defines the gradient direction and size.\n\t * @param {Number} y1 The position of the second point defining the line that defines the gradient direction and size.\n\t * @return {easeljs.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t */\n\tbeginLinearGradientStroke (colors, ratios, x0, y0, x1, y1) {\n\t\treturn this._setStroke(new Stroke().linearGradient(colors, ratios, x0, y0, x1, y1));\n\t}\n\n\t/**\n\t * Begins a radial gradient stroke. This ends the current sub-path.\n\t * A tiny API method "rs" also exists.\n\t *\n\t * @example <caption>Define a red to blue radial gradient centered at (100, 100), with a radius of 50, and draw a rectangle to display it</caption>\n\t * graphics.setStrokeStyle(10)\n\t *   .beginRadialGradientStroke(["#F00","#00F"], [0, 1], 100, 100, 0, 100, 100, 50)\n\t *   .drawRect(50, 90, 150, 110);\n\t *\n\t * @param {Array<String>} colors An array of CSS compatible color values. For example, ["#F00","#00F"] would define\n\t * a gradient drawing from red to blue.\n\t * @param {Array<Number>} ratios An array of gradient positions which correspond to the colors. For example, [0.1,\n\t * 0.9] would draw the first color to 10% then interpolating to the second color at 90%, then draw the second color\n\t * to 100%.\n\t * @param {Number} x0 Center position of the inner circle that defines the gradient.\n\t * @param {Number} y0 Center position of the inner circle that defines the gradient.\n\t * @param {Number} r0 Radius of the inner circle that defines the gradient.\n\t * @param {Number} x1 Center position of the outer circle that defines the gradient.\n\t * @param {Number} y1 Center position of the outer circle that defines the gradient.\n\t * @param {Number} r1 Radius of the outer circle that defines the gradient.\n\t * @return {easeljs.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t */\n\tbeginRadialGradientStroke (colors, ratios, x0, y0, r0, x1, y1, r1) {\n\t\treturn this._setStroke(new Stroke().radialGradient(colors, ratios, x0, y0, r0, x1, y1, r1));\n\t}\n\n\t/**\n\t * Begins a pattern fill using the specified image. This ends the current sub-path. Note that unlike bitmap fills,\n\t * strokes do not currently support a matrix parameter due to limitations in the canvas API.\n\t * A tiny API method "bs" also exists.\n\t *\n\t * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} image The Image, Canvas, or Video object to use\n\t * as the pattern. Must be loaded prior to creating a bitmap fill, or the fill will be empty.\n\t * @param {String} [repetition="repeat"] Indicates whether to repeat the image in the fill area. One of\n\t * "repeat", "repeat-x", "repeat-y", or "no-repeat". Defaults to "repeat".\n\t * @return {easeljs.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t */\n\tbeginBitmapStroke (image, repetition = "repeat") {\n\t\t// NOTE: matrix is not supported for stroke because transforms on strokes also affect the drawn stroke width.\n\t\treturn this._setStroke(new Stroke().bitmap(image, repetition));\n\t}\n\n\t/**\n\t * Ends the current sub-path, and begins a new one with no stroke. Functionally identical to `beginStroke(null)`.\n\t * A tiny API method "es" also exists.\n\t * @return {easeljs.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t */\n\tendStroke () {\n\t\treturn this.beginStroke();\n\t}\n\n\t/**\n\t * Draws a rounded rectangle with all corners with the specified radius.\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} w\n\t * @param {Number} h\n\t * @param {Number} radius Corner radius.\n\t * @return {easeljs.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t */\n\tdrawRoundRect (x, y, w, h, radius) {\n\t\treturn this.drawRoundRectComplex(x, y, w, h, radius, radius, radius, radius);\n\t}\n\n\t/**\n\t * Draws a rounded rectangle with different corner radii. Supports positive and negative corner radii.\n\t * A tiny API method "rc" also exists.\n\t * @param {Number} x The horizontal coordinate to draw the round rect.\n\t * @param {Number} y The vertical coordinate to draw the round rect.\n\t * @param {Number} w The width of the round rect.\n\t * @param {Number} h The height of the round rect.\n\t * @param {Number} radiusTL Top left corner radius.\n\t * @param {Number} radiusTR Top right corner radius.\n\t * @param {Number} radiusBR Bottom right corner radius.\n\t * @param {Number} radiusBL Bottom left corner radius.\n\t * @return {easeljs.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t */\n\tdrawRoundRectComplex (x, y, w, h, radiusTL, radiusTR, radiusBR, radiusBL) {\n\t\treturn this.append(new RoundRect(x, y, w, h, radiusTL, radiusTR, radiusBR, radiusBL));\n\t}\n\n\t/**\n\t * Draws a circle with the specified radius at (x, y).\n\t * A tiny API method "dc" also exists.\n\t *\n\t * @example\n\t * let g = new Graphics();\n\t * g.setStrokeStyle(1);\n\t * g.beginStroke(Graphics.getRGB(0,0,0));\n\t * g.beginFill(Graphics.getRGB(255,0,0));\n\t * g.drawCircle(0,0,3);\n\t * let s = new Shape(g);\n\t * s.x = 100;\n\t * s.y = 100;\n\t * stage.addChild(s);\n\t * stage.update();\n\t *\n\t * @param {Number} x x coordinate center point of circle.\n\t * @param {Number} y y coordinate center point of circle.\n\t * @param {Number} radius Radius of circle.\n\t * @return {easeljs.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t */\n\tdrawCircle (x, y, radius) {\n\t\treturn this.append(new Circle(x, y, radius));\n\t}\n\n\t/**\n\t * Draws an ellipse (oval) with a specified width (w) and height (h). Similar to {@link easels.Graphics#drawCircle},\n\t * except the width and height can be different.\n\t * A tiny API method "de" also exists.\n\t * @param {Number} x The left coordinate point of the ellipse. Note that this is different from {@link easels.Graphics#drawCircle}\n\t * which draws from center.\n\t * @param {Number} y The top coordinate point of the ellipse. Note that this is different from {@link easels.Graphics#drawCircle}\n\t * which draws from the center.\n\t * @param {Number} w The height (horizontal diameter) of the ellipse. The horizontal radius will be half of this\n\t * number.\n\t * @param {Number} h The width (vertical diameter) of the ellipse. The vertical radius will be half of this number.\n\t * @return {easeljs.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t */\n\tdrawEllipse (x, y, w, h) {\n\t\treturn this.append(new Ellipse(x, y, w, h));\n\t}\n\n\t/**\n\t * Draws a star if pointSize is greater than 0, or a regular polygon if pointSize is 0 with the specified number of points.\n\t * A tiny API method "dp" also exists.\n\t *\n\t * @example <caption>Draw a 5 pointed star shape centered at 100, 100 and with a radius of 50</caption>\n\t * graphics.beginFill("#FF0").drawPolyStar(100, 100, 50, 5, 0.6, -90);\n\t * // Note: -90 makes the first point vertical\n\t *\n\t * @param {Number} x Position of the center of the shape.\n\t * @param {Number} y Position of the center of the shape.\n\t * @param {Number} radius The outer radius of the shape.\n\t * @param {Number} sides The number of points on the star or sides on the polygon.\n\t * @param {Number} pointSize The depth or "pointy-ness" of the star points. A pointSize of 0 will draw a regular\n\t * polygon (no points), a pointSize of 1 will draw nothing because the points are infinitely pointy.\n\t * @param {Number} angle The angle of the first point / corner. For example a value of 0 will draw the first point\n\t * directly to the right of the center.\n\t * @return {easeljs.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t */\n\tdrawPolyStar (x, y, radius, sides, pointSize, angle) {\n\t\treturn this.append(new PolyStar(x, y, radius, sides, pointSize, angle));\n\t}\n\n\t/**\n\t * Appends a graphics command object to the graphics queue. Command objects expose an "exec" method\n\t * that accepts two parameters: the Context2D to operate on, and an arbitrary data object passed into\n\t * {@link easeljs.Graphics#draw}. The latter will usually be the Shape instance that called draw.\n\t *\n\t * This method is used internally by Graphics methods, such as drawCircle, but can also be used directly to insert\n\t * built-in or custom graphics commands.\n\t *\n\t * @example\n\t * // attach data to our shape, so we can access it during the draw:\n\t * shape.color = "red";\n\t *\n\t * // append a Circle command object:\n\t * shape.graphics.append(new Graphics.Circle(50, 50, 30));\n\t *\n\t * // append a custom command object with an exec method that sets the fill style\n\t * // based on the shape\'s data, and then fills the circle.\n\t * shape.graphics.append({\n\t *   exec: (ctx, shape) => {\n\t *     ctx.fillStyle = shape.color;\n\t *     ctx.fill();\n\t *   }\n\t * });\n\t *\n\t * @param {Object} command A graphics command object exposing an "exec" method.\n\t * @param {Boolean} clean The clean param is primarily for internal use. A value of true indicates that a command does not generate a path that should be stroked or filled.\n\t * @return {easeljs.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t */\n\tappend (command, clean) {\n\t\tthis._activeInstructions.push(command);\n\t\tthis.command = command;\n\t\tif (!clean) { this._dirty = true; }\n\t\treturn this;\n\t}\n\n\t/**\n\t * Decodes a compact encoded path string into a series of draw instructions.\n\t * This format is not intended to be human readable, and is meant for use by authoring tools.\n\t * The format uses a base64 character set, with each character representing 6 bits, to define a series of draw\n\t * commands.\n\t *\n\t * Each command is comprised of a single "header" character followed by a variable number of alternating x and y\n\t * position values. Reading the header bits from left to right (most to least significant): bits 1 to 3 specify the\n\t * type of operation (0-moveTo, 1-lineTo, 2-quadraticCurveTo, 3-bezierCurveTo, 4-closePath, 5-7 unused). Bit 4\n\t * indicates whether position values use 12 bits (2 characters) or 18 bits (3 characters), with a one indicating the\n\t * latter. Bits 5 and 6 are currently unused.\n\t *\n\t * Following the header is a series of 0 (closePath), 2 (moveTo, lineTo), 4 (quadraticCurveTo), or 6 (bezierCurveTo)\n\t * parameters. These parameters are alternating x/y positions represented by 2 or 3 characters (as indicated by the\n\t * 4th bit in the command char). These characters consist of a 1 bit sign (1 is negative, 0 is positive), followed\n\t * by an 11 (2 char) or 17 (3 char) bit integer value. All position values are in tenths of a pixel. Except in the\n\t * case of move operations which are absolute, this value is a delta from the previous x or y position (as\n\t * appropriate).\n\t *\n\t * For example, the string "A3cAAMAu4AAA" represents a line starting at -150,0 and ending at 150,0.\n\t * <br />A - bits 000000. First 3 bits (000) indicate a moveTo operation. 4th bit (0) indicates 2 chars per\n\t * parameter.\n\t * <br />n0 - 110111011100. Absolute x position of -150.0px. First bit indicates a negative value, remaining bits\n\t * indicate 1500 tenths of a pixel.\n\t * <br />AA - 000000000000. Absolute y position of 0.\n\t * <br />I - 001100. First 3 bits (001) indicate a lineTo operation. 4th bit (1) indicates 3 chars per parameter.\n\t * <br />Au4 - 000000101110111000. An x delta of 300.0px, which is added to the previous x value of -150.0px to\n\t * provide an absolute position of +150.0px.\n\t * <br />AAA - 000000000000000000. A y delta value of 0.\n\t *\n\t * A tiny API method "p" also exists.\n\t *\n\t * @param {String} str The path string to decode.\n\t * @return {easeljs.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t */\n\tdecodePath (str) {\n\t\tlet instructions = [this.moveTo, this.lineTo, this.quadraticCurveTo, this.bezierCurveTo, this.closePath];\n\t\tlet paramCount = [2, 2, 4, 6, 0];\n\t\tlet i = 0;\n\t\tconst l = str.length;\n\t\tlet params = [];\n\t\tlet x = 0, y = 0;\n\t\tlet base64 = Graphics._BASE_64;\n\n\t\twhile (i < l) {\n\t\t\tlet c = str.charAt(i);\n\t\t\tlet n = base64[c];\n\t\t\tlet fi = n>>3; // highest order bits 1-3 code for operation.\n\t\t\tlet f = instructions[fi];\n\t\t\t// check that we have a valid instruction & that the unused bits are empty:\n\t\t\tif (!f || (n&3)) { throw `Bad path data (@${i}):c`; }\n\t\t\tconst pl = paramCount[fi];\n\t\t\tif (!fi) { x=y=0; } // move operations reset the position.\n\t\t\tparams.length = 0;\n\t\t\ti++;\n\t\t\tlet charCount = (n>>2&1)+2;  // 4th header bit indicates number size for this operation.\n\t\t\tfor (let p = 0; p < pl; p++) {\n\t\t\t\tlet num = base64[str.charAt(i)];\n\t\t\t\tlet sign = (num>>5) ? -1 : 1;\n\t\t\t\tnum = ((num&31)<<6)|(base64[str.charAt(i+1)]);\n\t\t\t\tif (charCount === 3) { num = (num<<6)|(base64[str.charAt(i+2)]); }\n\t\t\t\tnum = sign*num/10;\n\t\t\t\tif (p%2) { x = (num += x); }\n\t\t\t\telse { y = (num += y); }\n\t\t\t\tparams[p] = num;\n\t\t\t\ti += charCount;\n\t\t\t}\n\t\t\tf.apply(this, params);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stores all graphics commands so they won\'t be executed in future draws. Calling store() a second time adds to\n\t * the existing store. This also affects `drawAsPath()`.\n\t *\n\t * This is useful in cases where you are creating vector graphics in an iterative manner (ex. generative art), so\n\t * that only new graphics need to be drawn (which can provide huge performance benefits), but you wish to retain all\n\t * of the vector instructions for later use (ex. scaling, modifying, or exporting).\n\t *\n\t * Note that calling store() will force the active path (if any) to be ended in a manner similar to changing\n\t * the fill or stroke.\n\t *\n\t * For example, consider a application where the user draws lines with the mouse. As each line segment (or collection of\n\t * segments) are added to a Shape, it can be rasterized using {@link easeljs.DisplayObject#updateCache},\n\t * and then stored, so that it can be redrawn at a different scale when the application is resized, or exported to SVGraphics.\n\t *\n\t * @example\n\t * // set up cache:\n\t * shape.cache(0,0,500,500,scale);\n\t *\n\t * // when the user drags, draw a new line:\n\t * shape.graphics.moveTo(oldX,oldY).lineTo(newX,newY);\n\t * // then draw it into the existing cache:\n\t * shape.updateCache("source-over");\n\t * // store the new line, so it isn\'t redrawn next time:\n\t * shape.store();\n\t *\n\t * // then, when the window resizes, we can re-render at a different scale:\n\t * // first, unstore all our lines:\n\t * shape.unstore();\n\t * // then cache using the new scale:\n\t * shape.cache(0,0,500,500,newScale);\n\t * // finally, store the existing commands again:\n\t * shape.store();\n\t *\n\t * @return {easeljs.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t */\n\tstore () {\n\t\tthis._updateInstructions(true);\n\t\tthis._storeIndex = this._instructions.length;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Unstores any graphics commands that were previously stored using {@link easeljs.Graphics#store}\n\t * so that they will be executed in subsequent draw calls.\n\t *\n\t * @return {easeljs.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t */\n\tunstore () {\n\t\tthis._storeIndex = 0;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns a clone of this Graphics instance. Note that the individual command objects are not cloned.\n\t * @return {easeljs.Graphics} A clone of the current Graphics instance.\n\t */\n\tclone () {\n\t\tlet o = new Graphics();\n\t\to.command = this.command;\n\t\to._stroke = this._stroke;\n\t\to._strokeStyle = this._strokeStyle;\n\t\to._strokeDash = this._strokeDash;\n\t\to._strokeIgnoreScale = this._strokeIgnoreScale;\n\t\to._fill = this._fill;\n\t\to._instructions = this._instructions.slice();\n\t\to._commitIndex = this._commitIndex;\n\t\to._activeInstructions = this._activeInstructions.slice();\n\t\to._dirty = this._dirty;\n\t\to._storeIndex = this._storeIndex;\n\t\treturn o;\n\t}\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @return {String} a string representation of the instance.\n\t */\n\ttoString () {\n\t\treturn `[${this.constructor.name}]`;\n\t}\n\n\t/**\n\t * @param {Boolean} commit\n\t * @protected\n\t */\n\t_updateInstructions (commit) {\n\t\tlet instr = this._instructions, active = this._activeInstructions, commitIndex = this._commitIndex;\n\n\t\tif (this._dirty && active.length) {\n\t\t\tinstr.length = commitIndex; // remove old, uncommitted commands\n\t\t\tinstr.push(Graphics.beginCmd);\n\n\t\t\tconst l = active.length, ll = instr.length;\n\t\t\tinstr.length = ll+l;\n\t\t\tfor (let i = 0; i < l; i++) { instr[i+ll] = active[i]; }\n\n\t\t\tif (this._fill) { instr.push(this._fill); }\n\t\t\tif (this._stroke) {\n\t\t\t\t// doesn\'t need to be re-applied if it hasn\'t changed.\n\t\t\t\tif (this._strokeDash !== this._oldStrokeDash) {\n\t\t\t\t\tinstr.push(this._strokeDash);\n\t\t\t\t}\n\t\t\t\tif (this._strokeStyle !== this._oldStrokeStyle) {\n\t\t\t\t\tinstr.push(this._strokeStyle);\n\t\t\t\t}\n\t\t\t\tif (commit) {\n\t\t\t\t\tthis._oldStrokeDash = this._strokeDash;\n\t\t\t\t\tthis._oldStrokeStyle = this._strokeStyle;\n\t\t\t\t}\n\t\t\t\tinstr.push(this._stroke);\n\t\t\t}\n\n\t\t\tthis._dirty = false;\n\t\t}\n\n\t\tif (commit) {\n\t\t\tactive.length = 0;\n\t\t\tthis._commitIndex = instr.length;\n\t\t}\n\t};\n\n\t/**\n\t * @param {easeljs.Graphics.Fill} fill\n\t * @protected\n\t */\n\t_setFill (fill) {\n\t\tthis._updateInstructions(true);\n\t\tthis.command = this._fill = fill;\n\t\treturn this;\n\t}\n\n\t/**\n\t * @param {easeljs.Graphics.Stroke} stroke\n\t * @protected\n\t */\n\t_setStroke (stroke) {\n\t\tthis._updateInstructions(true);\n\t\tif (this.command = this._stroke = stroke) {\n\t\t\tstroke.ignoreScale = this._strokeIgnoreScale;\n\t\t}\n\t\treturn this;\n\t}\n\n\tstatic get LineTo () { return LineTo; }\n\tstatic get MoveTo () { return MoveTo; }\n\tstatic get ArcTo () { return ArcTo; }\n\tstatic get Arc () { return Arc; }\n\tstatic get QuadraticCurveTo () { return QuadraticCurveTo; }\n\tstatic get BezierCurveTo () { return BezierCurveTo; }\n\tstatic get Rect () { return Rect; }\n\tstatic get ClosePath () { return ClosePath; }\n\tstatic get BeginPath () { return BeginPath; }\n\tstatic get Fill () { return Fill; }\n\tstatic get Stroke () { return Stroke; }\n\tstatic get StrokeStyle () { return StrokeStyle; }\n\tstatic get StrokeDash () { return StrokeDash; }\n\tstatic get RoundRect () { return RoundRect; }\n\tstatic get Circle () { return Circle; }\n\tstatic get Ellipse () { return Ellipse; }\n\tstatic get PolyStar () { return PolyStar; }\n\n}\n\n/**\n * @see {@link easeljs.Graphics#lineTo}\n * @alias easeljs.Graphics.LineTo\n * @param {Number} x\n * @param {Number} y\n */\nclass LineTo {\n\tconstructor (x, y) {\n\t\t/**\n\t\t * @type {Number}\n\t\t */\n\t\tthis.x = x;\n\t\t/**\n\t\t * @type {Number}\n\t\t */\n\t\tthis.y = y;\n\t}\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\texec (ctx) {\n\t\tctx.lineTo(this.x, this.y);\n\t}\n}\n\n/**\n * @see {@link easeljs.Graphics#moveTo}\n * @alias easeljs.Graphics.MoveTo\n * @param {Number} x\n * @param {Number} y\n */\nclass MoveTo {\n \tconstructor (x, y) {\n\t\t/**\n\t\t * @type {Number}\n\t\t */\n \t\tthis.x = x;\n\t\t/**\n\t\t * @type {Number}\n\t\t */\n\t\tthis.y = y;\n \t}\n\t/**\n\t * @param {CanvasRenderingContext2D} ctx\n\t */\n \texec (ctx) {\n \t\tctx.moveTo(this.x, this.y);\n \t}\n}\n\n\n/**\n * @see {@link easeljs.Graphics#arcTo}\n * @alias easeljs.Graphics.ArcTo\n * @param {Number} x1\n * @param {Number} y1\n * @param {Number} x2\n * @param {Number} y2\n * @param {Number} radius\n */\nclass ArcTo {\n \tconstructor (x1, y1, x2, y2, radius) {\n\t\t/**\n\t\t * @type {Number}\n\t\t */\n\t \tthis.x1 = x1;\n\t\t/**\n\t\t * @type {Number}\n\t\t */\n\t\tthis.y1 = y1;\n\t\t/**\n\t\t * @type {Number}\n\t\t */\n\t \tthis.x2 = x2;\n\t\t/**\n\t\t * @type {Number}\n\t\t */\n\t\tthis.y2 = y2;\n\t\t/**\n\t\t * @type {Number}\n\t\t */\n\t \tthis.radius = radius;\n \t}\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n \texec (ctx) {\n \t\tctx.arcTo(this.x1, this.y1, this.x2, this.y2, this.radius);\n \t}\n}\n\n/**\n * @see {@link easeljs.Graphics#arc}\n * @alias easeljs.Graphics.Arc\n * @param {Number} x\n * @param {Number} y\n * @param {Number} radius\n * @param {Number} startAngle\n * @param {Number} endAngle\n * @param {Boolean} [anticlockwise=false]\n */\nclass Arc {\n \tconstructor (x, y, radius, startAngle, endAngle, anticlockwise = false) {\n\t\t/**\n\t\t * @type {Number}\n\t\t */\n\t \tthis.x = x;\n\t\t/**\n\t\t * @type {Number}\n\t\t */\n\t\tthis.y = y;\n\t\t/**\n\t\t * @type {Number}\n\t\t */\n\t \tthis.radius = radius;\n\t\t/**\n\t\t * @type {Number}\n\t\t */\n\t \tthis.startAngle = startAngle;\n\t\t/**\n\t\t * @type {Number}\n\t\t */\n\t\tthis.endAngle = endAngle;\n\t\t/**\n\t\t * @type {Boolean}\n\t\t */\n\t \tthis.anticlockwise = anticlockwise;\n \t}\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n \texec (ctx) {\n \t\tctx.arc(this.x, this.y, this.radius, this.startAngle, this.endAngle, this.anticlockwise);\n \t}\n}\n\n/**\n * @see {@link easeljs.Graphics#quadraticCurveTo}\n * @alias easeljs.Graphics.QuadraticCurveTo\n * @param {Number} cpx\n * @param {Number} cpy\n * @param {Number} x\n * @param {Number} y\n */\nclass QuadraticCurveTo {\n \tconstructor (cpx, cpy, x, y) {\n\t\t/**\n\t\t * @property cpx\n\t\t * @type Number\n\t\t */\n\t \tthis.cpx = cpx;\n\t\t/**\n\t\t * @property cpy\n\t\t * @type Number\n\t\t */\n\t\tthis.cpy = cpy;\n\t\t/**\n\t\t * @property x\n\t\t * @type Number\n\t\t */\n\t \tthis.x = x;\n\t\t/**\n\t\t * @property y\n\t\t * @type Number\n\t\t */\n\t\tthis.y = y;\n \t}\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n \texec (ctx) {\n \t\tctx.quadraticCurveTo(this.cpx, this.cpy, this.x, this.y);\n \t}\n}\n\n/**\n * @see {@link easeljs.Graphics#bezierCurveTo}\n * @alias easeljs.Graphics.BezierCurveTo\n * @param {Number} cp1x\n * @param {Number} cp1y\n * @param {Number} cp2x\n * @param {Number} cp2y\n * @param {Number} x\n * @param {Number} y\n */\nclass BezierCurveTo {\n \tconstructor (cp1x, cp1y, cp2x, cp2y, x, y) {\n\t\t/**\n\t\t * @type {Number}\n\t\t */\n\t \tthis.cp1x = cp1x;\n\t\t/**\n\t\t * @type {Number}\n\t\t */\n\t\tthis.cp1y = cp1y;\n\t\t/**\n\t\t * @type {Number}\n\t\t */\n\t \tthis.cp2x = cp2x;\n\t\t/**\n\t\t * @type {Number}\n\t\t */\n\t\tthis.cp2y = cp2y;\n\t\t/**\n\t\t * @type {Number}\n\t\t */\n\t \tthis.x = x;\n\t\t/**\n\t\t * @type {Number}\n\t\t */\n\t\tthis.y = y;\n \t}\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n \texec (ctx) {\n \t\tctx.bezierCurveTo(this.cp1x, this.cp1y, this.cp2x, this.cp2y, this.x, this.y);\n \t}\n}\n\n/**\n * @see {@link easeljs.Graphics#rect}\n * @alias easeljs.Graphics.Rect\n * @param {Number} x\n * @param {Number} y\n * @param {Number} w\n * @param {Number} h\n */\nclass Rect {\n \tconstructor (x, y, w, h) {\n\t\t/**\n\t\t * @type {Number}\n\t\t */\n\t \tthis.x = x;\n\t\t/**\n\t\t * @type {Number}\n\t\t */\n\t\tthis.y = y;\n\t\t/**\n\t\t * @type {Number}\n\t\t */\n\t \tthis.w = w;\n\t\t/**\n\t\t * @type {Number}\n\t\t */\n\t\tthis.h = h;\n \t}\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n \texec (ctx) {\n \t\tctx.rect(this.x, this.y, this.w, this.h);\n \t}\n}\n\n/**\n * @see {@link easeljs.Graphics#closePath}\n * @alias easeljs.Graphics.ClosePath\n */\nclass ClosePath {\n \tconstructor () { }\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n \texec (ctx) {\n \t\tctx.closePath();\n \t}\n}\n\n/**\n * @see {@link easeljs.Graphics#beginPath}\n * @alias easeljs.Graphics.BeginPath\n */\nclass BeginPath {\n \tconstructor () { }\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n \texec (ctx) {\n \t\tctx.beginPath();\n \t}\n}\n\n/**\n * @see {@link easeljs.Graphics#beginFill}\n * @alias easeljs.Graphics.Fill\n * @param {Object} style A valid Context2D fillStyle.\n * @param {Matrix2D} matrix\n */\nclass Fill {\n\tconstructor (style, matrix) {\n\t\t/**\n\t\t * A valid Context2D fillStyle.\n\t\t * @type {Object}\n\t\t */\n\t\tthis.style = style;\n\t\t/**\n\t\t * @type {easeljs.Matrix2D}\n\t\t */\n\t\tthis.matrix = matrix;\n\t\t/**\n\t\t * @type {Boolean}\n\t\t */\n\t\tthis.path = false;\n\t}\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\texec (ctx) {\n\t\tif (!this.style) { return; }\n\t\tctx.fillStyle = this.style;\n\t\tlet mtx = this.matrix;\n\t\tif (mtx) { ctx.save(); ctx.transform(mtx.a, mtx.b, mtx.c, mtx.d, mtx.tx, mtx.ty); }\n\t\tctx.fill();\n\t\tif (mtx) { ctx.restore(); }\n\t}\n\t/**\n\t * Creates a linear gradient style and assigns it to {@link easeljs.Graphics.Fill#style}.\n\t * @see {@link easeljs.Graphics#beginLinearGradientFill}\n\t * @param {Array<String>} colors\n\t * @param {Array<Number>} ratios\n\t * @param {Number} x0\n\t * @param {Number} y0\n\t * @param {Number} x1\n\t * @param {Number} y1\n\t * @return {easeljs.Graphics.Fill} Returns this Fill object for chaining or assignment.\n\t */\n\tlinearGradient (colors, ratios, x0, y0, x1, y1) {\n\t\tlet o = this.style = Graphics._ctx.createLinearGradient(x0, y0, x1, y1);\n\t\tconst l = colors.length;\n\t\tfor (let i = 0; i < l; i++) { o.addColorStop(ratios[i], colors[i]); }\n\t\to.props = {colors, ratios, x0, y0, x1, y1, type:"linear"};\n\t\treturn this;\n\t}\n\t/**\n\t * Creates a linear gradient style and assigns it to {@link easeljs.Graphics.Fill#style}.\n\t * @see {@link easeljs.Graphics#beginRadialGradientFill}\n\t * @param {Array<String>} colors\n\t * @param {Array<Number>} ratios\n\t * @param {Number} x0\n\t * @param {Number} y0\n\t * @param {Number} r0\n\t * @param {Number} x1\n\t * @param {Number} y1\n\t * @param {Number} r1\n\t * @return {easeljs.Graphics.Fill} Returns this Fill object for chaining or assignment.\n\t */\n\tradialGradient (colors, ratios, x0, y0, r0, x1, y1, r1) {\n\t\tlet o = this.style = Graphics._ctx.createRadialGradient(x0, y0, r0, x1, y1, r1);\n\t\tconst l = colors.length;\n\t\tfor (let i = 0; i < l; i++) { o.addColorStop(ratios[i], colors[i]); }\n\t\to.props = {colors, ratios, x0, y0, r0, x1, y1, r1, type: "radial"};\n\t\treturn this;\n\t}\n\t/**\n\t * Creates a linear gradient style and assigns it to {@link easeljs.Graphics.Fill#style}.\n\t * @see {@link easeljs.Graphics#beginBitmapFill}\n\t * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} image  Must be loaded prior to creating a bitmap fill, or the fill will be empty.\n\t * @param {String} [repetition=""] One of: repeat, repeat-x, repeat-y, or no-repeat.\n\t * @return {easeljs.Graphics.Fill} Returns this Fill object for chaining or assignment.\n\t */\n\tbitmap (image, repetition = "") {\n\t\tif (image.naturalWidth || image.getContext || image.readyState >= 2) {\n\t\t\tlet o = this.style = Graphics._ctx.createPattern(image, repetition);\n\t\t\to.props = {image, repetition, type: "bitmap"};\n\t\t}\n\t\treturn this;\n\t}\n}\n\n/**\n * @see {@link easeljs.Graphics#beginStroke}\n * @alias easeljs.Graphics.Stroke\n * @extends easeljs.Graphics.Fill\n * @param {Object} style A valid Context2D fillStyle.\n * @param {Boolean} ignoreScale\n */\nclass Stroke extends Fill {\n\tconstructor (style, ignoreScale) {\n\t\tsuper();\n\t\t/**\n\t\t * A valid Context2D strokeStyle.\n\t\t * @type {Object}\n\t\t */\n\t\tthis.style = style;\n\t\t/**\n\t\t * @type {Boolean}\n\t\t */\n\t\tthis.ignoreScale = ignoreScale;\n\t\t/**\n\t\t * @type {Boolean}\n\t\t */\n\t\tthis.path = false;\n\t}\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @override\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\texec (ctx) {\n\t\tif (!this.style) { return; }\n\t\tctx.strokeStyle = this.style;\n\t\tif (this.ignoreScale) { ctx.save(); ctx.setTransform(1,0,0,1,0,0); }\n\t\tctx.stroke();\n\t\tif (this.ignoreScale) { ctx.restore(); }\n\t}\n}\n\n/**\n * @see {@link easeljs.Graphics#setStrokeStyle}\n * @alias easeljs.Graphics.StrokeStyle\n * @param {Number} [width=1]\n * @param {String} [caps=butt]\n * @param {String} [joints=miter]\n * @param {Number} [miterLimit=10]\n * @param {Boolean} [ignoreScale=false]\n */\nclass StrokeStyle {\n\tconstructor (width=1, caps="butt", joints="miter", miterLimit=10, ignoreScale=false) {\n\t\t/**\n\t\t * @type {Number}\n\t\t */\n\t\tthis.width = width;\n\t\t/**\n\t\t * One of: butt, round, square\n\t\t * @type {String}\n\t\t */\n\t\tthis.caps = caps;\n\t\t/**\n\t\t * One of: round, bevel, miter\n\t\t * @type {String}\n\t\t */\n\t\tthis.joints = joints;\n\t\t/**\n\t\t * @type {Number}\n\t\t */\n\t\tthis.miterLimit = miterLimit;\n\t\t/**\n\t\t * @type {Boolean}\n\t\t */\n\t\tthis.ignoreScale = ignoreScale;\n\t\t/**\n\t\t * @type {Boolean}\n\t\t */\n\t\tthis.path = false;\n\t}\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\texec (ctx) {\n\t\tctx.lineWidth = this.width;\n\t\tctx.lineCap = (isNaN(this.caps) ? this.caps : Graphics._STROKE_CAPS_MAP[this.caps]);\n\t\tctx.lineJoin = (isNaN(this.joints) ? this.joints : Graphics._STROKE_JOINTS_MAP[this.joints]);\n\t\tctx.miterLimit = this.miterLimit;\n\t\tctx.ignoreScale = this.ignoreScale;\n\t}\n}\n\n/**\n * @see {@link easeljs.Graphics#setStrokeDash}\n * @alias easeljs.Graphics.StrokeDash\n * @param {Array} [segments=[]]\n * @param {Number} [offset=0]\n */\nclass StrokeDash {\n \tconstructor (segments=[], offset=0) {\n\t\t/**\n\t\t * @type {Array}\n\t\t */\n\t \tthis.segments = segments;\n\t\t/**\n\t\t * @type {Number}\n\t\t */\n\t \tthis.offset = offset;\n \t}\n\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n \texec (ctx) {\n \t\tif (ctx.setLineDash) { // feature detection.\n\t \t\tctx.setLineDash(this.segments);\n\t \t\tctx.lineDashOffset = this.offset;\n\t \t}\n \t}\n}\n\n/**\n * @see {@link easeljs.Graphics#drawRoundRectComplex}\n * @alias easeljs.Graphics.RoundRect\n * @param {Number} x\n * @param {Number} y\n * @param {Number} w\n * @param {Number} h\n * @param {Number} radiusTL\n * @param {Number} radiusTR\n * @param {Number} radiusBR\n * @param {Number} radiusBL\n */\nclass RoundRect {\n \tconstructor (x, y, w, h, radiusTL, radiusTR, radiusBR, radiusBL) {\n\t\t/**\n\t\t * @type {Number}\n\t\t */\n\t \tthis.x = x;\n\t\t/**\n\t\t * @type {Number}\n\t\t */\n\t\tthis.y = y;\n\t\t/**\n\t\t * @type {Number}\n\t\t */\n\t \tthis.w = w;\n\t\t/**\n\t\t * @type {Number}\n\t\t */\n\t\tthis.h = h;\n\t\t/**\n\t\t * @type {Number}\n\t\t */\n\t \tthis.radiusTL = radiusTL;\n\t\t/**\n\t\t * @type {Number}\n\t\t */\n\t\tthis.radiusTR = radiusTR;\n\t\t/**\n\t\t * @type {Number}\n\t\t */\n\t \tthis.radiusBR = radiusBR;\n\t\t/**\n\t\t * @type {Number}\n\t\t */\n\t\tthis.radiusBL = radiusBL;\n \t}\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n \texec (ctx) {\n \t\tlet max = (this.w<this.h?this.w:this.h)/2;\n\t \tlet mTL=0, mTR=0, mBR=0, mBL=0;\n\t \tlet x = this.x, y = this.y, w = this.w, h = this.h;\n\t \tlet rTL = this.radiusTL, rTR = this.radiusTR, rBR = this.radiusBR, rBL = this.radiusBL;\n\n\t \tif (rTL < 0) { rTL *= (mTL=-1); }\n\t \tif (rTL > max) { rTL = max; }\n\t \tif (rTR < 0) { rTR *= (mTR=-1); }\n\t \tif (rTR > max) { rTR = max; }\n\t \tif (rBR < 0) { rBR *= (mBR=-1); }\n\t \tif (rBR > max) { rBR = max; }\n\t \tif (rBL < 0) { rBL *= (mBL=-1); }\n\t \tif (rBL > max) { rBL = max; }\n\n\t \tctx.moveTo(x+w-rTR, y);\n\t \tctx.arcTo(x+w+rTR*mTR, y-rTR*mTR, x+w, y+rTR, rTR);\n\t \tctx.lineTo(x+w, y+h-rBR);\n\t \tctx.arcTo(x+w+rBR*mBR, y+h+rBR*mBR, x+w-rBR, y+h, rBR);\n\t \tctx.lineTo(x+rBL, y+h);\n\t \tctx.arcTo(x-rBL*mBL, y+h+rBL*mBL, x, y+h-rBL, rBL);\n\t \tctx.lineTo(x, y+rTL);\n\t \tctx.arcTo(x-rTL*mTL, y-rTL*mTL, x+rTL, y, rTL);\n\t \tctx.closePath();\n \t}\n}\n\n/**\n * @see {@link easeljs.Graphics#drawCircle}\n * @alias easeljs.Graphics.Circle\n * @param {Number} x\n * @param {Number} y\n * @param {Number} radius\n */\nclass Circle {\n \tconstructor (x, y, radius) {\n\t\t/**\n\t\t * @type {Number}\n\t\t */\n\t \tthis.x = x;\n\t\t/**\n\t\t * @type {Number}\n\t\t */\n\t\tthis.y = y;\n\t\t/**\n\t\t * @type {Number}\n\t\t */\n\t \tthis.radius = radius;\n \t}\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n \texec (ctx) {\n \t\tctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);\n \t}\n}\n\n/**\n * @see {@link easeljs.Graphics#drawEllipse}\n * @alias easeljs.Graphics.Ellipse\n * @param {Number} x\n * @param {Number} y\n * @param {Number} w\n * @param {Number} h\n */\nclass Ellipse {\n \tconstructor (x, y, w, h) {\n\t\t/**\n\t\t * @type {Number}\n\t\t */\n\t \tthis.x = x;\n\t\t/**\n\t\t * @type {Number}\n\t\t */\n\t\tthis.y = y;\n\t\t/**\n\t\t * @type {Number}\n\t\t */\n\t \tthis.w = w;\n\t\t/**\n\t\t * @type {Number}\n\t\t */\n\t\tthis.h = h;\n \t}\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n \texec (ctx) {\n \t\tlet x = this.x, y = this.y;\n\t \tlet w = this.w, h = this.h;\n\n\t \tlet k = 0.5522848;\n\t \tlet ox = (w / 2) * k;\n\t \tlet oy = (h / 2) * k;\n\t \tlet xe = x + w;\n\t \tlet ye = y + h;\n\t \tlet xm = x + w / 2;\n\t \tlet ym = y + h / 2;\n\n\t \tctx.moveTo(x, ym);\n\t \tctx.bezierCurveTo(x, ym-oy, xm-ox, y, xm, y);\n\t \tctx.bezierCurveTo(xm+ox, y, xe, ym-oy, xe, ym);\n\t \tctx.bezierCurveTo(xe, ym+oy, xm+ox, ye, xm, ye);\n\t \tctx.bezierCurveTo(xm-ox, ye, x, ym+oy, x, ym);\n \t}\n}\n\n/**\n *  @see {@link easeljs.Graphics#drawPolyStar}\n * @alias easeljs.Graphics.PolyStar\n * @param {Number} x\n * @param {Number} y\n * @param {Number} radius\n * @param {Number} sides\n * @param {Number} [pointSize=0]\n * @param {Number} [angle=0]\n */\nclass PolyStar {\n \tconstructor (x, y, radius, sides, pointSize=0, angle=0) {\n\t\t/**\n\t\t * @type {Number}\n\t\t */\n\t \tthis.x = x;\n\t\t/**\n\t\t * @type {Number}\n\t\t */\n\t\tthis.y = y;\n\t\t/**\n\t\t * @type {Number}\n\t\t */\n\t \tthis.radius = radius;\n\t\t/**\n\t\t * @type {Number}\n\t\t */\n\t \tthis.sides = sides;\n\t\t/**\n\t\t * @type {Number}\n\t\t */\n\t \tthis.pointSize = pointSize;\n\t\t/**\n\t\t * @type {Number}\n\t\t */\n\t \tthis.angle = angle;\n \t}\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n \texec (ctx) {\n \t\tlet x = this.x, y = this.y;\n\t \tlet radius = this.radius;\n\t \tlet angle = this.angle/180*Math.PI;\n\t \tlet sides = this.sides;\n\t \tlet ps = 1-this.pointSize;\n\t \tlet a = Math.PI/sides;\n\n\t \tctx.moveTo(x+Math.cos(angle)*radius, y+Math.sin(angle)*radius);\n\t \tfor (let i = 0; i < sides; i++) {\n\t \t\tangle += a;\n\t \t\tif (ps != 1) {\n\t \t\t\tctx.lineTo(x+Math.cos(angle)*radius*ps, y+Math.sin(angle)*radius*ps);\n\t \t\t}\n\t \t\tangle += a;\n\t \t\tctx.lineTo(x+Math.cos(angle)*radius, y+Math.sin(angle)*radius);\n\t \t}\n\t \tctx.closePath();\n \t}\n}\n\n/**\n * A reusable instance of {@link easeljs.Graphics.BeginPath} to avoid unnecessary instantiation.\n * @static\n * @readonly\n * @type {easeljs.Graphics.BeginPath}\n */\nGraphics.beginCmd = new BeginPath();\n/**\n * Map of Base64 characters to values. Used by {@link easeljs.Graphics#decodePath}.\n * @static\n * @readonly\n * @protected\n * @type {Object}\n */\nGraphics._BASE_64 = {"A":0,"B":1,"C":2,"D":3,"E":4,"F":5,"G":6,"H":7,"I":8,"J":9,"K":10,"L":11,"M":12,"N":13,"O":14,"P":15,"Q":16,"R":17,"S":18,"T":19,"U":20,"V":21,"W":22,"X":23,"Y":24,"Z":25,"a":26,"b":27,"c":28,"d":29,"e":30,"f":31,"g":32,"h":33,"i":34,"j":35,"k":36,"l":37,"m":38,"n":39,"o":40,"p":41,"q":42,"r":43,"s":44,"t":45,"u":46,"v":47,"w":48,"x":49,"y":50,"z":51,"0":52,"1":53,"2":54,"3":55,"4":56,"5":57,"6":58,"7":59,"8":60,"9":61,"+":62,"/":63};\n/**\n * Maps numeric values for the caps parameter of {@link easeljs.Graphics#setStrokeStyle} to\n * corresponding string values. This is primarily for use with the tiny API.<br />\n * The mappings are as follows:\n * <ul>\n *   <li>0 to "butt"</li>\n *   <li>1 to "round"</li>\n *   <li>2 to "square".</li>\n * </ul>\n *\n * @example <caption>Set line caps to "square"</caption>\n * graphics.ss(16, 2);\n *\n * @static\n * @readonly\n * @protected\n * @type {Array<String>}\n */\nGraphics._STROKE_CAPS_MAP = ["butt","round","square"];\n/**\n * Maps numeric values for the joints parameter of {@link easeljs.Graphics#setStrokeStyle} to\n * corresponding string values. This is primarily for use with the tiny API.<br />\n * The mappings are as follows:\n * <ul>\n *   <li>0 to "miter"</li>\n *   <li>1 to "round"</li>\n *   <li>2 to "bevel".</li>\n * </ul>\n *\n * @example <caption>Set the line joints to "bevel"</caption>\n * graphics.ss(16, 0, 2);\n *\n * @static\n * @readonly\n * @protected\n * @type {Array<String>}\n */\nGraphics._STROKE_JOINTS_MAP = ["miter", "round", "bevel"];\n/**\n * @static\n * @readonly\n * @protected\n * @type {CanvasRenderingContext2D}\n */\nGraphics._ctx = createCanvas().getContext("2d");\n\n// CONCATENATED MODULE: ./node_modules/@createjs/tweenjs/src/AbstractTween.js\n/**\n * @license AbstractTween\n * Visit http://createjs.com/ for documentation, updates and examples.\n *\n * Copyright (c) 2017 gskinner.com, inc.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the "Software"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n\n\n\n/**\n * Base class that both {@link tweenjs.Tween} and {@link tweenjs.Timeline} extend. Should not be instantiated directly.\n *\n * @memberof tweenjs\n * @extends core.EventDispatcher\n *\n * @param {Object} [props] The configuration properties to apply to this instance (ex. `{loop:-1, paused:true}`).\n * @param {Boolean} [props.useTicks=false] See the {@link tweenjs.AbstractTween#useTicks} property for more information.\n * @param {Boolean} [props.ignoreGlobalPause=false] See the {@link tweenjs.AbstractTween#ignoreGlobalPause} for more information.\n * @param {Number|Boolean} [props.loop=0] See the {@link tweenjs.AbstractTween#loop} for more information.\n * @param {Boolean} [props.reversed=false] See the {@link tweenjs.AbstractTween#reversed} for more information.\n * @param {Boolean} [props.bounce=false] See the {@link tweenjs.AbstractTween#bounce} for more information.\n * @param {Number} [props.timeScale=1] See the {@link tweenjs.AbstractTween#timeScale} for more information.\n * @param {Function} [props.onChange] Adds the specified function as a listener to the {@link tweenjs.AbstractTween#event:change} event.\n * @param {Function} [props.onComplete] Adds the specified function as a listener to the {@link tweenjs.AbstractTween#event:complete} event.\n */\nclass AbstractTween_AbstractTween extends events_EventDispatcher {\n\n  constructor (props) {\n    super();\n\n\t\t/**\n\t\t * Causes this tween to continue playing when a global pause is active. For example, if TweenJS is using {@link core.Ticker},\n\t\t * then setting this to false (the default) will cause this tween to be paused when `Ticker.setPaused(true)`\n\t\t * is called. See the {@link tweenjs.Tween#tick} method for more info. Can be set via the `props` parameter.\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.ignoreGlobalPause = false;\n\n\t\t/**\n\t\t * Indicates the number of times to loop. If set to -1, the tween will loop continuously.\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.loop = 0;\n\n\t\t/**\n\t\t * Uses ticks for all durations instead of milliseconds. This also changes the behaviour of some actions (such as `call`).\n\t\t * Changing this value on a running tween could have unexpected results.\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t * @readonly\n\t\t */\n\t\tthis.useTicks = false;\n\n\t\t/**\n\t\t * Causes the tween to play in reverse.\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.reversed = false;\n\n\t\t/**\n\t\t * Causes the tween to reverse direction at the end of each loop.\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.bounce = false;\n\n\t\t/**\n\t\t * Changes the rate at which the tween advances. For example, a `timeScale` value of `2` will double the\n\t\t * playback speed, a value of `0.5` would halve it.\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t */\n\t\tthis.timeScale = 1;\n\n\t\t/**\n\t\t * Indicates the duration of this tween in milliseconds (or ticks if `useTicks` is true), irrespective of `loops`.\n\t\t * This value is automatically updated as you modify the tween. Changing it directly could result in unexpected\n\t\t * behaviour.\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t * @readonly\n\t\t */\n\t\tthis.duration = 0;\n\n\t\t/**\n\t\t * The current normalized position of the tween. This will always be a value between 0 and `duration`.\n\t\t * Changing this property directly will have unexpected results, use {@link tweenjs.Tween#setPosition}.\n\t\t * @type {Object}\n\t\t * @default 0\n\t\t * @readonly\n\t\t */\n\t\tthis.position = 0;\n\n\t\t/**\n\t\t * The raw tween position. This value will be between `0` and `loops * duration` while the tween is active, or -1 before it activates.\n\t\t * @type {Number}\n\t\t * @default -1\n\t\t * @readonly\n\t\t */\n\t\tthis.rawPosition = -1;\n\n\t\t/**\n\t\t * @private\n\t\t * @default false\n\t\t */\n\t\tthis._paused = true;\n\n\t\t/**\n\t\t * @private\n\t\t * @type {Tween}\n\t\t * @default null\n\t\t */\n\t\tthis._next = null;\n\n\t\t/**\n\t\t * @private\n\t\t * @type {Tween}\n\t\t * @default null\n\t\t */\n\t\tthis._prev = null;\n\n\t\t/**\n\t\t * @private\n\t\t * @type {Object}\n\t\t * @default null\n\t\t */\n\t\tthis._parent = null;\n\n\t\t/**\n\t\t * @private\n\t\t * @type {Object}\n\t\t */\n\t\tthis._labels = null;\n\n\t\t/**\n\t\t * @private\n\t\t * @type {Object[]}\n\t\t */\n\t\tthis._labelList = null;\n\n\t\tif (props) {\n\t\t\tthis.useTicks = !!props.useTicks;\n\t\t\tthis.ignoreGlobalPause = !!props.ignoreGlobalPause;\n\t\t\tthis.loop = props.loop === true ? -1 : (props.loop||0);\n\t\t\tthis.reversed = !!props.reversed;\n\t\t\tthis.bounce = !!props.bounce;\n\t\t\tthis.timeScale = props.timeScale||1;\n\t\t\tprops.onChange && this.addEventListener("change", props.onChange);\n\t\t\tprops.onComplete && this.addEventListener("complete", props.onComplete);\n\t\t}\n\n\t\t// while `position` is shared, it needs to happen after ALL props are set, so it\'s handled in _init()\n  }\n\n\t/**\n\t * Returns a list of the labels defined on this tween sorted by position.\n\t * @type {Object[]}\n\t */\n\tget labels () {\n\t\tlet list = this._labelList;\n\t\tif (!list) {\n\t\t\tlist = this._labelList = [];\n\t\t\tlet labels = this._labels;\n\t\t\tfor (let label in labels) {\n\t\t\t\tlist.push({ label, position: labels[label] });\n\t\t\t}\n\t\t\tlist.sort((a, b) => a.position - b.position);\n\t\t}\n\t\treturn list;\n\t}\n\tset labels (labels) {\n\t\tthis._labels = labels;\n\t\tthis._labelList = null;\n\t}\n\n  /**\n   * Returns the name of the label on or immediately before the current position. For example, given a tween with\n   * two labels, "first" on frame index 4, and "second" on frame 8, currentLabel would return:\n   * <ul>\n   *   <li>null if the current position is 2.</li>\n   *   <li>"first" if the current position is 4.</li>\n   *   <li>"first" if the current position is 7.</li>\n   *   <li>"second" if the current position is 15.</li>\n   * </ul>\n   * @type {String}\n   * @readonly\n   */\n  get currentLabel () {\n    let labels = this.labels;\n    let pos = this.position;\n    for (let i = 0, l = labels.length; i < l; i++) { if (pos < labels[i].position) { break; } }\n    return (i === 0) ? null : labels[i-1].label;\n  }\n\n  /**\n   * Pauses or unpauses the tween. A paused tween is removed from the global registry and is eligible for garbage collection\n   * if no other references to it exist.\n   * @type {Boolean}\n\t */\n\tget paused () { return this._paused; }\n  set paused (paused) {\n    Tween_Tween._register(this, paused);\n\t\tthis._paused = paused;\n  }\n\n\t/**\n\t * Advances the tween by a specified amount.\t *\n\t * @param {Number} delta The amount to advance in milliseconds (or ticks if useTicks is true). Negative values are supported.\n\t * @param {Boolean} [ignoreActions=false] If true, actions will not be executed due to this change in position.\n\t */\n\tadvance (delta, ignoreActions = false) {\n\t\tthis.setPosition(this.rawPosition + delta * this.timeScale, ignoreActions);\n\t}\n\n\t/**\n\t * Advances the tween to a specified position.\n\t *\n\t * @emits tweenjs.AbstractTween#event:change\n\t * @emits tweenjs.AbstractTween#event:complete\n\t *\n\t * @param {Number} rawPosition The raw position to seek to in milliseconds (or ticks if useTicks is true).\n\t * @param {Boolean} [ignoreActions=false] If true, do not run any actions that would be triggered by this operation.\n\t * @param {Boolean} [jump=false] If true, only actions at the new position will be run. If false, actions between the old and new position are run.\n\t * @param {Function} [callback] Primarily for use with MovieClip, this callback is called after properties are updated, but before actions are run.\n\t */\n\tsetPosition (rawPosition, ignoreActions = false, jump = false, callback) {\n\t\tconst d = this.duration, loopCount = this.loop, prevRawPos = this.rawPosition;\n    let loop = 0, t = 0, end = false;\n\n\t\t// normalize position:\n\t\tif (rawPosition < 0) { rawPosition = 0; }\n\n\t\tif (d === 0) {\n\t\t\t// deal with 0 length tweens.\n\t\t\tend = true;\n\t\t\tif (prevRawPos !== -1) { return end; } // we can avoid doing anything else if we\'re already at 0.\n\t\t} else {\n\t\t\tloop = rawPosition / d | 0;\n\t\t\tt = rawPosition - loop * d;\n\n\t\t\tend = (loopCount !== -1 && rawPosition >= loopCount * d + d);\n\t\t\tif (end) { rawPosition = (t = d) * (loop = loopCount) + d; }\n\t\t\tif (rawPosition === prevRawPos) { return end; } // no need to update\n\n\t\t\t// current loop is reversed\n\t\t\tif (!this.reversed !== !(this.bounce && loop % 2)) { t = d - t; }\n\t\t}\n\n\t\t// set this in advance in case an action modifies position:\n\t\tthis.position = t;\n\t\tthis.rawPosition = rawPosition;\n\n\t\tthis._updatePosition(jump, end);\n\t\tif (end) { this.paused = true; }\n\n\t\tcallback && callback(this);\n\n\t\tif (!ignoreActions) { this._runActions(prevRawPos, rawPosition, jump, !jump && prevRawPos === -1); }\n\n\t\tthis.dispatchEvent("change");\n\t\tif (end) { this.dispatchEvent("complete"); }\n\t}\n\n\t/**\n\t * Calculates a normalized position based on a raw position.\n\t *\n\t * @example\n\t * // given a tween with a duration of 3000ms set to loop:\n\t * console.log(myTween.calculatePosition(3700); // 700\n\t *\n\t * @param {Number} rawPosition A raw position.\n\t */\n\tcalculatePosition (rawPosition) {\n\t\t// largely duplicated from setPosition, but necessary to avoid having to instantiate generic objects to pass values (end, loop, position) back.\n\t\tconst d = this.duration, loopCount = this.loop;\n    let loop = 0, t = 0;\n\n\t\tif (d === 0) { return 0; }\n\t\tif (loopCount !== -1 && rawPosition >= loopCount * d + d) {\n      t = d;\n      loop = loopCount\n    } else if (rawPosition < 0) {\n      t = 0;\n    } else {\n      loop = rawPosition / d | 0;\n      t = rawPosition - loop * d;\n    }\n\n\t\treturn (!this.reversed !== !(this.bounce && loop % 2)) ? d - t : t;\n\t}\n\n\t/**\n\t * Adds a label that can be used with {@link tweenjs.Timeline#gotoAndPlay}/{@link tweenjs.Timeline#gotoAndStop}.\n\t *\n\t * @param {String} label The label name.\n\t * @param {Number} position The position this label represents.\n\t */\n\taddLabel (label, position) {\n\t\tif (!this._labels) { this._labels = {}; }\n\t\tthis._labels[label] = position;\n\t\tconst list = this._labelList;\n\t\tif (list) {\n\t\t\tfor (let i = 0, l = list.length; i < l; i++) { if (position < list[i].position) { break; } }\n\t\t\tlist.splice(i, 0, { label, position });\n\t\t}\n\t}\n\n\t/**\n\t * Unpauses this timeline and jumps to the specified position or label.\n\t *\n\t * @param {String|Number} positionOrLabel The position in milliseconds (or ticks if `useTicks` is `true`)\n\t * or label to jump to.\n\t */\n\tgotoAndPlay (positionOrLabel) {\n\t\tthis.paused = false;\n\t\tthis._goto(positionOrLabel);\n\t}\n\n\t/**\n\t * Pauses this timeline and jumps to the specified position or label.\n\t *\n\t * @param {String|Number} positionOrLabel The position in milliseconds (or ticks if `useTicks` is `true`) or label\n\t * to jump to.\n\t */\n\tgotoAndStop (positionOrLabel) {\n\t\tthis.paused = true;\n\t\tthis._goto(positionOrLabel);\n\t}\n\n\t/**\n\t * If a numeric position is passed, it is returned unchanged. If a string is passed, the position of the\n\t * corresponding frame label will be returned, or `null` if a matching label is not defined.\n\t *\n\t * @param {String|Number} positionOrLabel A numeric position value or label String.\n\t */\n\tresolve (positionOrLabel) {\n\t\tconst pos = Number(positionOrLabel);\n    return isNaN(pos) ? this._labels && this._labels[positionOrLabel] : pos;\n\t}\n\n\t/**\n\t * Returns a string representation of this object.\n\t *\n\t * @return {String} a string representation of the instance.\n\t */\n\ttoString () {\n\t\treturn `[${this.constructor.name}${this.name ? ` (name=${this.name})` : ""}]`;\n\t}\n\n\t/**\n\t * @throws AbstractTween cannot be cloned.\n\t */\n\tclone () {\n\t\tthrow "AbstractTween cannot be cloned.";\n\t}\n\n\t/**\n\t * Shared logic that executes at the end of the subclass constructor.\n\t *\n\t * @private\n\t *\n\t * @param {Object} [props]\n\t */\n\t_init (props) {\n\t\tif (!props || !props.paused) { this.paused = false; }\n\t\tif (props && props.position != null) { this.setPosition(props.position); }\n\t}\n\n\t/**\n\t * @private\n\t * @param {String|Number} positionOrLabel\n\t */\n\t_goto (positionOrLabel) {\n\t\tconst pos = this.resolve(positionOrLabel);\n\t\tif (pos != null) { this.setPosition(pos, false, true); }\n\t}\n\n\t/**\n   * Runs actions between startPos & endPos. Separated to support action deferral.\n   *\n\t * @private\n\t *\n\t * @param {Number} startRawPos\n\t * @param {Number} endRawPos\n\t * @param {Boolean} jump\n\t * @param {Boolean} includeStart\n\t */\n\t_runActions (startRawPos, endRawPos, jump, includeStart) {\n\t  // console.log(this.passive === false ? " > Tween" : "Timeline", "run", startRawPos, endRawPos, jump, includeStart);\n\t\t// if we don\'t have any actions, and we\'re not a Timeline, then return:\n\t\t// TODO: a cleaner way to handle this would be to override this method in Tween, but I\'m not sure it\'s worth the overhead.\n\t\tif (!this._actionHead && !this.tweens) { return; }\n\n\t\tconst d = this.duration, loopCount = this.loop;\n    let reversed = this.reversed, bounce = this.bounce;\n\t\tlet loop0, loop1, t0, t1;\n\n\t\tif (d === 0) {\n\t\t\t// deal with 0 length tweens:\n\t\t\tloop0 = loop1 = t0 = t1 = 0;\n\t\t\treversed = bounce = false;\n\t\t} else {\n\t\t\tloop0 = startRawPos / d | 0;\n\t\t\tloop1 = endRawPos / d | 0;\n\t\t\tt0 = startRawPos - loop0 * d;\n\t\t\tt1 = endRawPos - loop1 * d;\n\t\t}\n\n\t\t// catch positions that are past the end:\n\t\tif (loopCount !== -1) {\n\t\t\tif (loop1 > loopCount) { t1 = d; loop1 = loopCount; }\n\t\t\tif (loop0 > loopCount) { t0 = d; loop0 = loopCount; }\n\t\t}\n\n\t\t// special cases:\n\t\tif (jump) { return this._runActionsRange(t1, t1, jump, includeStart); } // jump.\n    else if (loop0 === loop1 && t0 === t1 && !jump && !includeStart) { return; } // no actions if the position is identical and we aren\'t including the start\n\t\telse if (loop0 === -1) { loop0 = t0 = 0; } // correct the -1 value for first advance, important with useTicks.\n\n\t\tconst dir = (startRawPos <= endRawPos);\n\t\tlet loop = loop0;\n\t\tdo {\n\t\t\tlet rev = !reversed !== !(bounce && loop % 2);\n\t\t\tlet start = (loop === loop0) ? t0 : dir ? 0 : d;\n\t\t\tlet end = (loop === loop1) ? t1 : dir ? d : 0;\n\n\t\t\tif (rev) {\n\t\t\t\tstart = d - start;\n\t\t\t\tend = d - end;\n\t\t\t}\n\n\t\t\tif (bounce && loop !== loop0 && start === end) { /* bounced onto the same time/frame, don\'t re-execute end actions */ }\n\t\t\telse if (this._runActionsRange(start, end, jump, includeStart || (loop !== loop0 && !bounce))) { return true; }\n\n\t\t\tincludeStart = false;\n\t\t} while ((dir && ++loop <= loop1) || (!dir && --loop >= loop1));\n\t}\n\n  /**\n   * @private\n   * @abstract\n   * @throws Must be overridden by a subclass.\n\t */\n\t_runActionsRange (startPos, endPos, jump, includeStart) {\n\t\tthrow "_runActionsRange is abstract and must be overridden by a subclass.";\n\t}\n\n  /**\n\t * @private\n   * @abstract\n   * @throws Must be overridden by a subclass.\n\t */\n\t_updatePosition (jump, end) {\n    throw "_updatePosition is abstract and must be overridden by a subclass.";\n\t}\n\n}\n\n/**\n * Dispatched whenever the tween\'s position changes. It occurs after all tweened properties are updated and actions\n * are executed.\n * @event tweenjs.AbstractTween#change\n */\n/**\n * Dispatched when the tween reaches its end and has paused itself. This does not fire until all loops are complete;\n * tweens that loop continuously will never fire a complete event.\n * @event tweenjs.AbstractTween#complete\n */\n\n// CONCATENATED MODULE: ./node_modules/@createjs/tweenjs/src/Ease.js\n/**\n * @license Ease\n * Visit http://createjs.com/ for documentation, updates and examples.\n *\n * Copyright (c) 2017 gskinner.com, inc.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the "Software"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * The Ease class provides a collection of easing functions for use with TweenJS. It does not use the standard 4 param\n * easing signature. Instead it uses a single param which indicates the current linear ratio (0 to 1) of the tween.\n *\n * Most methods on Ease can be passed directly as easing functions:\n *\n *      Tween.get(target).to({x:100}, 500, Ease.linear);\n *\n * However, methods beginning with "get" will return an easing function based on parameter values:\n *\n *      Tween.get(target).to({y:200}, 500, Ease.getPowIn(2.2));\n *\n * Please see the <a href="http://www.createjs.com/Demos/TweenJS/Tween_SparkTable">spark table demo</a> for an\n * overview of the different ease types on <a href="http://tweenjs.com">TweenJS.com</a>.\n *\n * <em>Equations derived from work by Robert Penner.</em>\n *\n * @memberof tweenjs\n * @module Ease\n */\n\n/**\n * @param {Number} t\n * @return {Number}\n */\nfunction linear (t) {\n\treturn t;\n}\n\n/**\n * Mimics the simple -100 to 100 easing in Flash Pro.\n * @param {Number} amount A value from -1 (ease in) to 1 (ease out) indicating the strength and direction of the ease.\n * @return {Function}\n */\nfunction get (amount) {\n\tif (amount < -1) { amount = -1; } else if (amount > 1) { amount = 1; }\n\treturn function (t) {\n\t\tif (amount == 0) { return t; }\n\t\tif (amount < 0) { return t * (t * -amount + 1 + amount); }\n\t\treturn t * ((2 - t) * amount + (1 - amount));\n\t};\n}\n\n/**\n * Configurable exponential ease.\n * @param {Number} pow The exponent to use (ex. 3 would return a cubic ease).\n * @return {Function}\n */\nfunction getPowIn (pow) {\n\treturn function (t) {\n\t\treturn Math.pow(t, pow);\n\t};\n}\n\n/**\n * Configurable exponential ease.\n * @param {Number} pow The exponent to use (ex. 3 would return a cubic ease).\n * @return {Function}\n */\nfunction getPowOut (pow) {\n\treturn function (t) {\n\t\treturn 1 - Math.pow(1 - t, pow);\n\t};\n}\n\n/**\n * Configurable exponential ease.\n * @param {Number} pow The exponent to use (ex. 3 would return a cubic ease).\n * @return {Function}\n */\nfunction getPowInOut (pow) {\n\treturn function (t) {\n\t\tif ((t *= 2) < 1) return 0.5 * Math.pow(t, pow);\n\t\treturn 1 - 0.5 * Math.abs(Math.pow(2 - t, pow));\n\t};\n}\n\n/**\n * @param {Number} t\n * @return {Number}\n */\nfunction sineIn (t) {\n\treturn 1 - Math.cos(t * Math.PI / 2);\n}\n\n/**\n * @param {Number} t\n * @return {Number}\n */\nfunction sineOut (t) {\n\treturn Math.sin(t * Math.PI / 2);\n}\n\n/**\n * @param {Number} t\n * @return {Number}\n */\nfunction sineInOut (t) {\n\treturn -0.5 * (Math.cos(Math.PI * t) - 1);\n}\n\n/**\n * Configurable "back in" ease.\n * @param {Number} amount The strength of the ease.\n * @return {Function}\n */\nfunction getBackIn (amount) {\n\treturn function (t) {\n\t\treturn t * t * ((amount + 1) * t - amount);\n\t};\n}\n\n/**\n * Configurable "back out" ease.\n * @param {Number} amount The strength of the ease.\n * @return {Function}\n */\nfunction getBackOut (amount) {\n\treturn function (t) {\n\t\treturn (--t * t * ((amount + 1) * t + amount) + 1);\n\t};\n}\n\n/**\n * Configurable "back in out" ease.\n * @param {Number} amount The strength of the ease.\n * @return {Function}\n */\nfunction getBackInOut (amount) {\n\tamount *= 1.525;\n\treturn function (t) {\n\t\tif ((t *= 2) < 1) return 0.5 * (t * t * ((amount + 1) * t - amount));\n\t\treturn 0.5 * ((t -= 2) * t * ((amount + 1) * t + amount) + 2);\n\t};\n}\n\n/**\n * @param {Number} t\n * @return {Number}\n */\nfunction circIn (t) {\n\treturn -(Math.sqrt(1 - t * t) - 1);\n}\n\n/**\n * @param {Number} t\n * @return {Number}\n */\nfunction circOut (t) {\n\treturn Math.sqrt(1 - --t * t);\n}\n\n/**\n * @param {Number} t\n * @return {Number}\n */\nfunction circInOut (t) {\n\tif ((t *= 2) < 1) return -0.5 * (Math.sqrt(1 - t * t) - 1);\n\treturn 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);\n}\n\n/**\n * @param {Number} t\n * @return {Number}\n */\nfunction bounceIn (t) {\n\treturn 1 - Ease.bounceOut(1 - t);\n}\n\n/**\n * @param {Number} t\n * @return {Number}\n */\nfunction bounceOut (t) {\n\tif (t < 1 / 2.75) {\n\t\treturn 7.5625 * t * t;\n\t} else if (t < 2 / 2.75) {\n\t\treturn 7.5625 * (t -= 1.5 / 2.75) * t + 0.75;\n\t} else if (t < 2.5 / 2.75) {\n\t\treturn 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375;\n\t} else {\n\t\treturn 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;\n\t}\n}\n\n/**\n * @param {Number} t\n * @return {Number}\n */\nfunction bounceInOut (t) {\n\tif (t < 0.5) return Ease.bounceIn(t * 2) * 0.5;\n\treturn Ease.bounceOut(t * 2 - 1) * 0.5 + 0.5;\n}\n\n/**\n * Configurable elastic ease.\n * @param {Number} amplitude\n * @param {Number} period\n * @return {Function}\n */\nfunction getElasticIn (amplitude, period) {\n\tlet pi2 = Math.PI * 2;\n\treturn function (t) {\n\t\tif (t === 0 || t === 1) return t;\n\t\tlet s = period / pi2 * Math.asin(1 / amplitude);\n\t\treturn -(amplitude * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * pi2 / period));\n\t};\n}\n\n/**\n * Configurable elastic ease.\n * @param {Number} amplitude\n * @param {Number} period\n * @return {Function}\n */\nfunction getElasticOut (amplitude, period) {\n\tlet pi2 = Math.PI * 2;\n\treturn function (t) {\n\t\tif (t === 0 || t === 1) return t;\n\t\tlet s = period / pi2 * Math.asin(1 / amplitude);\n\t\treturn amplitude * Math.pow(2, -10 * t) * Math.sin((t - s) * pi2 / period) + 1;\n\t};\n}\n\n/**\n * Configurable elastic ease.\n * @param {Number} amplitude\n * @param {Number} period\n * @return {Function}\n */\nfunction getElasticInOut (amplitude, period) {\n\tlet pi2 = Math.PI * 2;\n\treturn function (t) {\n\t\tlet s = period / pi2 * Math.asin(1 / amplitude);\n\t\tif ((t *= 2) < 1) return -0.5 * (amplitude * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * pi2 / period));\n\t\treturn amplitude * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - s) * pi2 / period) * 0.5 + 1;\n\t};\n}\n\n/**\n * Identical to linear.\n * @param {Number} t\n * @return {Number}\n */\nconst none = linear;\n/**\n * @param {Number} t\n * @return {Number}\n */\nconst quadIn = getPowIn(2);\n/**\n * @param {Number} t\n * @return {Number}\n */\nconst quadOut = getPowOut(2);\n/**\n * @param {Number} t\n * @return {Number}\n */\nconst quadInOut = getPowInOut(2);\n/**\n * @param {Number} t\n * @return {Number}\n */\nconst cubicIn = getPowIn(3);\n/**\n * @param {Number} t\n * @return {Number}\n */\nconst cubicOut = getPowOut(3);\n/**\n * @param {Number} t\n * @return {Number}\n */\nconst cubicInOut = getPowInOut(3);\n/**\n * @param {Number} t\n * @return {Number}\n */\nconst quartIn = getPowIn(4);\n/**\n * @param {Number} t\n * @return {Number}\n */\nconst quartOut = getPowOut(4);\n/**\n * @param {Number} t\n * @return {Number}\n */\nconst quartInOut = getPowInOut(4);\n/**\n * @param {Number} t\n * @return {Number}\n */\nconst quintIn = getPowIn(5);\n/**\n * @param {Number} t\n * @return {Number}\n */\nconst quintOut = getPowOut(5);\n/**\n * @param {Number} t\n * @return {Number}\n */\nconst quintInOut = getPowInOut(5);\n/**\n * @param {Number} t\n * @return {Number}\n */\nconst backIn = getBackIn(1.7);\n/**\n * @param {Number} t\n * @return {Number}\n */\nconst backOut = getBackOut(1.7);\n/**\n * @param {Number} t\n * @return {Number}\n */\nconst backInOut = getBackInOut(1.7);\n/**\n * @param {Number} t\n * @return {Number}\n */\nconst elasticIn = getElasticIn(1, 0.3);\n/**\n * @param {Number} t\n * @return {Number}\n */\nconst elasticOut = getElasticOut(1, 0.3);\n/**\n * @param {Number} t\n * @return {Number}\n */\nconst elasticInOut = getElasticInOut(1, 0.3 * 1.5);\n\n// CONCATENATED MODULE: ./node_modules/@createjs/tweenjs/src/Tween.js\n/**\n * @license Tween\n * Visit http://createjs.com/ for documentation, updates and examples.\n *\n * Copyright (c) 2017 gskinner.com, inc.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the "Software"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n\n\n\n\n/**\n * Tweens properties for a single target. Methods can be chained to create complex animation sequences:\n *\n * @example\n * Tween.get(target)\n *   .wait(500)\n *   .to({ alpha: 0, visible: false }, 1000)\n *   .call(handleComplete);\n *\n * Multiple tweens can share a target, however if they affect the same properties there could be unexpected\n * behaviour. To stop all tweens on an object, use {@link tweenjs.Tween#removeTweens} or pass `override:true`\n * in the props argument.\n *\n * \tcreatejs.Tween.get(target, {override:true}).to({x:100});\n *\n * Subscribe to the {@link tweenjs.Tween#event:change} event to be notified when the tween position changes.\n *\n * \tcreatejs.Tween.get(target, {override:true}).to({x:100}).addEventListener("change", handleChange);\n * \tfunction handleChange(event) {\n * \t\t// The tween changed.\n * \t}\n *\n * @see {@link tweenjs.Tween.get}\n *\n * @memberof tweenjs\n * @extends tweenjs.AbstractTween\n *\n * @param {Object} target The target object that will have its properties tweened.\n * @param {Object} [props] The configuration properties to apply to this instance (ex. `{loop:-1, paused:true}`).\n * @param {Boolean} [props.useTicks]\n * @param {Boolean} [props.ignoreGlobalPause]\n * @param {Number|Boolean} [props.loop]\n * @param {Boolean} [props.reversed]\n * @param {Boolean} [props.bounce]\n * @param {Number} [props.timeScale]\n * @param {Object} [props.pluginData]\n * @param {Boolean} [props.paused]\n * @param {*} [props.position] indicates the initial position for this tween\n * @param {*} [props.onChange] adds the specified function as a listener to the `change` event\n * @param {*} [props.onComplete] adds the specified function as a listener to the `complete` event\n * @param {*} [props.override] if true, removes all existing tweens for the target\n */\nclass Tween_Tween extends AbstractTween_AbstractTween {\n\n\tconstructor (target, props) {\n\t\tsuper(props);\n\n\t\t/**\n\t\t * Allows you to specify data that will be used by installed plugins. Each plugin uses this differently, but in general\n\t\t * you specify data by assigning it to a property of `pluginData` with the same name as the plugin.\n\t\t * Note that in many cases, this data is used as soon as the plugin initializes itself for the tween.\n\t\t * As such, this data should be set before the first `to` call in most cases.\n\t\t *\n\t\t * Some plugins also store working data in this object, usually in a property named `_PluginClassName`.\n\t\t * See the documentation for individual plugins for more details.\n\t\t *\n\t\t * @example\n\t\t * myTween.pluginData.SmartRotation = data;\n\t\t * myTween.pluginData.SmartRotation_disabled = true;\n\t\t *\n\t\t *\n\t\t * @default null\n\t\t * @type {Object}\n\t\t */\n\t\tthis.pluginData = null;\n\n\t\t/**\n\t\t * The target of this tween. This is the object on which the tweened properties will be changed.\n\t\t * @type {Object}\n\t\t * @readonly\n\t\t */\n\t\tthis.target = target;\n\n\t\t/**\n\t\t * Indicates the tween\'s current position is within a passive wait.\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t * @readonly\n\t\t */\n\t\tthis.passive = false;\n\n\t\t/**\n\t\t * @private\n\t\t * @type {TweenStep}\n\t\t */\n\t\tthis._stepHead = new TweenStep(null, 0, 0, {}, null, true);\n\n\t\t/**\n\t\t * @private\n\t\t * @type {TweenStep}\n\t\t */\n\t\tthis._stepTail = this._stepHead;\n\n\t\t/**\n\t\t * The position within the current step. Used by MovieClip.\n\t\t * @private\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis._stepPosition = 0;\n\n\t\t/**\n\t\t * @private\n\t\t * @type {TweenAction}\n\t\t * @default null\n\t\t */\n\t\tthis._actionHead = null;\n\n\t\t/**\n\t\t * @private\n\t\t * @type {TweenAction}\n\t\t * @default null\n\t\t */\n\t\tthis._actionTail = null;\n\n\t\t/**\n\t\t * Plugins added to this tween instance.\n\t\t * @private\n\t\t * @type {Object[]}\n\t\t * @default null\n\t\t */\n\t\tthis._plugins = null;\n\n\t\t/**\n\t\t * Hash for quickly looking up added plugins. Null until a plugin is added.\n\t\t * @private\n\t\t * @type {Object}\n\t\t * @default null\n\t\t */\n\t\tthis._pluginIds = null;\n\n\n\t\t/**\n\t\t * Used by plugins to inject new properties.\n\t\t * @private\n\t\t * @type {Object}\n\t\t * @default null\n\t\t */\n\t\tthis._injected = null;\n\n\t\tif (props) {\n\t\t\tthis.pluginData = props.pluginData;\n\t\t\tif (props.override) { Tween_Tween.removeTweens(target); }\n\t\t}\n\t\tif (!this.pluginData) { this.pluginData = {}; }\n\n\t\tthis._init(props);\n\t}\n\n\t/**\n\t * Returns a new tween instance. This is functionally identical to using `new Tween(...)`, but may look cleaner\n\t * with the chained syntax of TweenJS.\n\t *\n\t * @static\n\t * @example\n\t * let tween = Tween.get(target).to({ x: 100 }, 500);\n\t * // equivalent to:\n\t * let tween = new Tween(target).to({ x: 100 }, 500);\n\t *\n\t * @param {Object} target The target object that will have its properties tweened.\n\t * @param {Object} [props] The configuration properties to apply to this instance (ex. `{loop:-1, paused:true}`).\n\t * @param {Boolean} [props.useTicks]\n\t * @param {Boolean} [props.ignoreGlobalPause]\n\t * @param {Number|Boolean} [props.loop]\n\t * @param {Boolean} [props.reversed]\n\t * @param {Boolean} [props.bounce]\n\t * @param {Number} [props.timeScale]\n\t * @param {Object} [props.pluginData]\n\t * @param {Boolean} [props.paused]\n\t * @param {*} [props.position] indicates the initial position for this tween\n\t * @param {*} [props.onChange] adds the specified function as a listener to the `change` event\n\t * @param {*} [props.onComplete] adds the specified function as a listener to the `complete` event\n\t * @param {*} [props.override] if true, removes all existing tweens for the target\n\t * @return {Tween} A reference to the created tween.\n\t */\n\tstatic get (target, props) {\n\t\treturn new Tween_Tween(target, props);\n\t}\n\n\t/**\n\t * Advances all tweens. This typically uses the {{#crossLink "Ticker"}}{{/crossLink}} class, but you can call it\n\t * manually if you prefer to use your own "heartbeat" implementation.\n\t *\n\t * @static\n\t *\n\t * @param {Number} delta The change in time in milliseconds since the last tick. Required unless all tweens have\n\t * `useTicks` set to true.\n\t * @param {Boolean} paused Indicates whether a global pause is in effect. Tweens with {@link tweenjs.Tween#ignoreGlobalPause}\n\t * will ignore this, but all others will pause if this is `true`.\n\t */\n\tstatic tick (delta, paused) {\n\t\tlet tween = Tween_Tween._tweenHead;\n\t\twhile (tween) {\n\t\t\tlet next = tween._next; // in case it completes and wipes its _next property\n\t\t\tif ((paused && !tween.ignoreGlobalPause) || tween._paused) { /* paused */ }\n\t\t\telse { tween.advance(tween.useTicks ? 1: delta); }\n\t\t\ttween = next;\n\t\t}\n\t}\n\n\t/**\n\t * Handle events that result from Tween being used as an event handler. This is included to allow Tween to handle\n\t * {@link tweenjs.Ticker#event:tick} events from the {@link tweenjs.Ticker}.\n\t * No other events are handled in Tween.\n\t *\n\t * @static\n\t * @since 0.4.2\n\t *\n\t * @param {Object} event An event object passed in by the {@link core.EventDispatcher}. Will\n\t * usually be of type "tick".\n\t */\n\tstatic handleEvent (event) {\n\t\tif (event.type === "tick") {\n\t\t\tthis.tick(event.delta, event.paused);\n\t\t}\n\t}\n\n\t/**\n\t * Removes all existing tweens for a target. This is called automatically by new tweens if the `override`\n\t * property is `true`.\n\t *\n\t * @static\n\t *\n\t * @param {Object} target The target object to remove existing tweens from.=\n\t */\n\tstatic removeTweens (target) {\n\t\tif (!target.tweenjs_count) { return; }\n\t\tlet tween = Tween_Tween._tweenHead;\n\t\twhile (tween) {\n\t\t\tlet next = tween._next;\n\t\t\tif (tween.target === target) { tween.paused = true; }\n\t\t\ttween = next;\n\t\t}\n\t\ttarget.tweenjs_count = 0;\n\t}\n\n\t/**\n\t * Stop and remove all existing tweens.\n\t *\n\t * @static\n\t * @since 0.4.1\n\t */\n\tstatic removeAllTweens () {\n\t\tlet tween = Tween_Tween._tweenHead;\n\t\twhile (tween) {\n\t\t\tlet next = tween._next;\n\t\t\ttween._paused = true;\n\t\t\ttween.target && (tween.target.tweenjs_count = 0);\n\t\t\ttween._next = tween._prev = null;\n\t\t\ttween = next;\n\t\t}\n\t\tTween_Tween._tweenHead = Tween_Tween._tweenTail = null;\n\t}\n\n\t/**\n\t * Indicates whether there are any active tweens on the target object (if specified) or in general.\n\t *\n\t * @static\n\t *\n\t * @param {Object} [target] The target to check for active tweens. If not specified, the return value will indicate\n\t * if there are any active tweens on any target.\n\t * @return {Boolean} Indicates if there are active tweens.\n\t */\n\tstatic hasActiveTweens (target) {\n\t\tif (target) { return !!target.tweenjs_count; }\n\t\treturn !!Tween_Tween._tweenHead;\n\t}\n\n\t/**\n\t * Installs a plugin, which can modify how certain properties are handled when tweened. See the {{#crossLink "SamplePlugin"}}{{/crossLink}}\n\t * for an example of how to write TweenJS plugins. Plugins should generally be installed via their own `install` method, in order to provide\n\t * the plugin with an opportunity to configure itself.\n\t *\n\t * @static\n\t *\n\t * @param {Object} plugin The plugin to install\n\t * @param {Object} props The props to pass to the plugin\n\t */\n\tstatic installPlugin (plugin, props) {\n\t\tplugin.install(props);\n\t\tconst priority = (plugin.priority = plugin.priority || 0), arr = (Tween_Tween._plugins = Tween_Tween._plugins || []);\n\t\tfor (let i = 0, l = arr.length; i < l; i++) {\n\t\t\tif (priority < arr[i].priority) { break; }\n\t\t}\n\t\tarr.splice(i, 0, plugin);\n\t}\n\n\t/**\n\t * Registers or unregisters a tween with the ticking system.\n\t *\n\t * @private\n\t * @static\n\t *\n\t * @param {Tween} tween The tween instance to register or unregister.\n\t * @param {Boolean} paused If `false`, the tween is registered. If `true` the tween is unregistered.\n\t */\n\tstatic _register (tween, paused) {\n\t\tconst target = tween.target;\n\t\tif (!paused && tween._paused) {\n\t\t\t// TODO: this approach might fail if a dev is using sealed objects\n\t\t\tif (target) { target.tweenjs_count = target.tweenjs_count ? target.tweenjs_count + 1 : 1; }\n\t\t\tlet tail = Tween_Tween._tweenTail;\n\t\t\tif (!tail) { Tween_Tween._tweenHead = Tween_Tween._tweenTail = tween; }\n\t\t\telse {\n\t\t\t\tTween_Tween._tweenTail = tail._next = tween;\n\t\t\t\ttween._prev = tail;\n\t\t\t}\n\t\t\tif (!Tween_Tween._inited) { utils_Ticker.addEventListener("tick", Tween_Tween); Tween_Tween._inited = true; }\n\t\t} else if (paused && !tween._paused) {\n\t\t\tif (target) { target.tweenjs_count--; }\n\t\t\tlet next = tween._next, prev = tween._prev;\n\n\t\t\tif (next) { next._prev = prev; }\n\t\t\telse { Tween_Tween._tweenTail = prev; } // was tail\n\t\t\tif (prev) { prev._next = next; }\n\t\t\telse { Tween_Tween._tweenHead = next; } // was head.\n\n\t\t\ttween._next = tween._prev = null;\n\t\t}\n\t}\n\n\t/**\n\t * Adds a wait (essentially an empty tween).\n\t *\n\t * @example\n\t * // This tween will wait 1s before alpha is faded to 0.\n\t * Tween.get(target)\n\t *   .wait(1000)\n\t *   .to({ alpha: 0 }, 1000);\n\t *\n\t * @param {Number} duration The duration of the wait in milliseconds (or in ticks if `useTicks` is true).\n\t * @param {Boolean} [passive=false] Tween properties will not be updated during a passive wait. This\n\t * is mostly useful for use with {@link tweenjs.Timeline} instances that contain multiple tweens\n\t * affecting the same target at different times.\n\t * @chainable\n\t */\n\twait (duration, passive = false) {\n\t\tif (duration > 0) { this._addStep(+duration, this._stepTail.props, null, passive); }\n\t\treturn this;\n\t}\n\n\t/**\n\t * Adds a tween from the current values to the specified properties. Set duration to 0 to jump to these value.\n\t * Numeric properties will be tweened from their current value in the tween to the target value. Non-numeric\n\t * properties will be set at the end of the specified duration.\n\t *\n\t * @example\n\t * Tween.get(target)\n\t *   .to({ alpha: 0, visible: false }, 1000);\n\t *\n\t * @param {Object} props An object specifying property target values for this tween (Ex. `{x:300}` would tween the x\n\t * property of the target to 300).\n\t * @param {Number} [duration=0] The duration of the tween in milliseconds (or in ticks if `useTicks` is true).\n\t * @param {Function} [ease=Ease.linear] The easing function to use for this tween. See the {@link tweenjs.Ease}\n\t * class for a list of built-in ease functions.\n\t * @chainable\n\t */\n\tto (props, duration = 0, ease = linear) {\n\t\tif (duration < 0) { duration = 0; }\n\t\tconst step = this._addStep(+duration, null, ease);\n\t\tthis._appendProps(props, step);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Adds a label that can be used with {@link tweenjs.Tween#gotoAndPlay}/{@link tweenjs.Tween#gotoAndStop}\n\t * at the current point in the tween.\n\t *\n\t * @example\n\t * let tween = Tween.get(foo)\n\t *   .to({ x: 100 }, 1000)\n\t *   .label("myLabel")\n\t *   .to({ x: 200 }, 1000);\n\t * // ...\n\t * tween.gotoAndPlay("myLabel"); // would play from 1000ms in.\n\t *\n\t * @param {String} label The label name.\n\t * @chainable\n\t */\n\tlabel (name) {\n\t\tthis.addLabel(name, this.duration);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Adds an action to call the specified function.\n\t *\n\t * @example\n\t * // would call myFunction() after 1 second.\n\t * Tween.get()\n\t *   .wait(1000)\n\t *   .call(myFunction);\n\t *\n\t * @param {Function} callback The function to call.\n\t * @param {Array} [params]. The parameters to call the function with. If this is omitted, then the function\n\t * will be called with a single param pointing to this tween.\n\t * @param {Object} [scope]. The scope to call the function in. If omitted, it will be called in the target\'s scope.\n\t * @chainable\n\t */\n\tcall (callback, params, scope) {\n\t\treturn this._addAction(scope || this.target, callback, params || [this]);\n\t}\n\n\t/**\n\t * Adds an action to set the specified props on the specified target. If `target` is null, it will use this tween\'s\n\t * target. Note that for properties on the target object, you should consider using a zero duration {@link tweenjs.Tween#to}\n\t * operation instead so the values are registered as tweened props.\n\t *\n\t * @example\n\t * tween.wait(1000)\n\t *   .set({ visible: false }, foo);\n\t *\n\t * @param {Object} props The properties to set (ex. `{ visible: false }`).\n\t * @param {Object} [target] The target to set the properties on. If omitted, they will be set on the tween\'s target.\n\t * @chainable\n\t */\n\tset (props, target) {\n\t\treturn this._addAction(target || this.target, this._set, [ props ]);\n\t}\n\n\t/**\n\t * Adds an action to play (unpause) the specified tween. This enables you to sequence multiple tweens.\n\t *\n\t * @example\n\t * tween.to({ x: 100 }, 500)\n\t *   .play(otherTween);\n\t *\n\t * @param {Tween} [tween] The tween to play. Defaults to this tween.\n\t * @chainable\n\t */\n\tplay (tween) {\n    return this._addAction(tween || this, this._set, [{ paused: false }]);\n\t}\n\n\t/**\n\t * Adds an action to pause the specified tween.\n\t * At 60fps the tween will advance by ~16ms per tick, if the tween above was at 999ms prior to the current tick, it\n   * will advance to 1015ms (15ms into the second "step") and then pause.\n\t *\n\t * @example\n\t * tween.pause(otherTween)\n\t *   .to({ alpha: 1 }, 1000)\n\t *   .play(otherTween);\n\t *\n\t * // Note that this executes at the end of a tween update,\n\t * // so the tween may advance beyond the time the pause action was inserted at.\n   *\n   * tween.to({ foo: 0 }, 1000)\n   *   .pause()\n   *   .to({ foo: 1 }, 1000);\n\t *\n\t * @param {Tween} [tween] The tween to pause. Defaults to this tween.\n\t * @chainable\n\t */\n\tpause (tween) {\n\t\treturn this._addAction(tween || this, this._set, [{ paused: false }]);\n\t}\n\n\t/**\n\t * @throws Tween cannot be cloned.\n\t */\n\tclone () {\n\t\tthrow "Tween can not be cloned.";\n\t}\n\n\t/**\n\t * @private\n\t * @param {Object} plugin\n\t */\n\t_addPlugin (plugin) {\n\t\tlet ids = this._pluginIds || (this._pluginIds = {}), id = plugin.id;\n\t\tif (!id || ids[id]) { return; } // already added\n\n\t\tids[id] = true;\n\t\tlet plugins = this._plugins || (this._plugins = []), priority = plugin.priority || 0;\n\t\tfor (let i = 0, l = plugins.length; i < l; i++) {\n\t\t\tif (priority < plugins[i].priority) {\n\t\t\t\tplugins.splice(i, 0, plugin);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tplugins.push(plugin);\n\t}\n\n\t/**\n\t * @private\n\t * @param {} jump\n\t * @param {Boolean} end\n   */\n\t_updatePosition (jump, end) {\n\t\tlet step = this._stepHead.next, t = this.position, d = this.duration;\n\t\tif (this.target && step) {\n\t\t\t// find our new step index:\n\t\t\tlet stepNext = step.next;\n\t\t\twhile (stepNext && stepNext.t <= t) { step = step.next; stepNext = step.next; }\n\t\t\tlet ratio = end ? d === 0 ? 1 : t/d : (t-step.t)/step.d; // TODO: revisit this.\n\t\t\tthis._updateTargetProps(step, ratio, end);\n\t\t}\n\t\tthis._stepPosition = step ? t - step.t : 0;\n\t}\n\n\t/**\n\t * @private\n\t * @param {Object} step\n\t * @param {Number} ratio\n\t * @param {Boolean} end Indicates to plugins that the full tween has ended.\n\t */\n\t_updateTargetProps (step, ratio, end) {\n\t\tif (this.passive = !!step.passive) { return; } // don\'t update props.\n\n\t\tlet v, v0, v1, ease;\n\t\tlet p0 = step.prev.props;\n\t\tlet p1 = step.props;\n\t\tif (ease = step.ease) { ratio = ease(ratio, 0, 1, 1); }\n\n\t\tlet plugins = this._plugins;\n\t\tproploop : for (let n in p0) {\n\t\t\tv0 = p0[n];\n\t\t\tv1 = p1[n];\n\n\t\t\t// values are different & it is numeric then interpolate:\n\t\t\tif (v0 !== v1 && (typeof(v0) === "number")) {\n\t\t\t\tv = v0 + (v1 - v0) * ratio;\n\t\t\t} else {\n\t\t\t\tv = ratio >= 1 ? v1 : v0;\n\t\t\t}\n\n\t\t\tif (plugins) {\n\t\t\t\tfor (let i = 0, l = plugins.length; i < l; i++) {\n\t\t\t\t\tlet value = plugins[i].change(this, step, n, v, ratio, end);\n\t\t\t\t\tif (value === Tween_Tween.IGNORE) { continue proploop; }\n\t\t\t\t\tif (value !== undefined) { v = value; }\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.target[n] = v;\n\t\t}\n\n\t}\n\n\t/**\n\t * @private\n\t * @param {Number} startPos\n\t * @param {Number} endPos\n\t * @param {Boolean} includeStart\n\t */\n\t_runActionsRange (startPos, endPos, jump, includeStart) {\n\t\tlet rev = startPos > endPos;\n\t\tlet action = rev ? this._actionTail : this._actionHead;\n\t\tlet ePos = endPos, sPos = startPos;\n\t\tif (rev) { ePos = startPos; sPos = endPos; }\n\t\tlet t = this.position;\n\t\twhile (action) {\n\t\t\tlet pos = action.t;\n\t\t\tif (pos === endPos || (pos > sPos && pos < ePos) || (includeStart && pos === startPos)) {\n\t\t\t\taction.funct.apply(action.scope, action.params);\n\t\t\t\tif (t !== this.position) { return true; }\n\t\t\t}\n\t\t\taction = rev ? action.prev : action.next;\n\t\t}\n\t}\n\n\t/**\n\t * @private\n\t * @param {Object} props\n\t */\n\t_appendProps (props, step, stepPlugins) {\n\t\tlet initProps = this._stepHead.props, target = this.target, plugins = Tween_Tween._plugins;\n\t\tlet n, i, l, value, initValue, inject;\n\n\t\tlet oldStep = step.prev, oldProps = oldStep.props;\n\t\tlet stepProps = step.props || (step.props = this._cloneProps(oldProps));\n\t\tlet cleanProps = {};\n\n\t\tfor (n in props) {\n\t\t\tif (!props.hasOwnProperty(n)) { continue; }\n\t\t\tcleanProps[n] = stepProps[n] = props[n];\n\n\t\t\tif (initProps[n] !== undefined) { continue; }\n\n\t\t\tinitValue = undefined; // accessing missing properties on DOMElements when using CSSPlugin is INSANELY expensive, so we let the plugin take a first swing at it.\n\t\t\tif (plugins) {\n        for (i = plugins.length - 1; i >= 0; i--) {\n\t\t\t\t\tvalue = plugins[i].init(this, n, initValue);\n\t\t\t\t\tif (value !== undefined) { initValue = value; }\n\t\t\t\t\tif (initValue === Tween_Tween.IGNORE) {\n\t\t\t\t\t\t(ignored = ignored || {})[n] = true;\n\t\t\t\t\t\tdelete(stepProps[n]);\n\t\t\t\t\t\tdelete(cleanProps[n]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (initValue !== Tween_Tween.IGNORE) {\n\t\t\t\tif (initValue === undefined) { initValue = target[n]; }\n\t\t\t\toldProps[n] = (initValue === undefined) ? null : initValue;\n\t\t\t}\n\t\t}\n\n\t\tfor (n in cleanProps) {\n\t\t\tvalue = props[n];\n\n\t\t\t// propagate old value to previous steps:\n\t\t\tlet o, prev = oldStep;\n\t\t\twhile ((o = prev) && (prev = o.prev)) {\n\t\t\t\tif (prev.props === o.props) { continue; } // wait step\n\t\t\t\tif (prev.props[n] !== undefined) { break; } // already has a value, we\'re done.\n\t\t\t\tprev.props[n] = oldProps[n];\n\t\t\t}\n\t\t}\n\n\t\tif (stepPlugins && (plugins = this._plugins)) {\n      for (i = plugins.length - 1; i >= 0; i--) {\n\t\t\t\tplugins[i].step(this, step, cleanProps);\n\t\t\t}\n\t\t}\n\n\t\tif (inject = this._injected) {\n\t\t\tthis._injected = null;\n\t\t\tthis._appendProps(inject, step, false);\n\t\t}\n\t}\n\n\t/**\n\t * Used by plugins to inject properties onto the current step. Called from within `Plugin.step` calls.\n\t * For example, a plugin dealing with color, could read a hex color, and inject red, green, and blue props into the tween.\n\t * See the SamplePlugin for more info.\n\t * @see tweenjs.SamplePlugin\n\t * @private\n\t * @param {String} name\n\t * @param {Object} value\n\t */\n\t_injectProp (name, value) {\n\t\tlet o = this._injected || (this._injected = {});\n\t\to[name] = value;\n\t}\n\n\t/**\n\t * @private\n\t * @param {Number} duration\n\t * @param {Object} props\n\t * @param {Function} ease\n\t * @param {Boolean} [passive=false]\n\t */\n\t_addStep (duration, props, ease, passive = false) {\n\t\tlet step = new TweenStep(this._stepTail, this.duration, duration, props, ease, passive);\n\t\tthis.duration += duration;\n\t\treturn this._stepTail = (this._stepTail.next = step);\n\t}\n\n\t/**\n\t * @private\n\t * @param {Object} scope\n\t * @param {Function} funct\n\t * @param {Array} params\n\t */\n\t_addAction (scope, funct, params) {\n\t\tlet action = new TweenAction(this._actionTail, this.duration, scope, funct, params);\n\t\tif (this._actionTail) { this._actionTail.next = action; }\n\t\telse { this._actionHead = action; }\n\t\tthis._actionTail = action;\n\t\treturn this;\n\t}\n\n\t/**\n\t * @private\n\t * @param {Object} props\n\t */\n\t_set (props) {\n\t\tfor (let n in props) {\n\t\t\tthis[n] = props[n];\n\t\t}\n\t}\n\n\t/**\n\t * @private\n\t * @param {Object} props\n\t */\n\t_cloneProps (props) {\n\t\tlet o = {};\n\t\tfor (let n in props) { o[n] = props[n]; }\n\t\treturn o;\n\t}\n\n}\n\n// tiny api (primarily for tool output):\n{\n\tlet p = Tween_Tween.prototype;\n\tp.w = p.wait;\n\tp.t = p.to;\n\tp.c = p.call;\n\tp.s = p.set;\n}\n\n// static properties\n/**\n * Constant returned by plugins to tell the tween not to use default assignment.\n * @property IGNORE\n * @type {Object}\n * @static\n */\nTween_Tween.IGNORE = {};\n\n/**\n * @property _listeners\n * @type {Tween[]}\n * @static\n * @private\n */\nTween_Tween._tweens = [];\n\n/**\n * @property _plugins\n * @type {Object}\n * @static\n * @private\n */\nTween_Tween._plugins = null;\n\n/**\n * @property _tweenHead\n * @type {Tween}\n * @static\n * @private\n */\nTween_Tween._tweenHead = null;\n\n/**\n * @property _tweenTail\n * @type {Tween}\n * @static\n * @private\n */\nTween_Tween._tweenTail = null;\n\n// helpers:\n\n/**\n * @private\n * @param {*} prev\n * @param {*} t\n * @param {*} d\n * @param {*} props\n * @param {*} ease\n * @param {*} passive\n */\nclass TweenStep {\n\n\tconstructor (prev, t, d, props, ease, passive) {\n\t\tthis.next = null;\n\t\tthis.prev = prev;\n\t\tthis.t = t;\n\t\tthis.d = d;\n\t\tthis.props = props;\n\t\tthis.ease = ease;\n\t\tthis.passive = passive;\n\t\tthis.index = prev ? prev.index + 1 : 0;\n\t}\n\n}\n\n/**\n * @private\n * @param {*} prev\n * @param {*} t\n * @param {*} scope\n * @param {*} funct\n * @param {*} params\n */\nclass TweenAction {\n\n\tconstructor (prev, t, scope, funct, params) {\n\t\tthis.next = null;\n\t\tthis.d = 0;\n\t\tthis.prev = prev;\n\t\tthis.t = t;\n\t\tthis.scope = scope;\n\t\tthis.funct = funct;\n\t\tthis.params = params;\n\t}\n\n}\n\n// CONCATENATED MODULE: ./node_modules/@createjs/tweenjs/src/Timeline.js\n/**\n * @license Timeline\n * Visit http://createjs.com/ for documentation, updates and examples.\n *\n * Copyright (c) 2010 gskinner.com, inc.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the "Software"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n\n\n/**\n * The Timeline class synchronizes multiple tweens and allows them to be controlled as a group. Please note that if a\n * timeline is looping, the tweens on it may appear to loop even if the "loop" property of the tween is false.\n *\n * NOTE: Timeline currently also accepts a param list in the form: `tweens, labels, props`. This is for backwards\n * compatibility only and will be removed in the future. Include tweens and labels as properties on the props object.\n *\n * @memberof tweenjs\n * @extends tweenjs.AbstractTween\n *\n * @param {Object} [props] The configuration properties to apply to this instance\n * @param {Boolean} [props.useTicks=false] See the {@link tweenjs.AbstractTween#useTicks} property for more information.\n * @param {Boolean} [props.ignoreGlobalPause=false] See the {@link tweenjs.AbstractTween#ignoreGlobalPause} for more information.\n * @param {Number|Boolean} [props.loop=0] See the {@link tweenjs.AbstractTween#loop} for more information.\n * @param {Boolean} [props.reversed=false] See the {@link tweenjs.AbstractTween#reversed} for more information.\n * @param {Boolean} [props.bounce=false] See the {@link tweenjs.AbstractTween#bounce} for more information.\n * @param {Number} [props.timeScale=1] See the {@link tweenjs.AbstractTween#timeScale} for more information.\n * @param {Boolean} [props.paused=false] See the {@link tweenjs.AbstractTween#paused} for more information.\n * @param {Number} [props.position] See the {@link tweenjs.AbstractTween#position} for more information.\n * @param {Boolean} [props.tweens]\n * @param {Number} [props.labels]\n * @param {Function} [props.onChange] Adds the specified function as a listener to the {@link tweenjs.AbstractTween#event:change} event.\n * @param {Function} [props.onComplete] Adds the specified function as a listener to the {@link tweenjs.AbstractTween#event:complete} event.\n */\nclass Timeline_Timeline extends AbstractTween_AbstractTween {\n\n\tconstructor (props = {}) {\n\t\tsuper(props);\n\n\t\t/**\n\t\t * The array of tweens in the timeline. It is *strongly* recommended that you use\n\t\t * {@link tweenjs.Tween#addTween} and {@link tweenjs.Tween#removeTween},\n\t\t * rather than accessing this directly, but it is included for advanced uses.\n\t\t * @type {Tween[]}\n\t\t */\n\t\tthis.tweens = [];\n\n\t\tif (props.tweens) { this.addTween(...props.tweens); }\n\t\tif (props.labels) { this.labels = props.labels; }\n\n\t\tthis._init(props);\n\t}\n\n\t/**\n\t * Adds one or more tweens (or timelines) to this timeline. The tweens will be paused (to remove them from the\n\t * normal ticking system) and managed by this timeline. Adding a tween to multiple timelines will result in\n\t * unexpected behaviour.\n\t *\n\t * @param {Tween} ...tweens The tween(s) to add. Accepts multiple arguments.\n\t * @return {Tween} The first tween that was passed in.\n\t */\n\taddTween (...tweens) {\n\t\tconst l = tweens.length;\n\t\tif (l === 1) {\n\t\t\tconst tween = tweens[0];\n\t\t\tthis.tweens.push(tween);\n\t\t\ttween._parent = this;\n\t\t\ttween.paused = true;\n\t\t\tlet d = tween.duration;\n\t\t\tif (tween.loop > 0) { d *= tween.loop + 1; }\n\t\t\tif (d > this.duration) { this.duration = d; }\n\t\t\tif (this.rawPosition >= 0) { tween.setPosition(this.rawPosition); }\n\t\t\treturn tween;\n\t\t}\n\t\tif (l > 1) {\n\t\t\tfor (let i = 0; i < l; i++) { this.addTween(tweens[i]); }\n\t\t\treturn tweens[l - 1];\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Removes one or more tweens from this timeline.\n\t *\n\t * @param {Tween} ...tweens The tween(s) to remove. Accepts multiple arguments.\n\t * @return {Boolean} Returns `true` if all of the tweens were successfully removed.\n\t */\n\tremoveTween (...tweens) {\n\t\tconst l = tweens.length;\n\t\tif (l === 1) {\n\t\t\tconst tw = this.tweens;\n\t\t\tconst tween = tweens[0];\n\t\t\tlet i = tw.length;\n\t\t\twhile (i--) {\n\t\t\t\tif (tw[i] === tween) {\n\t\t\t\t\ttw.splice(i, 1);\n\t\t\t\t\ttween._parent = null;\n\t\t\t\t\tif (tween.duration >= this.duration) { this.updateDuration(); }\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tif (l > 1) {\n\t\t\tlet good = true;\n\t\t\tfor (let i = 0; i < l; i++) { good = good && this.removeTween(tweens[i]); }\n\t\t\treturn good;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Recalculates the duration of the timeline. The duration is automatically updated when tweens are added or removed,\n\t * but this method is useful if you modify a tween after it was added to the timeline.\n\t */\n\tupdateDuration () {\n\t\tthis.duration = 0;\n\t\tfor (let i = 0, l = this.tweens.length; i < l; i++) {\n\t\t\tlet tween = this.tweens[i];\n\t\t\tlet d = tween.duration;\n\t\t\tif (tween.loop > 0) { d *= tween.loop + 1; }\n\t\t\tif (d > this.duration) { this.duration = d; }\n\t\t}\n\t}\n\n\t/**\n\t * @throws Timeline cannot be cloned.\n\t */\n\tclone () {\n\t\tthrow "Timeline can not be cloned.";\n\t}\n\n\t/**\n\t * @private\n\t */\n\t_updatePosition (jump, end) {\n\t\tconst t = this.position;\n\t\tfor (let i = 0, l = this.tweens.length; i < l; i++) {\n\t\t\tthis.tweens[i].setPosition(t, true, jump); // actions will run after all the tweens update.\n\t\t}\n\t}\n\n\t/**\n\t * @private\n\t */\n\t_runActionsRange (startPos, endPos, jump, includeStart) {\n\t\t//console.log("\trange", startPos, endPos, jump, includeStart);\n\t\tconst t = this.position;\n\t\tfor (let i = 0, l = this.tweens.length; i < l; i++) {\n\t\t\tthis.tweens[i]._runActions(startPos, endPos, jump, includeStart);\n\t\t\tif (t !== this.position) { return true; } // an action changed this timeline\'s position.\n\t\t}\n\t}\n\n}\n\n// CONCATENATED MODULE: ./node_modules/@createjs/tweenjs/src/main.js\n/**\n * README: Export Order\n *\n * Due to some classes having circular import bindings (whether at the top of the import chain or deeper in),\n * some exports here are in reverse order (such as Tween being exported before AbstractTween).\n * This is explained here: https://github.com/rollup/rollup/issues/845#issuecomment-240277194\n */\n\n/**\n * @namespace tweenjs\n */\n\n\n\n\n\n\n\n\n\n// CONCATENATED MODULE: ./node_modules/@createjs/easeljs/src/display/MovieClip.js\n/**\n * @license MovieClip\n * Visit http://createjs.com/ for documentation, updates and examples.\n *\n * Copyright (c) 2017 gskinner.com, inc.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the "Software"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n\n\n\n\n/**\n * The MovieClip class associates a TweenJS Timeline with an EaselJS {@link easeljs.Container}. It allows\n * you to create objects which encapsulate timeline animations, state changes, and synched actions. Due to the\n * complexities inherent in correctly setting up a MovieClip, it is largely intended for tool output and is not included\n * in the main EaselJS library.\n *\n * Currently MovieClip only works properly if it is tick based (as opposed to time based) though some concessions have\n * been made to support time-based timelines in the future.\n *\n * It is recommended to use `tween.to()` to animate and set properties (use no duration to have it set\n * immediately), and the `tween.wait()` method to create delays between animations. Note that using the\n * `tween.set()` method to affect properties will likely not provide the desired result.\n *\n * @memberof easeljs\n * @example <caption>Animate two shapes back and forth</caption>\n * let stage = new Stage("canvas");\n * Ticker.addEventListener("tick", stage);\n *\n * let mc = new MovieClip(null, 0, true, {start:20});\n * stage.addChild(mc);\n *\n * let child1 = new Shape(\n *   new Graphics().beginFill("#999999").drawCircle(30,30,30)\n * );\n * let child2 = new Shape(\n *   new Graphics().beginFill("#5a9cfb").drawCircle(30,30,30)\n * );\n *\n * mc.timeline.addTween(\n *   Tween.get(child1).to({x:0}).to({x:60}, 50).to({x:0}, 50)\n * );\n * mc.timeline.addTween(\n *   Tween.get(child2).to({x:60}).to({x:0}, 50).to({x:60}, 50)\n * );\n *\n * mc.gotoAndPlay("start");\n *\n * @extends easeljs.Container\n * @param {Object} [props] The configuration properties to apply to this instances.\n * This object will also be passed into the Timeline instance associated with this MovieClip.\n * See the documentation for Timeline for a list of supported props.\n */\nclass MovieClip_MovieClip extends Container_Container {\n\n\tconstructor (props) {\n\t\tsuper();\n\t\t!MovieClip_MovieClip.inited && MovieClip_MovieClip.init();\n\n\t\t/**\n\t\t * Controls how this MovieClip advances its time. Must be one of 0 (INDEPENDENT), 1 (SINGLE_FRAME), or 2 (SYNCHED).\n\t\t * See each constant for a description of the behaviour.\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.mode = props.mode != null ? props.mode : MovieClip_MovieClip.INDEPENDENT;\n\n\t\t/**\n\t\t * Specifies what the first frame to play in this movieclip, or the only frame to display if mode is SINGLE_FRAME.\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.startPosition = props.startPosition != null ? props.startPosition : 0;\n\n\t\t/**\n     * Specifies how many times this MovieClip should loop. A value of -1 indicates it should loop indefinitely. A value of\n     * 1 would cause it to loop once (ie. play a total of twice).\n     * @property loop\n\t\t * @type {Number}\n\t\t * @default -1\n\t\t */\n\t\tif (typeof props.loop === "number") {\n\t\t\tthis.loop = props.loop;\n\t\t} else if (props.loop === false) {\n\t\t\tthis.loop = 0;\n\t\t} else {\n\t\t\tthis.loop = -1;\n\t\t}\n\n\t\t/**\n\t\t * The current frame of the movieclip.\n\t\t * @type Number\n\t\t * @default 0\n\t\t * @readonly\n\t\t */\n\t\tthis.currentFrame = 0;\n\n\t\t/**\n     * The TweenJS Timeline that is associated with this MovieClip. This is created automatically when the MovieClip\n     * instance is initialized. Animations are created by adding <a href="http://tweenjs.com">TweenJS</a> Tween\n     * instances to the timeline.\n     *\n     * Elements can be added and removed from the timeline by toggling an "_off" property\n     * using the `tweenInstance.to()` method. Note that using `Tween.set` is not recommended to\n     * create MovieClip animations. The following example will toggle the target off on frame 0, and then back on for\n     * frame 1. You can use the "visible" property to achieve the same effect.\n     *\n     * @example\n     * let tween = Tween.get(target).to({x:0}).to({x:100}, 30);\n     * let mc = new MovieClip();\n     * mc.timeline.addTween(tween);\n     *\n     * @example\n     * Tween.get(target).to({_off:false})\n     *   .wait(1).to({_off:true})\n     *   .wait(1).to({_off:false});\n     *\n     * @type {easeljs.Timeline}\n\t\t */\n\t\tthis.timeline = new Timeline_Timeline(Object.assign({ useTicks: true, paused: true }, props));\n\n\t\t/**\n\t\t * If true, the MovieClip\'s position will not advance when ticked.\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.paused = props.paused != null ? props.paused : false;\n\n\t\t/**\n\t\t * If true, actions in this MovieClip\'s tweens will be run when the playhead advances.\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.actionsEnabled = true;\n\n\t\t/**\n\t\t * If true, the MovieClip will automatically be reset to its first frame whenever the timeline adds\n\t\t * it back onto the display list. This only applies to MovieClip instances with mode=INDEPENDENT.\n\t\t * <br><br>\n\t\t * For example, if you had a character animation with a "body" child MovieClip instance\n\t\t * with different costumes on each frame, you could set `body.autoReset = false`, so that\n\t\t * you can manually change the frame it is on, without worrying that it will be reset\n\t\t * automatically.\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.autoReset = true;\n\n\t\t/**\n\t\t * An array of bounds for each frame in the MovieClip. This is mainly intended for tool output.\n\t\t * @type {Array}\n\t\t */\n\t\tthis.frameBounds = this.frameBounds || props.frameBounds; // frameBounds are set on the prototype in Animate.\n\n\t\t/**\n\t\t * By default MovieClip instances advance one frame per tick. Specifying a framerate for the MovieClip\n\t\t * will cause it to advance based on elapsed time between ticks as appropriate to maintain the target\n\t\t * framerate.\n\t\t *\n\t\t * For example, if a MovieClip with a framerate of 10 is placed on a Stage being updated at 40fps, then the MovieClip will\n\t\t * advance roughly one frame every 4 ticks. This will not be exact, because the time between each tick will\n\t\t * vary slightly between frames.\n\t\t *\n\t\t * This feature is dependent on the tick event object (or an object with an appropriate "delta" property) being\n\t\t * passed into {@link easeljs.Stage#update}.\n\t\t * @type {Number}\n\t\t * @default null\n\t\t */\n\t\tthis.framerate = null;\n\n\t\t/**\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t * @private\n\t\t */\n\t\tthis._synchOffset = 0;\n\n\t\t/**\n\t\t * @type {Number}\n\t\t * @default -1\n\t\t * @private\n\t\t */\n\t\tthis._rawPosition = -1; // TODO: evaluate using a ._reset Boolean prop instead of -1.\n\n\t\t/**\n\t\t * The time remaining from the previous tick, only applicable when .framerate is set.\n\t\t * @type {Number}\n\t\t * @private\n\t\t */\n\t\tthis._t = 0;\n\n\t\t/**\n\t\t * List of display objects that are actively being managed by the MovieClip.\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis._managed = {};\n\n\t\t/**\n\t\t * @type {Function}\n\t\t * @private\n\t\t */\n\t\tthis._bound_resolveState = this._resolveState.bind(this);\n\t}\n\n\tstatic init () {\n\t\tif (MovieClip_MovieClip.inited) { return; }\n\t\t// plugins introduce some overhead to Tween, so we only install this if an MC is instantiated.\n\t\tMovieClip_MovieClipPlugin.install();\n\t\tMovieClip_MovieClip.inited = true;\n\t}\n\n\t// TODO: can we just proxy `get currentFrame` to timeline.position as well? Ditto for `get loop` (or just remove entirely).\n\t//\n\t/**\n\t * Returns an array of objects with label and position (aka frame) properties, sorted by position.\n\t * @see {@link tweenjs.Timeline#labels}\n\t * @type {Array}\n\t * @readonly\n\t */\n\tget labels () {\n\t\treturn this.timeline.labels;\n\t}\n\n\t/**\n\t * Returns the name of the label on or immediately before the current frame.\n\t * @see {@link tweenjs.Timeline#currentLabel}\n\t * for more information.\n\t * @type {String}\n\t * @readonly\n\t */\n\tget currentLabel () {\n\t\treturn this.timeline.currentLabel;\n\t}\n\n\t /**\n \t * Returns the duration of this MovieClip in seconds or ticks.\n \t * @see {@link tweenjs.Timeline#duration}\n \t * @type {Number}\n \t * @readonly\n \t */\n \tget duration () {\n\t\treturn this.timeline.duration;\n\t}\n\n\t/**\n\t * Returns the duration of this MovieClip in seconds or ticks. Identical to {@link easeljs.MovieClip#duration}\n\t * and provided for Adobe Flash/Animate API compatibility.\n\t * @see {@link tweenjs.Timeline#duration}\n\t * @type {Number}\n\t * @readonly\n\t */\n\tget totalFrames () {\n\t\treturn this.duration;\n\t}\n\n\tisVisible () {\n\t\t// children are placed in draw, so we can\'t determine if we have content.\n\t\treturn !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0);\n\t}\n\n\tdraw (ctx, ignoreCache) {\n\t\t// draw to cache first:\n\t\tif (this.drawCache(ctx, ignoreCache)) { return true; }\n    this._updateState();\n\t\tsuper.draw(ctx, ignoreCache);\n\t\treturn true;\n\t}\n\n\t/**\n\t * Sets paused to false.\n\t */\n\tplay () {\n\t\tthis.paused = false;\n\t}\n\n\t/**\n\t * Sets paused to true.\n\t */\n\tstop () {\n\t\tthis.paused = true;\n\t}\n\n\t/**\n\t * Advances this movie clip to the specified position or label and plays the timeline.\n\t * @param {String | Number} positionOrLabel The animation name or frame number to go to.\n\t */\n\tgotoAndPlay (positionOrLabel) {\n\t\tthis.play();\n\t\tthis._goto(positionOrLabel);\n\t}\n\n\t/**\n\t * Advances this movie clip to the specified position or label and stops the timeline.\n\t * @param {String | Number} positionOrLabel The animation or frame name to go to.\n\t */\n\tgotoAndStop (positionOrLabel) {\n\t\tthis.stop();\n\t\tthis._goto(positionOrLabel);\n\t}\n\n\t/**\n\t * Advances the playhead. This occurs automatically each tick by default.\n\t * @param {Number} [time] The amount of time in ms to advance by. Only applicable if framerate is set.\n\t*/\n\tadvance (time) {\n\t\tif (this.mode !== MovieClip_MovieClip.INDEPENDENT) { return; } // update happens in draw for synched clips\n\t\t// if this MC doesn\'t have a framerate, hunt ancestors for one:\n\t\tlet o = this, fps = o.framerate;\n\t\twhile ((o = o.parent) && fps === null) {\n\t\t\tif (o.mode === MovieClip_MovieClip.INDEPENDENT) { fps = o._framerate; }\n\t\t}\n\t\tthis._framerate = fps;\n\n\t\tif (this.paused) { return; }\n\t\t// calculate how many frames to advance:\n\t\tlet t = (fps !== null && fps !== -1 && time !== null) ? time / (1000 / fps) + this._t : 1;\n\t\tlet frames = t | 0;\n\t\tthis._t = t - frames; // leftover time, save to add to next advance.\n\n\t\twhile (frames--) {\n\t\t\tthis._updateTimeline(this._rawPosition + 1, false);\n\t\t}\n\t}\n\n\t/**\n\t * MovieClip instances cannot be cloned.\n\t * @throws MovieClip cannot be cloned.\n\t */\n\tclone () {\n\t\t// TODO: add support for this? Need to clone the Timeline & retarget tweens - pretty complex.\n\t\tthrow "MovieClip cannot be cloned.";\n\t}\n\n\t_updateState () {\n\t\tif (this._rawPosition === -1 || this.mode !== MovieClip_MovieClip.INDEPENDENT) { this._updateTimeline(-1); }\n\t}\n\n\t_tick (evtObj) {\n\t\tthis.advance(evtObj && evtObj.delta);\n\t\tsuper._tick(evtObj);\n\t}\n\n\t/**\n\t * @param {String | Number} positionOrLabel The animation name or frame number to go to.\n\t * @protected\n\t */\n\t_goto (positionOrLabel) {\n\t\tlet pos = this.timeline.resolve(positionOrLabel);\n\t\tif (pos == null) { return; }\n\t\tthis._t = 0;\n\t\tthis._updateTimeline(pos, true);\n\t}\n\n\t/**\n\t * @private\n\t */\n\t_reset () {\n\t\tthis._rawPosition = -1;\n\t\tthis._t = this.currentFrame = 0;\n\t\tthis.paused = false;\n\t}\n\n\t/**\n\t * @param {Number} rawPosition\n\t * @param {Boolean} jump Indicates whether this update is due to jumping (via gotoAndXX) to a new position.\n\t * @protected\n\t */\n\t_updateTimeline (rawPosition, jump) {\n\t\tlet synced = this.mode !== MovieClip_MovieClip.INDEPENDENT, tl = this.timeline;\n\t\tif (synced) { rawPosition = this.startPosition + (this.mode === MovieClip_MovieClip.SINGLE_FRAME ? 0 : this._synchOffset); }\n\t\tif (rawPosition < 1) { rawPosition = 0; }\n\t\tif (this._rawPosition === rawPosition && !synced) { return; }\n\t\tthis._rawPosition = rawPosition;\n\n\t\t// update timeline position, ignoring actions if this is a graphic.\n\t\ttl.loop = this.loop; // TODO: should we maintain this on MovieClip, or just have it on timeline?\n\t\ttl.setPosition(rawPosition, synced || !this.actionsEnabled, jump, this._bound_resolveState);\n\t}\n\n\t/**\n\t * Renders position 0 without running actions or updating _rawPosition.\n\t * Primarily used by Animate CC to build out the first frame in the constructor of MC symbols.\n\t * NOTE: not tested when run after the MC advances past the first frame.\n\t * @protected\n\t */\n\t_renderFirstFrame () {\n\t\tconst tl = this.timeline, pos = tl.rawPosition;\n\t\ttl.setPosition(0, true, true, this._bound_resolveState);\n\t\ttl.rawPosition = pos;\n\t}\n\n\t/**\n\t * Runs via a callback after timeline property updates and before actions.\n\t * @protected\n\t */\n\t_resolveState () {\n\t\tlet tl = this.timeline;\n\t\tthis.currentFrame = tl.position;\n\n\t\tfor (let n in this._managed) { this._managed[n] = 1; }\n\n\t\tlet tweens = tl.tweens;\n\t\tfor (let tween of tweens) {\n\t\t\tlet target = tween.target;\n\t\t\tif (target === this || tween.passive) { continue; } // TODO: this assumes the actions tween from Animate has `this` as the target. Likely a better approach.\n\t\t\tlet offset = tween._stepPosition;\n\n\t\t\tif (target instanceof DisplayObject_DisplayObject) {\n\t\t\t\t// motion tween.\n\t\t\t\tthis._addManagedChild(target, offset);\n\t\t\t} else {\n\t\t\t\t// state tween.\n\t\t\t\tthis._setState(target.state, offset);\n\t\t\t}\n\t\t}\n\n\t\tlet kids = this.children;\n\t\tfor (let i=kids.length-1; i>=0; i--) {\n\t\t\tlet id = kids[i].id;\n\t\t\tif (this._managed[id] === 1) {\n\t\t\t\tthis.removeChildAt(i);\n\t\t\t\tdelete(this._managed[id]);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {Array} state\n\t * @param {Number} offset\n\t * @protected\n\t */\n\t_setState (state, offset) {\n\t\tif (!state) { return; }\n\t\tfor (let i = state.length - 1; i >= 0; i--) {\n\t\t\tlet o = state[i];\n\t\t\tlet target = o.t;\n\t\t\tlet props = o.p;\n\t\t\tfor (let n in props) { target[n] = props[n]; }\n\t\t\tthis._addManagedChild(target, offset);\n\t\t}\n\t}\n\n\t/**\n\t * Adds a child to the timeline, and sets it up as a managed child.\n\t * @param {easeljs.MovieClip} child The child MovieClip to manage\n\t * @param {Number} offset\n\t * @private\n\t */\n\t_addManagedChild (child, offset) {\n\t\tif (child._off) { return; }\n\t\tthis.addChildAt(child, 0);\n\n\t\tif (child instanceof MovieClip_MovieClip) {\n\t\t\tchild._synchOffset = offset;\n\t\t\t// TODO: this does not precisely match Adobe Flash/Animate, which loses track of the clip if it is renamed or removed from the timeline, which causes it to reset.\n      // TODO: should also reset when MovieClip loops, though that will be a bit tricky to detect.\n\t\t\tif (child.mode === MovieClip_MovieClip.INDEPENDENT && child.autoReset && !this._managed[child.id]) { child._reset(); }\n\t\t}\n\t\tthis._managed[child.id] = 2;\n\t}\n\n\t/**\n\t * @param {easeljs.Matrix2D} matrix\n\t * @param {Boolean} ignoreTransform\n\t * @return {easeljs.Rectangle}\n\t * @protected\n\t */\n\t_getBounds (matrix, ignoreTransform) {\n\t\tlet bounds = this.getBounds();\n\t\tif (!bounds && this.frameBounds) { bounds = this._rectangle.copy(this.frameBounds[this.currentFrame]); }\n\t\tif (bounds) { return this._transformBounds(bounds, matrix, ignoreTransform); }\n\t\treturn super._getBounds(matrix, ignoreTransform);\n\t}\n\n}\n\n/**\n * The MovieClip will advance independently of its parent, even if its parent is paused.\n * This is the default mode.\n * @static\n * @type {String}\n * @default independent\n * @readonly\n */\nMovieClip_MovieClip.INDEPENDENT = "independent";\n/**\n * The MovieClip will only display a single frame (as determined by the startPosition property).\n * @static\n * @type {String}\n * @default single\n * @readonly\n */\nMovieClip_MovieClip.SINGLE_FRAME = "single";\n/**\n * The MovieClip will be advanced only when its parent advances and will be synched to the position of\n * the parent MovieClip.\n * @static\n * @type {String}\n * @default synched\n * @readonly\n */\nMovieClip_MovieClip.SYNCHED = "synched";\n/**\n * Has the MovieClipPlugin been installed to TweenJS yet?\n * @static\n * @type {Boolean}\n * @default false\n * @readonly\n */\nMovieClip_MovieClip.inited = false;\n\n/**\n * This plugin works with <a href="http://tweenjs.com" target="_blank">TweenJS</a> to prevent the startPosition property from tweening.\n * @todo update to new plugin model\n * @static\n * @inner\n */\nclass MovieClip_MovieClipPlugin {\n\n\tconstructor () {\n\t\tthrow "MovieClipPlugin cannot be instantiated.";\n\t}\n\n\t/**\n\t * @private\n\t */\n\tstatic install () {\n\t\tTween_Tween.installPlugin(MovieClip_MovieClipPlugin);\n\t}\n\n\t/**\n\t * @param {tweenjs.Tween} tween\n\t * @param {String} prop\n\t * @param {String|Number|Boolean} value\n\t * @private\n\t */\n\tstatic init (tween, prop, value) {\n\t\treturn value;\n\t}\n\n\t/**\n\t * @param {tweenjs.Tween} tween\n\t * @param {String} prop\n\t * @param {String | Number | Boolean} value\n\t * @param {Array} startValues\n\t * @param {Array} endValues\n\t * @param {Number} ratio\n\t * @param {Object} wait\n\t * @param {Object} end\n\t * @return {*}\n\t */\n\tstatic tween (tween, prop, value, startValues, endValues, ratio, wait, end) {\n\t\tif (!(tween.target instanceof MovieClip_MovieClip)) { return value; }\n\t\treturn (ratio === 1 ? endValues[prop] : startValues[prop]);\n\t}\n\n}\n\n/**\n * @static\n * @type {Number}\n * @default 100\n * @readonly\n */\nMovieClip_MovieClipPlugin.priority = 100;\n\n// CONCATENATED MODULE: ./node_modules/@createjs/easeljs/src/display/Shape.js\n/**\n * @license Shape\n * Visit http://createjs.com/ for documentation, updates and examples.\n *\n * Copyright (c) 2017 gskinner.com, inc.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the "Software"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n\n\n\n/**\n * A Shape allows you to display vector art in the display list. It composites a {@link easeljs.Graphics}\n * instance which exposes all of the vector drawing methods. The Graphics instance can be shared between multiple Shape\n * instances to display the same vector graphics with different positions or transforms.\n *\n * If the vector art will not change between draws, you may want to use the {@link easeljs.DisplayObject#cache}\n * method to reduce the rendering cost.\n *\n * @memberof easeljs\n * @example\n * var graphics = new Graphics().beginFill("#ff0000").drawRect(0, 0, 100, 100);\n * var shape = new Shape(graphics);\n * // Alternatively use can also use the graphics property of the Shape class to renderer the same as above.\n * var shape = new Shape();\n * shape.graphics.beginFill("#ff0000").drawRect(0, 0, 100, 100);\n *\n * @extends easeljs.DisplayObject\n * @param {easeljs.Graphics} [graphics] The graphics instance to display. If null, a new Graphics instance will be created.\n */\nclass Shape_Shape extends DisplayObject_DisplayObject {\n\n\tconstructor (graphics = new Graphics()) {\n\t\tsuper();\n\n\t\t/**\n\t\t * The graphics instance to display.\n\t\t * @type {easeljs.Graphics}\n\t\t */\n\t\tthis.graphics = graphics;\n\t}\n\n\tisVisible () {\n\t\tlet hasContent = this.cacheCanvas || (this.graphics && !this.graphics.isEmpty());\n\t\treturn !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0 && hasContent);\n\t}\n\n\tdraw (ctx, ignoreCache = false) {\n\t\tif (super.draw(ctx, ignoreCache)) { return true; }\n\t\tthis.graphics.draw(ctx, this);\n\t\treturn true;\n\t}\n\n\t/**\n\t * Returns a clone of this Shape. Some properties that are specific to this instance\'s current context are reverted to\n\t * their defaults (for example .parent).\n\t * @override\n\t * @param {Boolean} [recursive=false] If true, this Shape\'s {@link easeljs.Graphics} instance will also be\n\t * cloned. If false, the Graphics instance will be shared with the new Shape.\n\t */\n\tclone (recursive = false) {\n\t\tlet g = (recursive && this.graphics) ? this.graphics.clone() : this.graphics;\n\t\treturn this._cloneProps(new Shape_Shape(g));\n\t}\n\n}\n\n// CONCATENATED MODULE: ./node_modules/@createjs/easeljs/src/display/SpriteSheet.js\n/**\n * @license SpriteSheet\n * Visit http://createjs.com/ for documentation, updates and examples.\n *\n * Copyright (c) 2017 gskinner.com, inc.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the "Software"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPliED, INCLUDING BUT NOT liMITED TO THE WARRANTIES\n * OF MERCHANTABIliTY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HolDERS BE liABLE FOR ANY CLAIM, DAMAGES OR OTHER liABIliTY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEAliNGS IN THE SOFTWARE.\n */\n\n\n\n\n/**\n * Encapsulates the properties and methods associated with a sprite sheet. A sprite sheet is a series of images (usually\n * animation frames) combined into a larger image (or images). For example, an animation consisting of eight 100x100\n * images could be combined into a single 400x200 sprite sheet (4 frames across by 2 high).\n * <br />\n * The data passed to the SpriteSheet constructor defines:\n * <ol>\n * \t<li> The source image or images to use.</li>\n * \t<li> The positions of individual image frames.</li>\n * \t<li> Sequences of frames that form named animations. Optional.</li>\n * \t<li> The target playback framerate. Optional.</li>\n * </ol>\n *\n * <h3>SpriteSheet Format</h3>\n * SpriteSheets are an object with two required properties (`images` and `frames`), and two optional properties\n * (`framerate` and `animations`). This makes them easy to define in javascript code, or in JSON.\n *\n * <h4>images</h4>\n * An array of source images. Images can be either an HTMlimage\n * instance, or a uri to an image. The former is recommended to control preloading.\n *\n * \timages: [image1, "path/to/image2.png"],\n *\n * <h4>frames</h4>\n * Defines the individual frames. There are two supported formats for frame data:\n * When all of the frames are the same size (in a grid), use an object with `width`, `height`, `regX`, `regY`,\n * and `count` properties.\n *\n * <ul>\n *  <li>`width` & `height` are required and specify the dimensions of the frames</li>\n *  <li>`regX` & `regY` indicate the registration point or "origin" of the frames</li>\n *  <li>`spacing` indicate the spacing between frames</li>\n *  <li>`margin` specify the margin around the image(s)</li>\n *  <li>`count` allows you to specify the total number of frames in the spritesheet; if omitted, this will\n *  be calculated based on the dimensions of the source images and the frames. Frames will be assigned\n *  indexes based on their position in the source images (left to right, top to bottom).</li>\n * </ul>\n *\n *  \tframes: {width:64, height:64, count:20, regX: 32, regY:64, spacing:0, margin:0}\n *\n * If the frames are of different sizes, use an array of frame definitions. Each definition is itself an array\n * with 4 required and 3 optional entries, in the order:\n *\n * <ul>\n *  <li>The first four, `x`, `y`, `width`, and `height` are required and define the frame rectangle.</li>\n *  <li>The fifth, `imageIndex`, specifies the index of the source image (defaults to 0)</li>\n *  <li>The last two, `regX` and `regY` specify the registration point of the frame</li>\n * </ul>\n *\n * \tframes: [\n * \t\t// x, y, width, height, imageIndex*, regX*, regY*\n * \t\t[64, 0, 96, 64],\n * \t\t[0, 0, 64, 64, 1, 32, 32]\n * \t\t// etc.\n * \t]\n *\n * <h4>animations</h4>\n * Optional. An object defining sequences of frames to play as named animations. Each property corresponds to an\n * animation of the same name. Each animation must specify the frames to play, and may\n * also include a relative playback `speed` (ex. 2 would playback at double speed, 0.5 at half), and\n * the name of the `next` animation to sequence to after it completes.\n *\n * There are three formats supported for defining the frames in an animation, which can be mixed and matched as appropriate:\n * <ol>\n * \t<li>for a single frame animation, you can simply specify the frame index\n *\n * \t\tanimations: {\n * \t\t\tsit: 7\n * \t\t}\n *\n * </li>\n * <li>\n *      for an animation of consecutive frames, you can use an array with two required, and two optional entries\n * \t\tin the order: `start`, `end`, `next`, and `speed`. This will play the frames from start to end inclusive.\n *\n * \t\tanimations: {\n * \t\t\t// start, end, next*, speed*\n * \t\t\trun: [0, 8],\n * \t\t\tjump: [9, 12, "run", 2]\n * \t\t}\n *\n *  </li>\n *  <li>\n *     for non-consecutive frames, you can use an object with a `frames` property defining an array of frame\n *     indexes to play in order. The object can also specify `next` and `speed` properties.\n *\n * \t\tanimations: {\n * \t\t\twalk: {\n * \t\t\t\tframes: [1,2,3,3,2,1]\n * \t\t\t},\n * \t\t\tshoot: {\n * \t\t\t\tframes: [1,4,5,6],\n * \t\t\t\tnext: "walk",\n * \t\t\t\tspeed: 0.5\n * \t\t\t}\n * \t\t}\n *\n *  </li>\n * </ol>\n * <strong>Note:</strong> the `speed` property was added in EaselJS 0.7.0. Earlier versions had a `frequency`\n * property instead, which was the inverse of `speed`. For example, a value of "4" would be 1/4 normal speed in\n * earlier versions, but is 4x normal speed in EaselJS 0.7.0+.\n *\n * <h4>framerate</h4>\n * Optional. Indicates the default framerate to play this spritesheet at in frames per second. See\n * {{#crossLink "SpriteSheet/framerate:property"}}{{/crossLink}} for more information.\n *\n * \t\tframerate: 20\n *\n * Note that the Sprite framerate will only work if the stage update method is provided with the {{#crossLink "Ticker/tick:event"}}{{/crossLink}}\n * event generated by the {{#crossLink "Ticker"}}{{/crossLink}}.\n *\n * \t\tcreatejs.Ticker.on("tick", handleTick);\n * \t\tfunction handleTick(event) {\n *\t\t\tstage.update(event);\n *\t\t}\n *\n * <h3>Example</h3>\n * To define a simple sprite sheet, with a single image "sprites.jpg" arranged in a regular 50x50 grid with three\n * animations: "stand" showing the first frame, "run" looping frame 1-5 inclusive, and "jump" playing frame 6-8 and\n * sequencing back to run.\n *\n * \t\tvar data = {\n * \t\t\timages: ["sprites.jpg"],\n * \t\t\tframes: {width:50, height:50},\n * \t\t\tanimations: {\n * \t\t\t\tstand:0,\n * \t\t\t\trun:[1,5],\n * \t\t\t\tjump:[6,8,"run"]\n * \t\t\t}\n * \t\t};\n * \t\tvar spriteSheet = new createjs.SpriteSheet(data);\n * \t\tvar animation = new createjs.Sprite(spriteSheet, "run");\n *\n * <h3>Generating SpriteSheet Images</h3>\n * Spritesheets can be created manually by combining images in PhotoShop, and specifying the frame size or\n * coordinates manually, however there are a number of tools that facilitate this.\n * <ul>\n *     <li>Exporting SpriteSheets or HTML5 content from Adobe Flash/Animate supports the EaselJS SpriteSheet format.</li>\n *     <li>The popular <a href="https://www.codeandweb.com/texturepacker/easeljs" target="_blank">Texture Packer</a> has\n *     EaselJS support.\n *     <li>SWF animations in Adobe Flash/Animate can be exported to SpriteSheets using <a href="http://createjs.com/zoe" target="_blank"></a></li>\n * </ul>\n *\n * <h3>Cross Origin Issues</h3>\n * <strong>Warning:</strong> Images loaded cross-origin will throw cross-origin security errors when interacted with\n * using:\n * <ul>\n *     <li>a mouse</li>\n *     <li>methods such as {{#crossLink "Container/getObjectUnderPoint"}}{{/crossLink}}</li>\n *     <li>Filters (see {{#crossLink "Filter"}}{{/crossLink}})</li>\n *     <li>caching (see {{#crossLink "DisplayObject/cache"}}{{/crossLink}})</li>\n * </ul>\n * You can get around this by setting `crossOrigin` property on your images before passing them to EaselJS, or\n * setting the `crossOrigin` property on PreloadJS\' LoadQueue or LoadItems.\n *\n * \t\tvar image = new Image();\n * \t\timg.crossOrigin="Anonymous";\n * \t\timg.src = "http://server-with-CORS-support.com/path/to/image.jpg";\n *\n * If you pass string paths to SpriteSheets, they will not work cross-origin. The server that stores the image must\n * support cross-origin requests, or this will not work. For more information, check out\n * <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS" target="_blank">CORS overview on MDN</a>.\n *\n * @memberof easeljs\n * @extends core.EventDispatcher\n * @param {Object} data An object describing the SpriteSheet data.\n */\nclass SpriteSheet_SpriteSheet extends events_EventDispatcher {\n\n\tconstructor (data) {\n\t\tsuper();\n\n\t\t/**\n\t\t * Indicates whether all images are finished loading.\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t */\n\t\tthis.complete = true;\n\n\t\t/**\n\t\t * Specifies the framerate to use by default for Sprite instances using the SpriteSheet. See the Sprite class\n\t\t * {@link easeljs.Sprite#framerate} for more information.\n\t\t * @type Number\n\t\t */\n\t\tthis.framerate = 0;\n\n\t\t/**\n\t\t * @protected\n\t\t * @type {Array}\n\t\t */\n\t\tthis._animations = null;\n\n\t\t/**\n\t\t * @protected\n\t\t * @type {Array}\n\t\t */\n\t\tthis._frames = null;\n\n\t\t/**\n\t\t * @protected\n\t\t * @type {Array}\n\t\t */\n\t\tthis._images = null;\n\n\t\t/**\n\t\t * @protected\n\t\t * @type {Object}\n\t\t */\n\t\tthis._data = null;\n\n\t\t/**\n\t\t * @protected\n\t\t * @type {Number}\n\t\t */\n\t\tthis._loadCount = 0;\n\n\t\t// only used for simple frame defs:\n\t\t/**\n\t\t * @protected\n\t\t * @type {Number}\n\t\t */\n\t\tthis._frameHeight = 0;\n\n\t\t/**\n\t\t * @protected\n\t\t * @type {Number}\n\t\t */\n\t\tthis._frameWidth = 0;\n\n\t\t/**\n\t\t * @protected\n\t\t * @type {Number}\n\t\t */\n\t\tthis._numFrames = 0;\n\n\t\t/**\n\t\t * @protected\n\t\t * @type {Number}\n\t\t */\n\t\tthis._regX = 0;\n\n\t\t/**\n\t\t * @protected\n\t\t * @type {Number}\n\t\t */\n\t\tthis._regY = 0;\n\n\t\t/**\n\t\t * @protected\n\t\t * @type {Number}\n\t\t */\n\t\tthis._spacing = 0;\n\n\t\t/**\n\t\t * @protected\n\t\t * @type {Number}\n\t\t */\n\t\tthis._margin = 0;\n\n\t\tthis._parseData(data);\n\t}\n\n\t/**\n\t * Returns an array of all available animation names available on this sprite sheet as strings.\n\t * @type {Array}\n\t * @readonly\n\t */\n\tget animations () {\n\t\treturn this._animations.slice();\n\t}\n\n\t/**\n\t * Returns the total number of frames in the specified animation, or in the whole sprite\n\t * sheet if the animation param is omitted. Returns 0 if the spritesheet relies on calculated frame counts, and\n\t * the images have not been fully loaded.\n\t * @param {String} animation The name of the animation to get a frame count for.\n\t * @return {Number} The number of frames in the animation, or in the entire sprite sheet if the animation param is omitted.\n\t */\n\tgetNumFrames (animation) {\n\t\tif (animation == null) {\n\t\t\treturn this._frames ? this._frames.length : this._numFrames || 0;\n\t\t} else {\n\t\t\tlet data = this._data[animation];\n\t\t\tif (data == null) { return 0; }\n\t\t\telse { return data.frames.length; }\n\t\t}\n\t}\n\n\t/**\n\t * Returns an object defining the specified animation. The returned object contains:\n\t * <ul>\n\t * \t<li>frames: an array of the frame ids in the animation</li>\n\t * \t<li>speed: the playback speed for this animation</li>\n\t * \t<li>name: the name of the animation</li>\n\t * \t<li>next: the default animation to play next. If the animation loops, the name and next property will be the same.</li>\n\t * </ul>\n\t * @param {String} name The name of the animation to get.\n\t * @return {Object} a generic object with frames, speed, name, and next properties.\n\t */\n\tgetAnimation (name) {\n\t\treturn this._data[name];\n\t}\n\n\t/**\n\t * Returns an object specifying the image and source rect of the specified frame. The returned object has:\n\t * <ul>\n\t * \t<li>an image property holding a reference to the image object in which the frame is found</li>\n\t * \t<li>a rect property containing a Rectangle instance which defines the boundaries for the frame within that image.</li>\n\t * \t<li> A regX and regY property corresponding to the regX/Y values for the frame.\n\t * </ul>\n\t * @param {Number} frameIndex The index of the frame.\n\t * @return {Object} a generic object with image and rect properties. Returns null if the frame does not exist.\n\t */\n\tgetFrame (frameIndex) {\n\t\tlet frame;\n\t\tif (this._frames && (frame = this._frames[frameIndex])) { return frame; }\n\t\treturn null;\n\t}\n\n\t/**\n\t * Returns a {@link easeljs.Rectangle} instance defining the bounds of the specified frame relative\n\t * to the origin.\n\t *\n\t * @param {Number} frameIndex The index of the frame.\n\t * @param {easeljs.Rectangle} [rectangle] A Rectangle instance to copy the values into. By default a new instance is created.\n\t * @return {easeljs.Rectangle} A Rectangle instance. Returns null if the frame does not exist, or the image is not fully loaded.\n\t */\n\tgetFrameBounds (frameIndex, rectangle = new Rectangle()) {\n\t\tlet frame = this.getFrame(frameIndex);\n\t\treturn frame ? rectangle.setValues(-frame.regX, -frame.regY, frame.rect.width, frame.rect.height) : null;\n\t}\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @return {String} a string representation of the instance.\n\t */\n\ttoString () {\n\t\treturn `[${this.constructor.name}]`;\n\t}\n\n\t/**\n\t * SpriteSheet cannot be cloned. A SpriteSheet can be shared by multiple Sprite instances without cloning it.\n\t * @override\n\t * @throws SpriteSheet cannot be cloned.\n\t */\n\tclone () {\n\t\tthrow "SpriteSheet cannot be cloned.";\n\t}\n\n\t/**\n\t * @param {Object} data An object describing the SpriteSheet data.\n\t * @protected\n\t */\n\t_parseData (data) {\n\t\tif (data == null) { return; }\n\t\tthis.framerate = data.framerate||0;\n\n\t\t// parse images:\n\t\tif (data.images) {\n\t\t\tfor (let img of data.images) {\n\t\t\t\tlet a = this._images = [];\n\t\t\t\tlet src;\n\t\t\t\tif (typeof img === "string") {\n\t\t\t\t\tsrc = img;\n\t\t\t\t\timg = document.createElement("img");\n\t\t\t\t\timg.src = src;\n\t\t\t\t}\n\t\t\t\ta.push(img);\n\t\t\t\tif (!img.getContext && !img.naturalWidth) {\n\t\t\t\t\tthis._loadCount++;\n\t\t\t\t\tthis.complete = false;\n\t\t\t\t\timg.onload = () => this._handleImageLoad(src);\n\t\t\t\t\timg.onerror = () => this._handleImageError(src);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// parse frames:\n\t\tif (data.frames != null) {\n\t\t\tif (Array.isArray(data.frames)) {\n\t\t\t\tthis._frames = [];\n\t\t\t\tfor (let arr of data.frames) {\n\t\t\t\t\tthis._frames.push({image:this._images[arr[4]?arr[4]:0], rect:new Rectangle(arr[0],arr[1],arr[2],arr[3]), regX:arr[5]||0, regY:arr[6]||0 });\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlet o = data.frames;\n\t\t\t\tthis._frameWidth = o.width;\n\t\t\t\tthis._frameHeight = o.height;\n\t\t\t\tthis._regX = o.regX||0;\n\t\t\t\tthis._regY = o.regY||0;\n\t\t\t\tthis._spacing = o.spacing||0;\n\t\t\t\tthis._margin = o.margin||0;\n\t\t\t\tthis._numFrames = o.count;\n\t\t\t\tif (this._loadCount === 0) { this._calculateFrames(); }\n\t\t\t}\n\t\t}\n\n\t\t// parse animations:\n\t\tthis._animations = [];\n\t\tif (data.animations != null) {\n\t\t\tthis._data = {};\n\t\t\tlet o = data.animations;\n\t\t\tfor (let name in o) {\n\t\t\t\tlet anim = { name };\n\t\t\t\tlet obj = o[name];\n\t\t\t\tlet a;\n\t\t\t\tif (typeof obj === "number") { // single frame\n\t\t\t\t\ta = anim.frames = [obj];\n\t\t\t\t} else if (Array.isArray(obj)) { // simple\n\t\t\t\t\tif (obj.length === 1) { anim.frames = [obj[0]]; }\n\t\t\t\t\telse {\n\t\t\t\t\t\tanim.speed = obj[3];\n\t\t\t\t\t\tanim.next = obj[2];\n\t\t\t\t\t\ta = anim.frames = [];\n\t\t\t\t\t\tfor (let i=obj[0];i<=obj[1];i++) {\n\t\t\t\t\t\t\ta.push(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else { // complex\n\t\t\t\t\tanim.speed = obj.speed;\n\t\t\t\t\tanim.next = obj.next;\n\t\t\t\t\tlet frames = obj.frames;\n\t\t\t\t\ta = anim.frames = (typeof frames === "number") ? [frames] : frames.slice(0);\n\t\t\t\t}\n\t\t\t\tif (anim.next === true || anim.next === undefined) { anim.next = name; } // loop\n\t\t\t\tif (anim.next === false || (a.length < 2 && anim.next === name)) { anim.next = null; } // stop\n\t\t\t\tif (!anim.speed) { anim.speed = 1; }\n\t\t\t\tthis._animations.push(name);\n\t\t\t\tthis._data[name] = anim;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @emits easeljs.SpriteSheet#event:complete\n\t * @protected\n\t * @param {Object} src\n\t */\n\t _handleImageLoad (src) {\n\t\tif (--this._loadCount === 0) {\n\t\t\tthis._calculateFrames();\n\t\t\tthis.complete = true;\n\t\t\tthis.dispatchEvent("complete");\n\t\t}\n\t}\n\n\t/**\n\t * @emits easeljs.SpriteSheet#event:complete\n\t * @emits easeljs.SpriteSheet#event:error\n\t * @protected\n\t * @param {Object} src\n\t */\n\t_handleImageError (src) {\n\t\tlet errorEvent = new events_Event("error");\n\t\terrorEvent.src = src;\n\t\tthis.dispatchEvent(errorEvent);\n\n\t\t// Complete is still dispatched.\n\t\tif (--this._loadCount === 0) {\n\t\t\tthis.dispatchEvent("complete");\n\t\t}\n\t}\n\n\t/**\n\t * @protected\n\t */\n\t_calculateFrames () {\n\t\tif (this._frames || this._frameWidth === 0) { return; }\n\n\t\tthis._frames = [];\n\n\t\tlet maxFrames = this._numFrames || 100000; // if we go over this, something is wrong.\n\t\tlet frameCount = 0, frameWidth = this._frameWidth, frameHeight = this._frameHeight;\n\t\tlet spacing = this._spacing, margin = this._margin;\n\n\t\timgLoop:\n\t\tfor (let i=0, imgs=this._images, l=imgs.length; i<l; i++) {\n\t\t\tlet img = imgs[i],\n\t\t\t\timgW = (img.width||img.naturalWidth),\n\t\t\t\timgH = (img.height||img.naturalHeight);\n\n\t\t\tlet y = margin;\n\t\t\twhile (y <= imgH-margin-frameHeight) {\n\t\t\t\tlet x = margin;\n\t\t\t\twhile (x <= imgW-margin-frameWidth) {\n\t\t\t\t\tif (frameCount >= maxFrames) { break imgLoop; }\n\t\t\t\t\tframeCount++;\n\t\t\t\t\tthis._frames.push({\n\t\t\t\t\t\timage: img,\n\t\t\t\t\t\trect: new Rectangle(x, y, frameWidth, frameHeight),\n\t\t\t\t\t\tregX: this._regX,\n\t\t\t\t\t\tregY: this._regY\n\t\t\t\t\t});\n\t\t\t\t\tx += frameWidth+spacing;\n\t\t\t\t}\n\t\t\t\ty += frameHeight+spacing;\n\t\t\t}\n\t\t}\n\t\tthis._numFrames = frameCount;\n\t}\n\n}\n\n/**\n * Dispatched when all images are loaded.  Note that this only fires if the images\n * were not fully loaded when the sprite sheet was initialized. You should check the complete property\n * to prior to adding a listener. Ex.\n *\n * \tvar sheet = new createjs.SpriteSheet(data);\n * \tif (!sheet.complete) {\n * \t\t// not preloaded, listen for the complete event:\n * \t\tsheet.addEventListener("complete", handler);\n * \t}\n *\n * @event easeljs.SpriteSheet#complete\n * @property {Object} target The object that dispatched the event.\n * @property {String} type The event type.\n * @since 0.6.0\n */\n\n/**\n * Dispatched when getFrame is called with a valid frame index. This is primarily intended for use by {@link easeljs.SpriteSheetBuilder}\n * when doing on-demand rendering.\n * @event easeljs.SpriteSheet#getframe\n * @property {Number} index The frame index.\n * @property {Object} frame The frame object that getFrame will return.\n */\n\n/**\n * Dispatched when an image encounters an error. A SpriteSheet will dispatch an error event for each image that\n * encounters an error, and will still dispatch a {@link easeljs.SpriteSheet#event:complete}\n * event once all images are finished processing, even if an error is encountered.\n * @event easeljs.SpriteSheet#error\n * @property {String} src The source of the image that failed to load.\n * @since 0.8.2\n */\n\n// CONCATENATED MODULE: ./node_modules/@createjs/easeljs/src/display/Text.js\n/**\n * @license Text\n * Visit http://createjs.com/ for documentation, updates and examples.\n *\n * Copyright (c) 2017 gskinner.com, inc.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the "Software"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n\n\n\n/**\n * Display one or more lines of dynamic text (not user editable) in the display list. Line wrapping support (using the\n * lineWidth) is very basic, wrapping on spaces and tabs only. Note that as an alternative to Text, you can position HTML\n * text above or below the canvas relative to items in the display list using the {@link easeljs.DisplayObject#localToGlobal}\n * method, or using {@link easeljs.DOMElement}.\n *\n * <b>Please note that Text does not support HTML text, and can only display one font style at a time.</b> To use\n * multiple font styles, you will need to create multiple text instances, and position them manually.\n *\n * CreateJS Text supports web fonts (the same rules as Canvas). The font must be loaded and supported by the browser\n * before it can be displayed.\n *\n * <strong>Note:</strong> Text can be expensive to generate, so cache instances where possible. Be aware that not all\n * browsers will render Text exactly the same.\n *\n * @memberof easeljs\n * @extends easeljs.DisplayObject\n * @example\n * let text = new Text("Hello World", "20px Arial", "#ff7700");\n * text.x = 100;\n * text.textBaseline = "alphabetic";\n *\n * @param {String} [text] The text to display.\n * @param {String} [font] The font style to use. Any valid value for the CSS font attribute is acceptable (ex. "bold\n * 36px Arial").\n * @param {String} [color] The color to draw the text in. Any valid value for the CSS color attribute is acceptable (ex.\n * "#F00", "red", or "#FF0000").\n */\nclass Text_Text extends DisplayObject_DisplayObject {\n\n\tconstructor (text, font, color) {\n\t\tsuper();\n\n\t\t/**\n\t\t * The text to display.\n\t\t * @type {String}\n\t\t */\n\t\tthis.text = text;\n\n\t\t/**\n\t\t * The font style to use. Any valid value for the CSS font attribute is acceptable (ex. "bold 36px Arial").\n\t\t * @type {String}\n\t\t */\n\t\tthis.font = font;\n\n\t\t/**\n\t\t * The color to draw the text in. Any valid value for the CSS color attribute is acceptable (ex. "#F00"). Default is "#000".\n\t\t * It will also accept valid canvas fillStyle values.\n\t\t * @type {String}\n\t\t */\n\t\tthis.color = color;\n\n\t\t/**\n\t\t * The horizontal text alignment. Any of "start", "end", "left", "right", and "center".\n\t\t * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#text-styles "WHATWG spec"}\n\t\t * @type {String}\n\t\t * @default left\n\t\t */\n\t\tthis.textAlign = "left";\n\n\t\t/**\n\t\t * The vertical alignment point on the font. Any of "top", "hanging", "middle", "alphabetic", "ideographic", or "bottom".\n\t\t * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#text-styles "WHATWG spec"}\n\t\t * @type {String}\n\t\t * @default top\n\t\t*/\n\t\tthis.textBaseline = "top";\n\n\t\t/**\n\t\t * The maximum width to draw the text. If maxWidth is specified (not null), the text will be condensed or\n\t\t * shrunk to make it fit in this width.\n\t\t * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#text-styles "WHATWG spec"}\n\t\t * @type {Number}\n\t\t*/\n\t\tthis.maxWidth = null;\n\n\t\t/**\n\t\t * If greater than 0, the text will be drawn as a stroke (outline) of the specified width.\n\t\t * @type {Number}\n\t\t */\n\t\tthis.outline = 0;\n\n\t\t/**\n\t\t * Indicates the line height (vertical distance between baselines) for multi-line text. If null or 0,\n\t\t * the value of getMeasuredLineHeight is used.\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.lineHeight = 0;\n\n\t\t/**\n\t\t * Indicates the maximum width for a line of text before it is wrapped to multiple lines. If null,\n\t\t * the text will not be wrapped.\n\t\t * @type {Number}\n\t\t */\n\t\tthis.lineWidth = null;\n\t}\n\n \tisVisible () {\n \t\tlet hasContent = this.cacheCanvas || (this.text != null && this.text !== "");\n \t\treturn !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0 && hasContent);\n \t}\n\n \tdraw (ctx, ignoreCache) {\n \t\tif (super.draw(ctx, ignoreCache)) { return true; }\n\n \t\tlet col = this.color || "#000";\n \t\tif (this.outline) { ctx.strokeStyle = col; ctx.lineWidth = this.outline*1; }\n \t\telse { ctx.fillStyle = col; }\n\n \t\tthis._drawText(this._prepContext(ctx));\n \t\treturn true;\n \t}\n\n \t/**\n \t * Returns the measured, untransformed width of the text without wrapping. Use getBounds for a more robust value.\n \t * @return {Number} The measured, untransformed width of the text.\n \t */\n \tgetMeasuredWidth () {\n \t\treturn this._getMeasuredWidth(this.text);\n \t}\n\n \t/**\n \t * Returns an approximate line height of the text, ignoring the lineHeight property. This is based on the measured\n \t * width of a "M" character multiplied by 1.2, which provides an approximate line height for most fonts.\n \t * @return {Number} an approximate line height of the text, ignoring the lineHeight property. This is\n \t * based on the measured width of a "M" character multiplied by 1.2, which approximates em for most fonts.\n \t */\n \tgetMeasuredLineHeight () {\n \t\treturn this._getMeasuredWidth("M")*1.2;\n \t}\n\n \t/**\n \t * Returns the approximate height of multi-line text by multiplying the number of lines against either the\n \t * `lineHeight` (if specified) or {@link easeljs.Text#getMeasuredLineHeight}. Note that\n \t * this operation requires the text flowing logic to run, which has an associated CPU cost.\n \t * @return {Number} The approximate height of the untransformed multi-line text.\n \t */\n \tgetMeasuredHeight () {\n \t\treturn this._drawText(null, {}).height;\n \t}\n\n \tgetBounds () {\n \t\tlet rect = super.getBounds();\n \t\tif (rect) { return rect; }\n \t\tif (this.text == null || this.text === "") { return null; }\n \t\tlet o = this._drawText(null, {});\n \t\tlet w = (this.maxWidth && this.maxWidth < o.width) ? this.maxWidth : o.width;\n \t\tlet x = w * Text_Text.H_OFFSETS[this.textAlign||"left"];\n \t\tlet lineHeight = this.lineHeight||this.getMeasuredLineHeight();\n \t\tlet y = lineHeight * Text_Text.V_OFFSETS[this.textBaseline||"top"];\n \t\treturn this._rectangle.setValues(x, y, w, o.height);\n \t}\n\n \t/**\n \t * Returns an object with width, height, and lines properties. The width and height are the visual width and height\n \t * of the drawn text. The lines property contains an array of strings, one for\n \t * each line of text that will be drawn, accounting for line breaks and wrapping. These strings have trailing\n \t * whitespace removed.\n \t * @return {Object} An object with width, height, and lines properties.\n \t */\n \tgetMetrics () {\n \t\tlet o = {lines:[]};\n \t\to.lineHeight = this.lineHeight || this.getMeasuredLineHeight();\n \t\to.vOffset = o.lineHeight * Text_Text.V_OFFSETS[this.textBaseline||"top"];\n \t\treturn this._drawText(null, o, o.lines);\n \t}\n\n \t/**\n \t * Returns a clone of the Text instance.\n \t * @return {easeljs.Text} a clone of the Text instance.\n \t */\n \tclone () {\n \t\treturn this._cloneProps(new Text_Text(this.text, this.font, this.color));\n \t}\n\n \t/**\n \t * Returns a string representation of this object.\n \t * @override\n \t * @return {String} a string representation of the instance.\n \t */\n \ttoString () {\n \t\treturn `[${this.constructor.name} (text=${this.text.length > 20 ? `${this.text.substr(0, 17)}...` : this.text})]`;\n \t}\n\n \t/**\n \t * @param {easeljs.Text} o\n \t * @protected\n \t * @return {easeljs.Text} o\n \t */\n \t_cloneProps (o) {\n \t\tsuper._cloneProps(o);\n \t\to.textAlign = this.textAlign;\n \t\to.textBaseline = this.textBaseline;\n \t\to.maxWidth = this.maxWidth;\n \t\to.outline = this.outline;\n \t\to.lineHeight = this.lineHeight;\n \t\to.lineWidth = this.lineWidth;\n \t\treturn o;\n \t}\n\n \t/**\n \t * @param {CanvasRenderingContext2D} ctx\n \t * @return {CanvasRenderingContext2D}\n \t * @protected\n \t */\n \t_prepContext (ctx) {\n \t\tctx.font = this.font||"10px sans-serif";\n \t\tctx.textAlign = this.textAlign||"left";\n \t\tctx.textBaseline = this.textBaseline||"top";\n\t\tctx.lineJoin = "miter";\n\t\tctx.miterLimit = 2.5;\n\t\treturn ctx;\n\t}\n\n\t/**\n\t * Draws multiline text.\n\t * @param {CanvasRenderingContext2D} ctx\n\t * @param {Object} o\n\t * @param {Array} lines\n\t * @return {Object}\n\t * @protected\n\t */\n \t_drawText (ctx, o, lines) {\n \t\tconst paint = !!ctx;\n \t\tif (!paint) {\n \t\t\tctx = Text_Text._ctx;\n \t\t\tctx.save();\n \t\t\tthis._prepContext(ctx);\n \t\t}\n \t\tlet lineHeight = this.lineHeight||this.getMeasuredLineHeight();\n\n \t\tlet maxW = 0, count = 0;\n \t\tlet hardLines = String(this.text).split(/(?:\\r\\n|\\r|\\n)/);\n \t\tfor (let str of hardLines) {\n \t\t\tlet w = null;\n\n \t\t\tif (this.lineWidth != null && (w = ctx.measureText(str).width) > this.lineWidth) {\n \t\t\t\t// text wrapping:\n \t\t\t\tlet words = str.split(/(\\s)/);\n \t\t\t\tstr = words[0];\n \t\t\t\tw = ctx.measureText(str).width;\n\n\t\t\t\tconst l = words.length;\n \t\t\t\tfor (let i=1; i<l; i+=2) {\n \t\t\t\t\t// Line needs to wrap:\n \t\t\t\t\tlet wordW = ctx.measureText(words[i] + words[i+1]).width;\n \t\t\t\t\tif (w + wordW > this.lineWidth) {\n \t\t\t\t\t\tif (paint) { this._drawTextLine(ctx, str, count*lineHeight); }\n \t\t\t\t\t\tif (lines) { lines.push(str); }\n \t\t\t\t\t\tif (w > maxW) { maxW = w; }\n \t\t\t\t\t\tstr = words[i+1];\n \t\t\t\t\t\tw = ctx.measureText(str).width;\n \t\t\t\t\t\tcount++;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tstr += words[i] + words[i+1];\n \t\t\t\t\t\tw += wordW;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n\n \t\t\tif (paint) { this._drawTextLine(ctx, str, count*lineHeight); }\n \t\t\tif (lines) { lines.push(str); }\n \t\t\tif (o && w == null) { w = ctx.measureText(str).width; }\n \t\t\tif (w > maxW) { maxW = w; }\n \t\t\tcount++;\n \t\t}\n\n \t\tif (o) {\n \t\t\to.width = maxW;\n \t\t\to.height = count*lineHeight;\n \t\t}\n \t\tif (!paint) { ctx.restore(); }\n \t\treturn o;\n \t}\n\n \t/**\n \t * @param {CanvasRenderingContext2D} ctx\n \t * @param {String} text\n \t * @param {Number} y\n \t * @protected\n \t */\n \t_drawTextLine (ctx, text, y) {\n \t\t// Chrome 17 will fail to draw the text if the last param is included but null, so we feed it a large value instead:\n \t\tif (this.outline) { ctx.strokeText(text, 0, y, this.maxWidth||0xFFFF); }\n \t\telse { ctx.fillText(text, 0, y, this.maxWidth||0xFFFF); }\n \t}\n\n \t/**\n \t * @param {String} text\n \t * @protected\n \t */\n \t_getMeasuredWidth (text) {\n \t\tlet ctx = Text_Text._ctx;\n \t\tctx.save();\n \t\tlet w = this._prepContext(ctx).measureText(text).width;\n \t\tctx.restore();\n \t\treturn w;\n \t}\n\n}\n\n/**\n * Lookup table for the ratio to offset bounds x calculations based on the textAlign property.\n * @type {Object}\n * @readonly\n * @static\n */\nText_Text.H_OFFSETS = {start: 0, left: 0, center: -0.5, end: -1, right: -1};\n/**\n * Lookup table for the ratio to offset bounds y calculations based on the textBaseline property.\n * @type {Object}\n * @readonly\n * @static\n */\nText_Text.V_OFFSETS = {top: 0, hanging: -0.01, middle: -0.4, alphabetic: -0.8, ideographic: -0.85, bottom: -1};\n\n/**\n * @property _ctx\n * @type {CanvasRenderingContext2D}\n * @private\n * @static\n */\nText_Text._ctx = createCanvas().getContext("2d");\n\n// CONCATENATED MODULE: ./node_modules/@createjs/easeljs/src/filters/AlphaMapFilter.js\n/**\n * @license AlphaMapFilter\n * Visit http://createjs.com/ for documentation, updates and examples.\n *\n * Copyright (c) 2017 gskinner.com, inc.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the "Software"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n\n\n/**\n * Applies a greyscale alpha map image (or canvas) to the target, such that the alpha channel of the result will\n * be copied from the red channel of the map, and the RGB channels will be copied from the target.\n *\n * Generally, it is recommended that you use {@link easeljs.AlphaMaskFilter}, because it has much better performance.\n *\n * @memberof easeljs\n * @extends easeljs.Filter\n * @example *\n * let box = new Shape();\n * box.graphics.beginLinearGradientFill(["#ff0000", "#0000ff"], [0, 1], 0, 0, 0, 100)\n * box.graphics.drawRect(0, 0, 100, 100);\n * box.cache(0, 0, 100, 100);\n * let bmp = new Bitmap("path/to/image.jpg");\n * bmp.filters = [ new AlphaMapFilter(box.cacheCanvas) ];\n * bmp.cache(0, 0, 100, 100);\n *\n * @param {HTMLImageElement | HTMLCanvasElement} alphaMap The greyscale image (or canvas) to use as the alpha value for the\n * result. This should be exactly the same dimensions as the target.\n */\nclass AlphaMapFilter_AlphaMapFilter extends Filter {\n\n\tconstructor (alphaMap) {\n\t\tsuper();\n\n\t\t/**\n\t\t * The greyscale image (or canvas) to use as the alpha value for the result. This should be exactly the same\n\t\t * dimensions as the target.\n\t\t * @type {HTMLImageElement | HTMLCanvasElement}\n\t\t */\n\t\tthis.alphaMap = alphaMap;\n\n\t\t/**\n\t\t * @protected\n\t\t * @type {HTMLImageElement | HTMLCanvasElement}\n\t\t * @default null\n\t\t */\n\t\tthis._alphaMap = null;\n\n\t\t/**\n\t\t * @protected\n\t\t * @type {Uint8ClampedArray}\n\t\t * @default null\n\t\t */\n\t\tthis._mapData = null;\n\n\t\t/**\n\t\t * @protected\n\t\t * @type {*}\n\t\t * @default null\n\t\t */\n\t\tthis._mapTexture = null;\n\n\t\tthis.FRAG_SHADER_BODY = `\n\t\t\tuniform sampler2D uAlphaSampler;\n\n\t\t\tvoid main (void) {\n\t\t\t\tvec4 color = texture2D(uSampler, vRenderCoord);\n\t\t\t\tvec4 alphaMap = texture2D(uAlphaSampler, vTextureCoord);\n\n\t\t\t\t// some image formats can have transparent white rgba(1,1,1, 0) when put on the GPU, this means we need a slight tweak\n\t\t\t\t// using ceil ensure that the colour will be used so long as it exists but pure transparency will be treated black\n\t\t\t\tgl_FragColor = vec4(color.rgb, color.a * (alphaMap.r * ceil(alphaMap.a)));\n\t\t\t}\n\t\t`;\n\t}\n\n\t/**\n\t * @todo docs\n\t * @param {*} gl\n\t * @param {*} stage\n\t * @param {*} shaderProgram\n\t */\n\tshaderParamSetup (gl, stage, shaderProgram) {\n\t\tif (!this._mapTexture) { this._mapTexture = gl.createTexture(); }\n\n\t\tgl.activeTexture(gl.TEXTURE1);\n\t\tgl.bindTexture(gl.TEXTURE_2D, this._mapTexture);\n\t\tstage.setTextureParams(gl);\n\t\tgl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.alphaMap);\n\n\t\tgl.uniform1i(\n\t\t\tgl.getUniformLocation(shaderProgram, "uAlphaSampler"),\n\t\t\t1\n\t\t);\n\t}\n\n\t/**\n\t * @return {easeljs.AlphaMapFilter}\n\t */\n\tclone () {\n\t\tlet o = new AlphaMapFilter_AlphaMapFilter(this.alphaMap);\n\t\to._alphaMap = this._alphaMap;\n\t\to._mapData = this._mapData;\n\t\treturn o;\n\t}\n\n\t_applyFilter (imageData) {\n\t\tif (!this.alphaMap) { return true; }\n\t\tif (!this._prepAlphaMap()) { return false; }\n\n\t\t// TODO: update to support scenarios where the target has different dimensions.\n\t\tlet data = imageData.data;\n\t\tlet map = this._mapData;\n\t\tconst l = data.length;\n\t\tfor (let i=0; i<l; i += 4) { data[i + 3] = map[i] || 0; }\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * @protected\n\t */\n\t_prepAlphaMap () {\n\t\tif (!this.alphaMap) { return false; }\n\t\tif (this.alphaMap === this._alphaMap && this._mapData) { return true; }\n\t\tthis._mapData = null;\n\n\t\tlet map = this._alphaMap = this.alphaMap;\n\t\tlet canvas = map;\n\t\tlet ctx;\n\t\tif (map instanceof HTMLCanvasElement) {\n\t\t\tctx = canvas.getContext("2d");\n\t\t} else {\n\t\t\tcanvas = window.createjs && createjs.createCanvas ? createjs.createCanvas() : document.createElement("canvas");\n\t\t\tcanvas.width = map.width;\n\t\t\tcanvas.height = map.height;\n\t\t\tctx = canvas.getContext("2d");\n\t\t\tctx.drawImage(map, 0, 0);\n\t\t}\n\n\t\ttry {\n\t\t\tthis._mapData = ctx.getImageData(0, 0, map.width, map.height).data\n\t\t\treturn true;\n\t\t} catch (e) {\n\t\t\t//if (!this.suppressCrossDomainErrors) throw new Error("unable to access local image data: " + e);\n\t\t\treturn false;\n\t\t}\n\t}\n\n}\n\n// CONCATENATED MODULE: ./node_modules/@createjs/easeljs/src/filters/AlphaMaskFilter.js\n/**\n * @license AlphaMaskFilter\n * Visit http://createjs.com/ for documentation, updates and examples.\n *\n * Copyright (c) 2017 gskinner.com, inc.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the "Software"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n\n\n/**\n * Applies the alpha from the mask image (or canvas) to the target, such that the alpha channel of the result will\n * be derived from the mask, and the RGB channels will be copied from the target. This can be used, for example, to\n * apply an alpha mask to a display object. This can also be used to combine a JPG compressed RGB image with a PNG32\n * alpha mask, which can result in a much smaller file size than a single PNG32 containing ARGB.\n *\n * <b>IMPORTANT NOTE: This filter currently does not support the targetCtx, or targetX/Y parameters correctly.</b>\n *\n * @memberof easeljs\n * @extends easeljs.Filter\n * @example\n * var box = new Shape();\n * box.graphics.beginLinearGradientFill(["#000000", "rgba(0, 0, 0, 0)"], [0, 1], 0, 0, 100, 100)\n * box.graphics.drawRect(0, 0, 100, 100);\n * box.cache(0, 0, 100, 100);\n * var bmp = new Bitmap("path/to/image.jpg");\n * bmp.filters = [ new AlphaMaskFilter(box.cacheCanvas) ];\n * bmp.cache(0, 0, 100, 100);\n *\n * @param {HTMLImageElement | HTMLCanvasElement} mask\n */\nclass AlphaMaskFilter_AlphaMaskFilter extends Filter {\n\n\tconstructor (mask) {\n\t\tsuper();\n\n\t\t/**\n\t\t * The image (or canvas) to use as the mask.\n\t\t * @type {HTMLImageElement | HTMLCanvasElement}\n\t\t */\n\t\tthis.mask = mask;\n\n\t\tthis.usesContext = true;\n\n\t\tthis.FRAG_SHADER_BODY = `\n\t\t\tuniform sampler2D uAlphaSampler;\n\n\t\t\tvoid main (void) {\n\t\t\t\tvec4 color = texture2D(uSampler, vRenderCoord);\n\t\t\t\tvec4 alphaMap = texture2D(uAlphaSampler, vTextureCoord);\n\n\t\t\t\tgl_FragColor = vec4(color.rgb, color.a * alphaMap.a);\n\t\t\t}\n\t\t`;\n\t}\n\n\t/**\n\t * Applies the filter to the specified context.\n\t *\n\t * <strong>IMPORTANT NOTE: This filter currently does not support the targetCtx, or targetX/Y parameters correctly.</strong>\n\t * @param {CanvasRenderingContext2D} ctx The 2D context to use as the source.\n\t * @param {Number} x The x position to use for the source rect.\n\t * @param {Number} y The y position to use for the source rect.\n\t * @param {Number} width The width to use for the source rect.\n\t * @param {Number} height The height to use for the source rect.\n\t * @param {CanvasRenderingContext2D} [targetCtx] NOT SUPPORTED IN THIS FILTER. The 2D context to draw the result to. Defaults to the context passed to ctx.\n\t * @param {Number} [targetX] NOT SUPPORTED IN THIS FILTER. The x position to draw the result to. Defaults to the value passed to x.\n\t * @param {Number} [targetY] NOT SUPPORTED IN THIS FILTER. The y position to draw the result to. Defaults to the value passed to y.\n\t * @return {Boolean} If the filter was applied successfully.\n\t */\n\tapplyFilter (ctx, x, y, width, height, targetCtx, targetX, targetY) {\n\t\tif (!this.mask) { return true; }\n\t\ttargetCtx = targetCtx || ctx;\n\t\tif (targetX == null) { targetX = x; }\n\t\tif (targetY == null) { targetY = y; }\n\n\t\ttargetCtx.save();\n\t\tif (ctx != targetCtx) {\n\t\t\t// TODO: support targetCtx and targetX/Y\n\t\t\t// clearRect, then draw the ctx in?\n\t\t\treturn false;\n\t\t}\n\n\t\ttargetCtx.globalCompositeOperation = "destination-in";\n\t\ttargetCtx.drawImage(this.mask, targetX, targetY);\n\t\ttargetCtx.restore();\n\t\treturn true;\n\t}\n\n\t/**\n\t * @return {easeljs.AlphaMaskFilter}\n\t */\n\tclone () {\n\t\treturn new AlphaMaskFilter_AlphaMaskFilter(this.mask);\n\t}\n\n\t/**\n\t * @todo docs\n\t * @param {*} gl\n\t * @param {*} stage\n\t * @param {*} shaderProgram\n\t */\n\tshaderParamSetup (gl, stage, shaderProgram) {\n\t\tif(!this._mapTexture) { this._mapTexture = gl.createTexture(); }\n\n\t\tgl.activeTexture(gl.TEXTURE1);\n\t\tgl.bindTexture(gl.TEXTURE_2D, this._mapTexture);\n\t\tstage.setTextureParams(gl);\n\t\tgl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.mask);\n\n\t\tgl.uniform1i(\n\t\t\tgl.getUniformLocation(shaderProgram, "uAlphaSampler"),\n\t\t\t1\n\t\t);\n\t}\n\n}\n\n// CONCATENATED MODULE: ./node_modules/@createjs/easeljs/src/filters/BlurFilter.js\n/**\n * @license BlurFilter\n * Visit http://createjs.com/ for documentation, updates and examples.\n *\n * Copyright (c) 2017 gskinner.com, inc.\n *\n * BoxBlur Algorithm by Mario Klingemann, quasimondo.com\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the "Software"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n\n\n\n/**\n * Applies a box blur to DisplayObjects. Note that this filter is fairly CPU intensive, particularly if the quality is\n * set higher than 1.\n *\n * @memberof easeljs\n * @extends easeljs.Filter\n * @example\n * let shape = new Shape().set({x:100,y:100});\n * shape.graphics.beginFill("#ff0000").drawCircle(0,0,50);\n * let blurFilter = new BlurFilter(5, 5, 1);\n * shape.filters = [blurFilter];\n * let bounds = blurFilter.getBounds();\n * shape.cache(-50+bounds.x, -50+bounds.y, 100+bounds.width, 100+bounds.height);\n *\n * @param {Number} [blurX=0] The horizontal blur radius in pixels.\n * @param {Number} [blurY=0] The vertical blur radius in pixels.\n * @param {Number} [quality=1] The number of blur iterations.\n */\nclass BlurFilter_BlurFilter extends Filter {\n\n\tconstructor (blurX = 0, blurY = 0, quality = 1) {\n\t\tsuper();\n\n\t\t/**\n\t\t * @protected\n\t\t * @default 0\n\t\t * @type {Number}\n\t\t */\n\t\tthis._blurX = blurX;\n\t\t/**\n\t\t * @protected\n\t\t * @type {Array}\n\t\t */\n\t\tthis._blurXTable = [];\n\t\t/**\n\t\t * @protected\n\t\t * @type {Number}\n\t\t * @default null\n\t\t */\n\t\tthis._lastBlurX = null;\n\n\t\t/**\n\t\t * @default 0\n\t\t * @type {Number}\n\t\t */\n\t\tthis._blurY = blurY;\n\t\t/**\n\t\t * @protected\n\t\t * @type {Array}\n\t\t */\n\t\tthis._blurYTable = [];\n\t\t/**\n\t\t * @protected\n\t\t * @type {Number}\n\t\t * @default null\n\t\t */\n\t\tthis._lastBlurY = null;\n\n\t\t/**\n\t\t * Number of blur iterations. For example, a value of 1 will produce a rough blur. A value of 2 will produce a\n\t\t * smoother blur, but take twice as long to run.\n\t\t * @default 1\n\t\t * @type {Number}\n\t\t */\n\t\tthis._quality = (isNaN(quality) || quality < 1) ? 1 : quality;\n\t\t/**\n\t\t * @protected\n\t\t * @type {Number}\n\t\t * @default null\n\t\t */\n\t\tthis._lastQuality = null;\n\n\t\tthis.FRAG_SHADER_TEMPLATE = `\n\t\t\tuniform float xWeight[{{blurX}}];\n\t\t\tuniform float yWeight[{{blurY}}];\n\t\t\tuniform vec2 textureOffset;\n\t\t\tvoid main (void) {\n\t\t\t\tvec4 color = vec4(0.0);\n\n\t\t\t\tfloat xAdj = ({{blurX}}.0-1.0)/2.0;\n\t\t\t\tfloat yAdj = ({{blurY}}.0-1.0)/2.0;\n\t\t\t\tvec2 sampleOffset;\n\n\t\t\t\tfor(int i=0; i<{{blurX}}; i++) {\n\t\t\t\t\tfor(int j=0; j<{{blurY}}; j++) {\n\t\t\t\t\t\tsampleOffset = vRenderCoord + (textureOffset * vec2(float(i)-xAdj, float(j)-yAdj));\n\t\t\t\t\t\tcolor += texture2D(uSampler, sampleOffset) * (xWeight[i] * yWeight[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = color.rgba;\n\t\t\t}\n\t\t`;\n\t}\n\n\t/**\n\t * Horizontal blur radius in pixels.\n\t * @type {Number}\n\t */\n\tget blurX () { return this._blurX; }\n\tset blurX (blurX) {\n\t\tif (isNaN(blurX) || blurX < 0) { blurX = 0; }\n\t\tthis._blurX = blurX;\n\t}\n\n\t/**\n\t * Vertical blur radius in pixels.\n\t * @type {Number}\n\t */\n\tget blurY () { return this._blurY; }\n\tset blurY (blurY) {\n\t\tif (isNaN(blurY) || blurY < 0) { blurY = 0; }\n\t\tthis._blurY = blurY;\n\t}\n\n\t/**\n\t * Number of blur iterations. For example, a value of 1 will produce a rough blur. A value of 2 will produce a\n\t * smoother blur, but take twice as long to run.\n\t * @type {Number}\n\t */\n\tget quality () { return this._quality | 0; }\n\tset quality (quality) {\n\t\tif (isNaN(quality) || quality < 0) { quality = 0; }\n\t\tthis._quality = quality;\n\t}\n\n\t/**\n\t * @protected\n\t * @type {*}\n\t */\n\tget _buildShader () {\n\t\tconst xChange = this._lastBlurX !== this._blurX;\n\t\tconst yChange = this._lastBlurY !== this._blurY;\n\t\tconst qChange = this._lastQuality !== this._quality;\n\t\tif (xChange || yChange || qChange) {\n\t\t\t\tif (xChange || qChange) { this._blurXTable = this._getTable(this._blurX * this._quality); }\n\t\t\t\tif (yChange || qChange) { this._blurYTable = this._getTable(this._blurY * this._quality); }\n\t\t\t\tthis._updateShader();\n\t\t\t\tthis._lastBlurX = this._blurX;\n\t\t\t\tthis._lastBlurY = this._blurY;\n\t\t\t\tthis._lastQuality = this._quality;\n\t\t\t\treturn undefined; // force a rebuild\n\t\t}\n\t\treturn this._compiledShader;\n\t}\n\tset _builtShader (value) { this._compiledShader = value; }\n\n\tshaderParamSetup (gl, stage, shaderProgram) {\n\t\t// load the normalized gaussian weight tables\n\t\tgl.uniform1fv(\n\t\t\tgl.getUniformLocation(shaderProgram, "xWeight"),\n\t\t\tthis._blurXTable\n\t\t);\n\t\tgl.uniform1fv(\n\t\t\tgl.getUniformLocation(shaderProgram, "yWeight"),\n\t\t\tthis._blurYTable\n\t\t);\n\n\t\t// what is the size of a single pixel in -1, 1 (webGL) space\n\t\tgl.uniform2f(\n\t\t\tgl.getUniformLocation(shaderProgram, "textureOffset"),\n\t\t\t2/(stage._viewportWidth*this._quality), 2/(stage._viewportHeight*this._quality)\n\t\t);\n\t}\n\n\tgetBounds (rect) {\n\t\tlet x = this.blurX|0, y = this.blurY| 0;\n\t\tif (x <= 0 && y <= 0) { return rect; }\n\t\tlet q = Math.pow(this.quality, 0.2);\n\t\treturn (rect || new Rectangle()).pad(y*q+1,x*q+1,y*q+1,x*q+1);\n\t}\n\n\t/**\n\t * @return {easeljs.BlurFilter}\n\t */\n\tclone () {\n\t\treturn new BlurFilter_BlurFilter(this.blurX, this.blurY, this.quality);\n\t}\n\n\t_updateShader () {\n\t\tlet result = this.FRAG_SHADER_TEMPLATE;\n\t\tresult = result.replace(/{{blurX}}/g, this._blurXTable.length.toFixed(0));\n\t\tresult = result.replace(/{{blurY}}/g, this._blurYTable.length.toFixed(0));\n\t\tthis.FRAG_SHADER_BODY = result;\n\t}\n\n\t_getTable (spread) {\n\t\tconst EDGE = 4.2;\n\t\tif (spread <= 1) { return [1]; }\n\n\t\tlet result = [];\n\t\tlet count = Math.ceil(spread*2);\n\t\tcount += (count%2)?0:1;\n\t\tlet adjust = (count/2)|0;\n\t\tfor (let i = -adjust; i<=adjust; i++) {\n\t\t\tlet x = (i/adjust)*EDGE;\n\t\t\tresult.push(1/Math.sqrt(2*Math.PI) * Math.pow(Math.E, -(Math.pow(x,2)/4)));\n\t\t}\n\t\tlet factor = result.reduce((a, b) => a + b, 0);\n\t\treturn result.map(currentValue => currentValue / factor);\n\t}\n\n\t_applyFilter (imageData) {\n\t\tlet radiusX = this._blurX >> 1;\n\t\tif (isNaN(radiusX) || radiusX < 0) return false;\n\t\tlet radiusY = this._blurY >> 1;\n\t\tif (isNaN(radiusY) || radiusY < 0) return false;\n\t\tif (radiusX === 0 && radiusY === 0) return false;\n\n\t\tlet iterations = this.quality;\n\t\tif (isNaN(iterations) || iterations < 1) iterations = 1;\n\t\titerations |= 0;\n\t\tif (iterations > 3) iterations = 3;\n\t\tif (iterations < 1) iterations = 1;\n\n\t\tlet px = imageData.data;\n\t\tlet x=0, y=0, i=0, p=0, yp=0, yi=0, yw=0, r=0, g=0, b=0, a=0, pr=0, pg=0, pb=0, pa=0;\n\n\t\tlet divx = (radiusX + radiusX + 1) | 0;\n\t\tlet divy = (radiusY + radiusY + 1) | 0;\n\t\tlet w = imageData.width | 0;\n\t\tlet h = imageData.height | 0;\n\n\t\tlet w1 = (w - 1) | 0;\n\t\tlet h1 = (h - 1) | 0;\n\t\tlet rxp1 = (radiusX + 1) | 0;\n\t\tlet ryp1 = (radiusY + 1) | 0;\n\n\t\tlet ssx = {r:0,b:0,g:0,a:0};\n\t\tlet sx = ssx;\n\t\tfor ( i = 1; i < divx; i++ )\n\t\t{\n\t\t\tsx = sx.n = {r:0,b:0,g:0,a:0};\n\t\t}\n\t\tsx.n = ssx;\n\n\t\tlet ssy = {r:0,b:0,g:0,a:0};\n\t\tlet sy = ssy;\n\t\tfor ( i = 1; i < divy; i++ )\n\t\t{\n\t\t\tsy = sy.n = {r:0,b:0,g:0,a:0};\n\t\t}\n\t\tsy.n = ssy;\n\n\t\tlet si = null;\n\n\n\t\tlet mtx = BlurFilter_BlurFilter.MUL_TABLE[radiusX] | 0;\n\t\tlet stx = BlurFilter_BlurFilter.SHG_TABLE[radiusX] | 0;\n\t\tlet mty = BlurFilter_BlurFilter.MUL_TABLE[radiusY] | 0;\n\t\tlet sty = BlurFilter_BlurFilter.SHG_TABLE[radiusY] | 0;\n\n\t\twhile (iterations-- > 0) {\n\n\t\t\tyw = yi = 0;\n\t\t\tlet ms = mtx;\n\t\t\tlet ss = stx;\n\t\t\tfor (y = h; --y > -1;) {\n\t\t\t\tr = rxp1 * (pr = px[(yi) | 0]);\n\t\t\t\tg = rxp1 * (pg = px[(yi + 1) | 0]);\n\t\t\t\tb = rxp1 * (pb = px[(yi + 2) | 0]);\n\t\t\t\ta = rxp1 * (pa = px[(yi + 3) | 0]);\n\n\t\t\t\tsx = ssx;\n\n\t\t\t\tfor( i = rxp1; --i > -1; )\n\t\t\t\t{\n\t\t\t\t\tsx.r = pr;\n\t\t\t\t\tsx.g = pg;\n\t\t\t\t\tsx.b = pb;\n\t\t\t\t\tsx.a = pa;\n\t\t\t\t\tsx = sx.n;\n\t\t\t\t}\n\n\t\t\t\tfor( i = 1; i < rxp1; i++ )\n\t\t\t\t{\n\t\t\t\t\tp = (yi + ((w1 < i ? w1 : i) << 2)) | 0;\n\t\t\t\t\tr += ( sx.r = px[p]);\n\t\t\t\t\tg += ( sx.g = px[p+1]);\n\t\t\t\t\tb += ( sx.b = px[p+2]);\n\t\t\t\t\ta += ( sx.a = px[p+3]);\n\n\t\t\t\t\tsx = sx.n;\n\t\t\t\t}\n\n\t\t\t\tsi = ssx;\n\t\t\t\tfor ( x = 0; x < w; x++ )\n\t\t\t\t{\n\t\t\t\t\tpx[yi++] = (r * ms) >>> ss;\n\t\t\t\t\tpx[yi++] = (g * ms) >>> ss;\n\t\t\t\t\tpx[yi++] = (b * ms) >>> ss;\n\t\t\t\t\tpx[yi++] = (a * ms) >>> ss;\n\n\t\t\t\t\tp = ((yw + ((p = x + radiusX + 1) < w1 ? p : w1)) << 2);\n\n\t\t\t\t\tr -= si.r - ( si.r = px[p]);\n\t\t\t\t\tg -= si.g - ( si.g = px[p+1]);\n\t\t\t\t\tb -= si.b - ( si.b = px[p+2]);\n\t\t\t\t\ta -= si.a - ( si.a = px[p+3]);\n\n\t\t\t\t\tsi = si.n;\n\n\t\t\t\t}\n\t\t\t\tyw += w;\n\t\t\t}\n\n\t\t\tms = mty;\n\t\t\tss = sty;\n\t\t\tfor (x = 0; x < w; x++) {\n\t\t\t\tyi = (x << 2) | 0;\n\n\t\t\t\tr = (ryp1 * (pr = px[yi])) | 0;\n\t\t\t\tg = (ryp1 * (pg = px[(yi + 1) | 0])) | 0;\n\t\t\t\tb = (ryp1 * (pb = px[(yi + 2) | 0])) | 0;\n\t\t\t\ta = (ryp1 * (pa = px[(yi + 3) | 0])) | 0;\n\n\t\t\t\tsy = ssy;\n\t\t\t\tfor( i = 0; i < ryp1; i++ )\n\t\t\t\t{\n\t\t\t\t\tsy.r = pr;\n\t\t\t\t\tsy.g = pg;\n\t\t\t\t\tsy.b = pb;\n\t\t\t\t\tsy.a = pa;\n\t\t\t\t\tsy = sy.n;\n\t\t\t\t}\n\n\t\t\t\typ = w;\n\n\t\t\t\tfor( i = 1; i <= radiusY; i++ )\n\t\t\t\t{\n\t\t\t\t\tyi = ( yp + x ) << 2;\n\n\t\t\t\t\tr += ( sy.r = px[yi]);\n\t\t\t\t\tg += ( sy.g = px[yi+1]);\n\t\t\t\t\tb += ( sy.b = px[yi+2]);\n\t\t\t\t\ta += ( sy.a = px[yi+3]);\n\n\t\t\t\t\tsy = sy.n;\n\n\t\t\t\t\tif( i < h1 )\n\t\t\t\t\t{\n\t\t\t\t\t\typ += w;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tyi = x;\n\t\t\t\tsi = ssy;\n\t\t\t\tif ( iterations > 0 )\n\t\t\t\t{\n\t\t\t\t\tfor ( y = 0; y < h; y++ )\n\t\t\t\t\t{\n\t\t\t\t\t\tp = yi << 2;\n\t\t\t\t\t\tpx[p+3] = pa =(a * ms) >>> ss;\n\t\t\t\t\t\tif ( pa > 0 )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpx[p]   = ((r * ms) >>> ss );\n\t\t\t\t\t\t\tpx[p+1] = ((g * ms) >>> ss );\n\t\t\t\t\t\t\tpx[p+2] = ((b * ms) >>> ss );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpx[p] = px[p+1] = px[p+2] = 0\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tp = ( x + (( ( p = y + ryp1) < h1 ? p : h1 ) * w )) << 2;\n\n\t\t\t\t\t\tr -= si.r - ( si.r = px[p]);\n\t\t\t\t\t\tg -= si.g - ( si.g = px[p+1]);\n\t\t\t\t\t\tb -= si.b - ( si.b = px[p+2]);\n\t\t\t\t\t\ta -= si.a - ( si.a = px[p+3]);\n\n\t\t\t\t\t\tsi = si.n;\n\n\t\t\t\t\t\tyi += w;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor ( y = 0; y < h; y++ )\n\t\t\t\t\t{\n\t\t\t\t\t\tp = yi << 2;\n\t\t\t\t\t\tpx[p+3] = pa =(a * ms) >>> ss;\n\t\t\t\t\t\tif ( pa > 0 )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpa = 255 / pa;\n\t\t\t\t\t\t\tpx[p]   = ((r * ms) >>> ss ) * pa;\n\t\t\t\t\t\t\tpx[p+1] = ((g * ms) >>> ss ) * pa;\n\t\t\t\t\t\t\tpx[p+2] = ((b * ms) >>> ss ) * pa;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpx[p] = px[p+1] = px[p+2] = 0\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tp = ( x + (( ( p = y + ryp1) < h1 ? p : h1 ) * w )) << 2;\n\n\t\t\t\t\t\tr -= si.r - ( si.r = px[p]);\n\t\t\t\t\t\tg -= si.g - ( si.g = px[p+1]);\n\t\t\t\t\t\tb -= si.b - ( si.b = px[p+2]);\n\t\t\t\t\t\ta -= si.a - ( si.a = px[p+3]);\n\n\t\t\t\t\t\tsi = si.n;\n\n\t\t\t\t\t\tyi += w;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\treturn true;\n\t}\n\n}\n\n/**\n * Array of multiply values for blur calculations.\n * @type {Array}\n * @protected\n * @readonly\n * @static\n */\nBlurFilter_BlurFilter.MUL_TABLE = [1, 171, 205, 293, 57, 373, 79, 137, 241, 27, 391, 357, 41, 19, 283, 265, 497, 469, 443, 421, 25, 191, 365, 349, 335, 161, 155, 149, 9, 278, 269, 261, 505, 245, 475, 231, 449, 437, 213, 415, 405, 395, 193, 377, 369, 361, 353, 345, 169, 331, 325, 319, 313, 307, 301, 37, 145, 285, 281, 69, 271, 267, 263, 259, 509, 501, 493, 243, 479, 118, 465, 459, 113, 446, 55, 435, 429, 423, 209, 413, 51, 403, 199, 393, 97, 3, 379, 375, 371, 367, 363, 359, 355, 351, 347, 43, 85, 337, 333, 165, 327, 323, 5, 317, 157, 311, 77, 305, 303, 75, 297, 294, 73, 289, 287, 71, 141, 279, 277, 275, 68, 135, 67, 133, 33, 262, 260, 129, 511, 507, 503, 499, 495, 491, 61, 121, 481, 477, 237, 235, 467, 232, 115, 457, 227, 451, 7, 445, 221, 439, 218, 433, 215, 427, 425, 211, 419, 417, 207, 411, 409, 203, 202, 401, 399, 396, 197, 49, 389, 387, 385, 383, 95, 189, 47, 187, 93, 185, 23, 183, 91, 181, 45, 179, 89, 177, 11, 175, 87, 173, 345, 343, 341, 339, 337, 21, 167, 83, 331, 329, 327, 163, 81, 323, 321, 319, 159, 79, 315, 313, 39, 155, 309, 307, 153, 305, 303, 151, 75, 299, 149, 37, 295, 147, 73, 291, 145, 289, 287, 143, 285, 71, 141, 281, 35, 279, 139, 69, 275, 137, 273, 17, 271, 135, 269, 267, 133, 265, 33, 263, 131, 261, 130, 259, 129, 257, 1];\n/**\n * Array of shift values for blur calculations.\n * @type {Array}\n * @protected\n * @static\n */\nBlurFilter_BlurFilter.SHG_TABLE = [0, 9, 10, 11, 9, 12, 10, 11, 12, 9, 13, 13, 10, 9, 13, 13, 14, 14, 14, 14, 10, 13, 14, 14, 14, 13, 13, 13, 9, 14, 14, 14, 15, 14, 15, 14, 15, 15, 14, 15, 15, 15, 14, 15, 15, 15, 15, 15, 14, 15, 15, 15, 15, 15, 15, 12, 14, 15, 15, 13, 15, 15, 15, 15, 16, 16, 16, 15, 16, 14, 16, 16, 14, 16, 13, 16, 16, 16, 15, 16, 13, 16, 15, 16, 14, 9, 16, 16, 16, 16, 16, 16, 16, 16, 16, 13, 14, 16, 16, 15, 16, 16, 10, 16, 15, 16, 14, 16, 16, 14, 16, 16, 14, 16, 16, 14, 15, 16, 16, 16, 14, 15, 14, 15, 13, 16, 16, 15, 17, 17, 17, 17, 17, 17, 14, 15, 17, 17, 16, 16, 17, 16, 15, 17, 16, 17, 11, 17, 16, 17, 16, 17, 16, 17, 17, 16, 17, 17, 16, 17, 17, 16, 16, 17, 17, 17, 16, 14, 17, 17, 17, 17, 15, 16, 14, 16, 15, 16, 13, 16, 15, 16, 14, 16, 15, 16, 12, 16, 15, 16, 17, 17, 17, 17, 17, 13, 16, 15, 17, 17, 17, 16, 15, 17, 17, 17, 16, 15, 17, 17, 14, 16, 17, 17, 16, 17, 17, 16, 15, 17, 16, 14, 17, 16, 15, 17, 16, 17, 17, 16, 17, 15, 16, 17, 14, 17, 16, 15, 17, 16, 17, 13, 17, 16, 17, 17, 16, 17, 14, 17, 16, 17, 16, 17, 16, 17, 9];\n\n// CONCATENATED MODULE: ./node_modules/@createjs/easeljs/src/filters/ColorFilter.js\n/**\n * @license ColorFilter\n * Visit http://createjs.com/ for documentation, updates and examples.\n *\n * Copyright (c) 2017 gskinner.com, inc.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the "Software"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n\n\n/**\n * Applies a color transform to DisplayObjects.\n *\n * @memberof easeljs\n * @extends easeljs.Filter\n * @example\n * let shape = new Shape().set({ x: 100, y: 100 });\n * shape.graphics.beginFill("#ff0000").drawCircle(0,0,50);\n * shape.filters = [ new ColorFilter(0,0,0,1, 0,0,255,0) ];\n * shape.cache(-50, -50, 100, 100);\n *\n * @param {Number} [redMultiplier=1] The amount to multiply against the red channel. This is a range between 0 and 1.\n * @param {Number} [greenMultiplier=1] The amount to multiply against the green channel. This is a range between 0 and 1.\n * @param {Number} [blueMultiplier=1] The amount to multiply against the blue channel. This is a range between 0 and 1.\n * @param {Number} [alphaMultiplier=1] The amount to multiply against the alpha channel. This is a range between 0 and 1.\n * @param {Number} [redOffset=0] The amount to add to the red channel after it has been multiplied. This is a range\n * between -255 and 255.\n * @param {Number} [greenOffset=0] The amount to add to the green channel after it has been multiplied. This is a range\n * between -255 and 255.\n * @param {Number} [blueOffset=0] The amount to add to the blue channel after it has been multiplied. This is a range\n * between -255 and 255.\n * @param {Number} [alphaOffset=0] The amount to add to the alpha channel after it has been multiplied. This is a range\n * between -255 and 255.\n */\nclass ColorFilter_ColorFilter extends Filter {\n\n\tconstructor (redMultiplier = 1, greenMultiplier = 1, blueMultiplier = 1, alphaMultiplier = 1, redOffset = 0, greenOffset = 0, blueOffset = 0, alphaOffset = 0) {\n\t\tsuper();\n\n\t\t/**\n\t\t * Red channel multiplier.\n\t\t * @type {Number}\n\t\t */\n\t\tthis.redMultiplier = redMultiplier;\n\n\t\t/**\n\t\t * Green channel multiplier.\n\t\t * @type {Number}\n\t\t */\n\t\tthis.greenMultiplier = greenMultiplier;\n\n\t\t/**\n\t\t * Blue channel multiplier.\n\t\t * @type {Number}\n\t\t */\n\t\tthis.blueMultiplier = blueMultiplier;\n\n\t\t/**\n\t\t * Alpha channel multiplier.\n\t\t * @type {Number}\n\t\t */\n\t\tthis.alphaMultiplier = alphaMultiplier;\n\n\t\t/**\n\t\t * Red channel offset (added to value).\n\t\t * @type {Number}\n\t\t */\n\t\tthis.redOffset = redOffset;\n\n\t\t/**\n\t\t * Green channel offset (added to value).\n\t\t * @type {Number}\n\t\t */\n\t\tthis.greenOffset = greenOffset;\n\n\t\t/**\n\t\t * Blue channel offset (added to value).\n\t\t * @type {Number}\n\t\t */\n\t\tthis.blueOffset = blueOffset;\n\n\t\t/**\n\t\t * Alpha channel offset (added to value).\n\t\t * @type {Number}\n\t\t */\n\t\tthis.alphaOffset = alphaOffset;\n\n\t\tthis.FRAG_SHADER_BODY = `\n\t\t\tuniform vec4 uColorMultiplier;\n\t\t\tuniform vec4 uColorOffset;\n\n\t\t\tvoid main (void) {\n\t\t\t\tvec4 color = texture2D(uSampler, vRenderCoord);\n\n\t\t\t\tgl_FragColor = (color * uColorMultiplier) + uColorOffset;\n\t\t\t}\n\t\t`;\n\n\t}\n\n\tshaderParamSetup (gl, stage, shaderProgram) {\n\t\tgl.uniform4f(\n\t\t\tgl.getUniformLocation(shaderProgram, "uColorMultiplier"),\n\t\t\tthis.redMultiplier, this.greenMultiplier, this.blueMultiplier, this.alphaMultiplier\n\t\t);\n\n\t\tgl.uniform4f(\n\t\t\tgl.getUniformLocation(shaderProgram, "uColorOffset"),\n\t\t\tthis.redOffset/255, this.greenOffset/255, this.blueOffset/255, this.alphaOffset/255\n\t\t);\n\t}\n\n\t/**\n\t * @return {easeljs.ColorFilter}\n\t */\n\tclone () {\n\t\treturn new ColorFilter_ColorFilter(\n\t\t\tthis.redMultiplier, this.greenMultiplier, this.blueMultiplier, this.alphaMultiplier,\n\t\t\tthis.redOffset, this.greenOffset, this.blueOffset, this.alphaOffset\n\t\t);\n\t}\n\n\t_applyFilter (imageData) {\n\t\tlet data = imageData.data;\n\t\tconst l = data.length;\n\t\tfor (let i=0; i<l; i+=4) {\n\t\t\tdata[i] = data[i]*this.redMultiplier+this.redOffset;\n\t\t\tdata[i+1] = data[i+1]*this.greenMultiplier+this.greenOffset;\n\t\t\tdata[i+2] = data[i+2]*this.blueMultiplier+this.blueOffset;\n\t\t\tdata[i+3] = data[i+3]*this.alphaMultiplier+this.alphaOffset;\n\t\t}\n\t\treturn true;\n\t}\n\n}\n\n// CONCATENATED MODULE: ./node_modules/@createjs/easeljs/src/filters/ColorMatrix.js\n/**\n * @license ColorMatrix\n * Visit http://createjs.com/ for documentation, updates and examples.\n *\n * Copyright (c) 2017 gskinner.com, inc.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the "Software"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * Provides helper functions for assembling a matrix for use with the {@link easeljs.ColorMatrixFilter}.\n * Most methods return the instance to facilitate chained calls.\n *\n * @memberof easeljs\n * @example\n * colorMatrix.adjustHue(20).adjustBrightness(50);\n *\n * @param {Number} brightness\n * @param {Number} contrast\n * @param {Number} saturation\n * @param {Number} hue\n */\nclass ColorMatrix {\n\n\tconstructor (brightness, contrast, saturation, hue) {\n\t\tthis.setColor(brightness, contrast, saturation, hue);\n\t}\n\n\t/**\n\t * Resets the instance with the specified values.\n\t * @param {Number} brightness\n\t * @param {Number} contrast\n\t * @param {Number} saturation\n\t * @param {Number} hue\n\t * @return {easeljs.ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t */\n\tsetColor (brightness, contrast, saturation, hue) {\n\t\treturn this.reset().adjustColor(brightness, contrast, saturation, hue);\n\t}\n\n\t/**\n\t * Resets the matrix to identity values.\n\t * @return {easeljs.ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t */\n\treset () {\n\t\treturn this.copy(ColorMatrix.IDENTITY_MATRIX);\n\t}\n\n\t/**\n\t * Shortcut method to adjust brightness, contrast, saturation and hue. Equivalent to calling adjustHue(hue), adjustContrast(contrast),\n\t * adjustBrightness(brightness), adjustSaturation(saturation), in that order.\n\t * @param {Number} brightness\n\t * @param {Number} contrast\n\t * @param {Number} saturation\n\t * @param {Number} hue\n\t * @return {easeljs.ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t */\n\tadjustColor (brightness, contrast, saturation, hue) {\n\t\treturn this.adjustBrightness(brightness).adjustContrast(contrast).adjustSaturation(saturation).adjustHue(hue);\n\t}\n\n\t/**\n\t * Adjusts the brightness of pixel color by adding the specified value to the red, green and blue channels.\n\t * Positive values will make the image brighter, negative values will make it darker.\n\t * @param {Number} value A value between -255 & 255 that will be added to the RGB channels.\n\t * @return {easeljs.ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t */\n\tadjustBrightness (value) {\n\t\tif (value === 0 || isNaN(value)) { return this; }\n\t\tvalue = this._cleanValue(value, 255);\n\t\tthis._multiplyMatrix([\n\t\t\t1,0,0,0,value,\n\t\t\t0,1,0,0,value,\n\t\t\t0,0,1,0,value,\n\t\t\t0,0,0,1,0,\n\t\t\t0,0,0,0,1\n\t\t]);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Adjusts the contrast of pixel color.\n\t * Positive values will increase contrast, negative values will decrease contrast.\n\t * @param {Number} value A value between -100 & 100.\n\t * @return {easeljs.ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t */\n\tadjustContrast (value) {\n\t\tif (value === 0 || isNaN(value)) { return this; }\n\t\tvalue = this._cleanValue(value, 100);\n\t\tlet x;\n\t\tif (value<0) {\n\t\t\tx = 127+value/100*127;\n\t\t} else {\n\t\t\tx = value%1;\n\t\t\tif (x === 0) {\n\t\t\t\tx = ColorMatrix.DELTA_INDEX[value];\n\t\t\t} else {\n\t\t\t\tx = ColorMatrix.DELTA_INDEX[(value<<0)]*(1-x)+ColorMatrix.DELTA_INDEX[(value<<0)+1]*x; // use linear interpolation for more granularity.\n\t\t\t}\n\t\t\tx = x*127+127;\n\t\t}\n\t\tthis._multiplyMatrix([\n\t\t\tx/127,0,0,0,0.5*(127-x),\n\t\t\t0,x/127,0,0,0.5*(127-x),\n\t\t\t0,0,x/127,0,0.5*(127-x),\n\t\t\t0,0,0,1,0,\n\t\t\t0,0,0,0,1\n\t\t]);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Adjusts the color saturation of the pixel.\n\t * Positive values will increase saturation, negative values will decrease saturation (trend towards greyscale).\n\t * @param {Number} value A value between -100 & 100.\n\t * @return {easeljs.ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t */\n\tadjustSaturation (value) {\n\t\tif (value === 0 || isNaN(value)) { return this; }\n\t\tvalue = this._cleanValue(value, 100);\n\t\tlet x = 1+((value > 0) ? 3*value/100 : value/100);\n\t\tlet lumR = 0.3086;\n\t\tlet lumG = 0.6094;\n\t\tlet lumB = 0.0820;\n\t\tthis._multiplyMatrix([\n\t\t\tlumR*(1-x)+x,lumG*(1-x),lumB*(1-x),0,0,\n\t\t\tlumR*(1-x),lumG*(1-x)+x,lumB*(1-x),0,0,\n\t\t\tlumR*(1-x),lumG*(1-x),lumB*(1-x)+x,0,0,\n\t\t\t0,0,0,1,0,\n\t\t\t0,0,0,0,1\n\t\t]);\n\t\treturn this;\n\t}\n\n\n\t/**\n\t * Adjusts the hue of the pixel color.\n\t * @param {Number} value A value between -180 & 180.\n\t * @return {easeljs.ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t */\n\tadjustHue (value) {\n\t\tif (value === 0 || isNaN(value)) { return this; }\n\t\tvalue = this._cleanValue(value, 180)/180*Math.PI;\n\t\tlet cosVal = Math.cos(value);\n\t\tlet sinVal = Math.sin(value);\n\t\tlet lumR = 0.213;\n\t\tlet lumG = 0.715;\n\t\tlet lumB = 0.072;\n\t\tthis._multiplyMatrix([\n\t\t\tlumR+cosVal*(1-lumR)+sinVal*(-lumR),lumG+cosVal*(-lumG)+sinVal*(-lumG),lumB+cosVal*(-lumB)+sinVal*(1-lumB),0,0,\n\t\t\tlumR+cosVal*(-lumR)+sinVal*(0.143),lumG+cosVal*(1-lumG)+sinVal*(0.140),lumB+cosVal*(-lumB)+sinVal*(-0.283),0,0,\n\t\t\tlumR+cosVal*(-lumR)+sinVal*(-(1-lumR)),lumG+cosVal*(-lumG)+sinVal*(lumG),lumB+cosVal*(1-lumB)+sinVal*(lumB),0,0,\n\t\t\t0,0,0,1,0,\n\t\t\t0,0,0,0,1\n\t\t]);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Concatenates (multiplies) the specified matrix with this one.\n\t * @param {Array} matrix An array or ColorMatrix instance.\n\t * @return {easeljs.ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t */\n\tconcat (matrix) {\n\t\tmatrix = this._fixMatrix(matrix);\n\t\tif (matrix.length != ColorMatrix.LENGTH) { return this; }\n\t\tthis._multiplyMatrix(matrix);\n\t\treturn this;\n\t}\n\n\t/**\n\t * @return {easeljs.ColorMatrix} A clone of this ColorMatrix.\n\t */\n\tclone () {\n\t\treturn (new ColorMatrix()).copy(this);\n\t}\n\n\t/**\n\t * Return a length 25 (5x5) array instance containing this matrix\'s values.\n\t * @return {Array} An array holding this matrix\'s values.\n\t */\n\ttoArray () {\n\t\tconst arr = [];\n\t\tconst l = ColorMatrix.LENGTH;\n\t\tfor (let i=0; i<l; i++) {\n\t\t\tarr[i] = this[i];\n\t\t}\n\t\treturn arr;\n\t}\n\n\t/**\n\t * Copy the specified matrix\'s values to this matrix.\n\t * @param {Array | easeljs.ColorMatrix} matrix An array or ColorMatrix instance.\n\t * @return {easeljs.ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t */\n\tcopy (matrix) {\n\t\tconst l = ColorMatrix.LENGTH;\n\t\tfor (let i=0;i<l;i++) {\n\t\t\tthis[i] = matrix[i];\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @return {String} a string representation of the instance.\n\t */\n\ttoString () {\n\t\treturn `[${this.constructor.name}]`;\n\t}\n\n\t/**\n\t * @param {Array} matrix\n\t * @protected\n\t */\n\t_multiplyMatrix (matrix) {\n\t\tlet col = [];\n\n\t\tfor (let i=0;i<5;i++) {\n\t\t\tfor (let j=0;j<5;j++) {\n\t\t\t\tcol[j] = this[j+i*5];\n\t\t\t}\n\t\t\tfor (let j=0;j<5;j++) {\n\t\t\t\tlet val=0;\n\t\t\t\tfor (let k=0;k<5;k++) {\n\t\t\t\t\tval += matrix[j+k*5]*col[k];\n\t\t\t\t}\n\t\t\t\tthis[j+i*5] = val;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Make sure values are within the specified range, hue has a limit of 180, brightness is 255, others are 100.\n\t * @param {Number} value The raw number\n\t * @param {Number} limit The maximum that the number can be. The minimum is the limit * -1.\n\t * @protected\n\t */\n\t_cleanValue (value, limit) {\n\t\treturn Math.min(limit, Math.max(-limit, value));\n\t}\n\n\t/**\n\t * Makes sure matrixes are 5x5 (25 long).\n\t * @param {Array} matrix\n\t * @protected\n\t */\n\t_fixMatrix (matrix) {\n\t\tif (matrix instanceof ColorMatrix) { matrix = matrix.toArray(); }\n\t\tif (matrix.length < ColorMatrix.LENGTH) {\n\t\t\tmatrix = matrix.slice(0, matrix.length).concat(ColorMatrix.IDENTITY_MATRIX.slice(matrix.length, ColorMatrix.LENGTH));\n\t\t} else if (matrix.length > ColorMatrix.LENGTH) {\n\t\t\tmatrix = matrix.slice(0, ColorMatrix.LENGTH);\n\t\t}\n\t\treturn matrix;\n\t}\n\n}\n\n/**\n * Array of delta values for contrast calculations.\n * @type {Array<Number>}\n * @protected\n * @readonly\n * @static\n */\nColorMatrix.DELTA_INDEX = Object.freeze([\n \t0,    0.01, 0.02, 0.04, 0.05, 0.06, 0.07, 0.08, 0.1,  0.11,\n \t0.12, 0.14, 0.15, 0.16, 0.17, 0.18, 0.20, 0.21, 0.22, 0.24,\n \t0.25, 0.27, 0.28, 0.30, 0.32, 0.34, 0.36, 0.38, 0.40, 0.42,\n \t0.44, 0.46, 0.48, 0.5,  0.53, 0.56, 0.59, 0.62, 0.65, 0.68,\n \t0.71, 0.74, 0.77, 0.80, 0.83, 0.86, 0.89, 0.92, 0.95, 0.98,\n \t1.0,  1.06, 1.12, 1.18, 1.24, 1.30, 1.36, 1.42, 1.48, 1.54,\n \t1.60, 1.66, 1.72, 1.78, 1.84, 1.90, 1.96, 2.0,  2.12, 2.25,\n \t2.37, 2.50, 2.62, 2.75, 2.87, 3.0,  3.2,  3.4,  3.6,  3.8,\n \t4.0,  4.3,  4.7,  4.9,  5.0,  5.5,  6.0,  6.5,  6.8,  7.0,\n \t7.3,  7.5,  7.8,  8.0,  8.4,  8.7,  9.0,  9.4,  9.6,  9.8,\n \t10.0\n]);\n/**\n * Identity matrix values.\n * @type {Array<Number>}\n * @protected\n * @readonly\n * @static\n */\nColorMatrix.IDENTITY_MATRIX = Object.freeze([\n \t1,0,0,0,0,\n \t0,1,0,0,0,\n \t0,0,1,0,0,\n \t0,0,0,1,0,\n \t0,0,0,0,1\n]);\n/**\n * The constant length of a color matrix.\n * @type {Number}\n * @protected\n * @readonly\n * @static\n */\nColorMatrix.LENGTH = 25;\n\n// CONCATENATED MODULE: ./node_modules/@createjs/easeljs/src/filters/ColorMatrixFilter.js\n/**\n * @license ColorMatrixFilter\n * Visit http://createjs.com/ for documentation, updates and examples.\n *\n * Copyright (c) 2017 gskinner.com, inc.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the "Software"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n\n\n/**\n * Allows you to carry out complex color operations such as modifying saturation, brightness, or inverting. See the\n * {@link easeljs.ColorMatrix} for more information on changing colors. For an easier color transform,\n * consider the {@link easeljs.ColorFilter}.\n *\n *\n * @memberof easeljs\n * @extends easeljs.Filter\n * @example\n * let shape = new Shape().set({ x: 100, y: 100 });\n * shape.graphics.beginFill("#ff0000").drawCircle(0, 0, 50);\n * let matrix = new ColorMatrix().adjustHue(180).adjustSaturation(100);\n * shape.filters = [ new ColorMatrixFilter(matrix) ];\n * shape.cache(-50, -50, 100, 100);\n *\n * @param {Array | easeljs.ColorMatrix} matrix A 4x5 matrix describing the color operation to perform.\n */\nclass ColorMatrixFilter_ColorMatrixFilter extends Filter {\n\n\tconstructor (matrix) {\n\t\tsuper();\n\n\t\t/**\n\t\t * A 4x5 matrix describing the color operation to perform.\n\t\t * @type {Array | easeljs.ColorMatrix}\n\t\t */\n\t\tthis.matrix = matrix;\n\n\t\tthis.FRAG_SHADER_BODY = `\n\t\t\tuniform mat4 uColorMatrix;\n\t\t\tuniform vec4 uColorMatrixOffset;\n\n\t\t\tvoid main (void) {\n\t\t\t\tvec4 color = texture2D(uSampler, vRenderCoord);\n\n\t\t\t\tmat4 m = uColorMatrix;\n\t\t\t\tvec4 newColor = vec4(0,0,0,0);\n\t\t\t\tnewColor.r = color.r*m[0][0] + color.g*m[0][1] + color.b*m[0][2] + color.a*m[0][3];\n\t\t\t\tnewColor.g = color.r*m[1][0] + color.g*m[1][1] + color.b*m[1][2] + color.a*m[1][3];\n\t\t\t\tnewColor.b = color.r*m[2][0] + color.g*m[2][1] + color.b*m[2][2] + color.a*m[2][3];\n\t\t\t\tnewColor.a = color.r*m[3][0] + color.g*m[3][1] + color.b*m[3][2] + color.a*m[3][3];\n\n\t\t\t\tgl_FragColor = newColor + uColorMatrixOffset;\n\t\t\t}\n\t\t`;\n\t}\n\n\tshaderParamSetup (gl, stage, shaderProgram) {\n\t\tlet mat = this.matrix;\n\t\tlet colorMatrix = new Float32Array([\n\t\t\tmat[0],mat[1],mat[2],mat[3],\n\t\t\tmat[5],mat[6],mat[7],mat[8],\n\t\t\tmat[10],mat[11],mat[12],mat[13],\n\t\t\tmat[15],mat[16],mat[17],mat[18]\n\t\t]);\n\n\t\tgl.uniformMatrix4fv(\n\t\t\tgl.getUniformLocation(shaderProgram, "uColorMatrix"),\n\t\t\tfalse, colorMatrix\n\t\t);\n\t\tgl.uniform4f(\n\t\t\tgl.getUniformLocation(shaderProgram, "uColorMatrixOffset"),\n\t\t\tmat[4]/255, mat[9]/255, mat[14]/255, mat[19]/255\n\t\t);\n\t}\n\n\t/**\n\t * @return {easeljs.ColorMatrixFilter}\n\t */\n\tclone () {\n\t\treturn new ColorMatrixFilter_ColorMatrixFilter(this.matrix);\n\t}\n\n\t_applyFilter (imageData) {\n\t\tlet data = imageData.data;\n\t\tconst l = data.length;\n\t\tlet r,g,b,a;\n\t\tlet mtx = this.matrix;\n\t\tlet m0 =  mtx[0],  m1 =  mtx[1],  m2 =  mtx[2],  m3 =  mtx[3],  m4 =  mtx[4];\n\t\tlet m5 =  mtx[5],  m6 =  mtx[6],  m7 =  mtx[7],  m8 =  mtx[8],  m9 =  mtx[9];\n\t\tlet m10 = mtx[10], m11 = mtx[11], m12 = mtx[12], m13 = mtx[13], m14 = mtx[14];\n\t\tlet m15 = mtx[15], m16 = mtx[16], m17 = mtx[17], m18 = mtx[18], m19 = mtx[19];\n\n\t\tfor (let i=0; i<l; i+=4) {\n\t\t\tr = data[i];\n\t\t\tg = data[i+1];\n\t\t\tb = data[i+2];\n\t\t\ta = data[i+3];\n\t\t\tdata[i] = r*m0+g*m1+b*m2+a*m3+m4; // red\n\t\t\tdata[i+1] = r*m5+g*m6+b*m7+a*m8+m9; // green\n\t\t\tdata[i+2] = r*m10+g*m11+b*m12+a*m13+m14; // blue\n\t\t\tdata[i+3] = r*m15+g*m16+b*m17+a*m18+m19; // alpha\n\t\t}\n\n\t\treturn true;\n\t}\n\n}\n\n// CONCATENATED MODULE: ./node_modules/@createjs/easeljs/src/ui/ButtonHelper.js\n/*\n* @license ButtonHelper\n* Visit http://createjs.com/ for documentation, updates and examples.\n*\n* Copyright (c) 2017 gskinner.com, inc.\n*\n* Permission is hereby granted, free of charge, to any person\n* obtaining a copy of this software and associated documentation\n* files (the "Software"), to deal in the Software without\n* restriction, including without limitation the rights to use,\n* copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the\n* Software is furnished to do so, subject to the following\n* conditions:\n*\n* The above copyright notice and this permission notice shall be\n* included in all copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,\n* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n* OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n/**\n * The ButtonHelper is a helper class to create interactive buttons from {@link easeljs.MovieClip} or\n * {@link easeljs.Sprite} instances. This class will intercept mouse events from an object, and\n * automatically call {@link easeljs.Sprite#gotoAndStop} or {@link easlejs.Sprite#gotoAndPlay},\n * to the respective animation labels, add a pointer cursor, and allows the user to define a hit state frame.\n *\n * The ButtonHelper instance does not need to be added to the stage, but a reference should be maintained to prevent\n * garbage collection.\n *\n * Note that over states will not work unless you call {@link easeljs.Stage#enableMouseOver}.\n *\n * @memberof easeljs\n * @example\n * let helper = new ButtonHelper(sprite, "out", "over", "down", false, sprite, "hit");\n * sprite.addEventListener("click", (evt) => {\n *   // clicked\n * }));\n *\n * @param {easeljs.Sprite | easeljs.MovieClip} target The instance to manage.\n * @param {String} [outLabel="out"] The label or animation to go to when the user rolls out of the button.\n * @param {String} [overLabel="over"] The label or animation to go to when the user rolls over the button.\n * @param {String} [downLabel="down"] The label or animation to go to when the user presses the button.\n * @param {Boolean} [play=false] If the helper should call "gotoAndPlay" or "gotoAndStop" on the button when changing\n * states.\n * @param {easeljs.DisplayObject} [hitArea] An optional item to use as the hit state for the button. If this is not defined,\n * then the button\'s visible states will be used instead. Note that the same instance as the "target" argument can be\n * used for the hitState.\n * @param {String} [hitLabel] The label or animation on the hitArea instance that defines the hitArea bounds. If this is\n * null, then the default state of the hitArea will be used.\n */\nclass ButtonHelper {\n\n\tconstructor (target, outLabel = "out", overLabel = "over", downLabel = "down", play = false, hitArea, hitLabel) {\n\t\tif (!target.addEventListener) { return; }\n\n\t\t/**\n\t\t * The target for this button helper.\n\t\t * @type {easeljs.MovieClip | easeljs.Sprite}\n\t\t * @readonly\n\t\t */\n\t\tthis.target = target;\n\n\t\t/**\n\t\t * The label name or frame number to display when the user mouses out of the target.\n\t\t * @default "over"\n\t\t * @type {String | Number}\n\t\t */\n\t\tthis.overLabel = overLabel;\n\n\t\t/**\n\t\t * The label name or frame number to display when the user mouses over the target.\n\t\t * @default "out"\n\t\t * @type {String | Number}\n\t\t */\n\t\tthis.outLabel = outLabel;\n\n\t\t/**\n\t\t * The label name or frame number to display when the user presses on the target.\n\t\t * @default "down"\n\t\t * @type {String | Number}\n\t\t */\n\t\tthis.downLabel = downLabel == null;\n\n\t\t/**\n\t\t * If true, then ButtonHelper will call gotoAndPlay, if false, it will use gotoAndStop.\n\t\t * @default false\n\t\t * @type {Boolean}\n\t\t */\n\t\tthis.play = play;\n\n\t\t/**\n\t\t * @type {Boolean}\n\t\t * @protected\n\t\t */\n\t\tthis._isPressed = false;\n\n\t\t/**\n\t\t * @type {Boolean}\n\t\t * @protected\n\t\t */\n\t\tthis._isOver = false;\n\n\t\t/**\n\t\t * @type {Boolean}\n\t\t * @protected\n\t\t */\n\t\tthis._enabled = false;\n\n\t\ttarget.mouseChildren = false; // prevents issues when children are removed from the display list when state changes.\n\t\tthis.enabled = true;\n\t\tthis.handleEvent({});\n\t\tif (hitArea) {\n\t\t\tif (hitLabel) {\n\t\t\t\thitArea.actionsEnabled = false;\n\t\t\t\thitArea.gotoAndStop&&hitArea.gotoAndStop(hitLabel);\n\t\t\t}\n\t\t\ttarget.hitArea = hitArea;\n\t\t}\n\t}\n\n\t/**\n\t * Enables or disables the button functionality on the target.\n\t * @type {Boolean}\n\t */\n\tget enabled () { return this._enabled; }\n\tset enabled (enabled) {\n\t\tif (enabled === this._enabled) { return; }\n\t\tlet o = this.target;\n\t\tthis._enabled = enabled;\n\t\tif (enabled) {\n\t\t\to.cursor = "pointer";\n\t\t\to.addEventListener("rollover", this);\n\t\t\to.addEventListener("rollout", this);\n\t\t\to.addEventListener("mousedown", this);\n\t\t\to.addEventListener("pressup", this);\n\t\t\tif (o._reset) { o.__reset = o._reset; o._reset = this._reset;}\n\t\t} else {\n\t\t\to.cursor = null;\n\t\t\to.removeEventListener("rollover", this);\n\t\t\to.removeEventListener("rollout", this);\n\t\t\to.removeEventListener("mousedown", this);\n\t\t\to.removeEventListener("pressup", this);\n\t\t\tif (o.__reset) { o._reset = o.__reset; delete(o.__reset); }\n\t\t}\n\t}\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @return {String} a string representation of the instance.\n\t */\n\ttoString () {\n\t\treturn `[${this.constructor.name}]`;\n\t}\n\n\t/**\n\t * @param {Object} evt The mouse event to handle.\n\t * @protected\n\t */\n\thandleEvent (evt) {\n\t\tlet label, t = this.target, type = evt.type;\n\t\tif (type === "mousedown") {\n\t\t\tthis._isPressed = true;\n\t\t\tlabel = this.downLabel;\n\t\t} else if (type === "pressup") {\n\t\t\tthis._isPressed = false;\n\t\t\tlabel = this._isOver ? this.overLabel : this.outLabel;\n\t\t} else if (type === "rollover") {\n\t\t\tthis._isOver = true;\n\t\t\tlabel = this._isPressed ? this.downLabel : this.overLabel;\n\t\t} else { // rollout and default\n\t\t\tthis._isOver = false;\n\t\t\tlabel = this._isPressed ? this.overLabel : this.outLabel;\n\t\t}\n\t\tif (this.play) {\n\t\t\tt.gotoAndPlay&&t.gotoAndPlay(label);\n\t\t} else {\n\t\t\tt.gotoAndStop&&t.gotoAndStop(label);\n\t\t}\n\t}\n\n\t/**\n\t * Injected into target. Preserves the paused state through a reset.\n\t * @protected\n\t */\n\t_reset () {\n\t\t// TODO: explore better ways to handle this issue. This is hacky & disrupts object signatures.\n\t\tlet p = this.paused;\n\t\tthis.__reset();\n\t\tthis.paused = p;\n\t}\n\n}\n\n// CONCATENATED MODULE: ./node_modules/@createjs/easeljs/src/ui/Touch.js\n/**\n * @license Touch\n * Visit http://createjs.com/ for documentation, updates and examples.\n *\n * Copyright (c) 2017 gskinner.com, inc.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the "Software"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * Global utility for working with multi-touch enabled devices in EaselJS. Currently supports W3C Touch API (iOS and\n * modern Android browser) and the Pointer API (IE), including ms-prefixed events in IE10, and unprefixed in IE11.\n *\n * Ensure that you {{#crossLink "Touch/disable"}}{{/crossLink}} touch when cleaning up your application. You do not have\n * to check if touch is supported to enable it, as it will fail gracefully if it is not supported.\n *\n * <strong>Note:</strong> It is important to disable Touch on a stage that you are no longer using:\n *\n * @memberof easeljs\n * @name easeljs.Touch\n * @example\n * let stage = new Stage("canvasId");\n * Touch.enable(stage);\n */\n/* harmony default export */ var Touch = ({\n\n\t/**\n\t * Returns `true` if touch is supported in the current browser.\n\t * @return {Boolean} Indicates whether touch is supported in the current browser.\n\t */\n\tisSupported () {\n\t\treturn\t!!((\'ontouchstart\' in window) // iOS & Android\n\t\t\t|| (window.MSPointerEvent && window.navigator.msMaxTouchPoints > 0) // IE10\n\t\t\t|| (window.PointerEvent && window.navigator.maxTouchPoints > 0)); // IE11+\n\t},\n\n\t/**\n\t * Enables touch interaction for the specified EaselJS {@link easeljs.Stage}. Currently supports iOS\n\t * (and compatible browsers, such as modern Android browsers), and IE10/11. Supports both single touch and\n\t * multi-touch modes. Extends the EaselJS {@link easeljs.MouseEvent} model, but without support for\n\t * double click or over/out events.\n\t * @param {easeljs.Stage} stage The Stage to enable touch on.\n\t * @param {Boolean} [singleTouch=false] If `true`, only a single touch will be active at a time.\n\t * @param {Boolean} [allowDefault=false] If `true`, then default gesture actions (ex. scrolling, zooming) will be\n\t * allowed when the user is interacting with the target canvas.\n\t * @return {Boolean} Returns `true` if touch was successfully enabled on the target stage.\n\t */\n\tenable (stage, singleTouch = false, allowDefault = false) {\n\t\tif (!stage || !stage.canvas || !this.isSupported()) { return false; }\n\t\tif (stage.__touch) { return true; }\n\n\t\t// inject required properties on stage:\n\t\tstage.__touch = {pointers:{}, multitouch:!singleTouch, preventDefault:!allowDefault, count:0};\n\n\t\t// note that in the future we may need to disable the standard mouse event model before adding\n\t\t// these to prevent duplicate calls. It doesn\'t seem to be an issue with iOS devices though.\n\t\tif (\'ontouchstart\' in window) { this._IOS_enable(stage); }\n\t\telse if (window.PointerEvent || window.MSPointerEvent) { this._IE_enable(stage); }\n\t\treturn true;\n\t},\n\n\t/**\n\t * Removes all listeners that were set up when calling `Touch.enable()` on a stage.\n\t * @param {easeljs.Stage} stage The Stage to disable touch on.\n\t */\n\tdisable (stage) {\n\t\tif (!stage) { return; }\n\t\tif (\'ontouchstart\' in window) { this._IOS_disable(stage); }\n\t\telse if (window.PointerEvent || window.MSPointerEvent) { this._IE_disable(stage); }\n\t\tdelete stage.__touch;\n\t},\n\n\t/**\n\t * @private\n\t * @param {easeljs.Stage} stage\n\t */\n\t_IOS_enable (stage) {\n\t\tlet canvas = stage.canvas;\n\t\tlet f = stage.__touch.f = e => this._IOS_handleEvent(stage, e);\n\t\tcanvas.addEventListener("touchstart", f, false);\n\t\tcanvas.addEventListener("touchmove", f, false);\n\t\tcanvas.addEventListener("touchend", f, false);\n\t\tcanvas.addEventListener("touchcancel", f, false);\n\t},\n\n\t/**\n\t * @private\n\t * @param {easeljs.Stage} stage\n\t */\n\t_IOS_disable (stage) {\n\t\tlet canvas = stage.canvas;\n\t\tif (!canvas) { return; }\n\t\tlet f = stage.__touch.f;\n\t\tcanvas.removeEventListener("touchstart", f, false);\n\t\tcanvas.removeEventListener("touchmove", f, false);\n\t\tcanvas.removeEventListener("touchend", f, false);\n\t\tcanvas.removeEventListener("touchcancel", f, false);\n\t},\n\n\t/**\n\t * @private\n\t * @param {easeljs.Stage} stage\n\t * @param {Object} e The event to handle\n\t */\n\t_IOS_handleEvent (stage, e) {\n\t\tif (!stage) { return; }\n\t\tif (stage.__touch.preventDefault) { e.preventDefault&&e.preventDefault(); }\n\t\tlet touches = e.changedTouches;\n\t\tlet type = e.type;\n\t\tconst l = touches.length;\n\t\tfor (let touch of touches) {\n\t\t\tlet id = touch.identifier;\n\t\t\tif (touch.target != stage.canvas) { continue; }\n\n\t\t\tif (type === "touchstart") {\n\t\t\t\tthis._handleStart(stage, id, e, touch.pageX, touch.pageY);\n\t\t\t} else if (type === "touchmove") {\n\t\t\t\tthis._handleMove(stage, id, e, touch.pageX, touch.pageY);\n\t\t\t} else if (type === "touchend" || type === "touchcancel") {\n\t\t\t\tthis._handleEnd(stage, id, e);\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * @private\n\t * @param {easeljs.Stage} stage\n\t */\n\t_IE_enable (stage) {\n\t\tlet canvas = stage.canvas;\n\t\tlet f = stage.__touch.f = e => this._IE_handleEvent(stage,e);\n\n\t\tif (window.PointerEvent === undefined) {\n\t\t\tcanvas.addEventListener("MSPointerDown", f, false);\n\t\t\twindow.addEventListener("MSPointerMove", f, false);\n\t\t\twindow.addEventListener("MSPointerUp", f, false);\n\t\t\twindow.addEventListener("MSPointerCancel", f, false);\n\t\t\tif (stage.__touch.preventDefault) { canvas.style.msTouchAction = "none"; }\n\t\t} else {\n\t\t\tcanvas.addEventListener("pointerdown", f, false);\n\t\t\twindow.addEventListener("pointermove", f, false);\n\t\t\twindow.addEventListener("pointerup", f, false);\n\t\t\twindow.addEventListener("pointercancel", f, false);\n\t\t\tif (stage.__touch.preventDefault) { canvas.style.touchAction = "none"; }\n\n\t\t}\n\t\tstage.__touch.activeIDs = {};\n\t},\n\n\t/**\n\t * @private\n\t * @param {easeljs.Stage} stage\n\t */\n\t_IE_disable (stage) {\n\t\tlet f = stage.__touch.f;\n\n\t\tif (window.PointerEvent === undefined) {\n\t\t\twindow.removeEventListener("MSPointerMove", f, false);\n\t\t\twindow.removeEventListener("MSPointerUp", f, false);\n\t\t\twindow.removeEventListener("MSPointerCancel", f, false);\n\t\t\tif (stage.canvas) {\n\t\t\t\tstage.canvas.removeEventListener("MSPointerDown", f, false);\n\t\t\t}\n\t\t} else {\n\t\t\twindow.removeEventListener("pointermove", f, false);\n\t\t\twindow.removeEventListener("pointerup", f, false);\n\t\t\twindow.removeEventListener("pointercancel", f, false);\n\t\t\tif (stage.canvas) {\n\t\t\t\tstage.canvas.removeEventListener("pointerdown", f, false);\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * @private\n\t * @param {easeljs.Stage} stage\n\t * @param {Object} e The event to handle.\n\t */\n\t_IE_handleEvent (stage, e) {\n\t\tif (!stage) { return; }\n\t\tif (stage.__touch.preventDefault) { e.preventDefault && e.preventDefault(); }\n\t\tlet type = e.type;\n\t\tlet id = e.pointerId;\n\t\tlet ids = stage.__touch.activeIDs;\n\n\t\tif (type === "MSPointerDown" || type === "pointerdown") {\n\t\t\tif (e.srcElement != stage.canvas) { return; }\n\t\t\tids[id] = true;\n\t\t\tthis._handleStart(stage, id, e, e.pageX, e.pageY);\n\t\t} else if (ids[id]) { // it\'s an id we\'re watching\n\t\t\tif (type === "MSPointerMove" || type === "pointermove") {\n\t\t\t\tthis._handleMove(stage, id, e, e.pageX, e.pageY);\n\t\t\t} else if (type === "MSPointerUp" || type === "MSPointerCancel"\n\t\t\t\t\t|| type === "pointerup" || type === "pointercancel") {\n\t\t\t\tdelete(ids[id]);\n\t\t\t\tthis._handleEnd(stage, id, e);\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * @private\n\t * @param {easeljs.Stage} stage\n\t * @param {String | Number} id\n\t * @param {Object} e\n\t * @param {Number} x\n\t * @param {Number} y\n\t */\n\t_handleStart (stage, id, e, x, y) {\n\t\tlet props = stage.__touch;\n\t\tif (!props.multitouch && props.count) { return; }\n\t\tlet ids = props.pointers;\n\t\tif (ids[id]) { return; }\n\t\tids[id] = true;\n\t\tprops.count++;\n\t\tstage._handlePointerDown(id, e, x, y);\n\t},\n\n\t/**\n\t * @private\n\t * @param {easeljs.Stage} stage\n\t * @param {String | Number} id\n\t * @param {Object} e\n\t * @param {Number} x\n\t * @param {Number} y\n\t */\n\t_handleMove (stage, id, e, x, y) {\n\t\tif (!stage.__touch.pointers[id]) { return; }\n\t\tstage._handlePointerMove(id, e, x, y);\n\t},\n\n\t/**\n\t * @private\n\t * @param {easeljs.Stage} stage\n\t * @param {String | Number} id\n\t * @param {Object} e\n\t */\n\t_handleEnd (stage, id, e) {\n\t\t// TODO: cancel should be handled differently for proper UI (ex. an up would trigger a click, a cancel would more closely resemble an out).\n\t\tlet props = stage.__touch;\n\t\tlet ids = props.pointers;\n\t\tif (!ids[id]) { return; }\n\t\tprops.count--;\n\t\tstage._handlePointerUp(id, e, true);\n\t\tdelete(ids[id]);\n\t}\n\n});\n\n// CONCATENATED MODULE: ./node_modules/@createjs/easeljs/src/utils/SpriteSheetBuilder.js\n/**\n * @license SpriteSheetBuilder\n * Visit http://createjs.com/ for documentation, updates and examples.\n *\n * Copyright (c) 2017 gskinner.com, inc.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the "Software"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n\n\n\n\n/**\n * The SpriteSheetBuilder allows you to generate {@link easeljs.SpriteSheet} instances at run time\n * from any display object. This can allow you to maintain your assets as vector graphics (for low file size), and\n * render them at run time as SpriteSheets for better performance.\n *\n * SpriteSheets can be built either synchronously, or asynchronously, so that large SpriteSheets can be generated\n * without locking the UI.\n *\n * Note that the "images" used in the generated SpriteSheet are actually canvas elements, and that they will be\n * sized to the nearest power of 2 up to the value of {@link easeljs.SpriteSheetBuilder#maxWidth}\n * or {@link easeljs.SpriteSheetBuilder#maxHeight}.\n *\n * @memberof easeljs\n * @extends core.EventDispatcher\n *\n * @param {Number} [framerate=0] The {{#crossLink "SpriteSheet/framerate:property"}}{{/crossLink}} of\n * {@link easeljs.SpriteSheet} instances that are created.\n */\nclass SpriteSheetBuilder_SpriteSheetBuilder extends events_EventDispatcher {\n\n\tconstructor (framerate = 0) {\n\t\tsuper();\n\n\t\t/**\n\t\t * The maximum width for the images (not individual frames) in the generated SpriteSheet. It is recommended to\n\t\t * use a power of 2 for this value (ex. 1024, 2048, 4096). If the frames cannot all fit within the max\n\t\t * dimensions, then additional images will be created as needed.\n\t\t * @type {Number}\n\t\t * @default 2048\n\t\t*/\n\t\tthis.maxWidth = 2048;\n\n\t\t/**\n\t\t * The maximum height for the images (not individual frames) in the generated SpriteSheet. It is recommended to\n\t\t * use a power of 2 for this value (ex. 1024, 2048, 4096). If the frames cannot all fit within the max\n\t\t * dimensions, then additional images will be created as needed.\n\t\t * @type {Number}\n\t\t * @default 2048\n\t\t */\n\t\tthis.maxHeight = 2048;\n\n\t\t/**\n\t\t * The SpriteSheet that was generated. This will be null before a build is completed successfully.\n\t\t * @type {easeljs.SpriteSheet}\n\t\t */\n\t\tthis.spriteSheet = null;\n\n\t\t/**\n\t\t * The scale to apply when drawing all frames to the SpriteSheet. This is multiplied against any scale specified\n\t\t * in the addFrame call. This can be used, for example, to generate a SpriteSheet at run time that is tailored\n\t\t * to the a specific device resolution (ex. tablet vs mobile).\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t */\n\t\tthis.scale = 1;\n\n\t\t/**\n\t\t* The padding to use between frames. This is helpful to preserve antialiasing on drawn vector content.\n\t\t* @type {Number}\n\t\t* @default 1\n\t\t*/\n\t\tthis.padding = 1;\n\n\t\t/**\n\t\t * A number from 0.01 to 0.99 that indicates what percentage of time the builder can use. This can be\n\t\t * thought of as the number of seconds per second the builder will use. For example, with a timeSlice value of 0.3,\n\t\t * the builder will run 20 times per second, using approximately 15ms per build (30% of available time, or 0.3s per second).\n\t\t * Defaults to 0.3.\n\t\t * @type {Number}\n\t\t * @default 0.3\n\t\t */\n\t\tthis.timeSlice = 0.3;\n\n\t\t/**\n\t\t * A value between 0 and 1 that indicates the progress of a build, or -1 if a build has not\n\t\t * been initiated.\n\t\t * @type {Number}\n\t\t * @default -1\n\t\t * @readonly\n\t\t */\n\t\tthis.progress = -1;\n\n\t\t/**\n\t\t * A {@link easeljs.SpriteSheet#framerate} value that will be passed to new SpriteSheet instances that are\n\t\t * created. If no framerate is specified (or it is 0), then SpriteSheets will use the {@link core.Ticker} framerate.\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.framerate = framerate;\n\n\t\t/**\n\t\t * @protected\n\t\t * @type {Array}\n\t\t */\n\t\tthis._frames = [];\n\n\t\t/**\n\t\t * @protected\n\t\t * @type {Array}\n\t\t */\n\t\tthis._animations = {};\n\n\t\t/**\n\t\t * @protected\n\t\t * @type {Array}\n\t\t */\n\t\tthis._data = null;\n\n\t\t/**\n\t\t * @protected\n\t\t * @type {Number}\n\t\t */\n\t\tthis._nextFrameIndex = 0;\n\n\t\t/**\n\t\t * @protected\n\t\t * @type {Number}\n\t\t */\n\t\tthis._index = 0;\n\n\t\t/**\n\t\t * @protected\n\t\t * @type {Number}\n\t\t */\n\t\tthis._timerID = null;\n\n\t\t/**\n\t\t * @protected\n\t\t * @type {Number}\n\t\t */\n\t\tthis._scale = 1;\n\t}\n\n\t/**\n\t * Adds a frame to the {@link easeljs.SpriteSheet}. Note that the frame will not be drawn until you\n\t * call {@link easeljs.SpriteSheetBuilder#build} method. The optional setup params allow you to have\n\t * a function run immediately before the draw occurs. For example, this allows you to add a single source multiple\n\t * times, but manipulate it or its children to change it to generate different frames.\n\t *\n\t * Note that the source\'s transformations (x, y, scale, rotate, alpha) will be ignored, except for regX/Y. To apply\n\t * transforms to a source object and have them captured in the SpriteSheet, simply place it into a {@link easeljs.Container}\n\t * and pass in the Container as the source.\n\t * @param {easeljs.DisplayObject} source The source {{#crossLink "DisplayObject"}}{{/crossLink}}  to draw as the frame.\n\t * @param {easeljs.Rectangle} [sourceRect] A {{#crossLink "Rectangle"}}{{/crossLink}} defining the portion of the\n\t * source to draw to the frame. If not specified, it will look for a `getBounds` method, bounds property, or\n\t * `nominalBounds` property on the source to use. If one is not found, the frame will be skipped.\n\t * @param {Number} [scale=1] Optional. The scale to draw this frame at. Default is 1.\n\t * @param {Function} [setupFunction] A function to call immediately before drawing this frame. It will be called with two parameters: the source, and setupData.\n\t * @param {Object} [setupData] Arbitrary setup data to pass to setupFunction as the second parameter.\n\t * @return {Number} The index of the frame that was just added, or null if a sourceRect could not be determined.\n\t */\n\taddFrame (source, sourceRect, scale = 1, setupFunction, setupData) {\n\t\tif (this._data) { throw SpriteSheetBuilder_SpriteSheetBuilder.ERR_RUNNING; }\n\t\tlet rect = sourceRect||source.bounds||source.nominalBounds||(source.getBounds&&source.getBounds());\n\t\tif (!rect) { return null; }\n\t\treturn this._frames.push({ source, sourceRect: rect, scale, funct: setupFunction, data: setupData, index: this._frames.length, height: rect.height*scale }) - 1;\n\t}\n\n\t/**\n\t * Adds an animation that will be included in the created {@link easeljs.SpriteSheet}.\n\t * @param {String} name The name for the animation.\n\t * @param {Array} frames An array of frame indexes that comprise the animation. Ex. [3,6,5] would describe an animation\n\t * that played frame indexes 3, 6, and 5 in that order.\n\t * @param {String} [next] Specifies the name of the animation to continue to after this animation ends. You can\n\t * also pass false to have the animation stop when it ends. By default it will loop to the start of the same animation.\n\t * @param {Number} [speed] Specifies a frame advance speed for this animation. For example, a value of 0.5 would\n\t * cause the animation to advance every second tick. Note that earlier versions used `frequency` instead, which had\n\t * the opposite effect.\n\t */\n\taddAnimation (name, frames, next, speed) {\n\t\tif (this._data) { throw SpriteSheetBuilder_SpriteSheetBuilder.ERR_RUNNING; }\n\t\tthis._animations[name] = { frames, next, speed };\n\t}\n\n\t/**\n\t * This will take a {@link easeljs.MovieClip} instance, and add its frames and labels to this\n\t * builder. Labels will be added as an animation running from the label index to the next label. For example, if\n\t * there is a label named "foo" at frame 0 and a label named "bar" at frame 10, in a MovieClip with 15 frames, it\n\t * will add an animation named "foo" that runs from frame index 0 to 9, and an animation named "bar" that runs from\n\t * frame index 10 to 14.\n\t *\n\t * Note that this will iterate through the full MovieClip with {@link easeljs.MovieClip#actionsEnabled}\n\t * set to `false`, ending on the last frame.\n\t * @param {easeljs.MovieClip} source The source MovieClip instance to add to the SpriteSheet.\n\t * @param {easeljs.Rectangle} [sourceRect] A Rectangle defining the portion of the source to\n\t * draw to the frame. If not specified, it will look for a {{#crossLink "DisplayObject/getBounds"}}{{/crossLink}}\n\t * method, `frameBounds` Array, `bounds` property, or `nominalBounds` property on the source to use. If one is not\n\t * found, the MovieClip will be skipped.\n\t * @param {Number} [scale=1] The scale to draw the movie clip at.\n\t * @param {Function} [setupFunction] A function to call immediately before drawing each frame. It will be called\n\t * with three parameters: the source, setupData, and the frame index.\n\t * @param {Object} [setupData] Arbitrary setup data to pass to setupFunction as the second parameter.\n\t * @param {Function} [labelFunction] This method will be called for each MovieClip label that is added with four\n\t * parameters: the label name, the source MovieClip instance, the starting frame index (in the movieclip timeline)\n\t * and the end index. It must return a new name for the label/animation, or `false` to exclude the label.\n\t */\n\taddMovieClip (source, sourceRect, scale = 1, setupFunction, setupData, labelFunction) {\n\t\tif (this._data) { throw SpriteSheetBuilder_SpriteSheetBuilder.ERR_RUNNING; }\n\t\tlet rects = source.frameBounds;\n\t\tlet rect = sourceRect||source.bounds||source.nominalBounds||(source.getBounds&&source.getBounds());\n\t\tif (!rect && !rects) { return; }\n\n\t\tlet baseFrameIndex = this._frames.length;\n\t\tconst duration = source.timeline.duration;\n\t\tfor (let i=0; i<duration; i++) {\n\t\t\tlet r = (rects&&rects[i]) ? rects[i] : rect;\n\t\t\tthis.addFrame(source, r, scale, this._setupMovieClipFrame, {i, f:setupFunction, d:setupData});\n\t\t}\n\t\tconst labels = source.timeline._labels;\n\t\tlet lbls = [];\n\t\tfor (let n in labels) {\n\t\t\tlbls.push({index:labels[n], label:n});\n\t\t}\n\t\tif (lbls.length) {\n\t\t\tlbls.sort((a, b) => a.index-b.index);\n\t\t\tfor (let i=0,l=lbls.length; i<l; i++) {\n\t\t\t\tlet label = lbls[i].label;\n\t\t\t\tlet start = baseFrameIndex+lbls[i].index;\n\t\t\t\tlet end = baseFrameIndex+((i === l-1) ? duration : lbls[i+1].index);\n\t\t\t\tlet frames = [];\n\t\t\t\tfor (let i=start; i<end; i++) { frames.push(i); }\n\t\t\t\tif (labelFunction) {\n\t\t\t\t\tlabel = labelFunction(label, source, start, end);\n\t\t\t\t\tif (!label) { continue; }\n\t\t\t\t}\n\t\t\t\tthis.addAnimation(label, frames, true); // for now, this loops all animations.\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Builds a {@link easeljs.SpriteSheet} instance based on the current frames.\n\t * @return {easeljs.SpriteSheet} The created SpriteSheet instance, or null if a build is already running or an error\n\t * occurred.\n\t */\n\tbuild () {\n\t\tif (this._data) { throw SpriteSheetBuilder_SpriteSheetBuilder.ERR_RUNNING; }\n\t\tthis._startBuild();\n\t\twhile (this._drawNext()) {}\n\t\tthis._endBuild();\n\t\treturn this.spriteSheet;\n\t}\n\n\t/**\n\t * Asynchronously builds a {@link easeljs.SpriteSheet} instance based on the current frames. It will\n\t * run 20 times per second, using an amount of time defined by `timeSlice`. When it is complete it will call the\n\t * specified callback.\n\t * @param {Number} [timeSlice] Sets the timeSlice property on this instance.\n\t */\n\tbuildAsync (timeSlice) {\n\t\tif (this._data) { throw SpriteSheetBuilder_SpriteSheetBuilder.ERR_RUNNING; }\n\t\tthis.timeSlice = timeSlice;\n\t\tthis._startBuild();\n\t\tthis._timerID = setTimeout(() => this._run(), 50-Math.max(0.01, Math.min(0.99, this.timeSlice||0.3))*50);\n\t}\n\n\t/**\n\t * Stops the current asynchronous build.\n\t */\n\tstopAsync () {\n\t\tclearTimeout(this._timerID);\n\t\tthis._data = null;\n\t}\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @override\n\t * @return {String} a string representation of the instance.\n\t */\n\ttoString () {\n\t\treturn `[${this.constructor.name}]`;\n\t}\n\n\t/**\n\t * @protected\n\t */\n\t_startBuild () {\n\t\tlet pad = this.padding||0;\n\t\tthis.progress = 0;\n\t\tthis.spriteSheet = null;\n\t\tthis._index = 0;\n\t\tthis._scale = this.scale;\n\t\tlet dataFrames = [];\n\t\tthis._data = {\n\t\t\timages: [],\n\t\t\tframes: dataFrames,\n\t\t\tframerate: this.framerate,\n\t\t\tanimations: this._animations // TODO: should we "clone" _animations in case someone adds more animations after a build?\n\t\t};\n\n\t\tlet frames = this._frames.slice();\n\t\tframes.sort((a, b) => (a.height<=b.height) ? -1 : 1);\n\n\t\tif (frames[frames.length-1].height+pad*2 > this.maxHeight) { throw SpriteSheetBuilder_SpriteSheetBuilder.ERR_DIMENSIONS; }\n\t\tlet y=0, x=0;\n\t\tlet img = 0;\n\t\twhile (frames.length) {\n\t\t\tlet o = this._fillRow(frames, y, img, dataFrames, pad);\n\t\t\tif (o.w > x) { x = o.w; }\n\t\t\ty += o.h;\n\t\t\tif (!o.h || !frames.length) {\n\t\t\t\tlet canvas = window.createjs&&createjs.createCanvas?createjs.createCanvas():document.createElement("canvas");\n\t\t\t\tcanvas.width = this._getSize(x,this.maxWidth);\n\t\t\t\tcanvas.height = this._getSize(y,this.maxHeight);\n\t\t\t\tthis._data.images[img] = canvas;\n\t\t\t\tif (!o.h) {\n\t\t\t\t\tx=y=0;\n\t\t\t\t\timg++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * @protected\n\t * @return {Number} The width & height of the row.\n\t */\n\t_setupMovieClipFrame (source, data) {\n\t\tlet ae = source.actionsEnabled;\n\t\tsource.actionsEnabled = false;\n\t\tsource.gotoAndStop(data.i);\n\t\tsource.actionsEnabled = ae;\n\t\tdata.f&&data.f(source, data.d, data.i);\n\t}\n\n\t/**\n\t * @protected\n\t * @return {Number} The width & height of the row.\n\t */\n\t_getSize (size, max) {\n\t\tlet pow = 4;\n\t\twhile (Math.pow(2, ++pow) < size) {}\n\t\treturn Math.min(max, Math.pow(2, pow));\n\t};\n\n\t/**\n\t * @protected\n\t * @param {Array} frames\n\t * @param {Number} y\n\t * @param {HTMLImageElement} img\n\t * @param {Object} dataFrames\n\t * @param {Number} pad\n\t * @return {Number} The width & height of the row.\n\t */\n\t_fillRow (frames, y, img, dataFrames, pad) {\n\t\tlet w = this.maxWidth;\n\t\tlet maxH = this.maxHeight;\n\t\ty += pad;\n\t\tlet h = maxH-y;\n\t\tlet x = pad;\n\t\tlet height = 0;\n\t\tfor (let i=frames.length-1; i>=0; i--) {\n\t\t\tlet frame = frames[i];\n\t\t\tlet sc = this._scale*frame.scale;\n\t\t\tlet rect = frame.sourceRect;\n\t\t\tlet source = frame.source;\n\t\t\tlet rx = Math.floor(sc*rect.x-pad);\n\t\t\tlet ry = Math.floor(sc*rect.y-pad);\n\t\t\tlet rh = Math.ceil(sc*rect.height+pad*2);\n\t\t\tlet rw = Math.ceil(sc*rect.width+pad*2);\n\t\t\tif (rw > w) { throw SpriteSheetBuilder_SpriteSheetBuilder.ERR_DIMENSIONS; }\n\t\t\tif (rh > h || x+rw > w) { continue; }\n\t\t\tframe.img = img;\n\t\t\tframe.rect = new Rectangle(x,y,rw,rh);\n\t\t\theight = height || rh;\n\t\t\tframes.splice(i,1);\n\t\t\tdataFrames[frame.index] = [x,y,rw,rh,img,Math.round(-rx+sc*source.regX-pad),Math.round(-ry+sc*source.regY-pad)];\n\t\t\tx += rw;\n\t\t}\n\t\treturn {w:x, h:height};\n\t}\n\n\t/**\n\t * @protected\n\t */\n\t_endBuild () {\n\t\tthis.spriteSheet = new SpriteSheet_SpriteSheet(this._data);\n\t\tthis._data = null;\n\t\tthis.progress = 1;\n\t\tthis.dispatchEvent("complete");\n\t}\n\n\t/**\n\t * @protected\n\t */\n\t_run () {\n\t\tlet ts = Math.max(0.01, Math.min(0.99, this.timeSlice||0.3))*50;\n\t\tlet t = (new Date()).getTime()+ts;\n\t\tlet complete = false;\n\t\twhile (t > (new Date()).getTime()) {\n\t\t\tif (!this._drawNext()) { complete = true; break; }\n\t\t}\n\t\tif (complete) {\n\t\t\tthis._endBuild();\n\t\t} else {\n\t\t\tthis._timerID = setTimeout(() => this._run(), 50-ts);\n\t\t}\n\t\tlet p = this.progress = this._index/this._frames.length;\n\t\tif (this.hasEventListener("progress")) {\n\t\t\tlet evt = new events_Event("progress");\n\t\t\tevt.progress = p;\n\t\t\tthis.dispatchEvent(evt);\n\t\t}\n\t}\n\n\t/**\n\t * @protected\n\t * @return {Boolean} Returns false if this is the last draw.\n\t */\n\t_drawNext () {\n\t\tlet frame = this._frames[this._index];\n\t\tlet sc = frame.scale*this._scale;\n\t\tlet rect = frame.rect;\n\t\tlet sourceRect = frame.sourceRect;\n\t\tlet canvas = this._data.images[frame.img];\n\t\tlet ctx = canvas.getContext("2d");\n\t\tframe.funct&&frame.funct(frame.source, frame.data);\n\t\tctx.save();\n\t\tctx.beginPath();\n\t\tctx.rect(rect.x, rect.y, rect.width, rect.height);\n\t\tctx.clip();\n\t\tctx.translate(Math.ceil(rect.x-sourceRect.x*sc), Math.ceil(rect.y-sourceRect.y*sc));\n\t\tctx.scale(sc,sc);\n\t\tframe.source.draw(ctx); // display object will draw itself.\n\t\tctx.restore();\n\t\treturn (++this._index) < this._frames.length;\n\t}\n\n}\n\n/**\n * @static\n * @readonly\n * @protected\n * @type {String}\n */\nSpriteSheetBuilder_SpriteSheetBuilder.ERR_DIMENSIONS = "frame dimensions exceed max spritesheet dimensions";\n/**\n * @static\n * @readonly\n * @protected\n * @type {String}\n */\nSpriteSheetBuilder_SpriteSheetBuilder.ERR_RUNNING = "a build is already running";\n\n/**\n * Dispatched when a build completes.\n * @event easeljs.SpriteSheetBuilder#complete\n * @property {Object} target The object that dispatched the event.\n * @property {String} type The event type.\n * @since 0.6.0\n */\n\n/**\n * Dispatched when an asynchronous build has progress.\n * @event easeljs.SpriteSheetBuilder#progress\n * @property {Object} target The object that dispatched the event.\n * @property {String} type The event type.\n * @property {Number} progress The current progress value (0-1).\n * @since 0.6.0\n */\n\n// CONCATENATED MODULE: ./node_modules/@createjs/easeljs/src/utils/SpriteSheetUtils.js\n/*\n* @license SpriteSheetUtils\n* Visit http://createjs.com/ for documentation, updates and examples.\n*\n* Copyright (c) 2017 gskinner.com, inc.\n*\n* Permission is hereby granted, free of charge, to any person\n* obtaining a copy of this software and associated documentation\n* files (the "Software"), to deal in the Software without\n* restriction, including without limitation the rights to use,\n* copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the\n* Software is furnished to do so, subject to the following\n* conditions:\n*\n* The above copyright notice and this permission notice shall be\n* included in all copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,\n* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n* OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n\n\n/**\n * The SpriteSheetUtils class is a collection of static methods for working with {{#crossLink "SpriteSheet"}}{{/crossLink}}s.\n * A sprite sheet is a series of images (usually animation frames) combined into a single image on a regular grid. For\n * example, an animation consisting of 8 100x100 images could be combined into a 400x200 sprite sheet (4 frames across\n * by 2 high). The SpriteSheetUtils class uses a static interface and should not be instantiated.\n *\n * @memberof easeljs\n * @name easeljs.SpriteSheetUtils\n */\n/* harmony default export */ var SpriteSheetUtils = ({\n\n\t/**\n\t * @protected\n\t * @type {HTMLCanvasElement | Object}\n\t */\n\t_workingCanvas: createCanvas(),\n\n\t/**\n\t * @protected\n\t * @type {CanvasRenderingContext2D}\n\t */\n\tget _workingContext () { return this._workingCanvas.getContext("2d"); },\n\n\t/**\n\t * Returns a single frame of the specified sprite sheet as a new PNG image. An example of when this may be useful is\n\t * to use a spritesheet frame as the source for a bitmap fill.\n\t *\n\t * <strong>WARNING:</strong> In almost all cases it is better to display a single frame using a {@link easeljs.Sprite}\n\t * with a {@link easeljs.Sprite#gotoAndStop} call than it is to slice out a frame using this\n\t * method and display it with a Bitmap instance. You can also crop an image using the {@link easeljs.Bitmap#sourceRect}\n\t * property of {@link easeljs.Bitmap}.\n\t *\n\t * The extractFrame method may cause cross-domain warnings since it accesses pixels directly on the canvas.\n\t *\n\t * @param {easeljs.SpriteSheet} spriteSheet The SpriteSheet instance to extract a frame from.\n\t * @param {Number | String} frameOrAnimation The frame number or animation name to extract. If an animation\n\t * name is specified, only the first frame of the animation will be extracted.\n\t * @return {HTMLImageElement} a single frame of the specified sprite sheet as a new PNG image.\n\t */\n\textractFrame (spriteSheet, frameOrAnimation) {\n\t\tif (isNaN(frameOrAnimation)) {\n\t\t\tframeOrAnimation = spriteSheet.getAnimation(frameOrAnimation).frames[0];\n\t\t}\n\t\tlet data = spriteSheet.getFrame(frameOrAnimation);\n\t\tif (!data) { return null; }\n\t\tlet r = data.rect;\n\t\tlet canvas = this._workingCanvas;\n\t\tcanvas.width = r.width;\n\t\tcanvas.height = r.height;\n\t\tthis._workingContext.drawImage(data.image, r.x, r.y, r.width, r.height, 0, 0, r.width, r.height);\n\t\tlet img = document.createElement("img");\n\t\timg.src = canvas.toDataURL("image/png");\n\t\treturn img;\n\t},\n\n\t/**\n\t * @protected\n\t * @param {easeljs.SpriteSheet} spriteSheet\n\t * @param {Number} count\n\t * @param {Number} h\n\t * @param {Number} v\n\t */\n\t_flip (spriteSheet, count, h, v) {\n\t\tlet imgs = spriteSheet._images;\n\t\tlet canvas = this._workingCanvas;\n\t\tlet ctx = this._workingContext;\n\t\tconst il = imgs.length/count;\n\t\tfor (let i=0; i<il; i++) {\n\t\t\tlet src = imgs[i];\n\t\t\tsrc.__tmp = i; // a bit hacky, but faster than doing indexOf below.\n\t\t\tctx.setTransform(1,0,0,1,0,0);\n\t\t\tctx.clearRect(0,0,canvas.width+1,canvas.height+1);\n\t\t\tcanvas.width = src.width;\n\t\t\tcanvas.height = src.height;\n\t\t\tctx.setTransform(h?-1:1, 0, 0, v?-1:1, h?src.width:0, v?src.height:0);\n\t\t\tctx.drawImage(src,0,0);\n\t\t\tlet img = document.createElement("img");\n\t\t\timg.src = canvas.toDataURL("image/png");\n\t\t\t// work around a strange bug in Safari:\n\t\t\timg.width = (src.width||src.naturalWidth);\n\t\t\timg.height = (src.height||src.naturalHeight);\n\t\t\timgs.push(img);\n\t\t}\n\n\t\tlet frames = spriteSheet._frames;\n\t\tconst fl = frames.length/count;\n\t\tfor (let i=0; i<fl; i++) {\n\t\t\tlet src = frames[i];\n\t\t\tlet rect = src.rect.clone();\n\t\t\tlet img = imgs[src.image.__tmp+il*count];\n\n\t\t\tlet frame = {image:img,rect,regX:src.regX,regY:src.regY};\n\t\t\tif (h) {\n\t\t\t\trect.x = (img.width||img.naturalWidth)-rect.x-rect.width; // update rect\n\t\t\t\tframe.regX = rect.width-src.regX; // update registration point\n\t\t\t}\n\t\t\tif (v) {\n\t\t\t\trect.y = (img.height||img.naturalHeight)-rect.y-rect.height;  // update rect\n\t\t\t\tframe.regY = rect.height-src.regY; // update registration point\n\t\t\t}\n\t\t\tframes.push(frame);\n\t\t}\n\n\t\tlet sfx = `_${h?"h":""}${v?"v":""}`;\n\t\tlet names = spriteSheet._animations;\n\t\tlet data = spriteSheet._data;\n\t\tconst al = names.length/count;\n\t\tfor (let i=0; i<al; i++) {\n\t\t\tlet name = names[i];\n\t\t\tlet src = data[name];\n\t\t\tlet anim = {name:name+sfx,speed:src.speed,next:src.next,frames:[]};\n\t\t\tif (src.next) { anim.next += sfx; }\n\t\t\tlet frames = src.frames;\n\t\t\tfor (let i=0,l=frames.length;i<l;i++) {\n\t\t\t\tanim.frames.push(frames[i]+fl*count);\n\t\t\t}\n\t\t\tdata[anim.name] = anim;\n\t\t\tnames.push(anim.name);\n\t\t}\n\t}\n\n});\n\n// CONCATENATED MODULE: ./node_modules/@createjs/easeljs/src/utils/WebGLInspector.js\n/**\n * @license WebGLInspector\n * Visit http://createjs.com/ for documentation, updates and examples.\n *\n * Copyright (c) 2017 gskinner.com, inc.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the "Software"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n\n\n /**\n  * A utility and helper class designed to work with {{#crossLink "StageGL"}}{{/crossLink}} to help investigate and\n  * test performance or display problems. It contains logging functions to analyze behaviour and performance testing\n  * utilities.\n  *\n  * @memberof easeljs\n  * @extends core.EventDispatcher\n  *\n  * @param {StageGL} stage The default stage to use when none is supplied.\n  */\nclass WebGLInspector_WebGLInspector extends events_EventDispatcher {\n\n\tconstructor (stage) {\n\t\tsuper();\n\n\t\t/**\n\t\t * The internal reference to the default stage this Inspector is for.\n\t\t * @protected\n\t\t * @type {easeljs.StageGL}\n\t\t */\n\t\tthis._stage = stage;\n\t}\n\n\t/**\n\t * Utility function for use with {@link easeljs.WebGLInspector#logDepth}. Logs an item\'s position and registration.\n\t * Useful to see if something is being forced off screen or has an integer position.\n\t * @param {easeljs.DisplayObject} item The item we\'re currently logging about.\n\t * @param {String} [prepend] The string to show before the item, usually formatting for a tree view.\n\t * @static\n\t */\n\tstatic dispProps (item, prepend = "") {\n\t\tlet p = `\\tP: ${item.x.toFixed(2)}x${item.y.toFixed(2)}\\t`;\n\t\tlet r = `\\tR: ${item.regX.toFixed(2)}x${item.regY.toFixed(2)}\\t`;\n\t\tWebGLInspector_WebGLInspector._log(prepend, `${item.toString()}\\t`, p, r);\n\t}\n\n\t/**\n\t * Log with alternateOutput if available, defaulting to the console.\n\t * @param {...*} info The info to log.\n\t * @static\n\t */\n\tstatic _log (...info) {\n\t\tif (WebGLInspector_WebGLInspector.alternateOutput) {\n\t\t\tWebGLInspector_WebGLInspector.alternateOutput.log(...info);\n\t\t} else {\n\t\t\tconsole.log(...info);\n\t\t}\n\t}\n\n\t/**\n\t * Perform all of the logging reports at once.\n\t * @param {easeljs.StageGL} [stage] The stage to log information for.\n\t */\n\tlog (stage) {\n\t\tif (!stage) { stage = this._stage; }\n\t\tWebGLInspector_WebGLInspector._log(`Batches Per Draw: ${(stage._batchID/stage._drawID).toFixed(4)}`);\n\t\tthis.logContextInfo(stage._webGLContext);\n\t\tthis.logDepth(stage.children, "");\n\t\tthis.logTextureFill(stage);\n\t}\n\n\t/**\n\t * Replace the stage\'s Draw command with an empty draw command. This is useful for testing performance, and ignoring rendering.\n\t * @param {StageGL} [stage=] The stage to log information for.\n\t * @param {Boolean} [enabled] Force enabled. If left undefined, it will toggle.\n\t */\n\ttoggleGPUDraw (stage, enabled) {\n\t\tif (!stage) { stage = this._stage; }\n\n\t\tif (enabled === undefined) {\n\t\t\tenabled = !!stage._drawBuffers_;\n\t\t}\n\n\t\tif (enabled && stage._drawBuffers_) {\n\t\t\tstage._drawBuffers = stage._drawBuffers_;\n\t\t\tstage._drawBuffers_ = undefined;\n\t\t} else {\n\t\t\tstage._drawBuffers_ = stage._drawBuffers;\n\t\t\tstage._drawBuffers = function _inspectorDrawBuffers (gl) {\n\t\t\t\tif (this.vocalDebug) {\n\t\t\t\t\tWebGLInspector_WebGLInspector._log(`BlankDraw[${this._drawID}:${this._batchID}] : ${this.batchReason}`);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Recursively walk the entire display tree, log the attached items, and display it in a tree view.\n\t * @param {Array} [children] The children array to walk through.\n\t * @param {String} [prepend] What to prepend to this output from this point onwards.\n\t * @param {Function} [logFunc] Custom logging function, mainly for filtering or formatting output.\n\t */\n\tlogDepth (children, prepend = "", logFunc = WebGLInspector_WebGLInspector._log) {\n\t\tif (!children) { children = this._stage.children; }\n\t\tconst l = children.length;\n\t\tfor (let i=0; i<l; i++) {\n\t\t\tlet child = children[i];\n\t\t\tlogFunc(`${prepend}-`, child);\n\t\t\tif (child.children && child.children.length) {\n\t\t\t\tthis.logDepth(child.children, `|${prepend}`, logFunc);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Examine the context and provide information about its capabilities.\n\t * @param {WebGLRenderingContext} [gl] The WebGL context to inspect.\n\t */\n\tlogContextInfo (gl) {\n\t\tif (!gl) { gl = this._stage._webGLContext; }\n\t\tlet data = `\n\t\t\t== LOG:\\n\n\t\t\tMax textures per draw: ${gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS)}\\n\n\t\t\tMax textures active: ${gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS)}\\n\n\t\t\t\\n\n\t\t\tMax texture size: ${gl.getParameter(gl.MAX_TEXTURE_SIZE)/2}\\n\n\t\t\tMax cache size: ${gl.getParameter(gl.MAX_RENDERBUFFER_SIZE)/2}\\n\n\t\t\t\\n\n\t\t\tMax attributes per vertex: ${gl.getParameter(gl.MAX_VERTEX_ATTRIBS)}\\n\n\t\t\tWebGL Version string: ${gl.getParameter(gl.VERSION)}\\n\n\t\t\t======\n\t\t`;\n\t\tWebGLInspector_WebGLInspector._log(data);\n\t}\n\n\t/**\n\t * Simulate renders and watch what happens for textures moving around between draw calls. A texture moving between\n\t * slots means it was removed and then re-added to draw calls. Performance may be better if it was allowed to stay\n\t * in place.\n\t * @param {StageGL} [stage] The stage to log information for.\n\t */\n\tlogTextureFill (stage) {\n\t\tif (!stage) { stage = this._stage; }\n\n\t\tlet dict = stage._textureDictionary;\n\t\tlet count = stage._batchTextureCount;\n\t\tWebGLInspector_WebGLInspector._log(`${textureMax}: ${count}`);\n\t\tlet output = [];\n\t\tfor (let n in dict) {\n\t\t\tlet str = n.replace(window.location.origin, "");\n\t\t\tlet tex = dict[n];\n\t\t\tlet shifted = tex._lastActiveIndex?tex._lastActiveIndex === tex._activeIndex:false;\n\t\t\toutput.push({src, element:tex, shifted});\n\t\t\ttex._lastActiveIndex = tex._activeIndex;\n\t\t}\n\n\t\toutput.sort((a,b) => {\n\t\t\tif (a.element._drawID === stage._drawID) { return 1; }\n\t\t\tif (a.element._drawID < b.element._drawID) { return -1; }\n\t\t\treturn 0;\n\t\t});\n\n\t\tconst l = output.length;\n\t\tfor (let i=0; i<l; i++) {\n\t\t\tlet out = output[i];\n\t\t\tlet active = out.element._drawID === stage._drawID;\n\t\t\tWebGLInspector_WebGLInspector._log(`[${out.src}] ${active?"ACTIVE":"stale"} ${out.shifted?"steady":"DRIFT"}`, out.element);\n\t\t}\n\t}\n\n}\n\n/**\n * Alternate output for debugging situations where "console" is not available, i.e. Mobile or remote debugging.\n * Expects object with a "log" function that takes any number of params.\n * @type {Console}\n * @default null\n * @static\n * @protected\n */\nWebGLInspector_WebGLInspector.alternateOutput = null;\n\n// CONCATENATED MODULE: ./node_modules/@createjs/easeljs/src/main.js\n/**\n * The core classes of EaselJS.\n * @namespace easeljs\n *\n * @example\n * import { Stage, Shape } from "@createjs/easeljs";\n * const stage = new Stage("myCanvas");\n * const shape = new Shape();\n * shape.graphics.beginFill("red").drawCircle(0, 0, 50);\n * stage.addChild(shape);\n * stage.update();\n */\n\n/**\n * README: Export Order\n *\n * Due to some classes having circular import bindings (whether at the top of the import chain or deeper in),\n * some exports here are in reverse order (such as Container being exported before DisplayObject).\n * This is explained here: https://github.com/rollup/rollup/issues/845#issuecomment-240277194\n */\n\n// core\n\n\n// display\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// events\n\n// filters\n\n\n\n\n\n\n\n\n// geom\n\n\n\n\n// ui\n\n\n// utils\n\n\n\n\n\n\n// CONCATENATED MODULE: ./src/js/index.js\n\n\nconst js_stage = new Stage_Stage(\'myCanvas\');\nconst circle = new Shape_Shape();\ncircle.graphics.beginFill(\'DarkRed\').drawCircle(0, 0, 50);\njs_stage.addChild(circle);\ncircle.x = 300;\ncircle.y = 200;\nTween_Tween.get(circle, {\n  loop: true\n}).wait(300).to({\n  x: 740,\n  y: 400,\n  scale: 2\n}, 700).to({\n  x: 400,\n  y: 0,\n  scale: 1.4\n}, 1200).to({\n  x: 500,\n  y: 300,\n  scale: 3\n}, 1200).to({\n  x: 300,\n  y: 200,\n  scale: 1\n}, 700);\nupdate(); // \n\nfunction update() {\n  js_stage.update();\n  requestAnimationFrame(() => update());\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGNyZWF0ZWpzL2NvcmUvc3JjL2V2ZW50cy9FdmVudC5qcz84NDZlIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AY3JlYXRlanMvY29yZS9zcmMvZXZlbnRzL0V2ZW50RGlzcGF0Y2hlci5qcz80OTc2Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AY3JlYXRlanMvY29yZS9zcmMvdXRpbHMvVGlja2VyLmpzPzMxNjMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BjcmVhdGVqcy9jb3JlL3NyYy9tYWluLmpzPzFhOGIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BjcmVhdGVqcy9lYXNlbGpzL3NyYy9kaXNwbGF5L1N0YWdlR0wuanM/MTJmZCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGNyZWF0ZWpzL2Vhc2VsanMvc3JjL2Rpc3BsYXkvU2hhZG93LmpzPzg5ZjQiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BjcmVhdGVqcy9lYXNlbGpzL3NyYy91dGlscy91aWQuanM/MTY1YSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGNyZWF0ZWpzL2Vhc2VsanMvc3JjL2dlb20vUG9pbnQuanM/ODk0NCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGNyZWF0ZWpzL2Vhc2VsanMvc3JjL2dlb20vTWF0cml4MkQuanM/NGFmOSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGNyZWF0ZWpzL2Vhc2VsanMvc3JjL2dlb20vRGlzcGxheVByb3BzLmpzPzNmZmYiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BjcmVhdGVqcy9lYXNlbGpzL3NyYy9nZW9tL1JlY3RhbmdsZS5qcz8zNGM5Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AY3JlYXRlanMvZWFzZWxqcy9zcmMvZmlsdGVycy9GaWx0ZXIuanM/ZWZlYiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGNyZWF0ZWpzL2Vhc2VsanMvc3JjL2ZpbHRlcnMvQml0bWFwQ2FjaGUuanM/NGMyZCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGNyZWF0ZWpzL2Vhc2VsanMvc3JjL2Rpc3BsYXkvRGlzcGxheU9iamVjdC5qcz8wZDllIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AY3JlYXRlanMvZWFzZWxqcy9zcmMvZGlzcGxheS9Db250YWluZXIuanM/NGNmYiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGNyZWF0ZWpzL2Vhc2VsanMvc3JjL2V2ZW50cy9Nb3VzZUV2ZW50LmpzPzhiNDAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BjcmVhdGVqcy9lYXNlbGpzL3NyYy9kaXNwbGF5L1N0YWdlLmpzP2U4MjkiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BjcmVhdGVqcy9lYXNlbGpzL3NyYy91dGlscy9DYW52YXMuanM/ZjUyOCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGNyZWF0ZWpzL2Vhc2VsanMvc3JjL3V0aWxzL1ZpZGVvQnVmZmVyLmpzP2ZiMTAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BjcmVhdGVqcy9lYXNlbGpzL3NyYy9kaXNwbGF5L0JpdG1hcC5qcz9jMTI4Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AY3JlYXRlanMvZWFzZWxqcy9zcmMvZGlzcGxheS9TcHJpdGUuanM/YTdjNiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGNyZWF0ZWpzL2Vhc2VsanMvc3JjL2Rpc3BsYXkvQml0bWFwVGV4dC5qcz82MzE0Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AY3JlYXRlanMvZWFzZWxqcy9zcmMvZGlzcGxheS9ET01FbGVtZW50LmpzPzcxOWEiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BjcmVhdGVqcy9lYXNlbGpzL3NyYy9kaXNwbGF5L0dyYXBoaWNzLmpzPzlhZGUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BjcmVhdGVqcy90d2VlbmpzL3NyYy9BYnN0cmFjdFR3ZWVuLmpzP2Q4MjYiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BjcmVhdGVqcy90d2VlbmpzL3NyYy9FYXNlLmpzPzdiZTAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BjcmVhdGVqcy90d2VlbmpzL3NyYy9Ud2Vlbi5qcz82YmVhIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AY3JlYXRlanMvdHdlZW5qcy9zcmMvVGltZWxpbmUuanM/OWI0OCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGNyZWF0ZWpzL3R3ZWVuanMvc3JjL21haW4uanM/YWQ4MyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGNyZWF0ZWpzL2Vhc2VsanMvc3JjL2Rpc3BsYXkvTW92aWVDbGlwLmpzP2JiMzUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BjcmVhdGVqcy9lYXNlbGpzL3NyYy9kaXNwbGF5L1NoYXBlLmpzPzU0MWQiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BjcmVhdGVqcy9lYXNlbGpzL3NyYy9kaXNwbGF5L1Nwcml0ZVNoZWV0LmpzPzRmMmQiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BjcmVhdGVqcy9lYXNlbGpzL3NyYy9kaXNwbGF5L1RleHQuanM/NDZmNSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGNyZWF0ZWpzL2Vhc2VsanMvc3JjL2ZpbHRlcnMvQWxwaGFNYXBGaWx0ZXIuanM/Y2ZiMyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGNyZWF0ZWpzL2Vhc2VsanMvc3JjL2ZpbHRlcnMvQWxwaGFNYXNrRmlsdGVyLmpzP2Y4MDciLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BjcmVhdGVqcy9lYXNlbGpzL3NyYy9maWx0ZXJzL0JsdXJGaWx0ZXIuanM/YjRkNCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGNyZWF0ZWpzL2Vhc2VsanMvc3JjL2ZpbHRlcnMvQ29sb3JGaWx0ZXIuanM/ZmY2MyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGNyZWF0ZWpzL2Vhc2VsanMvc3JjL2ZpbHRlcnMvQ29sb3JNYXRyaXguanM/ODkwMSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGNyZWF0ZWpzL2Vhc2VsanMvc3JjL2ZpbHRlcnMvQ29sb3JNYXRyaXhGaWx0ZXIuanM/NWJjYyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGNyZWF0ZWpzL2Vhc2VsanMvc3JjL3VpL0J1dHRvbkhlbHBlci5qcz8xZjU1Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AY3JlYXRlanMvZWFzZWxqcy9zcmMvdWkvVG91Y2guanM/N2I0YyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGNyZWF0ZWpzL2Vhc2VsanMvc3JjL3V0aWxzL1Nwcml0ZVNoZWV0QnVpbGRlci5qcz8xMThhIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AY3JlYXRlanMvZWFzZWxqcy9zcmMvdXRpbHMvU3ByaXRlU2hlZXRVdGlscy5qcz85M2M5Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AY3JlYXRlanMvZWFzZWxqcy9zcmMvdXRpbHMvV2ViR0xJbnNwZWN0b3IuanM/MmUxMSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGNyZWF0ZWpzL2Vhc2VsanMvc3JjL21haW4uanM/ZDM0YSIsIndlYnBhY2s6Ly8vLi9zcmMvanMvaW5kZXguanM/N2JhNSJdLCJuYW1lcyI6WyJzdGFnZSIsIlN0YWdlIiwiY2lyY2xlIiwiU2hhcGUiLCJncmFwaGljcyIsImJlZ2luRmlsbCIsImRyYXdDaXJjbGUiLCJhZGRDaGlsZCIsIngiLCJ5IiwiVHdlZW4iLCJnZXQiLCJsb29wIiwid2FpdCIsInRvIiwic2NhbGUiLCJ1cGRhdGUiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiXSwibWFwcGluZ3MiOiI7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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WUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0VBQXdFLGdDQUFnQztBQUN4RyxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQ0FBaUM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLE9BQU8sT0FBTyxnQ0FBZ0MsT0FBTyxFQUFFO0FBQzdGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFB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Q0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ087QUFDUDtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDTztBQUNQO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNPO0FBQ1A7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ087QUFDUDtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDTztBQUNQO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNPO0FBQ1A7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ087QUFDUDtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDTztBQUNQO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNPO0FBQ1A7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ087QUFDUDtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDTztBQUNQO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNPO0FBQ1A7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ087QUFDUDtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDTztBQUNQO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNPO0FBQ1A7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ087QUFDUDtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDTztBQUNQO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNPO0FBQ1A7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ087OztBQzFXUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFNBQVMsV0FBSztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFdBQUs7O0FBRUw7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxXQUFLOztBQUVMO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsV0FBSzs7QUFFTDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFdBQUs7O0FBRUw7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxXQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixXQUFXLEVBQUU7QUFDYixXQUFXLEVBQUU7QUFDYixXQUFXLEVBQUU7QUFDYixXQUFXLEVBQUU7QUFDYixXQUFXLEVBQUU7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixXQUFXLEVBQUU7QUFDYixXQUFXLEVBQUU7QUFDYixXQUFXLEVBQUU7QUFDYixXQUFXLEVBQUU7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FDOXlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTRDOztBQUU1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdB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LEVBSkwsQ0FJUTtBQUFDTixHQUFDLEVBQUUsR0FBSjtBQUFTQyxHQUFDLEVBQUUsR0FBWjtBQUFpQk0sT0FBSyxFQUFFO0FBQXhCLENBSlIsRUFJb0MsSUFKcEMsRUFLS0QsRUFMTCxDQUtRO0FBQUNOLEdBQUMsRUFBRSxHQUFKO0FBQVNDLEdBQUMsRUFBRSxHQUFaO0FBQWlCTSxPQUFLLEVBQUU7QUFBeEIsQ0FMUixFQUtvQyxHQUxwQztBQU9BQyxNQUFNLEcsQ0FFTjs7QUFDQSxTQUFTQSxNQUFULEdBQWtCO0FBQ2RoQixVQUFLLENBQUNnQixNQUFOO0FBQ0FDLHVCQUFxQixDQUFDLE1BQU1ELE1BQU0sRUFBYixDQUFyQjtBQUNIIiwiZmlsZSI6IjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIEV2ZW50XG4gKiBWaXNpdCBodHRwOi8vY3JlYXRlanMuY29tLyBmb3IgZG9jdW1lbnRhdGlvbiwgdXBkYXRlcyBhbmQgZXhhbXBsZXMuXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IGdza2lubmVyLmNvbSwgaW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gKiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxuICogZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0XG4gKiByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSxcbiAqIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiAqIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXG4gKiBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gKiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICogRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTXG4gKiBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICogTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcbiAqIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLFxuICogV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4gKiBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SXG4gKiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLyoqXG4gKiBDb250YWlucyBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIHNoYXJlZCBieSBhbGwgZXZlbnRzIGZvciB1c2Ugd2l0aCB7QGxpbmsgY29yZS5FdmVudERpc3BhdGNoZXJ9LlxuICogTm90ZSB0aGF0IEV2ZW50IG9iamVjdHMgYXJlIG9mdGVuIHJldXNlZCwgc28geW91IHNob3VsZCBuZXZlclxuICogcmVseSBvbiBhbiBldmVudCBvYmplY3QncyBzdGF0ZSBvdXRzaWRlIG9mIHRoZSBjYWxsIHN0YWNrIGl0IHdhcyByZWNlaXZlZCBpbi5cbiAqXG4gKiBAbWVtYmVyb2YgY29yZVxuICogQGV4YW1wbGVcbiAqIGNvbnN0IGV2dCA9IG5ldyBFdmVudChcIm15RXZlbnRcIik7XG4gKiBjb25zdCBkaXNwYXRjaGVyID0gbmV3IEV2ZW50RGlzcGF0Y2hlcigpO1xuICogZGlzcGF0Y2hlci5vbihcIm15RXZlbnRcIiwgZXZlbnQgPT4gY29uc29sZS5sb2coZXZlbnQudHlwZSkpO1xuICogZGlzcGF0Y2hlci5kaXNwYXRjaEV2ZW50KGV2dCk7IC8vIGxvZ3MgXCJteUV2ZW50XCJcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2J1YmJsZXM9ZmFsc2VdIEluZGljYXRlcyB3aGV0aGVyIHRoZSBldmVudCB3aWxsIGJ1YmJsZSB0aHJvdWdoIHRoZSBkaXNwbGF5IGxpc3QuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtjYW5jZWxhYmxlPWZhbHNlXSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZGVmYXVsdCBiZWhhdmlvdXIgb2YgdGhpcyBldmVudCBjYW4gYmUgY2FuY2VsbGVkLlxuICovXG5jbGFzcyBFdmVudCB7XG5cblx0Y29uc3RydWN0b3IgKHR5cGUsIGJ1YmJsZXMgPSBmYWxzZSwgY2FuY2VsYWJsZSA9IGZhbHNlKSB7XG5cdFx0LyoqXG5cdFx0ICogVGhlIHR5cGUgb2YgZXZlbnQuXG5cdFx0ICogQHR5cGUgc3RyaW5nXG5cdFx0ICovXG5cdFx0dGhpcy50eXBlID0gdHlwZTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBvYmplY3QgdGhhdCBnZW5lcmF0ZWQgYW4gZXZlbnQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICovXG5cdFx0dGhpcy50YXJnZXQgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGN1cnJlbnQgdGFyZ2V0IHRoYXQgYSBidWJibGluZyBldmVudCBpcyBiZWluZyBkaXNwYXRjaGVkIGZyb20uIEZvciBub24tYnViYmxpbmcgZXZlbnRzLCB0aGlzIHdpbGxcblx0XHQgKiBhbHdheXMgYmUgdGhlIHNhbWUgYXMgdGFyZ2V0LiBGb3IgZXhhbXBsZSwgaWYgY2hpbGRPYmoucGFyZW50ID0gcGFyZW50T2JqLCBhbmQgYSBidWJibGluZyBldmVudFxuXHRcdCAqIGlzIGdlbmVyYXRlZCBmcm9tIGNoaWxkT2JqLCB0aGVuIGEgbGlzdGVuZXIgb24gcGFyZW50T2JqIHdvdWxkIHJlY2VpdmUgdGhlIGV2ZW50IHdpdGhcblx0XHQgKiB0YXJnZXQ9Y2hpbGRPYmogKHRoZSBvcmlnaW5hbCB0YXJnZXQpIGFuZCBjdXJyZW50VGFyZ2V0PXBhcmVudE9iaiAod2hlcmUgdGhlIGxpc3RlbmVyIHdhcyBhZGRlZCkuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICovXG5cdFx0dGhpcy5jdXJyZW50VGFyZ2V0ID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEZvciBidWJibGluZyBldmVudHMsIHRoaXMgaW5kaWNhdGVzIHRoZSBjdXJyZW50IGV2ZW50IHBoYXNlOlxuXHRcdCAqIDxPTD5cblx0XHQgKiBcdDxMST4gY2FwdHVyZSBwaGFzZTogc3RhcnRpbmcgZnJvbSB0aGUgdG9wIHBhcmVudCB0byB0aGUgdGFyZ2V0PC9MST5cblx0XHQgKiBcdDxMST4gYXQgdGFyZ2V0IHBoYXNlOiBjdXJyZW50bHkgYmVpbmcgZGlzcGF0Y2hlZCBmcm9tIHRoZSB0YXJnZXQ8L0xJPlxuXHRcdCAqIFx0PExJPiBidWJibGluZyBwaGFzZTogZnJvbSB0aGUgdGFyZ2V0IHRvIHRoZSB0b3AgcGFyZW50PC9MST5cblx0XHQgKiA8L09MPlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgbnVtYmVyXG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqL1xuXHRcdHRoaXMuZXZlbnRQaGFzZSA9IDA7XG5cblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZXZlbnQgd2lsbCBidWJibGUgdGhyb3VnaCB0aGUgZGlzcGxheSBsaXN0LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgYm9vbGVhblxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqL1xuXHRcdHRoaXMuYnViYmxlcyA9IGJ1YmJsZXM7XG5cblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZGVmYXVsdCBiZWhhdmlvdXIgb2YgdGhpcyBldmVudCBjYW4gYmUgY2FuY2VsbGVkIHZpYSB7QGxpbmsgY29yZS5FdmVudCNwcmV2ZW50RGVmYXVsdH0uXG5cdFx0ICpcblx0XHQgKiBAdHlwZSBib29sZWFuXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICovXG5cdFx0dGhpcy5jYW5jZWxhYmxlID0gY2FuY2VsYWJsZTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBlcG9jaCB0aW1lIGF0IHdoaWNoIHRoaXMgZXZlbnQgd2FzIGNyZWF0ZWQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSBudW1iZXJcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKi9cblx0XHR0aGlzLnRpbWVTdGFtcCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIGlmIHtAbGluayBjb3JlLkV2ZW50I3ByZXZlbnREZWZhdWx0fSBoYXMgYmVlbiBjYWxsZWQgb24gdGhpcyBldmVudC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIGJvb2xlYW5cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqL1xuXHRcdHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIGlmIHtAbGluayBjb3JlLkV2ZW50I3N0b3BQcm9wYWdhdGlvbn0gb3Ige0BsaW5rIGNvcmUuRXZlbnQjc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9ufSBoYXMgYmVlbiBjYWxsZWQgb24gdGhpcyBldmVudC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIGJvb2xlYW5cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqL1xuXHRcdHRoaXMucHJvcGFnYXRpb25TdG9wcGVkID0gZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgaWYge0BsaW5rIGNvcmUuRXZlbnQjc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9ufSBoYXMgYmVlbiBjYWxsZWQgb24gdGhpcyBldmVudC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIGJvb2xlYW5cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqL1xuXHRcdHRoaXMuaW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgaWYge0BsaW5rIGNvcmUuRXZlbnQjcmVtb3ZlfSBoYXMgYmVlbiBjYWxsZWQgb24gdGhpcyBldmVudC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIGJvb2xlYW5cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqL1xuXHRcdHRoaXMucmVtb3ZlZCA9IGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMge0BsaW5rIGNvcmUuRXZlbnQjZGVmYXVsdFByZXZlbnRlZH0gdG8gdHJ1ZSBpZiB0aGUgZXZlbnQgaXMgY2FuY2VsYWJsZS5cblx0ICogTWlycm9ycyB0aGUgRE9NIGxldmVsIDIgZXZlbnQgc3RhbmRhcmQuIEluIGdlbmVyYWwsIGNhbmNlbGFibGUgZXZlbnRzIHRoYXQgaGF2ZSBgcHJldmVudERlZmF1bHQoKWAgY2FsbGVkIHdpbGxcblx0ICogY2FuY2VsIHRoZSBkZWZhdWx0IGJlaGF2aW91ciBhc3NvY2lhdGVkIHdpdGggdGhlIGV2ZW50LlxuXHQgKiBAcmV0dXJuIHtjb3JlLkV2ZW50fSB0aGlzLCBjaGFpbmFibGVcblx0ICovXG5cdHByZXZlbnREZWZhdWx0ICgpIHtcblx0XHR0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSB0aGlzLmNhbmNlbGFibGU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB7QGxpbmsgY29yZS5FdmVudCNwcm9wYWdhdGlvblN0b3BwZWR9IHRvIHRydWUuXG5cdCAqIE1pcnJvcnMgdGhlIERPTSBldmVudCBzdGFuZGFyZC5cblx0ICogQHJldHVybiB7Y29yZS5FdmVudH0gdGhpcywgY2hhaW5hYmxlXG5cdCAqL1xuXHRzdG9wUHJvcGFnYXRpb24gKCkge1xuXHRcdHRoaXMucHJvcGFnYXRpb25TdG9wcGVkID0gdHJ1ZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHtAbGluayBjb3JlLkV2ZW50I3Byb3BhZ2F0aW9uU3RvcHBlZH0gYW5kIHtAbGluayBjb3JlLkV2ZW50I2ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZH0gdG8gdHJ1ZS5cblx0ICogTWlycm9ycyB0aGUgRE9NIGV2ZW50IHN0YW5kYXJkLlxuXHQgKiBAcmV0dXJuIHtjb3JlLkV2ZW50fSB0aGlzLCBjaGFpbmFibGVcblx0ICovXG5cdHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiAoKSB7XG5cdFx0dGhpcy5pbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSB0aGlzLnByb3BhZ2F0aW9uU3RvcHBlZCA9IHRydWU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQ2F1c2VzIHRoZSBhY3RpdmUgbGlzdGVuZXIgdG8gYmUgcmVtb3ZlZCB2aWEgcmVtb3ZlRXZlbnRMaXN0ZW5lcigpO1xuXHQgKlxuXHQgKiBAZXhhbXBsZVxuXHQgKiBteUJ0bi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZXZlbnQgPT4ge1xuXHQgKiAgIGV2ZW50LnJlbW92ZSgpOyAvLyByZW1vdmVzIHRoaXMgbGlzdGVuZXIuXG5cdCAqIH0pO1xuXHQgKlxuXHQgKiBAcmV0dXJuIHtjb3JlLkV2ZW50fSB0aGlzLCBjaGFpbmFibGVcblx0ICovXG5cdHJlbW92ZSAoKSB7XG5cdFx0dGhpcy5yZW1vdmVkID0gdHJ1ZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIEV2ZW50IGluc3RhbmNlLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtjb3JlLkV2ZW50fSBhIGNsb25lIG9mIHRoZSBFdmVudCBpbnN0YW5jZS5cblx0ICovXG5cdGNsb25lICgpIHtcblx0XHRjb25zdCBldmVudCA9IG5ldyBFdmVudCh0aGlzLnR5cGUsIHRoaXMuYnViYmxlcywgdGhpcy5jYW5jZWxhYmxlKTtcblx0XHRmb3IgKGxldCBuIGluIHRoaXMpIHtcblx0XHRcdGlmICh0aGlzLmhhc093blByb3BlcnR5KG4pKSB7XG5cdFx0XHRcdGV2ZW50W25dID0gdGhpc1tuXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGV2ZW50O1xuXHR9XG5cblx0LyoqXG5cdCAqIFByb3ZpZGVzIGEgcmV0dXJuIHtjb3JlLkV2ZW50fSB0aGlzLCBjaGFpbmFibGUgc2hvcnRjdXQgbWV0aG9kIGZvciBzZXR0aW5nIGEgbnVtYmVyIG9mIHByb3BlcnRpZXMgb24gdGhlIGluc3RhbmNlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQSBnZW5lcmljIG9iamVjdCBjb250YWluaW5nIHByb3BlcnRpZXMgdG8gY29weSB0byB0aGUgaW5zdGFuY2UuXG5cdCAqIEByZXR1cm4ge2NvcmUuRXZlbnR9IHRoaXMsIGNoYWluYWJsZVxuXHQgKi9cblx0c2V0IChwcm9wcykge1xuXHRcdGZvciAobGV0IG4gaW4gcHJvcHMpIHsgdGhpc1tuXSA9IHByb3BzW25dOyB9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cblx0ICpcblx0ICogQHJldHVybiB7c3RyaW5nfSBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXG5cdCAqL1xuXHR0b1N0cmluZyAoKSB7XG5cdFx0cmV0dXJuIGBbJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9ICh0eXBlPSR7dGhpcy50eXBlfSldYDtcblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IEV2ZW50O1xuIiwiLyoqXG4gKiBAbGljZW5zZSBFdmVudERpc3BhdGNoZXJcbiAqIFZpc2l0IGh0dHA6Ly9jcmVhdGVqcy5jb20vIGZvciBkb2N1bWVudGF0aW9uLCB1cGRhdGVzIGFuZCBleGFtcGxlcy5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgZ3NraW5uZXIuY29tLCBpbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAqIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXG4gKiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXRcbiAqIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxuICogY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuICogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbiAqIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAqIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gKiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcbiAqIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gKiBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuICogSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXG4gKiBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcbiAqIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5pbXBvcnQgRXZlbnQgZnJvbSBcIi4vRXZlbnRcIjtcblxuLyoqXG4gKiBFdmVudERpc3BhdGNoZXIgcHJvdmlkZXMgbWV0aG9kcyBmb3IgbWFuYWdpbmcgcXVldWVzIG9mIGV2ZW50IGxpc3RlbmVycyBhbmQgZGlzcGF0Y2hpbmcgZXZlbnRzLlxuICpcbiAqIFlvdSBjYW4gZWl0aGVyIGV4dGVuZCBFdmVudERpc3BhdGNoZXIgb3IgbWl4IGl0cyBtZXRob2RzIGludG8gYW4gZXhpc3RpbmcgcHJvdG90eXBlIG9yIGluc3RhbmNlIGJ5IHVzaW5nIHRoZVxuICogRXZlbnREaXNwYXRjaGVyIHtAbGluayBjb3JlLkV2ZW50RGlzcGF0Y2hlci5pbml0aWFsaXplfSBtZXRob2QuXG4gKlxuICogVG9nZXRoZXIgd2l0aCB0aGUgQ3JlYXRlSlMgRXZlbnQgY2xhc3MsIEV2ZW50RGlzcGF0Y2hlciBwcm92aWRlcyBhbiBleHRlbmRlZCBldmVudCBtb2RlbCB0aGF0IGlzIGJhc2VkIG9uIHRoZVxuICogRE9NIExldmVsIDIgZXZlbnQgbW9kZWwsIGluY2x1ZGluZyBhZGRFdmVudExpc3RlbmVyLCByZW1vdmVFdmVudExpc3RlbmVyLCBhbmQgZGlzcGF0Y2hFdmVudC4gSXQgc3VwcG9ydHNcbiAqIGJ1YmJsaW5nIC8gY2FwdHVyZSwgcHJldmVudERlZmF1bHQsIHN0b3BQcm9wYWdhdGlvbiwgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uLCBhbmQgaGFuZGxlRXZlbnQuXG4gKlxuICogRXZlbnREaXNwYXRjaGVyIGFsc28gZXhwb3NlcyBhIHtAbGluayBjb3JlLkV2ZW50RGlzcGF0Y2hlciNvbn0gbWV0aG9kLCB3aGljaCBtYWtlcyBpdCBlYXNpZXJcbiAqIHRvIGNyZWF0ZSBzY29wZWQgbGlzdGVuZXJzLCBsaXN0ZW5lcnMgdGhhdCBvbmx5IHJ1biBvbmNlLCBhbmQgbGlzdGVuZXJzIHdpdGggYXNzb2NpYXRlZCBhcmJpdHJhcnkgZGF0YS4gVGhlXG4gKiB7QGxpbmsgY29yZS5FdmVudERpc3BhdGNoZXIjb2ZmfSBtZXRob2QgaXMgbWVyZWx5IGFuIGFsaWFzIHRvIHtAbGluayBjb3JlLkV2ZW50RGlzcGF0Y2hlciNyZW1vdmVFdmVudExpc3RlbmVyfS5cbiAqXG4gKiBBbm90aGVyIGFkZGl0aW9uIHRvIHRoZSBET00gTGV2ZWwgMiBtb2RlbCBpcyB0aGUge0BsaW5rIGNvcmUuRXZlbnREaXNwYXRjaGVyI3JlbW92ZUFsbEV2ZW50TGlzdGVuZXJzfVxuICogbWV0aG9kLCB3aGljaCBjYW4gYmUgdXNlZCB0byBsaXN0ZW5lcnMgZm9yIGFsbCBldmVudHMsIG9yIGxpc3RlbmVycyBmb3IgYSBzcGVjaWZpYyBldmVudC4gVGhlIEV2ZW50IG9iamVjdCBhbHNvXG4gKiBpbmNsdWRlcyBhIHtAbGluayBjb3JlLkV2ZW50I3JlbW92ZX0gbWV0aG9kIHdoaWNoIHJlbW92ZXMgdGhlIGFjdGl2ZSBsaXN0ZW5lci5cbiAqXG4gKiBAbWVtYmVyb2YgY29yZVxuICogQGV4YW1wbGVcbiAqIC8vIGFkZCBFdmVudERpc3BhdGNoZXIgY2FwYWJpbGl0aWVzIHRvIHRoZSBcIk15Q2xhc3NcIiBjbGFzcy5cbiAqIEV2ZW50RGlzcGF0Y2hlci5pbml0aWFsaXplKE15Q2xhc3MucHJvdG90eXBlKTtcbiAqXG4gKiAvLyBBZGQgYW4gZXZlbnQuXG4gKiBpbnN0YW5jZS5hZGRFdmVudExpc3RlbmVyKFwiZXZlbnROYW1lXCIsIGV2ZW50ID0+IGNvbnNvbGUubG9nKGV2ZW50LnRhcmdldCArIFwiIHdhcyBjbGlja2VkLlwiKSk7XG4gKlxuICogLy8gc2NvcGUgKFwidGhpc1wiKSBjYW4gYmUgYmUgYSBjaGFsbGVuZ2Ugd2l0aCBldmVudHMuXG4gKiAvLyB1c2luZyB0aGUge0BsaW5rIGNvcmUuRXZlbnREaXNwYXRjaGVyI29ufSBtZXRob2QgdG8gc3Vic2NyaWJlIHRvIGV2ZW50cyBzaW1wbGlmaWVzIHRoaXMuXG4gKiBpbnN0YW5jZS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZXZlbnQgPT4gY29uc29sZS5sb2coaW5zdGFuY2UgPT09IHRoaXMpKTsgLy8gZmFsc2UsIHNjb3BlIGlzIGFtYmlndW91cy5cbiAqIGluc3RhbmNlLm9uKFwiY2xpY2tcIiwgZXZlbnQgPT4gY29uc29sZS5sb2coaW5zdGFuY2UgPT09IHRoaXMpKTsgLy8gdHJ1ZSwgYG9uYCB1c2VzIGRpc3BhdGNoZXIgc2NvcGUgYnkgZGVmYXVsdC5cbiAqL1xuY2xhc3MgRXZlbnREaXNwYXRjaGVyIHtcblxuXHQvKipcblx0ICogU3RhdGljIGluaXRpYWxpemVyIHRvIG1peCBFdmVudERpc3BhdGNoZXIgbWV0aG9kcyBpbnRvIGEgdGFyZ2V0IG9iamVjdCBvciBwcm90b3R5cGUuXG5cdCAqXG5cdCAqIEBzdGF0aWNcblx0ICogQGV4YW1wbGVcblx0ICogRXZlbnREaXNwYXRjaGVyLmluaXRpYWxpemUoTXlDbGFzcy5wcm90b3R5cGUpOyAvLyBhZGQgdG8gdGhlIHByb3RvdHlwZSBvZiB0aGUgY2xhc3Ncblx0ICogRXZlbnREaXNwYXRjaGVyLmluaXRpYWxpemUobXlJbnN0YW5jZSk7IC8vIGFkZCB0byBhIHNwZWNpZmljIGluc3RhbmNlXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIHRhcmdldCBvYmplY3QgdG8gaW5qZWN0IEV2ZW50RGlzcGF0Y2hlciBtZXRob2RzIGludG8uXG5cdCAqL1xuXHRzdGF0aWMgaW5pdGlhbGl6ZSAodGFyZ2V0KSB7XG5cdFx0Y29uc3QgcCA9IEV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGU7XG5cdFx0dGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIgPSBwLmFkZEV2ZW50TGlzdGVuZXI7XG5cdFx0dGFyZ2V0Lm9uID0gcC5vbjtcblx0XHR0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IHRhcmdldC5vZmYgPSBwLnJlbW92ZUV2ZW50TGlzdGVuZXI7XG5cdFx0dGFyZ2V0LnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzID0gcC5yZW1vdmVBbGxFdmVudExpc3RlbmVycztcblx0XHR0YXJnZXQuaGFzRXZlbnRMaXN0ZW5lciA9IHAuaGFzRXZlbnRMaXN0ZW5lcjtcblx0XHR0YXJnZXQuZGlzcGF0Y2hFdmVudCA9IHAuZGlzcGF0Y2hFdmVudDtcblx0XHR0YXJnZXQuX2Rpc3BhdGNoRXZlbnQgPSBwLl9kaXNwYXRjaEV2ZW50O1xuXHRcdHRhcmdldC53aWxsVHJpZ2dlciA9IHAud2lsbFRyaWdnZXI7XG5cdH1cblxuXHRjb25zdHJ1Y3RvciAoKSB7XG5cdFx0LyoqXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICovXG5cdFx0dGhpcy5fbGlzdGVuZXJzID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqL1xuXHRcdHRoaXMuX2NhcHR1cmVMaXN0ZW5lcnMgPSBudWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgdGhlIHNwZWNpZmllZCBldmVudCBsaXN0ZW5lci4gTm90ZSB0aGF0IGFkZGluZyBtdWx0aXBsZSBsaXN0ZW5lcnMgdG8gdGhlIHNhbWUgZnVuY3Rpb24gd2lsbCByZXN1bHQgaW5cblx0ICogbXVsdGlwbGUgY2FsbGJhY2tzIGdldHRpbmcgZmlyZWQuXG5cdCAqXG5cdCAqIEBleGFtcGxlXG5cdCAqIGRpc3BsYXlPYmplY3QuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGV2ZW50ID0+IGNvbnNvbGUubG9nKCdjbGlja2VkJywgZXZlbnQpKTtcblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVGhlIHN0cmluZyB0eXBlIG9mIHRoZSBldmVudC5cblx0ICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R9IGxpc3RlbmVyIEFuIG9iamVjdCB3aXRoIGEgaGFuZGxlRXZlbnQgbWV0aG9kLCBvciBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgZXZlbnQgaXMgZGlzcGF0Y2hlZC5cblx0ICogQHBhcmFtIHtib29sZWFufSBbdXNlQ2FwdHVyZT1mYWxzZV0gRm9yIGV2ZW50cyB0aGF0IGJ1YmJsZSwgaW5kaWNhdGVzIHdoZXRoZXIgdG8gbGlzdGVuIGZvciB0aGUgZXZlbnQgaW4gdGhlIGNhcHR1cmUgb3IgYnViYmxpbmcvdGFyZ2V0IHBoYXNlLlxuXHQgKiBAcmV0dXJuIHtGdW5jdGlvbnxPYmplY3R9IFJldHVybnMgdGhlIGxpc3RlbmVyIGZvciBjaGFpbmluZyBvciBhc3NpZ25tZW50LlxuXHQgKi9cblx0YWRkRXZlbnRMaXN0ZW5lciAodHlwZSwgbGlzdGVuZXIsIHVzZUNhcHR1cmUgPSBmYWxzZSkge1xuXHRcdGxldCBsaXN0ZW5lcnM7XG5cdFx0aWYgKHVzZUNhcHR1cmUpIHtcblx0XHRcdGxpc3RlbmVycyA9IHRoaXMuX2NhcHR1cmVMaXN0ZW5lcnMgPSB0aGlzLl9jYXB0dXJlTGlzdGVuZXJzIHx8IHt9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnMgfHwge307XG5cdFx0fVxuXHRcdGxldCBhcnIgPSBsaXN0ZW5lcnNbdHlwZV07XG5cdFx0aWYgKGFycikge1xuXHRcdFx0dGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKTtcblx0XHRcdGFyciA9IGxpc3RlbmVyc1t0eXBlXTsgLy8gcmVtb3ZlIG1heSBoYXZlIGRlbGV0ZWQgdGhlIGFycmF5XG5cdFx0fVxuXHRcdGlmIChhcnIpIHsgYXJyLnB1c2gobGlzdGVuZXIpOyAgfVxuXHRcdGVsc2UgeyBsaXN0ZW5lcnNbdHlwZV0gPSBbbGlzdGVuZXJdOyB9XG5cdFx0cmV0dXJuIGxpc3RlbmVyO1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgc2hvcnRjdXQgbWV0aG9kIGZvciB1c2luZyBhZGRFdmVudExpc3RlbmVyIHRoYXQgbWFrZXMgaXQgZWFzaWVyIHRvIHNwZWNpZnkgYW4gZXhlY3V0aW9uIHNjb3BlLCBoYXZlIGEgbGlzdGVuZXJcblx0ICogb25seSBydW4gb25jZSwgYXNzb2NpYXRlIGFyYml0cmFyeSBkYXRhIHdpdGggdGhlIGxpc3RlbmVyLCBhbmQgcmVtb3ZlIHRoZSBsaXN0ZW5lci5cblx0ICpcblx0ICogVGhpcyBtZXRob2Qgd29ya3MgYnkgY3JlYXRpbmcgYW4gYW5vbnltb3VzIHdyYXBwZXIgZnVuY3Rpb24gYW5kIHN1YnNjcmliaW5nIGl0IHdpdGggYGFkZEV2ZW50TGlzdGVuZXJgLlxuXHQgKiBUaGUgd3JhcHBlciBmdW5jdGlvbiBpcyByZXR1cm5lZCBmb3IgdXNlIHdpdGggYHJlbW92ZUV2ZW50TGlzdGVuZXJgIChvciBgb2ZmYCkuXG5cdCAqXG5cdCAqIFRvIHJlbW92ZSBhIGxpc3RlbmVyIGFkZGVkIHdpdGggYG9uYCwgeW91IG11c3QgcGFzcyBpbiB0aGUgcmV0dXJuZWQgd3JhcHBlciBmdW5jdGlvbiBhcyB0aGUgbGlzdGVuZXIsIG9yIHVzZVxuXHQgKiB7QGxpbmsgY29yZS5FdmVudCNyZW1vdmV9LiBMaWtld2lzZSwgZWFjaCB0aW1lIHlvdSBjYWxsIGBvbmAgYSBORVcgd3JhcHBlciBmdW5jdGlvbiBpcyBzdWJzY3JpYmVkLCBzbyBtdWx0aXBsZSBjYWxsc1xuXHQgKiB0byBgb25gIHdpdGggdGhlIHNhbWUgcGFyYW1zIHdpbGwgY3JlYXRlIG11bHRpcGxlIGxpc3RlbmVycy5cblx0ICpcblx0ICogQGV4YW1wbGVcblx0ICogY29uc3QgbGlzdGVuZXIgPSBteUJ0bi5vbihcImNsaWNrXCIsIGhhbmRsZUNsaWNrLCBudWxsLCBmYWxzZSwgeyBjb3VudDogMyB9KTtcblx0ICogZnVuY3Rpb24gaGFuZGxlQ2xpY2sgKGV2dCwgZGF0YSkge1xuXHQgKiAgIGRhdGEuY291bnQgLT0gMTtcblx0ICogICBjb25zb2xlLmxvZyh0aGlzID09IG15QnRuKTsgLy8gdHJ1ZSAtIHNjb3BlIGRlZmF1bHRzIHRvIHRoZSBkaXNwYXRjaGVyXG5cdCAqICAgaWYgKGRhdGEuY291bnQgPT0gMCkge1xuXHQgKiAgICAgYWxlcnQoXCJjbGlja2VkIDMgdGltZXMhXCIpO1xuXHQgKiAgICAgbXlCdG4ub2ZmKFwiY2xpY2tcIiwgbGlzdGVuZXIpO1xuXHQgKiAgICAgLy8gYWx0ZXJuYXRlbHk6IGV2dC5yZW1vdmUoKTtcblx0ICogICB9XG5cdCAqIH1cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVGhlIHN0cmluZyB0eXBlIG9mIHRoZSBldmVudC5cblx0ICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R9IGxpc3RlbmVyIEFuIG9iamVjdCB3aXRoIGEgaGFuZGxlRXZlbnQgbWV0aG9kLCBvciBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgZXZlbnQgaXMgZGlzcGF0Y2hlZC5cblx0ICogQHBhcmFtIHtPYmplY3R9IFtzY29wZT1udWxsXSBUaGUgc2NvcGUgdG8gZXhlY3V0ZSB0aGUgbGlzdGVuZXIgaW4uIERlZmF1bHRzIHRvIHRoZSBkaXNwYXRjaGVyL2N1cnJlbnRUYXJnZXQgZm9yIGZ1bmN0aW9uIGxpc3RlbmVycywgYW5kIHRvIHRoZSBsaXN0ZW5lciBpdHNlbGYgZm9yIG9iamVjdCBsaXN0ZW5lcnMgKGllLiB1c2luZyBoYW5kbGVFdmVudCkuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW29uY2U9ZmFsc2VdIElmIHRydWUsIHRoZSBsaXN0ZW5lciB3aWxsIHJlbW92ZSBpdHNlbGYgYWZ0ZXIgdGhlIGZpcnN0IHRpbWUgaXQgaXMgdHJpZ2dlcmVkLlxuXHQgKiBAcGFyYW0geyp9IFtkYXRhPXt9XSBBcmJpdHJhcnkgZGF0YSB0aGF0IHdpbGwgYmUgaW5jbHVkZWQgYXMgdGhlIHNlY29uZCBwYXJhbWV0ZXIgd2hlbiB0aGUgbGlzdGVuZXIgaXMgY2FsbGVkLlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VDYXB0dXJlPWZhbHNlXSBGb3IgZXZlbnRzIHRoYXQgYnViYmxlLCBpbmRpY2F0ZXMgd2hldGhlciB0byBsaXN0ZW4gZm9yIHRoZSBldmVudCBpbiB0aGUgY2FwdHVyZSBvciBidWJibGluZy90YXJnZXQgcGhhc2UuXG5cdCAqIEByZXR1cm4ge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBhbm9ueW1vdXMgZnVuY3Rpb24gdGhhdCB3YXMgY3JlYXRlZCBhbmQgYXNzaWduZWQgYXMgdGhlIGxpc3RlbmVyLiBUaGlzIGlzIG5lZWRlZCB0byByZW1vdmUgdGhlIGxpc3RlbmVyIGxhdGVyIHVzaW5nIC5yZW1vdmVFdmVudExpc3RlbmVyLlxuXHQgKi9cblx0b24gKHR5cGUsIGxpc3RlbmVyLCBzY29wZSA9IG51bGwsIG9uY2UgPSBmYWxzZSwgZGF0YSA9IHt9LCB1c2VDYXB0dXJlID0gZmFsc2UpIHtcblx0XHRpZiAobGlzdGVuZXIuaGFuZGxlRXZlbnQpIHtcblx0XHRcdHNjb3BlID0gc2NvcGUgfHwgbGlzdGVuZXI7XG5cdFx0XHRsaXN0ZW5lciA9IGxpc3RlbmVyLmhhbmRsZUV2ZW50O1xuXHRcdH1cblx0XHRzY29wZSA9IHNjb3BlIHx8IHRoaXM7XG5cdFx0cmV0dXJuIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBldnQgPT4ge1xuXHRcdFx0bGlzdGVuZXIuY2FsbChzY29wZSwgZXZ0LCBkYXRhKTtcblx0XHRcdG9uY2UgJiYgZXZ0LnJlbW92ZSgpO1xuXHRcdH0sIHVzZUNhcHR1cmUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgdGhlIHNwZWNpZmllZCBldmVudCBsaXN0ZW5lci5cblx0ICpcblx0ICogWW91IG11c3QgcGFzcyB0aGUgZXhhY3QgZnVuY3Rpb24gcmVmZXJlbmNlIHVzZWQgd2hlbiB0aGUgZXZlbnQgd2FzIGFkZGVkLiBJZiBhIHByb3h5XG5cdCAqIGZ1bmN0aW9uLCBvciBmdW5jdGlvbiBjbG9zdXJlIGlzIHVzZWQgYXMgdGhlIGNhbGxiYWNrLCB0aGUgcHJveHkvY2xvc3VyZSByZWZlcmVuY2UgbXVzdCBiZSB1c2VkIC0gYSBuZXcgcHJveHkgb3Jcblx0ICogY2xvc3VyZSB3aWxsIG5vdCB3b3JrLlxuXHQgKlxuXHQgKiBAZXhhbXBsZVxuXHQgKiBkaXNwbGF5T2JqZWN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBoYW5kbGVDbGljayk7XG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFRoZSBzdHJpbmcgdHlwZSBvZiB0aGUgZXZlbnQuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgZnVuY3Rpb24gb3Igb2JqZWN0LlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VDYXB0dXJlPWZhbHNlXSBGb3IgZXZlbnRzIHRoYXQgYnViYmxlLCBpbmRpY2F0ZXMgd2hldGhlciB0byBsaXN0ZW4gZm9yIHRoZSBldmVudCBpbiB0aGUgY2FwdHVyZSBvciBidWJibGluZy90YXJnZXQgcGhhc2UuXG5cdCAqL1xuXHRyZW1vdmVFdmVudExpc3RlbmVyICh0eXBlLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSA9IGZhbHNlKSB7XG5cdFx0Y29uc3QgbGlzdGVuZXJzID0gdXNlQ2FwdHVyZSA/IHRoaXMuX2NhcHR1cmVMaXN0ZW5lcnMgOiB0aGlzLl9saXN0ZW5lcnM7XG5cdFx0aWYgKCFsaXN0ZW5lcnMpIHsgcmV0dXJuOyB9XG5cdFx0Y29uc3QgYXJyID0gbGlzdGVuZXJzW3R5cGVdO1xuXHRcdGlmICghYXJyKSB7IHJldHVybjsgfVxuXHRcdGNvbnN0IGwgPSBhcnIubGVuZ3RoO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRpZiAoYXJyW2ldID09PSBsaXN0ZW5lcikge1xuXHRcdFx0XHRpZiAobCA9PT0gMSkgeyBkZWxldGUobGlzdGVuZXJzW3R5cGVdKTsgfSAvLyBhbGxvd3MgZm9yIGZhc3RlciBjaGVja3MuXG5cdFx0XHRcdGVsc2UgeyBhcnIuc3BsaWNlKGksIDEpOyB9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBBIHNob3J0Y3V0IHRvIHRoZSByZW1vdmVFdmVudExpc3RlbmVyIG1ldGhvZCwgd2l0aCB0aGUgc2FtZSBwYXJhbWV0ZXJzIGFuZCByZXR1cm4gdmFsdWUuIFRoaXMgaXMgYSBjb21wYW5pb24gdG8gdGhlXG5cdCAqIGBvbmAgbWV0aG9kLlxuXHQgKlxuXHQgKiBUbyByZW1vdmUgYSBsaXN0ZW5lciBhZGRlZCB3aXRoIGBvbmAsIHlvdSBtdXN0IHBhc3MgaW4gdGhlIHJldHVybmVkIHdyYXBwZXIgZnVuY3Rpb24gYXMgdGhlIGxpc3RlbmVyLiBTZWVcblx0ICoge0BsaW5rIGNvcmUuRXZlbnREaXNwYXRjaGVyI29ufSBmb3IgYW4gZXhhbXBsZS5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVGhlIHN0cmluZyB0eXBlIG9mIHRoZSBldmVudC5cblx0ICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R9IGxpc3RlbmVyIFRoZSBsaXN0ZW5lciBmdW5jdGlvbiBvciBvYmplY3QuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZUNhcHR1cmU9ZmFsc2VdIEZvciBldmVudHMgdGhhdCBidWJibGUsIGluZGljYXRlcyB3aGV0aGVyIHRvIGxpc3RlbiBmb3IgdGhlIGV2ZW50IGluIHRoZSBjYXB0dXJlIG9yIGJ1YmJsaW5nL3RhcmdldCBwaGFzZS5cblx0ICovXG5cdG9mZiAodHlwZSwgbGlzdGVuZXIsIHVzZUNhcHR1cmUgPSBmYWxzZSkge1xuXHRcdHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSk7XG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlcyBhbGwgbGlzdGVuZXJzIGZvciB0aGUgc3BlY2lmaWVkIHR5cGUsIG9yIGFsbCBsaXN0ZW5lcnMgb2YgYWxsIHR5cGVzLlxuXHQgKlxuXHQgKiBAZXhhbXBsZVxuXHQgKiAvLyByZW1vdmUgYWxsIGxpc3RlbmVyc1xuXHQgKiBkaXNwbGF5T2JqZWN0LnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzKCk7XG5cdCAqXG5cdCAqIC8vIHJlbW92ZSBhbGwgY2xpY2sgbGlzdGVuZXJzXG5cdCAqIGRpc3BsYXlPYmplY3QucmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnMoXCJjbGlja1wiKTtcblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlPW51bGxdIFRoZSBzdHJpbmcgdHlwZSBvZiB0aGUgZXZlbnQuIElmIG9taXR0ZWQsIGFsbCBsaXN0ZW5lcnMgZm9yIGFsbCB0eXBlcyB3aWxsIGJlIHJlbW92ZWQuXG5cdCAqL1xuXHRyZW1vdmVBbGxFdmVudExpc3RlbmVycyAodHlwZSA9IG51bGwpIHtcblx0XHRpZiAodHlwZSkge1xuXHRcdFx0aWYgKHRoaXMuX2xpc3RlbmVycykgeyBkZWxldGUodGhpcy5fbGlzdGVuZXJzW3R5cGVdKTsgfVxuXHRcdFx0aWYgKHRoaXMuX2NhcHR1cmVMaXN0ZW5lcnMpIHsgZGVsZXRlKHRoaXMuX2NhcHR1cmVMaXN0ZW5lcnNbdHlwZV0pOyB9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2xpc3RlbmVycyA9IHRoaXMuX2NhcHR1cmVMaXN0ZW5lcnMgPSBudWxsO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBEaXNwYXRjaGVzIHRoZSBzcGVjaWZpZWQgZXZlbnQgdG8gYWxsIGxpc3RlbmVycy5cblx0ICpcblx0ICogQGV4YW1wbGVcblx0ICogLy8gdXNlIGEgc3RyaW5nIGV2ZW50XG5cdCAqIHRoaXMuZGlzcGF0Y2hFdmVudChcImNvbXBsZXRlXCIpXG5cdCAqXG5cdCAqIC8vIHVzZSBhbiBFdmVudCBpbnN0YW5jZVxuXHQgKiBjb25zdCBldmVudCA9IG5ldyBjcmVhdGVqcy5FdmVudChcInByb2dyZXNzXCIpO1xuXHQgKiB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdHxFdmVudHxzdHJpbmd9IGV2ZW50T2JqIEFuIG9iamVjdCB3aXRoIGEgXCJ0eXBlXCIgcHJvcGVydHksIG9yIGEgc3RyaW5nIHR5cGUuXG5cdCAqIFdoaWxlIGEgZ2VuZXJpYyBvYmplY3Qgd2lsbCB3b3JrLCBpdCBpcyByZWNvbW1lbmRlZCB0byB1c2UgYSBDcmVhdGVKUyBFdmVudCBpbnN0YW5jZS4gSWYgYSBzdHJpbmcgaXMgdXNlZCxcblx0ICogZGlzcGF0Y2hFdmVudCB3aWxsIGNvbnN0cnVjdCBhbiBFdmVudCBpbnN0YW5jZSBpZiBuZWNlc3Nhcnkgd2l0aCB0aGUgc3BlY2lmaWVkIHR5cGUuIFRoaXMgbGF0dGVyIGFwcHJvYWNoIGNhblxuXHQgKiBiZSB1c2VkIHRvIGF2b2lkIGV2ZW50IG9iamVjdCBpbnN0YW50aWF0aW9uIGZvciBub24tYnViYmxpbmcgZXZlbnRzIHRoYXQgbWF5IG5vdCBoYXZlIGFueSBsaXN0ZW5lcnMuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2J1YmJsZXM9ZmFsc2VdIFNwZWNpZmllcyB0aGUgYGJ1YmJsZXNgIHZhbHVlIHdoZW4gYSBzdHJpbmcgd2FzIHBhc3NlZCB0byBldmVudE9iai5cblx0ICogQHBhcmFtIHtib29sZWFufSBbY2FuY2VsYWJsZT1mYWxzZV0gU3BlY2lmaWVzIHRoZSBgY2FuY2VsYWJsZWAgdmFsdWUgd2hlbiBhIHN0cmluZyB3YXMgcGFzc2VkIHRvIGV2ZW50T2JqLlxuXHQgKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIGZhbHNlIGlmIGBwcmV2ZW50RGVmYXVsdCgpYCB3YXMgY2FsbGVkIG9uIGEgY2FuY2VsYWJsZSBldmVudCwgdHJ1ZSBvdGhlcndpc2UuXG5cdCAqL1xuXHRkaXNwYXRjaEV2ZW50IChldmVudE9iaiwgYnViYmxlcyA9IGZhbHNlLCBjYW5jZWxhYmxlID0gZmFsc2UpIHtcblx0XHRpZiAodHlwZW9mIGV2ZW50T2JqID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHQvLyBza2lwIGV2ZXJ5dGhpbmcgaWYgdGhlcmUncyBubyBsaXN0ZW5lcnMgYW5kIGl0IGRvZXNuJ3QgYnViYmxlOlxuXHRcdFx0Y29uc3QgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuXHRcdFx0aWYgKCFidWJibGVzICYmICghbGlzdGVuZXJzIHx8ICFsaXN0ZW5lcnNbZXZlbnRPYmpdKSkgeyByZXR1cm4gdHJ1ZTsgfVxuXHRcdFx0ZXZlbnRPYmogPSBuZXcgRXZlbnQoZXZlbnRPYmosIGJ1YmJsZXMsIGNhbmNlbGFibGUpO1xuXHRcdH0gZWxzZSBpZiAoZXZlbnRPYmoudGFyZ2V0ICYmIGV2ZW50T2JqLmNsb25lKSB7XG5cdFx0XHQvLyByZWRpc3BhdGNoaW5nIGFuIGFjdGl2ZSBldmVudCBvYmplY3QsIHNvIGNsb25lIGl0OlxuXHRcdFx0ZXZlbnRPYmogPSBldmVudE9iai5jbG9uZSgpO1xuXHRcdH1cblxuXHRcdC8vIFRPRE86IGl0IHdvdWxkIGJlIG5pY2UgdG8gZWxpbWluYXRlIHRoaXMuIE1heWJlIGluIGZhdm91ciBvZiBldnRPYmogaW5zdGFuY2VvZiBFdmVudD8gT3IgISFldnRPYmouY3JlYXRlRXZlbnRcblx0XHR0cnkgeyBldmVudE9iai50YXJnZXQgPSB0aGlzOyB9IGNhdGNoIChlKSB7fSAvLyB0cnkvY2F0Y2ggYWxsb3dzIHJlZGlzcGF0Y2hpbmcgb2YgbmF0aXZlIGV2ZW50c1xuXG5cdFx0aWYgKCFldmVudE9iai5idWJibGVzIHx8ICF0aGlzLnBhcmVudCkge1xuXHRcdFx0dGhpcy5fZGlzcGF0Y2hFdmVudChldmVudE9iaiwgMik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxldCB0b3AgPSB0aGlzO1xuXHRcdFx0Y29uc3QgbGlzdCA9IFt0b3BdO1xuXHRcdFx0d2hpbGUgKHRvcC5wYXJlbnQpIHsgbGlzdC5wdXNoKHRvcCA9IHRvcC5wYXJlbnQpOyB9XG5cdFx0XHRjb25zdCBsID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRsZXQgaTtcblxuXHRcdFx0Ly8gY2FwdHVyZSAmIGF0VGFyZ2V0XG5cdFx0XHRmb3IgKGkgPSBsIC0gMTsgaSA+PSAwICYmICFldmVudE9iai5wcm9wYWdhdGlvblN0b3BwZWQ7IGktLSkge1xuXHRcdFx0XHRsaXN0W2ldLl9kaXNwYXRjaEV2ZW50KGV2ZW50T2JqLCAxKyhpPT0wKSk7XG5cdFx0XHR9XG5cdFx0XHQvLyBidWJibGluZ1xuXHRcdFx0Zm9yIChpID0gMTsgaSA8IGwgJiYgIWV2ZW50T2JqLnByb3BhZ2F0aW9uU3RvcHBlZDsgaSsrKSB7XG5cdFx0XHRcdGxpc3RbaV0uX2Rpc3BhdGNoRXZlbnQoZXZlbnRPYmosIDMpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gIWV2ZW50T2JqLmRlZmF1bHRQcmV2ZW50ZWQ7XG5cdH1cblxuXHQvKipcblx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIGxpc3RlbmVyIGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50IHR5cGUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFRoZSBzdHJpbmcgdHlwZSBvZiB0aGUgZXZlbnQuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgbGlzdGVuZXIgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnQuXG5cdCAqL1xuXHRoYXNFdmVudExpc3RlbmVyICh0eXBlKSB7XG5cdFx0Y29uc3QgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzLCBjYXB0dXJlTGlzdGVuZXJzID0gdGhpcy5fY2FwdHVyZUxpc3RlbmVycztcblx0XHRyZXR1cm4gISEoKGxpc3RlbmVycyAmJiBsaXN0ZW5lcnNbdHlwZV0pIHx8IChjYXB0dXJlTGlzdGVuZXJzICYmIGNhcHR1cmVMaXN0ZW5lcnNbdHlwZV0pKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgbGlzdGVuZXIgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnQgdHlwZSBvbiB0aGlzIG9iamVjdCBvciBhbnkgb2YgaXRzXG5cdCAqIGFuY2VzdG9ycyAocGFyZW50LCBwYXJlbnQncyBwYXJlbnQsIGV0YykuIEEgcmV0dXJuIHZhbHVlIG9mIHRydWUgaW5kaWNhdGVzIHRoYXQgaWYgYSBidWJibGluZyBldmVudCBvZiB0aGVcblx0ICogc3BlY2lmaWVkIHR5cGUgaXMgZGlzcGF0Y2hlZCBmcm9tIHRoaXMgb2JqZWN0LCBpdCB3aWxsIHRyaWdnZXIgYXQgbGVhc3Qgb25lIGxpc3RlbmVyLlxuXHQgKlxuXHQgKiBUaGlzIGlzIHNpbWlsYXIgdG8ge0BsaW5rIGNvcmUuRXZlbnREaXNwYXRjaGVyI2hhc0V2ZW50TGlzdGVuZXJ9LCBidXQgaXQgc2VhcmNoZXMgdGhlIGVudGlyZVxuXHQgKiBldmVudCBmbG93IGZvciBhIGxpc3RlbmVyLCBub3QganVzdCB0aGlzIG9iamVjdC5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVGhlIHN0cmluZyB0eXBlIG9mIHRoZSBldmVudC5cblx0ICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIGxpc3RlbmVyIGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50LlxuXHQgKi9cblx0d2lsbFRyaWdnZXIgKHR5cGUpIHtcblx0XHRsZXQgbyA9IHRoaXM7XG5cdFx0d2hpbGUgKG8pIHtcblx0XHRcdGlmIChvLmhhc0V2ZW50TGlzdGVuZXIodHlwZSkpIHsgcmV0dXJuIHRydWU7IH1cblx0XHRcdG8gPSBvLnBhcmVudDtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxuXHQgKi9cblx0dG9TdHJpbmcgKCkge1xuXHRcdHJldHVybiBgWyR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lICsgdGhpcy5uYW1lID8gYCAke3RoaXMubmFtZX1gIDogXCJcIn1dYDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge09iamVjdHxFdmVudHxzdHJpbmd9IGV2ZW50T2JqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFBoYXNlXG5cdCAqL1xuXHRfZGlzcGF0Y2hFdmVudCAoZXZlbnRPYmosIGV2ZW50UGhhc2UpIHtcblx0XHRjb25zdCBsaXN0ZW5lcnMgPSBldmVudFBoYXNlID09PSAxID8gdGhpcy5fY2FwdHVyZUxpc3RlbmVycyA6IHRoaXMuX2xpc3RlbmVycztcblx0XHRpZiAoZXZlbnRPYmogJiYgbGlzdGVuZXJzKSB7XG5cdFx0XHRsZXQgYXJyID0gbGlzdGVuZXJzW2V2ZW50T2JqLnR5cGVdO1xuXHRcdFx0bGV0IGw7XG5cdFx0XHRpZiAoIWFyciB8fCAobCA9IGFyci5sZW5ndGgpID09PSAwKSB7IHJldHVybjsgfVxuXHRcdFx0dHJ5IHsgZXZlbnRPYmouY3VycmVudFRhcmdldCA9IHRoaXM7IH0gY2F0Y2ggKGUpIHt9XG5cdFx0XHR0cnkgeyBldmVudE9iai5ldmVudFBoYXNlID0gZXZlbnRQaGFzZTsgfSBjYXRjaCAoZSkge31cblx0XHRcdGV2ZW50T2JqLnJlbW92ZWQgPSBmYWxzZTtcblxuXHRcdFx0YXJyID0gYXJyLnNsaWNlKCk7IC8vIHRvIGF2b2lkIGlzc3VlcyB3aXRoIGl0ZW1zIGJlaW5nIHJlbW92ZWQgb3IgYWRkZWQgZHVyaW5nIHRoZSBkaXNwYXRjaFxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsICYmICFldmVudE9iai5pbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ7IGkrKykge1xuXHRcdFx0XHRsZXQgbyA9IGFycltpXTtcblx0XHRcdFx0aWYgKG8uaGFuZGxlRXZlbnQpIHsgby5oYW5kbGVFdmVudChldmVudE9iaik7IH1cblx0XHRcdFx0ZWxzZSB7IG8oZXZlbnRPYmopOyB9XG5cdFx0XHRcdGlmIChldmVudE9iai5yZW1vdmVkKSB7XG5cdFx0XHRcdFx0dGhpcy5vZmYoZXZlbnRPYmoudHlwZSwgbywgZXZlbnRQaGFzZSA9PT0gMSk7XG5cdFx0XHRcdFx0ZXZlbnRPYmoucmVtb3ZlZCA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgRXZlbnREaXNwYXRjaGVyO1xuIiwiLyoqXG4gKiBAbGljZW5zZSBUaWNrZXJcbiAqIFZpc2l0IGh0dHA6Ly9jcmVhdGVqcy5jb20vIGZvciBkb2N1bWVudGF0aW9uLCB1cGRhdGVzIGFuZCBleGFtcGxlcy5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgZ3NraW5uZXIuY29tLCBpbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAqIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXG4gKiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXRcbiAqIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxuICogY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuICogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbiAqIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAqIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gKiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcbiAqIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gKiBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuICogSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXG4gKiBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcbiAqIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5pbXBvcnQgRXZlbnREaXNwYXRjaGVyIGZyb20gXCIuLi9ldmVudHMvRXZlbnREaXNwYXRjaGVyXCI7XG5pbXBvcnQgRXZlbnQgZnJvbSBcIi4uL2V2ZW50cy9FdmVudFwiO1xuXG4vKipcbiAqIFRoZSBUaWNrZXIgcHJvdmlkZXMgYSBjZW50cmFsaXplZCB0aWNrIG9yIGhlYXJ0YmVhdCBicm9hZGNhc3QgYXQgYSBzZXQgaW50ZXJ2YWwuIExpc3RlbmVycyBjYW4gc3Vic2NyaWJlIHRvIHRoZSB0aWNrXG4gKiBldmVudCB0byBiZSBub3RpZmllZCB3aGVuIGEgc2V0IHRpbWUgaW50ZXJ2YWwgaGFzIGVsYXBzZWQuXG4gKlxuICogTm90ZSB0aGF0IHRoZSBpbnRlcnZhbCB0aGF0IHRoZSB0aWNrIGV2ZW50IGlzIGNhbGxlZCBpcyBhIHRhcmdldCBpbnRlcnZhbCwgYW5kIG1heSBiZSBicm9hZGNhc3QgYXQgYSBzbG93ZXIgaW50ZXJ2YWxcbiAqIHdoZW4gdW5kZXIgaGlnaCBDUFUgbG9hZC4gVGhlIFRpY2tlciBjbGFzcyB1c2VzIGEgc3RhdGljIGludGVyZmFjZSAoZXguIGBUaWNrZXIuZnJhbWVyYXRlID0gMzA7YCkgYW5kXG4gKiBjYW4gbm90IGJlIGluc3RhbnRpYXRlZC5cbiAqXG4gKiBAdG9kbyBQYXNzIHRpbWluZ01vZGUsIG1heERlbHRhLCBwYXVzZWQgdmFsdWVzIGFzIGluc3RhbnRpYXRpb24gYXJndW1lbnRzP1xuICpcbiAqIEBtZW1iZXJvZiBjb3JlXG4gKiBAZXhhbXBsZVxuICogVGlja2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJ0aWNrXCIsIGV2ZW50ID0+IHtcbiAqICAgLy8gQWN0aW9ucyBjYXJyaWVkIG91dCBlYWNoIHRpY2sgKGFrYSBmcmFtZSlcbiAqICAgaWYgKCFldmVudC5wYXVzZWQpIHtcbiAqICAgICAvLyBBY3Rpb25zIGNhcnJpZWQgb3V0IHdoZW4gdGhlIFRpY2tlciBpcyBub3QgcGF1c2VkLlxuICogICB9XG4gKiB9KTtcbiAqIEBleGFtcGxlXG4gKiAvLyBUaWNrZXIgZXhwb3J0IGV4cGxhbmF0aW9uXG4gKiBpbXBvcnQgVGlja2VyLCB7IFRpY2tlciBhcyBUaWNrZXJDbGFzcywgZ2V0VGlja2VyIH0gZnJvbSBcIkBjcmVhdGVqcy9jb3JlXCI7XG4gKiBUaWNrZXIubmFtZSwgVGlja2VyLlJBRiAvLyAtPiBjcmVhdGVqcy5nbG9iYWwsIHVuZGVmaW5lZFxuICogVGlja2VyQ2xhc3MuUkFGIC8vIC0+IHJhZlxuICogVGlja2VyID09PSBnZXRUaWNrZXIoXCJjcmVhdGVqcy5nbG9iYWxcIikgLy8gLT4gdHJ1ZVxuICpcbiAqIEBleHRlbmRzIGNvcmUuRXZlbnREaXNwYXRjaGVyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBhc3NpZ25lZCB0byB0aGlzIGluc3RhbmNlLlxuICovXG5jbGFzcyBUaWNrZXIgZXh0ZW5kcyBFdmVudERpc3BhdGNoZXIge1xuXG5cdC8qKlxuXHQgKiBJbiB0aGlzIG1vZGUsIFRpY2tlciB1c2VzIHRoZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgQVBJLCBidXQgYXR0ZW1wdHMgdG8gc3luY2ggdGhlIHRpY2tzIHRvIHRhcmdldCBmcmFtZXJhdGUuIEl0XG5cdCAqIHVzZXMgYSBzaW1wbGUgaGV1cmlzdGljIHRoYXQgY29tcGFyZXMgdGhlIHRpbWUgb2YgdGhlIFJBRiByZXR1cm4gdG8gdGhlIHRhcmdldCB0aW1lIGZvciB0aGUgY3VycmVudCBmcmFtZSBhbmRcblx0ICogZGlzcGF0Y2hlcyB0aGUgdGljayB3aGVuIHRoZSB0aW1lIGlzIHdpdGhpbiBhIGNlcnRhaW4gdGhyZXNob2xkLlxuXHQgKlxuXHQgKiBUaGlzIG1vZGUgaGFzIGEgaGlnaGVyIHZhcmlhbmNlIGZvciB0aW1lIGJldHdlZW4gZnJhbWVzIHRoYW4ge3sjY3Jvc3NMaW5rIFwiVGlja2VyL1RJTUVPVVQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0sXG5cdCAqIGJ1dCBkb2VzIG5vdCByZXF1aXJlIHRoYXQgY29udGVudCBiZSB0aW1lIGJhc2VkIGFzIHdpdGgge3sjY3Jvc3NMaW5rIFwiVGlja2VyL1JBRjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSB3aGlsZVxuXHQgKiBnYWluaW5nIHRoZSBiZW5lZml0cyBvZiB0aGF0IEFQSSAoc2NyZWVuIHN5bmNoLCBiYWNrZ3JvdW5kIHRocm90dGxpbmcpLlxuXHQgKlxuXHQgKiBWYXJpYW5jZSBpcyB1c3VhbGx5IGxvd2VzdCBmb3IgZnJhbWVyYXRlcyB0aGF0IGFyZSBhIGRpdmlzb3Igb2YgdGhlIFJBRiBmcmVxdWVuY3kuIFRoaXMgaXMgdXN1YWxseSA2MCwgc29cblx0ICogZnJhbWVyYXRlcyBvZiAxMCwgMTIsIDE1LCAyMCwgYW5kIDMwIHdvcmsgd2VsbC5cblx0ICpcblx0ICogRmFsbHMgYmFjayB0byB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvVElNRU9VVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBpZiB0aGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIEFQSSBpcyBub3Rcblx0ICogc3VwcG9ydGVkLlxuXHQgKlxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtzdHJpbmd9XG5cdCAqIEBkZWZhdWx0IFwic3luY2hlZFwiXG5cdCAqIEByZWFkb25seVxuXHQgKi9cblx0c3RhdGljIGdldCBSQUZfU1lOQ0hFRCAoKSB7IHJldHVybiBcInN5bmNoZWRcIjsgfVxuXG5cdC8qKlxuXHQgKiBJbiB0aGlzIG1vZGUsIFRpY2tlciBwYXNzZXMgdGhyb3VnaCB0aGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGhlYXJ0YmVhdCwgaWdub3JpbmcgdGhlIHRhcmdldCBmcmFtZXJhdGUgY29tcGxldGVseS5cblx0ICogQmVjYXVzZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgZnJlcXVlbmN5IGlzIG5vdCBkZXRlcm1pbmlzdGljLCBhbnkgY29udGVudCB1c2luZyB0aGlzIG1vZGUgc2hvdWxkIGJlIHRpbWUgYmFzZWQuXG5cdCAqIFlvdSBjYW4gbGV2ZXJhZ2Uge0BsaW5rIGNvcmUuVGlja2VyI2dldFRpbWV9IGFuZCB0aGUge0BsaW5rIGNvcmUuVGlja2VyI2V2ZW50OnRpY2t9XG5cdCAqIGV2ZW50IG9iamVjdCdzIFwiZGVsdGFcIiBwcm9wZXJ0aWVzIHRvIG1ha2UgdGhpcyBlYXNpZXIuXG5cdCAqXG5cdCAqIEZhbGxzIGJhY2sgb24ge0BsaW5rIGNvcmUuVGlja2VyLlRJTUVPVVR9IGlmIHRoZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgQVBJIGlzIG5vdCBzdXBwb3J0ZWQuXG5cdCAqXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge3N0cmluZ31cblx0ICogQGRlZmF1bHQgXCJyYWZcIlxuXHQgKiBAcmVhZG9ubHlcblx0ICovXG5cdHN0YXRpYyBnZXQgUkFGICgpIHsgcmV0dXJuIFwicmFmXCI7IH1cblxuXHQvKipcblx0ICogSW4gdGhpcyBtb2RlLCBUaWNrZXIgdXNlcyB0aGUgc2V0VGltZW91dCBBUEkuIFRoaXMgcHJvdmlkZXMgcHJlZGljdGFibGUsIGFkYXB0aXZlIGZyYW1lIHRpbWluZywgYnV0IGRvZXMgbm90XG5cdCAqIHByb3ZpZGUgdGhlIGJlbmVmaXRzIG9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSAoc2NyZWVuIHN5bmNoLCBiYWNrZ3JvdW5kIHRocm90dGxpbmcpLlxuXHQgKlxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtzdHJpbmd9XG5cdCAqIEBkZWZhdWx0IFwidGltZW91dFwiXG5cdCAqIEByZWFkb25seVxuXHQgKi9cblx0c3RhdGljIGdldCBUSU1FT1VUICgpIHsgcmV0dXJuIFwidGltZW91dFwiOyB9XG5cblx0Y29uc3RydWN0b3IgKG5hbWUpIHtcblx0XHRzdXBlcigpO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIG5hbWUgb2YgdGhpcyBpbnN0YW5jZS5cblx0XHQgKiBAdHlwZSB7c3RyaW5nfVxuXHRcdCAqL1xuXHRcdHRoaXMubmFtZSA9IG5hbWU7XG5cblx0XHQvKipcblx0XHQgKiBTcGVjaWZpZXMgdGhlIHRpbWluZyBhcGkgKHNldFRpbWVvdXQgb3IgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKSBhbmQgbW9kZSB0byB1c2UuXG5cdFx0ICpcblx0XHQgKiBAc2VlIHtAbGluayBjb3JlLlRpY2tlci5USU1FT1VUfVxuXHRcdCAqIEBzZWUge0BsaW5rIGNvcmUuVGlja2VyLlJBRn1cblx0XHQgKiBAc2VlIHtAbGluayBjb3JlLlRpY2tlci5SQUZfU1lOQ0hFRH1cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtzdHJpbmd9XG5cdFx0ICogQGRlZmF1bHQgVGlja2VyLlRJTUVPVVRcblx0XHQgKi9cblx0XHR0aGlzLnRpbWluZ01vZGUgPSBUaWNrZXIuVElNRU9VVDtcblxuXHRcdC8qKlxuXHRcdCAqIFNwZWNpZmllcyBhIG1heGltdW0gdmFsdWUgZm9yIHRoZSBkZWx0YSBwcm9wZXJ0eSBpbiB0aGUgdGljayBldmVudCBvYmplY3QuIFRoaXMgaXMgdXNlZnVsIHdoZW4gYnVpbGRpbmcgdGltZVxuXHRcdCAqIGJhc2VkIGFuaW1hdGlvbnMgYW5kIHN5c3RlbXMgdG8gcHJldmVudCBpc3N1ZXMgY2F1c2VkIGJ5IGxhcmdlIHRpbWUgZ2FwcyBjYXVzZWQgYnkgYmFja2dyb3VuZCB0YWJzLCBzeXN0ZW0gc2xlZXAsXG5cdFx0ICogYWxlcnQgZGlhbG9ncywgb3Igb3RoZXIgYmxvY2tpbmcgcm91dGluZXMuIERvdWJsZSB0aGUgZXhwZWN0ZWQgZnJhbWUgZHVyYXRpb24gaXMgb2Z0ZW4gYW4gZWZmZWN0aXZlIHZhbHVlXG5cdFx0ICogKGV4LiBtYXhEZWx0YT01MCB3aGVuIHJ1bm5pbmcgYXQgNDBmcHMpLlxuXHRcdCAqXG5cdFx0ICogVGhpcyBkb2VzIG5vdCBpbXBhY3QgYW55IG90aGVyIHZhbHVlcyAoZXguIHRpbWUsIHJ1blRpbWUsIGV0YyksIHNvIHlvdSBtYXkgZXhwZXJpZW5jZSBpc3N1ZXMgaWYgeW91IGVuYWJsZSBtYXhEZWx0YVxuXHRcdCAqIHdoZW4gdXNpbmcgYm90aCBkZWx0YSBhbmQgb3RoZXIgdmFsdWVzLlxuXHRcdCAqXG5cdFx0ICogSWYgMCwgdGhlcmUgaXMgbm8gbWF4aW11bS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqL1xuXHRcdHRoaXMubWF4RGVsdGEgPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogV2hlbiB0aGUgdGlja2VyIGlzIHBhdXNlZCwgYWxsIGxpc3RlbmVycyB3aWxsIHN0aWxsIHJlY2VpdmUgYSB0aWNrIGV2ZW50LCBidXQgdGhlIGBwYXVzZWRgIHByb3BlcnR5XG5cdFx0ICogb2YgdGhlIGV2ZW50IHdpbGwgYmUgYHRydWVgLiBBbHNvLCB3aGlsZSBwYXVzZWQgdGhlIGBydW5UaW1lYCB3aWxsIG5vdCBpbmNyZWFzZS5cblx0XHQgKlxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogVGlja2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJ0aWNrXCIsIGV2ZW50ID0+IGNvbnNvbGUubG9nKGV2ZW50LnBhdXNlZCwgVGlja2VyLmdldFRpbWUoZmFsc2UpLCBUaWNrZXIuZ2V0VGltZSh0cnVlKSkpO1xuXHRcdCAqIFRpY2tlci5wYXVzZWQgPSB0cnVlO1xuXHRcdCAqXG5cdFx0ICogQHNlZSB7QGxpbmsgY29yZS5UaWNrZXIjZXZlbnQ6dGlja31cblx0XHQgKiBAc2VlIHtAbGluayBjb3JlLlRpY2tlciNnZXRUaW1lfVxuXHRcdCAqIEBzZWUge0BsaW5rIGNvcmUuVGlja2VyI2dldEV2ZW50VGltZX1cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICovXG5cdFx0dGhpcy5wYXVzZWQgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKi9cblx0XHR0aGlzLl9pbml0ZWQgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0dGhpcy5fc3RhcnRUaW1lID0gMDtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0dGhpcy5fcGF1c2VkVGltZSA9IDA7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbnVtYmVyIG9mIHRpY2tzIHRoYXQgaGF2ZSBwYXNzZWQuXG5cdFx0ICpcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqL1xuXHRcdHRoaXMuX3RpY2tzID0gMDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBudW1iZXIgb2YgdGlja3MgdGhhdCBoYXZlIHBhc3NlZCB3aGlsZSBUaWNrZXIgaGFzIGJlZW4gcGF1c2VkLlxuXHRcdCAqXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0XG5cdFx0ICovXG5cdFx0dGhpcy5fcGF1c2VkVGlja3MgPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0XG5cdFx0ICovXG5cdFx0dGhpcy5faW50ZXJ2YWwgPSA1MDtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdFxuXHRcdCAqL1xuXHRcdHRoaXMuX2xhc3RUaW1lID0gMDtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQHR5cGUge0FycmF5fVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLl90aW1lcyA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5fdGlja1RpbWVzID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyB0aGUgdGltZW91dCBvciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgaWQuXG5cdFx0ICpcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuX3RpbWVySWQgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogVHJ1ZSBpZiBjdXJyZW50bHkgdXNpbmcgcmVxdWVzdEFuaW1hdGlvbkZyYW1lLCBmYWxzZSBpZiB1c2luZyBzZXRUaW1lb3V0LiBUaGlzIG1heSBiZSBkaWZmZXJlbnQgdGhhbiB0aW1pbmdNb2RlXG5cdFx0ICogaWYgdGhhdCBwcm9wZXJ0eSBjaGFuZ2VkIGFuZCBhIHRpY2sgaGFzbid0IGZpcmVkLlxuXHRcdCAqXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0dGhpcy5fcmFmID0gdHJ1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBJbmRpY2F0ZXMgdGhlIHRhcmdldCB0aW1lIChpbiBtaWxsaXNlY29uZHMpIGJldHdlZW4gdGlja3MuIERlZmF1bHQgaXMgNTAgKDIwIEZQUykuXG5cdCAqIE5vdGUgdGhhdCBhY3R1YWwgdGltZSBiZXR3ZWVuIHRpY2tzIG1heSBiZSBtb3JlIHRoYW4gc3BlY2lmaWVkIGRlcGVuZGluZyBvbiBDUFUgbG9hZC5cblx0ICogVGhpcyBwcm9wZXJ0eSBpcyBpZ25vcmVkIGlmIHRoZSB0aWNrZXIgaXMgdXNpbmcgdGhlIGBSQUZgIHRpbWluZyBtb2RlLlxuXHQgKlxuXHQgKiBAdHlwZSB7bnVtYmVyfVxuXHQgKi9cblx0Z2V0IGludGVydmFsICgpIHsgcmV0dXJuIHRoaXMuX2ludGVydmFsOyB9XG5cdHNldCBpbnRlcnZhbCAoaW50ZXJ2YWwpIHtcblx0XHR0aGlzLl9pbnRlcnZhbCA9IGludGVydmFsO1xuXHRcdGlmICghdGhpcy5faW5pdGVkKSB7IHJldHVybjsgfVxuXHRcdHRoaXMuX3NldHVwVGljaygpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEluZGljYXRlcyB0aGUgdGFyZ2V0IGZyYW1lIHJhdGUgaW4gZnJhbWVzIHBlciBzZWNvbmQgKEZQUykuIEVmZmVjdGl2ZWx5IGp1c3QgYSBzaG9ydGN1dCB0byBgaW50ZXJ2YWxgLCB3aGVyZVxuXHQgKiBgZnJhbWVyYXRlID09IDEwMDAvaW50ZXJ2YWxgLlxuXHQgKlxuXHQgKiBAdHlwZSB7bnVtYmVyfVxuXHQgKi9cblx0Z2V0IGZyYW1lcmF0ZSAoKSB7IHJldHVybiAxMDAwIC8gdGhpcy5faW50ZXJ2YWw7IH1cblx0c2V0IGZyYW1lcmF0ZSAoZnJhbWVyYXRlKSB7IHRoaXMuaW50ZXJ2YWwgPSAxMDAwIC8gZnJhbWVyYXRlOyB9XG5cblx0LyoqXG5cdCAqIFN0YXJ0cyB0aGUgdGljay4gVGhpcyBpcyBjYWxsZWQgYXV0b21hdGljYWxseSB3aGVuIHRoZSBmaXJzdCBsaXN0ZW5lciBpcyBhZGRlZC5cblx0ICovXG5cdGluaXQgKCkge1xuXHRcdGlmICh0aGlzLl9pbml0ZWQpIHsgcmV0dXJuOyB9XG5cdFx0dGhpcy5faW5pdGVkID0gdHJ1ZTtcblx0XHR0aGlzLl90aW1lcyA9IFtdO1xuXHRcdHRoaXMuX3RpY2tUaW1lcyA9IFtdO1xuXHRcdHRoaXMuX3N0YXJ0VGltZSA9IHRoaXMuX2dldFRpbWUoKTtcblx0XHR0aGlzLl90aW1lcy5wdXNoKHRoaXMuX2xhc3RUaW1lID0gMCk7XG5cdFx0dGhpcy5fc2V0dXBUaWNrKCk7XG5cdH1cblxuXHQvKipcblx0ICogU3RvcHMgdGhlIFRpY2tlciBhbmQgcmVtb3ZlcyBhbGwgbGlzdGVuZXJzLiBVc2UgaW5pdCgpIHRvIHJlc3RhcnQgdGhlIFRpY2tlci5cblx0ICovXG5cdHJlc2V0ICgpIHtcblx0XHRpZiAodGhpcy5fcmFmKSB7XG5cdFx0XHRsZXQgZiA9IHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cud2Via2l0Q2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1vekNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5vQ2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1zQ2FuY2VsQW5pbWF0aW9uRnJhbWU7XG5cdFx0XHRmICYmIGYodGhpcy5fdGltZXJJZCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNsZWFyVGltZW91dCh0aGlzLl90aW1lcklkKTtcblx0XHR9XG5cdFx0dGhpcy5yZW1vdmVBbGxFdmVudExpc3RlbmVycyhcInRpY2tcIik7XG5cdFx0dGhpcy5fdGltZXJJZCA9IHRoaXMuX3RpbWVzID0gdGhpcy5fdGlja1RpbWVzID0gbnVsbDtcblx0XHR0aGlzLl9zdGFydFRpbWUgPSB0aGlzLl9sYXN0VGltZSA9IHRoaXMuX3RpY2tzID0gMDtcblx0XHR0aGlzLl9pbml0ZWQgPSBmYWxzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBJbml0IHRoZSBUaWNrZXIgaW5zdGFuY2UgaWYgaXQgaGFzbid0IGJlZW4gYWxyZWFkeS5cblx0ICovXG5cdGFkZEV2ZW50TGlzdGVuZXIgKHR5cGUsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKSB7XG5cdFx0IXRoaXMuX2luaXRlZCAmJiB0aGlzLmluaXQoKTtcblx0XHRyZXR1cm4gc3VwZXIuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgYXZlcmFnZSB0aW1lIHNwZW50IHdpdGhpbiBhIHRpY2suIFRoaXMgY2FuIHZhcnkgc2lnbmlmaWNhbnRseSBmcm9tIHRoZSB2YWx1ZSBwcm92aWRlZCBieSBnZXRNZWFzdXJlZEZQU1xuXHQgKiBiZWNhdXNlIGl0IG9ubHkgbWVhc3VyZXMgdGhlIHRpbWUgc3BlbnQgd2l0aGluIHRoZSB0aWNrIGV4ZWN1dGlvbiBzdGFjay5cblx0ICpcblx0ICogRXhhbXBsZSAxOiBXaXRoIGEgdGFyZ2V0IEZQUyBvZiAyMCwgZ2V0TWVhc3VyZWRGUFMoKSByZXR1cm5zIDIwZnBzLCB3aGljaCBpbmRpY2F0ZXMgYW4gYXZlcmFnZSBvZiA1MG1zIGJldHdlZW5cblx0ICogdGhlIGVuZCBvZiBvbmUgdGljayBhbmQgdGhlIGVuZCBvZiB0aGUgbmV4dC4gSG93ZXZlciwgZ2V0TWVhc3VyZWRUaWNrVGltZSgpIHJldHVybnMgMTVtcy4gVGhpcyBpbmRpY2F0ZXMgdGhhdFxuXHQgKiB0aGVyZSBtYXkgYmUgdXAgdG8gMzVtcyBvZiBcImlkbGVcIiB0aW1lIGJldHdlZW4gdGhlIGVuZCBvZiBvbmUgdGljayBhbmQgdGhlIHN0YXJ0IG9mIHRoZSBuZXh0LlxuXHQgKlxuXHQgKiBFeGFtcGxlIDI6IFdpdGggYSB0YXJnZXQgRlBTIG9mIDMwLCBnZXRGUFMoKSByZXR1cm5zIDEwZnBzLCB3aGljaCBpbmRpY2F0ZXMgYW4gYXZlcmFnZSBvZiAxMDBtcyBiZXR3ZWVuIHRoZSBlbmQgb2Zcblx0ICogb25lIHRpY2sgYW5kIHRoZSBlbmQgb2YgdGhlIG5leHQuIEhvd2V2ZXIsIGdldE1lYXN1cmVkVGlja1RpbWUoKSByZXR1cm5zIDIwbXMuIFRoaXMgd291bGQgaW5kaWNhdGUgdGhhdCBzb21ldGhpbmdcblx0ICogb3RoZXIgdGhhbiB0aGUgdGljayBpcyB1c2luZyB+ODBtcyAoYW5vdGhlciBzY3JpcHQsIERPTSByZW5kZXJpbmcsIGV0YykuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbdGlja3M9bnVsbF0gVGhlIG51bWJlciBvZiBwcmV2aW91cyB0aWNrcyBvdmVyIHdoaWNoIHRvIG1lYXN1cmUgdGhlIGF2ZXJhZ2UgdGltZSBzcGVudCBpbiBhIHRpY2suXG5cdCAqIERlZmF1bHRzIHRvIHRoZSBudW1iZXIgb2YgdGlja3MgcGVyIHNlY29uZC4gVG8gZ2V0IG9ubHkgdGhlIGxhc3QgdGljaydzIHRpbWUsIHBhc3MgaW4gMS5cblx0ICogQHJldHVybiB7bnVtYmVyfSBUaGUgYXZlcmFnZSB0aW1lIHNwZW50IGluIGEgdGljayBpbiBtaWxsaXNlY29uZHMuXG5cdCAqL1xuXHRnZXRNZWFzdXJlZFRpY2tUaW1lICh0aWNrcyA9IG51bGwpIHtcblx0XHRjb25zdCB0aW1lcyA9IHRoaXMuX3RpY2tUaW1lcztcblx0XHRpZiAoIXRpbWVzIHx8IHRpbWVzLmxlbmd0aCA8IDEpIHsgcmV0dXJuIC0xOyB9XG5cdFx0Ly8gYnkgZGVmYXVsdCwgY2FsY3VsYXRlIGF2ZXJhZ2UgZm9yIHRoZSBwYXN0IH4xIHNlY29uZDpcblx0XHR0aWNrcyA9IE1hdGgubWluKHRpbWVzLmxlbmd0aCwgdGlja3MgfHwgKHRoaXMuZnJhbWVyYXRlIHwgMCkpO1xuXHRcdHJldHVybiB0aW1lcy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKSAvIHRpY2tzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGFjdHVhbCBmcmFtZXMgLyB0aWNrcyBwZXIgc2Vjb25kLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3RpY2tzPW51bGxdIFRoZSBudW1iZXIgb2YgcHJldmlvdXMgdGlja3Mgb3ZlciB3aGljaCB0byBtZWFzdXJlIHRoZSBhY3R1YWwgZnJhbWVzIC8gdGlja3MgcGVyIHNlY29uZC5cblx0ICogRGVmYXVsdHMgdG8gdGhlIG51bWJlciBvZiB0aWNrcyBwZXIgc2Vjb25kLlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBhY3R1YWwgZnJhbWVzIC8gdGlja3MgcGVyIHNlY29uZC4gRGVwZW5kaW5nIG9uIHBlcmZvcm1hbmNlLCB0aGlzIG1heSBkaWZmZXJcblx0ICogZnJvbSB0aGUgdGFyZ2V0IGZyYW1lcyBwZXIgc2Vjb25kLlxuXHQgKi9cblx0Z2V0TWVhc3VyZWRGUFMgKHRpY2tzID0gbnVsbCkge1xuXHRcdGNvbnN0IHRpbWVzID0gdGhpcy5fdGltZXM7XG5cdFx0aWYgKCF0aW1lcyB8fCB0aW1lcy5sZW5ndGggPCAyKSB7IHJldHVybiAtMTsgfVxuXHRcdC8vIGJ5IGRlZmF1bHQsIGNhbGN1bGF0ZSBmcHMgZm9yIHRoZSBwYXN0IH4xIHNlY29uZDpcblx0XHR0aWNrcyA9IE1hdGgubWluKHRpbWVzLmxlbmd0aCAtIDEsIHRpY2tzIHx8ICh0aGlzLmZyYW1lcmF0ZSB8IDApKTtcblx0XHRyZXR1cm4gMTAwMCAvICgodGltZXNbMF0gLSB0aW1lc1t0aWNrc10pIC8gdGlja3MpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdGhhdCBoYXZlIGVsYXBzZWQgc2luY2UgVGlja2VyIHdhcyBpbml0aWFsaXplZCB2aWEge0BsaW5rIGNvcmUuVGlja2VyI2luaXR9LlxuXHQgKiBSZXR1cm5zIC0xIGlmIFRpY2tlciBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQuIEZvciBleGFtcGxlLCB5b3UgY291bGQgdXNlXG5cdCAqIHRoaXMgaW4gYSB0aW1lIHN5bmNocm9uaXplZCBhbmltYXRpb24gdG8gZGV0ZXJtaW5lIHRoZSBleGFjdCBhbW91bnQgb2YgdGltZSB0aGF0IGhhcyBlbGFwc2VkLlxuXHQgKlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtydW5UaW1lPWZhbHNlXSBJZiB0cnVlIG9ubHkgdGltZSBlbGFwc2VkIHdoaWxlIFRpY2tlciB3YXMgbm90IHBhdXNlZCB3aWxsIGJlIHJldHVybmVkLlxuXHQgKiBJZiBmYWxzZSwgdGhlIHZhbHVlIHJldHVybmVkIHdpbGwgYmUgdG90YWwgdGltZSBlbGFwc2VkIHNpbmNlIHRoZSBmaXJzdCB0aWNrIGV2ZW50IGxpc3RlbmVyIHdhcyBhZGRlZC5cblx0ICogQHJldHVybiB7bnVtYmVyfSBOdW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBlbGFwc2VkIHNpbmNlIFRpY2tlciB3YXMgaW5pdGlhbGl6ZWQgb3IgLTEuXG5cdCAqL1xuXHRnZXRUaW1lIChydW5UaW1lID0gZmFsc2UpIHtcblx0XHRyZXR1cm4gdGhpcy5fc3RhcnRUaW1lID8gdGhpcy5fZ2V0VGltZSgpIC0gKHJ1blRpbWUgPyB0aGlzLl9wYXVzZWRUaW1lIDogMCkgOiAtMTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTaW1pbGFyIHRvIHtAbGluayBjb3JlLlRpY2tlciNnZXRUaW1lfSwgYnV0IHJldHVybnMgdGhlIHRpbWUgb24gdGhlIG1vc3QgcmVjZW50IHtAbGluayBjb3JlLlRpY2tlciNldmVudDp0aWNrfVxuXHQgKiBldmVudCBvYmplY3QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3J1blRpbWU9ZmFsc2VdIElmIHRydWUsIHRoZSBydW5UaW1lIHByb3BlcnR5IHdpbGwgYmUgcmV0dXJuZWQgaW5zdGVhZCBvZiB0aW1lLlxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgdGltZSBvciBydW5UaW1lIHByb3BlcnR5IGZyb20gdGhlIG1vc3QgcmVjZW50IHRpY2sgZXZlbnQgb3IgLTEuXG5cdCAqL1xuXHRnZXRFdmVudFRpbWUgKHJ1blRpbWUgPSBmYWxzZSkge1xuXHRcdHJldHVybiB0aGlzLl9zdGFydFRpbWUgPyAodGhpcy5fbGFzdFRpbWUgfHwgdGhpcy5fc3RhcnRUaW1lKSAtIChydW5UaW1lID8gdGhpcy5fcGF1c2VkVGltZSA6IDApIDogLTE7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHRpY2tzIHRoYXQgaGF2ZSBiZWVuIGJyb2FkY2FzdCBieSBUaWNrZXIuXG5cdCAqXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3BhdXNlYWJsZT1mYWxzZV0gSW5kaWNhdGVzIHdoZXRoZXIgdG8gaW5jbHVkZSB0aWNrcyB0aGF0IHdvdWxkIGhhdmUgYmVlbiBicm9hZGNhc3Rcblx0ICogd2hpbGUgVGlja2VyIHdhcyBwYXVzZWQuIElmIHRydWUgb25seSB0aWNrIGV2ZW50cyBicm9hZGNhc3Qgd2hpbGUgVGlja2VyIGlzIG5vdCBwYXVzZWQgd2lsbCBiZSByZXR1cm5lZC5cblx0ICogSWYgZmFsc2UsIHRpY2sgZXZlbnRzIHRoYXQgd291bGQgaGF2ZSBiZWVuIGJyb2FkY2FzdCB3aGlsZSBUaWNrZXIgd2FzIHBhdXNlZCB3aWxsIGJlIGluY2x1ZGVkIGluIHRoZSByZXR1cm5cblx0ICogdmFsdWUuXG5cdCAqIEByZXR1cm4ge251bWJlcn0gb2YgdGlja3MgdGhhdCBoYXZlIGJlZW4gYnJvYWRjYXN0LlxuXHQgKi9cblx0Z2V0VGlja3MgKHBhdXNlYWJsZSA9IGZhbHNlKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3RpY2tzIC0gKHBhdXNlYWJsZSA/IHRoaXMuX3BhdXNlZFRpY2tzIDogMCk7XG5cdH1cblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9oYW5kbGVTeW5jaCAoKSB7XG5cdFx0dGhpcy5fdGltZXJJZCA9IG51bGw7XG5cdFx0dGhpcy5fc2V0dXBUaWNrKCk7XG5cblx0XHQvLyBydW4gaWYgZW5vdWdoIHRpbWUgaGFzIGVsYXBzZWQsIHdpdGggYSBsaXR0bGUgYml0IG9mIGZsZXhpYmlsaXR5IHRvIGJlIGVhcmx5OlxuXHRcdGlmICh0aGlzLl9nZXRUaW1lKCkgLSB0aGlzLl9sYXN0VGltZSA+PSAodGhpcy5faW50ZXJ2YWwgLSAxKSAqIDAuOTcpIHtcblx0XHRcdHRoaXMuX3RpY2soKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9oYW5kbGVSQUYgKCkge1xuXHRcdHRoaXMuX3RpbWVySWQgPSBudWxsO1xuXHRcdHRoaXMuX3NldHVwVGljaygpO1xuXHRcdHRoaXMuX3RpY2soKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2hhbmRsZVRpbWVvdXQgKCkge1xuXHRcdHRoaXMuX3RpbWVySWQgPSBudWxsO1xuXHRcdHRoaXMuX3NldHVwVGljaygpO1xuXHRcdHRoaXMuX3RpY2soKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X3NldHVwVGljayAoKSB7XG5cdFx0aWYgKHRoaXMuX3RpbWVySWQgIT0gbnVsbCkgeyByZXR1cm47IH0gLy8gYXZvaWQgZHVwbGljYXRlc1xuXHRcdGNvbnN0IG1vZGUgPSB0aGlzLnRpbWluZ01vZGUgfHwgKHRoaXMuX3JhZiAmJiBUaWNrZXIuUkFGKTtcblx0XHRpZiAobW9kZSA9PT0gVGlja2VyLlJBRl9TWU5DSEVEIHx8IG1vZGUgPT09IFRpY2tlci5SQUYpIHtcblx0XHRcdGNvbnN0IGYgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cub1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG5cdFx0XHRpZiAoZikge1xuXHRcdFx0XHR0aGlzLl90aW1lcklkID0gZihtb2RlID09PSBUaWNrZXIuUkFGID8gdGhpcy5faGFuZGxlUkFGLmJpbmQodGhpcykgOiB0aGlzLl9oYW5kbGVTeW5jaC5iaW5kKHRoaXMpKTtcblx0XHRcdFx0dGhpcy5fcmFmID0gdHJ1ZTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLl9yYWYgPSBmYWxzZTtcblx0XHR0aGlzLl90aW1lcklkID0gc2V0VGltZW91dCh0aGlzLl9oYW5kbGVUaW1lb3V0LmJpbmQodGhpcyksIHRoaXMuX2ludGVydmFsKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAZW1pdHMgY29yZS5UaWNrZXIjZXZlbnQ6dGlja1xuXHQgKi9cblx0X3RpY2sgKCkge1xuXHRcdGNvbnN0IHBhdXNlZCA9IHRoaXMucGF1c2VkLCB0aW1lID0gdGhpcy5fZ2V0VGltZSgpLCBlbGFwc2VkVGltZSA9IHRpbWUgLSB0aGlzLl9sYXN0VGltZTtcblx0XHR0aGlzLl9sYXN0VGltZSA9IHRpbWU7XG5cdFx0dGhpcy5fdGlja3MrKztcblxuXHRcdGlmIChwYXVzZWQpIHtcblx0XHRcdHRoaXMuX3BhdXNlZFRpY2tzKys7XG5cdFx0XHR0aGlzLl9wYXVzZWRUaW1lICs9IGVsYXBzZWRUaW1lO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLmhhc0V2ZW50TGlzdGVuZXIoXCJ0aWNrXCIpKSB7XG5cdFx0XHRjb25zdCBldmVudCA9IG5ldyBFdmVudChcInRpY2tcIik7XG5cdFx0XHRjb25zdCBtYXhEZWx0YSA9IHRoaXMubWF4RGVsdGE7XG5cdFx0XHRldmVudC5kZWx0YSA9IChtYXhEZWx0YSAmJiBlbGFwc2VkVGltZSA+IG1heERlbHRhKSA/IG1heERlbHRhIDogZWxhcHNlZFRpbWU7XG5cdFx0XHRldmVudC5wYXVzZWQgPSBwYXVzZWQ7XG5cdFx0XHRldmVudC50aW1lID0gdGltZTtcblx0XHRcdGV2ZW50LnJ1blRpbWUgPSB0aW1lIC0gdGhpcy5fcGF1c2VkVGltZTtcblx0XHRcdHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fdGlja1RpbWVzLnVuc2hpZnQodGhpcy5fZ2V0VGltZSgpIC0gdGltZSk7XG5cdFx0d2hpbGUgKHRoaXMuX3RpY2tUaW1lcy5sZW5ndGggPiAxMDApIHsgdGhpcy5fdGlja1RpbWVzLnBvcCgpOyB9XG5cblx0XHR0aGlzLl90aW1lcy51bnNoaWZ0KHRpbWUpO1xuXHRcdHdoaWxlICh0aGlzLl90aW1lcy5sZW5ndGggPiAxMDApIHsgdGhpcy5fdGltZXMucG9wKCk7IH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2dldFRpbWUgKCkge1xuXHRcdGNvbnN0IG5vdyA9IHdpbmRvdy5wZXJmb3JtYW5jZSAmJiB3aW5kb3cucGVyZm9ybWFuY2Uubm93O1xuXHRcdHJldHVybiAoKG5vdyAmJiBub3cuY2FsbChwZXJmb3JtYW5jZSkpIHx8IChuZXcgRGF0ZSgpLmdldFRpbWUoKSkpIC0gdGhpcy5fc3RhcnRUaW1lO1xuXHR9XG5cblx0c3RhdGljIG9uICh0eXBlLCBsaXN0ZW5lciwgc2NvcGUsIG9uY2UsIGRhdGEsIHVzZUNhcHR1cmUpIHsgcmV0dXJuIF9pbnN0YW5jZS5vbih0eXBlLCBsaXN0ZW5lciwgc2NvcGUsIG9uY2UsIGRhdGEsIHVzZUNhcHR1cmUpOyB9XG5cdHN0YXRpYyByZW1vdmVFdmVudExpc3RlbmVyICh0eXBlLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSkgeyBfaW5zdGFuY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSk7IH1cblx0c3RhdGljIG9mZiAodHlwZSwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpIHsgX2luc3RhbmNlLm9mZih0eXBlLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSk7IH1cblx0c3RhdGljIHJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzICh0eXBlKSB7IF9pbnN0YW5jZS5yZW1vdmVBbGxFdmVudExpc3RlbmVycyh0eXBlKTsgfVxuXHRzdGF0aWMgZGlzcGF0Y2hFdmVudCAoZXZlbnRPYmosIGJ1YmJsZXMsIGNhbmNlbGFibGUpIHsgcmV0dXJuIF9pbnN0YW5jZS5kaXNwYXRjaEV2ZW50KGV2ZW50T2JqLCBidWJibGVzLCBjYW5jZWxhYmxlKTsgfVxuXHRzdGF0aWMgaGFzRXZlbnRMaXN0ZW5lciAodHlwZSkgeyByZXR1cm4gX2luc3RhbmNlLmhhc0V2ZW50TGlzdGVuZXIodHlwZSk7IH1cblx0c3RhdGljIHdpbGxUcmlnZ2VyICh0eXBlKSB7IHJldHVybiBfaW5zdGFuY2Uud2lsbFRyaWdnZXIodHlwZSk7IH1cblx0c3RhdGljIHRvU3RyaW5nICgpIHsgcmV0dXJuIF9pbnN0YW5jZS50b1N0cmluZygpOyB9XG5cdHN0YXRpYyBpbml0ICgpIHsgX2luc3RhbmNlLmluaXQoKTsgfVxuXHRzdGF0aWMgcmVzZXQgKCkgeyBfaW5zdGFuY2UucmVzZXQoKTsgfVxuXHRzdGF0aWMgYWRkRXZlbnRMaXN0ZW5lciAodHlwZSwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpIHsgX2luc3RhbmNlLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpOyB9XG5cdHN0YXRpYyBnZXRNZWFzdXJlZFRpY2tUaW1lICh0aWNrcykgeyByZXR1cm4gX2luc3RhbmNlLmdldE1lYXN1cmVkVGlja1RpbWUodGlja3MpOyB9XG5cdHN0YXRpYyBnZXRNZWFzdXJlZEZQUyAodGlja3MpIHsgcmV0dXJuIF9pbnN0YW5jZS5nZXRNZWFzdXJlZEZQUyh0aWNrcyk7IH1cblx0c3RhdGljIGdldFRpbWUgKHJ1blRpbWUpIHsgcmV0dXJuIF9pbnN0YW5jZS5nZXRUaW1lKHJ1blRpbWUpOyB9XG5cdHN0YXRpYyBnZXRFdmVudFRpbWUgKHJ1blRpbWUpIHsgcmV0dXJuIF9pbnN0YW5jZS5nZXRFdmVudFRpbWUocnVuVGltZSk7IH1cblx0c3RhdGljIGdldFRpY2tzIChwYXVzZWFibGUpIHsgcmV0dXJuIF9pbnN0YW5jZS5nZXRUaWNrcyhwYXVzZWFibGUpOyB9XG5cblx0c3RhdGljIGdldCBpbnRlcnZhbCAoKSB7IHJldHVybiBfaW5zdGFuY2UuaW50ZXJ2YWw7IH1cblx0c3RhdGljIHNldCBpbnRlcnZhbCAoaW50ZXJ2YWwpIHsgX2luc3RhbmNlLmludGVydmFsID0gaW50ZXJ2YWw7IH1cblx0c3RhdGljIGdldCBmcmFtZXJhdGUgKCkgeyByZXR1cm4gX2luc3RhbmNlLmZyYW1lcmF0ZTsgfVxuXHRzdGF0aWMgc2V0IGZyYW1lcmF0ZSAoZnJhbWVyYXRlKSB7IF9pbnN0YW5jZS5mcmFtZXJhdGUgPSBmcmFtZXJhdGU7IH1cblx0c3RhdGljIGdldCBuYW1lICgpIHsgcmV0dXJuIF9pbnN0YW5jZS5uYW1lOyB9XG5cdHN0YXRpYyBzZXQgbmFtZSAobmFtZSkgeyBfaW5zdGFuY2UubmFtZSA9IG5hbWU7IH1cblx0c3RhdGljIGdldCB0aW1pbmdNb2RlICgpIHsgcmV0dXJuIF9pbnN0YW5jZS50aW1pbmdNb2RlOyB9XG5cdHN0YXRpYyBzZXQgdGltaW5nTW9kZSAodGltaW5nTW9kZSkgeyBfaW5zdGFuY2UudGltaW5nTW9kZSA9IHRpbWluZ01vZGU7IH1cblx0c3RhdGljIGdldCBtYXhEZWx0YSAoKSB7IHJldHVybiBfaW5zdGFuY2UubWF4RGVsdGE7IH1cblx0c3RhdGljIHNldCBtYXhEZWx0YSAobWF4RGVsdGEpIHsgX2luc3RhbmNlLm1heERlbHRhID0gbWF4RGVsdGE7IH1cblx0c3RhdGljIGdldCBwYXVzZWQgKCkgeyByZXR1cm4gX2luc3RhbmNlLnBhdXNlZDsgfVxuXHRzdGF0aWMgc2V0IHBhdXNlZCAocGF1c2VkKSB7IF9pbnN0YW5jZS5wYXVzZWQgPSBwYXVzZWQ7IH1cblxufVxuXG4vKipcbiAqIERpc3BhdGNoZWQgZWFjaCB0aWNrLiBUaGUgZXZlbnQgd2lsbCBiZSBkaXNwYXRjaGVkIHRvIGVhY2ggbGlzdGVuZXIgZXZlbiB3aGVuIHRoZSBUaWNrZXIgaGFzIGJlZW4gcGF1c2VkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBUaWNrZXIuYWRkRXZlbnRMaXN0ZW5lcihcInRpY2tcIiwgZXZlbnQgPT4gY29uc29sZS5sb2coXCJQYXVzZWQ6XCIsIGV2ZW50LnBhdXNlZCwgZXZlbnQuZGVsdGEpKTtcbiAqXG4gKiBAZXZlbnQgY29yZS5UaWNrZXIjdGlja1xuICogQHR5cGUge09iamVjdH1cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSB0YXJnZXQgVGhlIG9iamVjdCB0aGF0IGRpc3BhdGNoZWQgdGhlIGV2ZW50LlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGUuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHBhdXNlZCBJbmRpY2F0ZXMgd2hldGhlciB0aGUgdGlja2VyIGlzIGN1cnJlbnRseSBwYXVzZWQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gZGVsdGEgVGhlIHRpbWUgZWxhcHNlZCBpbiBtcyBzaW5jZSB0aGUgbGFzdCB0aWNrLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHRpbWUgVGhlIHRvdGFsIHRpbWUgaW4gbXMgc2luY2UgVGlja2VyIHdhcyBpbml0aWFsaXplZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBydW5UaW1lIFRoZSB0b3RhbCB0aW1lIGluIG1zIHRoYXQgVGlja2VyIHdhcyBub3QgcGF1c2VkIHNpbmNlIGl0IHdhcyBpbml0aWFsaXplZC4gRm9yIGV4YW1wbGUsXG4gKiB5b3UgY291bGQgZGV0ZXJtaW5lIHRoZSBhbW91bnQgb2YgdGltZSB0aGF0IHRoZSBUaWNrZXIgaGFzIGJlZW4gcGF1c2VkIHNpbmNlIGluaXRpYWxpemF0aW9uIHdpdGggYHRpbWUtcnVuVGltZWAuXG4gKiBAc2luY2UgMC42LjBcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBUaWNrZXI7XG5cbi8vIHRoZSBkZWZhdWx0IFRpY2tlciBpbnN0YW5jZVxuY29uc3QgX2luc3RhbmNlID0gbmV3IFRpY2tlcihcImNyZWF0ZWpzLmdsb2JhbFwiKTtcbiIsIi8qKlxuICogVGhlIGNvcmUgY2xhc3NlcyBvZiBDcmVhdGVKUy5cbiAqIEBuYW1lc3BhY2UgY29yZVxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBFdmVudERpc3BhdGNoZXIsIEV2ZW50IH0gZnJvbSBcIkBjcmVhdGVqcy9jb3JlXCI7XG4gKiBjb25zdCBkaXNwYXRjaGVyID0gbmV3IEV2ZW50RGlzcGF0Y2hlcigpO1xuICogZGlzcGF0Y2hlci5vbihcIm15RXZlbnRcIiwgZm9vKTtcbiAqIGRpc3BhdGNoZXIuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJteUV2ZW50XCIpKTtcbiAqIC8vIGZvbygpIGlzIGNhbGxlZC5cbiAqL1xuXG4vLyBldmVudHNcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRXZlbnQgfSBmcm9tIFwiLi9ldmVudHMvRXZlbnRcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRXZlbnREaXNwYXRjaGVyIH0gZnJvbSBcIi4vZXZlbnRzL0V2ZW50RGlzcGF0Y2hlclwiO1xuLy8gdXRpbHNcbmV4cG9ydCB7IGRlZmF1bHQgYXMgVGlja2VyIH0gZnJvbSBcIi4vdXRpbHMvVGlja2VyXCI7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKlxuICogU3RhZ2VHTFxuICogVmlzaXQgaHR0cDovL2NyZWF0ZWpzLmNvbS8gZm9yIGRvY3VtZW50YXRpb24sIHVwZGF0ZXMgYW5kIGV4YW1wbGVzLlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNyBnc2tpbm5lci5jb20sIGluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICogb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cbiAqIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxuICogcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsXG4gKiBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4gKiBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuICogY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAqIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xuICogT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAqIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4gKiBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcbiAqIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuICogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUlxuICogT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICovXG5cbmNsYXNzIFN0YWdlR0wge1xuXHRjb25zdHJ1Y3RvciAoKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBcblx0XHRcdFN0YWdlR0wgaXMgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQgb24gdGhlIEVhc2VsSlMgMi4wIGJyYW5jaC5cblx0XHRcdEVuZCBvZiBRMSAyMDE4IGlzIHRhcmdldHRlZCBmb3IgU3RhZ2VHTCBzdXBwb3J0LlxuXHRcdFx0Rm9sbG93IEBDcmVhdGVKUyBvbiBUd2l0dGVyIGZvciB1cGRhdGVzLlxuXHRcdGApO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFN0YWdlR0w7XG4iLCIvKipcbiAqIEBsaWNlbnNlIFNoYWRvd1xuICogVmlzaXQgaHR0cDovL2NyZWF0ZWpzLmNvbS8gZm9yIGRvY3VtZW50YXRpb24sIHVwZGF0ZXMgYW5kIGV4YW1wbGVzLlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNyBnc2tpbm5lci5jb20sIGluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICogb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cbiAqIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxuICogcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsXG4gKiBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4gKiBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuICogY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAqIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xuICogT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAqIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4gKiBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcbiAqIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuICogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUlxuICogT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qKlxuICogVGhpcyBjbGFzcyBlbmNhcHN1bGF0ZXMgdGhlIHByb3BlcnRpZXMgcmVxdWlyZWQgdG8gZGVmaW5lIGEgc2hhZG93IHRvIGFwcGx5IHRvIGEge0BsaW5rIGVhc2VsanMuRGlzcGxheU9iamVjdH1cbiAqIHZpYSBpdHMgYHNoYWRvd2AgcHJvcGVydHkuXG4gKlxuICogQG1lbWJlcm9mIGVhc2VsanNcbiAqIEBleGFtcGxlXG4gKiBpbWcuc2hhZG93ID0gbmV3IFNoYWRvdyhcIiMwMDAwMDBcIiwgNSwgNSwgMTApO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbY29sb3I9YmxhY2tdIFRoZSBjb2xvciBvZiB0aGUgc2hhZG93LiBUaGlzIGNhbiBiZSBhbnkgdmFsaWQgQ1NTIGNvbG9yIHZhbHVlLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvZmZzZXRYPTBdIFRoZSB4IG9mZnNldCBvZiB0aGUgc2hhZG93IGluIHBpeGVscy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb2Zmc2V0WT0wXSBUaGUgeSBvZmZzZXQgb2YgdGhlIHNoYWRvdyBpbiBwaXhlbHMuXG4gKiBAcGFyYW0ge051bWJlcn0gW2JsdXI9MF0gVGhlIHNpemUgb2YgdGhlIGJsdXJyaW5nIGVmZmVjdC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2hhZG93IHtcblxuXHRjb25zdHJ1Y3RvciAoY29sb3IgPSBcImJsYWNrXCIsIG9mZnNldFggPSAwLCBvZmZzZXRZID0gMCwgYmx1ciA9IDApIHtcblx0XHQvKipcblx0XHQgKiBUaGUgY29sb3Igb2YgdGhlIHNoYWRvdy4gVGhpcyBjYW4gYmUgYW55IHZhbGlkIENTUyBjb2xvciB2YWx1ZS5cblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxuXHRcdCAqIEBkZWZhdWx0IGJsYWNrXG5cdFx0ICovXG5cdFx0dGhpcy5jb2xvciA9IGNvbG9yO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHggb2Zmc2V0IG9mIHRoZSBzaGFkb3cuXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0dGhpcy5vZmZzZXRYID0gb2Zmc2V0WDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSB5IG9mZnNldCBvZiB0aGUgc2hhZG93LlxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqL1xuXHRcdHRoaXMub2Zmc2V0WSA9IG9mZnNldFk7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgYmx1ciBvZiB0aGUgc2hhZG93LlxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqL1xuXHRcdHRoaXMuYmx1ciA9IGJsdXI7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cblx0ICogQHJldHVybiB7U3RyaW5nfVxuXHQgKi9cblx0dG9TdHJpbmcgKCkge1xuXHRcdHJldHVybiBgWyR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfV1gO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGlzIFNoYWRvdyBpbnN0YW5jZS5cblx0ICogQHJldHVybiB7U2hhZG93fSBBIGNsb25lIG9mIHRoZSBjdXJyZW50IFNoYWRvdyBpbnN0YW5jZS5cblx0ICovXG5cdGNsb25lICgpIHtcblx0XHRyZXR1cm4gbmV3IFNoYWRvdyh0aGlzLmNvbG9yLCB0aGlzLm9mZnNldFgsIHRoaXMub2Zmc2V0WSwgdGhpcy5ibHVyKTtcblx0fVxuXG59XG5cbi8qKlxuICogQW4gaWRlbnRpdHkgc2hhZG93IG9iamVjdCAoYWxsIHByb3BlcnRpZXMgYXJlIHNldCB0byAwKS5cbiAqIEB0eXBlIHtlYXNlbGpzLlNoYWRvd31cbiAqIEBzdGF0aWNcbiAqIEByZWFkb25seVxuICovXG5TaGFkb3cuaWRlbnRpdHkgPSBuZXcgU2hhZG93KFwidHJhbnNwYXJlbnRcIik7XG4iLCIvKipcbiAqIEBsaWNlbnNlIHVpZFxuICogVmlzaXQgaHR0cDovL2NyZWF0ZWpzLmNvbS8gZm9yIGRvY3VtZW50YXRpb24sIHVwZGF0ZXMgYW5kIGV4YW1wbGVzLlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNyBnc2tpbm5lci5jb20sIGluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICogb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cbiAqIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxuICogcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsXG4gKiBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4gKiBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuICogY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAqIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xuICogT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAqIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4gKiBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcbiAqIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuICogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUlxuICogT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qKiBAaWdub3JlICovXG5sZXQgX25leHRJZCA9IDA7XG5cbi8qKlxuICogR2xvYmFsIHV0aWxpdHkgZm9yIGdlbmVyYXRpbmcgc2VxdWVudGlhbCB1bmlxdWUgSUQgbnVtYmVycy5cbiAqXG4gKiBAbWVtYmVyb2YgZWFzZWxqc1xuICogQG5hbWUgZWFzZWxqcy51aWRcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyB1aWQgfSBmcm9tIFwiQGNyZWF0ZWpzL2Vhc2VsanNcIjtcbiAqIHZhciBpZHMgPSBbXTtcbiAqIHdoaWxlIChpZHMubGVuZ3RoIDw9IDMpIHtcbiAqICAgaWRzLnB1c2godWlkKCkpO1xuICogfVxuICogLy8gaWRzID09IFswLCAxLCAyLCAzXVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1aWQgKCkge1xuXHRyZXR1cm4gX25leHRJZCsrO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZSBQb2ludFxuICogVmlzaXQgaHR0cDovL2NyZWF0ZWpzLmNvbS8gZm9yIGRvY3VtZW50YXRpb24sIHVwZGF0ZXMgYW5kIGV4YW1wbGVzLlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNyBnc2tpbm5lci5jb20sIGluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICogb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cbiAqIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxuICogcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsXG4gKiBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4gKiBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuICogY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAqIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xuICogT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAqIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4gKiBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcbiAqIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuICogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUlxuICogT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHBvaW50IG9uIGEgMiBkaW1lbnNpb25hbCB4IC8geSBjb29yZGluYXRlIHN5c3RlbS5cbiAqXG4gKiBAbWVtYmVyb2YgZWFzZWxqc1xuICogQGV4YW1wbGVcbiAqIGxldCBwb2ludCA9IG5ldyBQb2ludCgwLCAxMDApO1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBbeF0gWCBwb3NpdGlvbi5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbeV0gWSBwb3NpdGlvbi5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9pbnQge1xuXG5cdGNvbnN0cnVjdG9yICh4LCB5KSB7XG5cdFx0dGhpcy5zZXRWYWx1ZXMoeCwgeSk7XG5cblx0XHQvLyBhc3NpZ25lZCBpbiB0aGUgc2V0VmFsdWVzIG1ldGhvZC5cblx0XHQvKipcblx0XHQgKiBYIHBvc2l0aW9uLlxuXHRcdCAqIEBwcm9wZXJ0eSB4XG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKi9cblxuXHRcdC8qKlxuXHRcdCAqIFkgcG9zaXRpb24uXG5cdFx0ICogQHByb3BlcnR5IHlcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqL1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHNwZWNpZmllZCB2YWx1ZXMgb24gdGhpcyBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt4PTBdIFggcG9zaXRpb24uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbeT0wXSBZIHBvc2l0aW9uLlxuXHQgKiBAcmV0dXJuIHtlYXNlbGpzLlBvaW50fSBUaGlzIGluc3RhbmNlLiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0ICogQGNoYWluYWJsZVxuXHQqL1xuXHRzZXRWYWx1ZXMgKHggPSAwLCB5ID0gMCkge1xuXHRcdHRoaXMueCA9IHg7XG5cdFx0dGhpcy55ID0geTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBDb3BpZXMgYWxsIHByb3BlcnRpZXMgZnJvbSB0aGUgc3BlY2lmaWVkIHBvaW50IHRvIHRoaXMgcG9pbnQuXG5cdCAqIEBwYXJhbSB7ZWFzZWxqcy5Qb2ludH0gcG9pbnQgVGhlIHBvaW50IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuXHQgKiBAcmV0dXJuIHtlYXNlbGpzLlBvaW50fSBUaGlzIHBvaW50LiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0ICogQGNoYWluYWJsZVxuXHQqL1xuXHRjb3B5IChwb2ludCkge1xuXHRcdHRoaXMueCA9IHBvaW50Lng7XG5cdFx0dGhpcy55ID0gcG9pbnQueTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIFBvaW50IGluc3RhbmNlLlxuXHQgKiBAcmV0dXJuIHtlYXNlbGpzLlBvaW50fSBhIGNsb25lIG9mIHRoZSBQb2ludCBpbnN0YW5jZS5cblx0ICovXG5cdGNsb25lICgpIHtcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMueCwgdGhpcy55KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZS5cblx0ICovXG5cdHRvU3RyaW5nICgpIHtcblx0XHRyZXR1cm4gYFske3RoaXMuY29uc3RydWN0b3IubmFtZX0gKHg9JHt0aGlzLnh9IHk9JHt0aGlzLnl9KV1gO1xuXHR9XG5cbn1cbiIsIi8qKlxuICogQGxpY2Vuc2UgTWF0cml4MkRcbiAqIFZpc2l0IGh0dHA6Ly9jcmVhdGVqcy5jb20vIGZvciBkb2N1bWVudGF0aW9uLCB1cGRhdGVzIGFuZCBleGFtcGxlcy5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgZ3NraW5uZXIuY29tLCBpbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAqIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXG4gKiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXRcbiAqIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxuICogY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuICogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbiAqIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAqIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gKiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcbiAqIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gKiBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuICogSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXG4gKiBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcbiAqIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5pbXBvcnQgUG9pbnQgZnJvbSBcIi4vUG9pbnRcIjtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIGFmZmluZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXgsIGFuZCBwcm92aWRlcyB0b29scyBmb3IgY29uc3RydWN0aW5nIGFuZCBjb25jYXRlbmF0aW5nIG1hdHJpY2VzLlxuICpcbiAqIDxwcmU+XG4gKiBUaGlzIG1hdHJpeCBjYW4gYmUgdmlzdWFsaXplZCBhczpcbiAqXG4gKiBcdFsgYSAgYyAgdHhcbiAqIFx0ICBiICBkICB0eVxuICogXHQgIDAgIDAgIDEgIF1cbiAqXG4gKiBOb3RlIHRoZSBsb2NhdGlvbnMgb2YgYiBhbmQgYy5cbiAqIDwvcHJlPlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBbYV0gU3BlY2lmaWVzIHRoZSBhIHByb3BlcnR5IGZvciB0aGUgbmV3IG1hdHJpeC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbYl0gU3BlY2lmaWVzIHRoZSBiIHByb3BlcnR5IGZvciB0aGUgbmV3IG1hdHJpeC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbY10gU3BlY2lmaWVzIHRoZSBjIHByb3BlcnR5IGZvciB0aGUgbmV3IG1hdHJpeC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbZF0gU3BlY2lmaWVzIHRoZSBkIHByb3BlcnR5IGZvciB0aGUgbmV3IG1hdHJpeC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbdHhdIFNwZWNpZmllcyB0aGUgdHggcHJvcGVydHkgZm9yIHRoZSBuZXcgbWF0cml4LlxuICogQHBhcmFtIHtOdW1iZXJ9IFt0eV0gU3BlY2lmaWVzIHRoZSB0eSBwcm9wZXJ0eSBmb3IgdGhlIG5ldyBtYXRyaXguXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1hdHJpeDJEIHtcblxuXHRjb25zdHJ1Y3RvciAoYSwgYiwgYywgZCwgdHgsIHR5KSB7XG5cdFx0dGhpcy5zZXRWYWx1ZXMoYSwgYiwgYywgZCwgdHgsIHR5KTtcblxuXHRcdC8vIGFzc2lnbmVkIGluIHRoZSBzZXRWYWx1ZXMgbWV0aG9kLlxuXHRcdC8qKlxuXHRcdCAqIFBvc2l0aW9uICgwLCAwKSBpbiBhIDN4MyBhZmZpbmUgdHJhbnNmb3JtYXRpb24gbWF0cml4LlxuXHRcdCAqIEBwcm9wZXJ0eSBhXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKi9cblxuXHRcdC8qKlxuXHRcdCAqIFBvc2l0aW9uICgwLCAxKSBpbiBhIDN4MyBhZmZpbmUgdHJhbnNmb3JtYXRpb24gbWF0cml4LlxuXHRcdCAqIEBwcm9wZXJ0eSBiXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKi9cblxuXHRcdC8qKlxuXHRcdCAqIFBvc2l0aW9uICgxLCAwKSBpbiBhIDN4MyBhZmZpbmUgdHJhbnNmb3JtYXRpb24gbWF0cml4LlxuXHRcdCAqIEBwcm9wZXJ0eSBjXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKi9cblxuXHRcdC8qKlxuXHRcdCAqIFBvc2l0aW9uICgxLCAxKSBpbiBhIDN4MyBhZmZpbmUgdHJhbnNmb3JtYXRpb24gbWF0cml4LlxuXHRcdCAqIEBwcm9wZXJ0eSBkXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKi9cblxuXHRcdC8qKlxuXHRcdCAqIFBvc2l0aW9uICgyLCAwKSBpbiBhIDN4MyBhZmZpbmUgdHJhbnNmb3JtYXRpb24gbWF0cml4LlxuXHRcdCAqIEBwcm9wZXJ0eSB0eFxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICovXG5cblx0XHQvKipcblx0XHQgKiBQb3NpdGlvbiAoMiwgMSkgaW4gYSAzeDMgYWZmaW5lIHRyYW5zZm9ybWF0aW9uIG1hdHJpeC5cblx0XHQgKiBAcHJvcGVydHkgdHlcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqL1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHNwZWNpZmllZCB2YWx1ZXMgb24gdGhpcyBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFthPTFdIFNwZWNpZmllcyB0aGUgYSBwcm9wZXJ0eSBmb3IgdGhlIG5ldyBtYXRyaXguXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbYj0wXSBTcGVjaWZpZXMgdGhlIGIgcHJvcGVydHkgZm9yIHRoZSBuZXcgbWF0cml4LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2M9MF0gU3BlY2lmaWVzIHRoZSBjIHByb3BlcnR5IGZvciB0aGUgbmV3IG1hdHJpeC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtkPTFdIFNwZWNpZmllcyB0aGUgZCBwcm9wZXJ0eSBmb3IgdGhlIG5ldyBtYXRyaXguXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbdHg9MF0gU3BlY2lmaWVzIHRoZSB0eCBwcm9wZXJ0eSBmb3IgdGhlIG5ldyBtYXRyaXguXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbdHk9MF0gU3BlY2lmaWVzIHRoZSB0eSBwcm9wZXJ0eSBmb3IgdGhlIG5ldyBtYXRyaXguXG5cdCAqIEByZXR1cm4ge01hdHJpeDJEfSBUaGlzIGluc3RhbmNlLiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0ICogQGNoYWluYWJsZVxuXHQqL1xuXHRzZXRWYWx1ZXMgKGEgPSAxLCBiID0gMCwgYyA9IDAsIGQgPSAxLCB0eCA9IDAsIHR5ID0gMCkge1xuXHRcdC8vIGRvbid0IGZvcmdldCB0byB1cGRhdGUgZG9jcyBpbiB0aGUgY29uc3RydWN0b3IgaWYgdGhlc2UgY2hhbmdlOlxuXHRcdHRoaXMuYSA9IGE7XG5cdFx0dGhpcy5iID0gYjtcblx0XHR0aGlzLmMgPSBjO1xuXHRcdHRoaXMuZCA9IGQ7XG5cdFx0dGhpcy50eCA9IHR4O1xuXHRcdHRoaXMudHkgPSB0eTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBBcHBlbmRzIHRoZSBzcGVjaWZpZWQgbWF0cml4IHByb3BlcnRpZXMgdG8gdGhpcyBtYXRyaXguIEFsbCBwYXJhbWV0ZXJzIGFyZSByZXF1aXJlZC5cblx0ICogVGhpcyBpcyB0aGUgZXF1aXZhbGVudCBvZiBtdWx0aXBseWluZyBgKHRoaXMgbWF0cml4KSAqIChzcGVjaWZpZWQgbWF0cml4KWAuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBhXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBiXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0eFxuXHQgKiBAcGFyYW0ge051bWJlcn0gdHlcblx0ICogQHJldHVybiB7ZWFzZWxqcy5NYXRyaXgyRH0gVGhpcyBtYXRyaXguIFVzZWZ1bCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRhcHBlbmQgKGEsIGIsIGMsIGQsIHR4LCB0eSkge1xuXHRcdGxldCBhMSA9IHRoaXMuYTtcblx0XHRsZXQgYjEgPSB0aGlzLmI7XG5cdFx0bGV0IGMxID0gdGhpcy5jO1xuXHRcdGxldCBkMSA9IHRoaXMuZDtcblx0XHRpZiAoYSAhPSAxIHx8IGIgIT0gMCB8fCBjICE9IDAgfHwgZCAhPSAxKSB7XG5cdFx0XHR0aGlzLmEgID0gYTEqYStjMSpiO1xuXHRcdFx0dGhpcy5iICA9IGIxKmErZDEqYjtcblx0XHRcdHRoaXMuYyAgPSBhMSpjK2MxKmQ7XG5cdFx0XHR0aGlzLmQgID0gYjEqYytkMSpkO1xuXHRcdH1cblx0XHR0aGlzLnR4ID0gYTEqdHgrYzEqdHkrdGhpcy50eDtcblx0XHR0aGlzLnR5ID0gYjEqdHgrZDEqdHkrdGhpcy50eTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogUHJlcGVuZHMgdGhlIHNwZWNpZmllZCBtYXRyaXggcHJvcGVydGllcyB0byB0aGlzIG1hdHJpeC5cblx0ICogVGhpcyBpcyB0aGUgZXF1aXZhbGVudCBvZiBtdWx0aXBseWluZyBgKHNwZWNpZmllZCBtYXRyaXgpICogKHRoaXMgbWF0cml4KWAuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBhXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBiXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0eFxuXHQgKiBAcGFyYW0ge051bWJlcn0gdHlcblx0ICogQHJldHVybiB7ZWFzZWxqcy5NYXRyaXgyRH0gVGhpcyBtYXRyaXguIFVzZWZ1bCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRwcmVwZW5kIChhLCBiLCBjLCBkLCB0eCwgdHkpIHtcblx0XHRsZXQgYTEgPSB0aGlzLmE7XG5cdFx0bGV0IGMxID0gdGhpcy5jO1xuXHRcdGxldCB0eDEgPSB0aGlzLnR4O1xuXG5cdFx0dGhpcy5hICA9IGEqYTErYyp0aGlzLmI7XG5cdFx0dGhpcy5iICA9IGIqYTErZCp0aGlzLmI7XG5cdFx0dGhpcy5jICA9IGEqYzErYyp0aGlzLmQ7XG5cdFx0dGhpcy5kICA9IGIqYzErZCp0aGlzLmQ7XG5cdFx0dGhpcy50eCA9IGEqdHgxK2MqdGhpcy50eSt0eDtcblx0XHR0aGlzLnR5ID0gYip0eDErZCp0aGlzLnR5K3R5O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFwcGVuZHMgdGhlIHNwZWNpZmllZCBtYXRyaXggdG8gdGhpcyBtYXRyaXguXG5cdCAqIFRoaXMgaXMgdGhlIGVxdWl2YWxlbnQgb2YgbXVsdGlwbHlpbmcgYCh0aGlzIG1hdHJpeCkgKiAoc3BlY2lmaWVkIG1hdHJpeClgLlxuXHQgKiBAcGFyYW0ge2Vhc2VsanMuTWF0cml4MkR9IG1hdHJpeFxuXHQgKiBAcmV0dXJuIHtlYXNlbGpzLk1hdHJpeDJEfSBUaGlzIG1hdHJpeC4gVXNlZnVsIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdGFwcGVuZE1hdHJpeCAobWF0cml4KSB7XG5cdFx0cmV0dXJuIHRoaXMuYXBwZW5kKG1hdHJpeC5hLCBtYXRyaXguYiwgbWF0cml4LmMsIG1hdHJpeC5kLCBtYXRyaXgudHgsIG1hdHJpeC50eSk7XG5cdH1cblxuXHQvKipcblx0ICogUHJlcGVuZHMgdGhlIHNwZWNpZmllZCBtYXRyaXggdG8gdGhpcyBtYXRyaXguXG5cdCAqIFRoaXMgaXMgdGhlIGVxdWl2YWxlbnQgb2YgbXVsdGlwbHlpbmcgYChzcGVjaWZpZWQgbWF0cml4KSAqICh0aGlzIG1hdHJpeClgLlxuXHQgKlxuXHQgKiBAZXhhbXBsZSA8Y2FwdGlvbj5DYWxjdWxhdGUgdGhlIGNvbWJpbmVkIHRyYW5zZm9ybWF0aW9uIGZvciBhIGNoaWxkIG9iamVjdDwvY2FwdGlvbj5cblx0ICogbGV0IG8gPSBkaXNwbGF5T2JqZWN0O1xuXHQgKiBsZXQgbXR4ID0gby5nZXRNYXRyaXgoKTtcblx0ICogd2hpbGUgKG8gPSBvLnBhcmVudCkge1xuXHQgKiBcdCAvLyBwcmVwZW5kIGVhY2ggcGFyZW50J3MgdHJhbnNmb3JtYXRpb24gaW4gdHVybjpcblx0ICogXHQgby5wcmVwZW5kTWF0cml4KG8uZ2V0TWF0cml4KCkpO1xuXHQgKiB9XG5cdCAqXG5cdCAqIEBwYXJhbSB7ZWFzZWxqcy5NYXRyaXgyRH0gbWF0cml4XG5cdCAqIEByZXR1cm4ge2Vhc2VsanMuTWF0cml4MkR9IFRoaXMgbWF0cml4LiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0cHJlcGVuZE1hdHJpeCAobWF0cml4KSB7XG5cdFx0cmV0dXJuIHRoaXMucHJlcGVuZChtYXRyaXguYSwgbWF0cml4LmIsIG1hdHJpeC5jLCBtYXRyaXguZCwgbWF0cml4LnR4LCBtYXRyaXgudHkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdlbmVyYXRlcyBtYXRyaXggcHJvcGVydGllcyBmcm9tIHRoZSBzcGVjaWZpZWQgZGlzcGxheSBvYmplY3QgdHJhbnNmb3JtIHByb3BlcnRpZXMsIGFuZCBhcHBlbmRzIHRoZW0gdG8gdGhpcyBtYXRyaXguXG5cdCAqXG5cdCAqIEBleGFtcGxlIDxjYXB0aW9uPkdlbmVyYXRlIGEgbWF0cml4IHJlcHJlc2VudGluZyB0aGUgdHJhbnNmb3JtYXRpb25zIG9mIGEgZGlzcGxheSBvYmplY3Q8L2NhcHRpb24+XG5cdCAqIGxldCBtdHggPSBuZXcgTWF0cml4MkQoKTtcblx0ICogbXR4LmFwcGVuZFRyYW5zZm9ybShvLngsIG8ueSwgby5zY2FsZVgsIG8uc2NhbGVZLCBvLnJvdGF0aW9uKTtcblx0ICpcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlWFxuXHQgKiBAcGFyYW0ge051bWJlcn0gc2NhbGVZXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByb3RhdGlvblxuXHQgKiBAcGFyYW0ge051bWJlcn0gc2tld1hcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHNrZXdZXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbcmVnWF1cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtyZWdZXVxuXHQgKiBAcmV0dXJuIHtlYXNlbGpzLk1hdHJpeDJEfSBUaGlzIG1hdHJpeC4gVXNlZnVsIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdGFwcGVuZFRyYW5zZm9ybSAoeCwgeSwgc2NhbGVYLCBzY2FsZVksIHJvdGF0aW9uLCBza2V3WCwgc2tld1ksIHJlZ1gsIHJlZ1kpIHtcblx0XHRsZXQgciwgY29zLCBzaW47XG5cdFx0aWYgKHJvdGF0aW9uJTM2MCkge1xuXHRcdFx0ciA9IHJvdGF0aW9uKk1hdHJpeDJELkRFR19UT19SQUQ7XG5cdFx0XHRjb3MgPSBNYXRoLmNvcyhyKTtcblx0XHRcdHNpbiA9IE1hdGguc2luKHIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb3MgPSAxO1xuXHRcdFx0c2luID0gMDtcblx0XHR9XG5cblx0XHRpZiAoc2tld1ggfHwgc2tld1kpIHtcblx0XHRcdC8vIFRPRE86IGNhbiB0aGlzIGJlIGNvbWJpbmVkIGludG8gYSBzaW5nbGUgYXBwZW5kIG9wZXJhdGlvbj9cblx0XHRcdHNrZXdYICo9IE1hdHJpeDJELkRFR19UT19SQUQ7XG5cdFx0XHRza2V3WSAqPSBNYXRyaXgyRC5ERUdfVE9fUkFEO1xuXHRcdFx0dGhpcy5hcHBlbmQoTWF0aC5jb3Moc2tld1kpLCBNYXRoLnNpbihza2V3WSksIC1NYXRoLnNpbihza2V3WCksIE1hdGguY29zKHNrZXdYKSwgeCwgeSk7XG5cdFx0XHR0aGlzLmFwcGVuZChjb3Mqc2NhbGVYLCBzaW4qc2NhbGVYLCAtc2luKnNjYWxlWSwgY29zKnNjYWxlWSwgMCwgMCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuYXBwZW5kKGNvcypzY2FsZVgsIHNpbipzY2FsZVgsIC1zaW4qc2NhbGVZLCBjb3Mqc2NhbGVZLCB4LCB5KTtcblx0XHR9XG5cblx0XHRpZiAocmVnWCB8fCByZWdZKSB7XG5cdFx0XHQvLyBhcHBlbmQgdGhlIHJlZ2lzdHJhdGlvbiBvZmZzZXQ6XG5cdFx0XHR0aGlzLnR4IC09IHJlZ1gqdGhpcy5hK3JlZ1kqdGhpcy5jO1xuXHRcdFx0dGhpcy50eSAtPSByZWdYKnRoaXMuYityZWdZKnRoaXMuZDtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogR2VuZXJhdGVzIG1hdHJpeCBwcm9wZXJ0aWVzIGZyb20gdGhlIHNwZWNpZmllZCBkaXNwbGF5IG9iamVjdCB0cmFuc2Zvcm0gcHJvcGVydGllcywgYW5kIHByZXBlbmRzIHRoZW0gdG8gdGhpcyBtYXRyaXguXG5cdCAqXG5cdCAqIE5vdGUgdGhhdCB0aGUgYWJvdmUgZXhhbXBsZSB3b3VsZCBub3QgYWNjb3VudCBmb3Ige0BsaW5rIGVhc2VsanMuRGlzcGxheU9iamVjdCN0cmFuc2Zvcm1NYXRyaXh9IHZhbHVlcy5cblx0ICogU2VlIHtAbGluayBlYXNlbGpzLk1hdHJpeDJEI3ByZXBlbmRNYXRyaXh9IGZvciBhbiBleGFtcGxlIHRoYXQgZG9lcy5cblx0ICpcblx0ICogQGV4YW1wbGUgPGNhcHRpb24+Q2FsY3VsYXRlIHRoZSBjb21iaW5lZCB0cmFuc2Zvcm1hdGlvbiBmb3IgYSBjaGlsZCBvYmplY3Q8L2NhcHRpb24+XG5cdCAqIGxldCBvID0gZGlzcGxheU9iamVjdDtcblx0ICogbGV0IG10eCA9IG5ldyBNYXRyaXgyRCgpO1xuXHQgKiBkbyAge1xuXHQgKiBcdCAvLyBwcmVwZW5kIGVhY2ggcGFyZW50J3MgdHJhbnNmb3JtYXRpb24gaW4gdHVybjpcblx0ICogXHQgbXR4LnByZXBlbmRUcmFuc2Zvcm0oby54LCBvLnksIG8uc2NhbGVYLCBvLnNjYWxlWSwgby5yb3RhdGlvbiwgby5za2V3WCwgby5za2V3WSwgby5yZWdYLCBvLnJlZ1kpO1xuXHQgKiB9IHdoaWxlIChvID0gby5wYXJlbnQpO1xuXHQgKlxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcGFyYW0ge051bWJlcn0gc2NhbGVYXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZVlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJvdGF0aW9uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBza2V3WFxuXHQgKiBAcGFyYW0ge051bWJlcn0gc2tld1lcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtyZWdYXVxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3JlZ1ldXG5cdCAqIEByZXR1cm4ge2Vhc2VsanMuTWF0cml4MkR9IFRoaXMgbWF0cml4LiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0ICovXG5cdHByZXBlbmRUcmFuc2Zvcm0gKHgsIHksIHNjYWxlWCwgc2NhbGVZLCByb3RhdGlvbiwgc2tld1gsIHNrZXdZLCByZWdYLCByZWdZKSB7XG5cdFx0bGV0IHIsIGNvcywgc2luO1xuXHRcdGlmIChyb3RhdGlvbiUzNjApIHtcblx0XHRcdHIgPSByb3RhdGlvbipNYXRyaXgyRC5ERUdfVE9fUkFEO1xuXHRcdFx0Y29zID0gTWF0aC5jb3Mocik7XG5cdFx0XHRzaW4gPSBNYXRoLnNpbihyKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29zID0gMTtcblx0XHRcdHNpbiA9IDA7XG5cdFx0fVxuXG5cdFx0aWYgKHJlZ1ggfHwgcmVnWSkge1xuXHRcdFx0Ly8gcHJlcGVuZCB0aGUgcmVnaXN0cmF0aW9uIG9mZnNldDpcblx0XHRcdHRoaXMudHggLT0gcmVnWDsgdGhpcy50eSAtPSByZWdZO1xuXHRcdH1cblx0XHRpZiAoc2tld1ggfHwgc2tld1kpIHtcblx0XHRcdC8vIFRPRE86IGNhbiB0aGlzIGJlIGNvbWJpbmVkIGludG8gYSBzaW5nbGUgcHJlcGVuZCBvcGVyYXRpb24/XG5cdFx0XHRza2V3WCAqPSBNYXRyaXgyRC5ERUdfVE9fUkFEO1xuXHRcdFx0c2tld1kgKj0gTWF0cml4MkQuREVHX1RPX1JBRDtcblx0XHRcdHRoaXMucHJlcGVuZChjb3Mqc2NhbGVYLCBzaW4qc2NhbGVYLCAtc2luKnNjYWxlWSwgY29zKnNjYWxlWSwgMCwgMCk7XG5cdFx0XHR0aGlzLnByZXBlbmQoTWF0aC5jb3Moc2tld1kpLCBNYXRoLnNpbihza2V3WSksIC1NYXRoLnNpbihza2V3WCksIE1hdGguY29zKHNrZXdYKSwgeCwgeSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMucHJlcGVuZChjb3Mqc2NhbGVYLCBzaW4qc2NhbGVYLCAtc2luKnNjYWxlWSwgY29zKnNjYWxlWSwgeCwgeSk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFwcGxpZXMgYSBjbG9ja3dpc2Ugcm90YXRpb24gdHJhbnNmb3JtYXRpb24gdG8gdGhlIG1hdHJpeC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGFuZ2xlIFRoZSBhbmdsZSB0byByb3RhdGUgYnksIGluIGRlZ3JlZXMuIFRvIHVzZSBhIHZhbHVlIGluIHJhZGlhbnMsIG11bHRpcGx5IGl0IGJ5IGBNYXRoLlBJLzE4MGAuXG5cdCAqIEByZXR1cm4ge2Vhc2VsanMuTWF0cml4MkR9IFRoaXMgbWF0cml4LiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0cm90YXRlIChhbmdsZSkge1xuXHRcdGFuZ2xlICo9IE1hdHJpeDJELkRFR19UT19SQUQ7XG5cdFx0bGV0IGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcblx0XHRsZXQgc2luID0gTWF0aC5zaW4oYW5nbGUpO1xuXG5cdFx0bGV0IGExID0gdGhpcy5hO1xuXHRcdGxldCBiMSA9IHRoaXMuYjtcblxuXHRcdHRoaXMuYSA9IGExKmNvcyt0aGlzLmMqc2luO1xuXHRcdHRoaXMuYiA9IGIxKmNvcyt0aGlzLmQqc2luO1xuXHRcdHRoaXMuYyA9IC1hMSpzaW4rdGhpcy5jKmNvcztcblx0XHR0aGlzLmQgPSAtYjEqc2luK3RoaXMuZCpjb3M7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQXBwbGllcyBhIHNrZXcgdHJhbnNmb3JtYXRpb24gdG8gdGhlIG1hdHJpeC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHNrZXdYIFRoZSBhbW91bnQgdG8gc2tldyBob3Jpem9udGFsbHkgaW4gZGVncmVlcy4gVG8gdXNlIGEgdmFsdWUgaW4gcmFkaWFucywgbXVsdGlwbHkgaXQgYnkgYE1hdGguUEkvMTgwYC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHNrZXdZIFRoZSBhbW91bnQgdG8gc2tldyB2ZXJ0aWNhbGx5IGluIGRlZ3JlZXMuXG5cdCAqIEByZXR1cm4ge2Vhc2VsanMuTWF0cml4MkR9IFRoaXMgbWF0cml4LiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0ICogQGNoYWluYWJsZVxuXHQqL1xuXHRza2V3IChza2V3WCwgc2tld1kpIHtcblx0XHRza2V3WCAqPSBNYXRyaXgyRC5ERUdfVE9fUkFEO1xuXHRcdHNrZXdZICo9IE1hdHJpeDJELkRFR19UT19SQUQ7XG5cdFx0dGhpcy5hcHBlbmQoTWF0aC5jb3Moc2tld1kpLCBNYXRoLnNpbihza2V3WSksIC1NYXRoLnNpbihza2V3WCksIE1hdGguY29zKHNrZXdYKSwgMCwgMCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQXBwbGllcyBhIHNjYWxlIHRyYW5zZm9ybWF0aW9uIHRvIHRoZSBtYXRyaXguXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSBhbW91bnQgdG8gc2NhbGUgaG9yaXpvbnRhbGx5LiBFLkcuIGEgdmFsdWUgb2YgMiB3aWxsIGRvdWJsZSB0aGUgc2l6ZSBpbiB0aGUgWCBkaXJlY3Rpb24sIGFuZCAwLjUgd2lsbCBoYWx2ZSBpdC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIGFtb3VudCB0byBzY2FsZSB2ZXJ0aWNhbGx5LlxuXHQgKiBAcmV0dXJuIHtlYXNlbGpzLk1hdHJpeDJEfSBUaGlzIG1hdHJpeC4gVXNlZnVsIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdHNjYWxlICh4LCB5KSB7XG5cdFx0dGhpcy5hICo9IHg7XG5cdFx0dGhpcy5iICo9IHg7XG5cdFx0dGhpcy5jICo9IHk7XG5cdFx0dGhpcy5kICo9IHk7XG5cdFx0Ly90aGlzLnR4ICo9IHg7XG5cdFx0Ly90aGlzLnR5ICo9IHk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogVHJhbnNsYXRlcyB0aGUgbWF0cml4IG9uIHRoZSB4IGFuZCB5IGF4ZXMuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEByZXR1cm4ge2Vhc2VsanMuTWF0cml4MkR9IFRoaXMgbWF0cml4LiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0dHJhbnNsYXRlICh4LCB5KSB7XG5cdFx0dGhpcy50eCArPSB0aGlzLmEqeCArIHRoaXMuYyp5O1xuXHRcdHRoaXMudHkgKz0gdGhpcy5iKnggKyB0aGlzLmQqeTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBtYXRyaXggdG8gdGhvc2Ugb2YgYW4gaWRlbnRpdHkgbWF0cml4IChvbmUgdGhhdCBhcHBsaWVzIGEgbnVsbCB0cmFuc2Zvcm1hdGlvbikuXG5cdCAqIEByZXR1cm4ge2Vhc2VsanMuTWF0cml4MkR9IFRoaXMgbWF0cml4LiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0aWRlbnRpdHkgKCkge1xuXHRcdHRoaXMuYSA9IHRoaXMuZCA9IDE7XG5cdFx0dGhpcy5iID0gdGhpcy5jID0gdGhpcy50eCA9IHRoaXMudHkgPSAwO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEludmVydHMgdGhlIG1hdHJpeCwgY2F1c2luZyBpdCB0byBwZXJmb3JtIHRoZSBvcHBvc2l0ZSB0cmFuc2Zvcm1hdGlvbi5cblx0ICogQHJldHVybiB7ZWFzZWxqcy5NYXRyaXgyRH0gVGhpcyBtYXRyaXguIFVzZWZ1bCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRpbnZlcnQgKCkge1xuXHRcdGxldCBhMSA9IHRoaXMuYTtcblx0XHRsZXQgYjEgPSB0aGlzLmI7XG5cdFx0bGV0IGMxID0gdGhpcy5jO1xuXHRcdGxldCBkMSA9IHRoaXMuZDtcblx0XHRsZXQgdHgxID0gdGhpcy50eDtcblx0XHRsZXQgbiA9IGExKmQxLWIxKmMxO1xuXG5cdFx0dGhpcy5hID0gZDEvbjtcblx0XHR0aGlzLmIgPSAtYjEvbjtcblx0XHR0aGlzLmMgPSAtYzEvbjtcblx0XHR0aGlzLmQgPSBhMS9uO1xuXHRcdHRoaXMudHggPSAoYzEqdGhpcy50eS1kMSp0eDEpL247XG5cdFx0dGhpcy50eSA9IC0oYTEqdGhpcy50eS1iMSp0eDEpL247XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSBtYXRyaXggaXMgYW4gaWRlbnRpdHkgbWF0cml4LlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKi9cblx0aXNJZGVudGl0eSAoKSB7XG5cdFx0cmV0dXJuIHRoaXMudHggPT09IDAgJiYgdGhpcy50eSA9PT0gMCAmJiB0aGlzLmEgPT09IDEgJiYgdGhpcy5iID09PSAwICYmIHRoaXMuYyA9PT0gMCAmJiB0aGlzLmQgPT09IDE7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoaXMgbWF0cml4IGlzIGVxdWFsIHRvIHRoZSBzcGVjaWZpZWQgbWF0cml4IChhbGwgcHJvcGVydHkgdmFsdWVzIGFyZSBlcXVhbCkuXG5cdCAqIEBwYXJhbSB7ZWFzZWxqcy5NYXRyaXgyRH0gbWF0cml4IFRoZSBtYXRyaXggdG8gY29tcGFyZS5cblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICovXG5cdGVxdWFscyAobWF0cml4KSB7XG5cdFx0cmV0dXJuIHRoaXMudHggPT09IG1hdHJpeC50eCAmJiB0aGlzLnR5ID09PSBtYXRyaXgudHkgJiYgdGhpcy5hID09PSBtYXRyaXguYSAmJiB0aGlzLmIgPT09IG1hdHJpeC5iICYmIHRoaXMuYyA9PT0gbWF0cml4LmMgJiYgdGhpcy5kID09PSBtYXRyaXguZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBUcmFuc2Zvcm1zIGEgcG9pbnQgYWNjb3JkaW5nIHRvIHRoaXMgbWF0cml4LlxuXHQgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgeCBjb21wb25lbnQgb2YgdGhlIHBvaW50IHRvIHRyYW5zZm9ybS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHkgY29tcG9uZW50IG9mIHRoZSBwb2ludCB0byB0cmFuc2Zvcm0uXG5cdCAqIEBwYXJhbSB7ZWFzZWxqcy5Qb2ludCB8IE9iamVjdH0gW3B0XSBBbiBvYmplY3QgdG8gY29weSB0aGUgcmVzdWx0IGludG8uIElmIG9taXR0ZWQgYSBnZW5lcmljIG9iamVjdCB3aXRoIHgveSBwcm9wZXJ0aWVzIHdpbGwgYmUgcmV0dXJuZWQuXG5cdCAqIEByZXR1cm4ge2Vhc2VsanMuUG9pbnR9IFRoaXMgbWF0cml4LiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0ICovXG5cdHRyYW5zZm9ybVBvaW50ICh4LCB5LCBwdCA9IG5ldyBQb2ludCgpKSB7XG5cdFx0cHQueCA9IHgqdGhpcy5hK3kqdGhpcy5jK3RoaXMudHg7XG5cdFx0cHQueSA9IHgqdGhpcy5iK3kqdGhpcy5kK3RoaXMudHk7XG5cdFx0cmV0dXJuIHB0O1xuXHR9XG5cblx0LyoqXG5cdCAqIERlY29tcG9zZXMgdGhlIG1hdHJpeCBpbnRvIHRyYW5zZm9ybSBwcm9wZXJ0aWVzICh4LCB5LCBzY2FsZVgsIHNjYWxlWSwgYW5kIHJvdGF0aW9uKS4gTm90ZSB0aGF0IHRoZXNlIHZhbHVlc1xuXHQgKiBtYXkgbm90IG1hdGNoIHRoZSB0cmFuc2Zvcm0gcHJvcGVydGllcyB5b3UgdXNlZCB0byBnZW5lcmF0ZSB0aGUgbWF0cml4LCB0aG91Z2ggdGhleSB3aWxsIHByb2R1Y2UgdGhlIHNhbWUgdmlzdWFsXG5cdCAqIHJlc3VsdHMuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbdGFyZ2V0XSBUaGUgb2JqZWN0IHRvIGFwcGx5IHRoZSB0cmFuc2Zvcm0gcHJvcGVydGllcyB0by4gSWYgbnVsbCwgdGhlbiBhIG5ldyBvYmplY3Qgd2lsbCBiZSByZXR1cm5lZC5cblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgdGFyZ2V0LCBvciBhIG5ldyBnZW5lcmljIG9iamVjdCB3aXRoIHRoZSB0cmFuc2Zvcm0gcHJvcGVydGllcyBhcHBsaWVkLlxuXHQqL1xuXHRkZWNvbXBvc2UgKHRhcmdldCA9IHt9KSB7XG5cdFx0Ly8gVE9ETzogaXQgd291bGQgYmUgbmljZSB0byBiZSBhYmxlIHRvIHNvbHZlIGZvciB3aGV0aGVyIHRoZSBtYXRyaXggY2FuIGJlIGRlY29tcG9zZWQgaW50byBvbmx5IHNjYWxlL3JvdGF0aW9uIGV2ZW4gd2hlbiBzY2FsZSBpcyBuZWdhdGl2ZVxuXHRcdHRhcmdldC54ID0gdGhpcy50eDtcblx0XHR0YXJnZXQueSA9IHRoaXMudHk7XG5cdFx0dGFyZ2V0LnNjYWxlWCA9IE1hdGguc3FydCh0aGlzLmEgKiB0aGlzLmEgKyB0aGlzLmIgKiB0aGlzLmIpO1xuXHRcdHRhcmdldC5zY2FsZVkgPSBNYXRoLnNxcnQodGhpcy5jICogdGhpcy5jICsgdGhpcy5kICogdGhpcy5kKTtcblxuXHRcdGxldCBza2V3WCA9IE1hdGguYXRhbjIoLXRoaXMuYywgdGhpcy5kKTtcblx0XHRsZXQgc2tld1kgPSBNYXRoLmF0YW4yKHRoaXMuYiwgdGhpcy5hKTtcblxuXHRcdGxldCBkZWx0YSA9IE1hdGguYWJzKDEtc2tld1gvc2tld1kpO1xuXHRcdGlmIChkZWx0YSA8IDAuMDAwMDEpIHsgLy8gZWZmZWN0aXZlbHkgaWRlbnRpY2FsLCBjYW4gdXNlIHJvdGF0aW9uOlxuXHRcdFx0dGFyZ2V0LnJvdGF0aW9uID0gc2tld1kvTWF0cml4MkQuREVHX1RPX1JBRDtcblx0XHRcdGlmICh0aGlzLmEgPCAwICYmIHRoaXMuZCA+PSAwKSB7XG5cdFx0XHRcdHRhcmdldC5yb3RhdGlvbiArPSAodGFyZ2V0LnJvdGF0aW9uIDw9IDApID8gMTgwIDogLTE4MDtcblx0XHRcdH1cblx0XHRcdHRhcmdldC5za2V3WCA9IHRhcmdldC5za2V3WSA9IDA7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRhcmdldC5za2V3WCA9IHNrZXdYL01hdHJpeDJELkRFR19UT19SQUQ7XG5cdFx0XHR0YXJnZXQuc2tld1kgPSBza2V3WS9NYXRyaXgyRC5ERUdfVE9fUkFEO1xuXHRcdH1cblx0XHRyZXR1cm4gdGFyZ2V0O1xuXHR9XG5cblx0LyoqXG5cdCAqIENvcGllcyBhbGwgcHJvcGVydGllcyBmcm9tIHRoZSBzcGVjaWZpZWQgbWF0cml4IHRvIHRoaXMgbWF0cml4LlxuXHQgKiBAcGFyYW0ge2Vhc2VsanMuTWF0cml4MkR9IG1hdHJpeCBUaGUgbWF0cml4IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuXHQgKiBAcmV0dXJuIHtlYXNlbGpzLk1hdHJpeDJEfSBUaGlzIG1hdHJpeC4gVXNlZnVsIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG5cdCAqIEBjaGFpbmFibGVcblx0Ki9cblx0Y29weSAobWF0cml4KSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0VmFsdWVzKG1hdHJpeC5hLCBtYXRyaXguYiwgbWF0cml4LmMsIG1hdHJpeC5kLCBtYXRyaXgudHgsIG1hdHJpeC50eSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIGNsb25lIG9mIHRoZSBNYXRyaXgyRCBpbnN0YW5jZS5cblx0ICogQHJldHVybiB7ZWFzZWxqcy5NYXRyaXgyRH0gYSBjbG9uZSBvZiB0aGUgTWF0cml4MkQgaW5zdGFuY2UuXG5cdCAqL1xuXHRjbG9uZSAoKSB7XG5cdFx0cmV0dXJuIG5ldyBNYXRyaXgyRCh0aGlzLmEsIHRoaXMuYiwgdGhpcy5jLCB0aGlzLmQsIHRoaXMudHgsIHRoaXMudHkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxuXHQgKi9cblx0dG9TdHJpbmcgKCkge1xuXHRcdHJldHVybiBgWyR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfSAoYT0ke3RoaXMuYX0gYj0ke3RoaXMuYn0gYz0ke3RoaXMuY30gZD0ke3RoaXMuZH0gdHg9JHt0aGlzLnR4fSB0eT0ke3RoaXMudHl9KV1gO1xuXHR9XG5cbn1cblxuLyoqXG4gKiBNdWx0aXBsaWVyIGZvciBjb252ZXJ0aW5nIGRlZ3JlZXMgdG8gcmFkaWFucy4gVXNlZCBpbnRlcm5hbGx5IGJ5IE1hdHJpeDJELlxuICogQHN0YXRpY1xuICogQHR5cGUge051bWJlcn1cbiAqIEByZWFkb25seVxuICovXG5NYXRyaXgyRC5ERUdfVE9fUkFEID0gTWF0aC5QSS8xODA7XG4vKipcbiAqIEFuIGlkZW50aXR5IG1hdHJpeCwgcmVwcmVzZW50aW5nIGEgbnVsbCB0cmFuc2Zvcm1hdGlvbi5cbiAqIEBzdGF0aWNcbiAqIEB0eXBlIHtlYXNlbGpzLk1hdHJpeDJEfVxuICogQHJlYWRvbmx5XG4gKi9cbk1hdHJpeDJELmlkZW50aXR5ID0gbmV3IE1hdHJpeDJEKCk7XG4iLCIvKipcbiAqIEBsaWNlbnNlIERpc3BsYXlQcm9wc1xuICogVmlzaXQgaHR0cDovL2NyZWF0ZWpzLmNvbS8gZm9yIGRvY3VtZW50YXRpb24sIHVwZGF0ZXMgYW5kIGV4YW1wbGVzLlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNyBnc2tpbm5lci5jb20sIGluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICogb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cbiAqIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxuICogcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsXG4gKiBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4gKiBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuICogY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAqIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xuICogT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAqIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4gKiBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcbiAqIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuICogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUlxuICogT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICovXG5cbmltcG9ydCBNYXRyaXgyRCBmcm9tIFwiLi9NYXRyaXgyRFwiO1xuXG4vKipcbiAqIFVzZWQgZm9yIGNhbGN1bGF0aW5nIGFuZCBlbmNhcHN1bGF0aW5nIGRpc3BsYXkgcmVsYXRlZCBwcm9wZXJ0aWVzLlxuICogQG1lbWJlcm9mIGVhc2VsanNcbiAqIEBwYXJhbSB7TnVtYmVyfSBbdmlzaWJsZV0gVmlzaWJsZSB2YWx1ZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbYWxwaGFdIEFscGhhIHZhbHVlLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtzaGFkb3ddIEEgU2hhZG93IGluc3RhbmNlIG9yIG51bGwuXG4gKiBAcGFyYW0ge051bWJlcn0gW2NvbXBvc2l0ZU9wZXJhdGlvbl0gQSBjb21wb3NpdGVPcGVyYXRpb24gdmFsdWUgb3IgbnVsbC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbbWF0cml4XSBBIHRyYW5zZm9ybWF0aW9uIG1hdHJpeC4gRGVmYXVsdHMgdG8gYSBuZXcgaWRlbnRpdHkgbWF0cml4LlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEaXNwbGF5UHJvcHMge1xuXG5cdGNvbnN0cnVjdG9yICh2aXNpYmxlLCBhbHBoYSwgc2hhZG93LCBjb21wb3NpdGVPcGVyYXRpb24sIG1hdHJpeCkge1xuXHRcdHRoaXMuc2V0VmFsdWVzKHZpc2libGUsIGFscGhhLCBzaGFkb3csIGNvbXBvc2l0ZU9wZXJhdGlvbiwgbWF0cml4KTtcblxuXHRcdC8vIGFzc2lnbmVkIGluIHRoZSBzZXRWYWx1ZXMgbWV0aG9kLlxuXHRcdC8qKlxuXHRcdCAqIFByb3BlcnR5IHJlcHJlc2VudGluZyB0aGUgYWxwaGEgdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gYSBkaXNwbGF5IG9iamVjdC5cblx0XHQgKiBAcHJvcGVydHkgYWxwaGFcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqL1xuXG5cdFx0LyoqXG5cdFx0ICogUHJvcGVydHkgcmVwcmVzZW50aW5nIHRoZSBzaGFkb3cgdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gYSBkaXNwbGF5IG9iamVjdC5cblx0XHQgKiBAcHJvcGVydHkgc2hhZG93XG5cdFx0ICogQHR5cGUge2Vhc2VsanMuU2hhZG93fVxuXHRcdCAqL1xuXG5cdFx0LyoqXG5cdFx0ICogUHJvcGVydHkgcmVwcmVzZW50aW5nIHRoZSBjb21wb3NpdGVPcGVyYXRpb24gdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gYSBkaXNwbGF5IG9iamVjdC5cblx0XHQgKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ2FudmFzX0FQSS9UdXRvcmlhbC9Db21wb3NpdGluZ31cblx0XHQgKiBAcHJvcGVydHkgY29tcG9zaXRlT3BlcmF0aW9uXG5cdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHQgKi9cblxuXHRcdC8qKlxuXHRcdCAqIFByb3BlcnR5IHJlcHJlc2VudGluZyB0aGUgdmFsdWUgZm9yIHZpc2libGUgdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gYSBkaXNwbGF5IG9iamVjdC5cblx0XHQgKiBAcHJvcGVydHkgdmlzaWJsZVxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqL1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCB0aGF0IHdpbGwgYmUgYXBwbGllZCB0byBhIGRpc3BsYXkgb2JqZWN0LlxuXHRcdCAqIEBwcm9wZXJ0eSBtYXRyaXhcblx0XHQgKiBAdHlwZSB7ZWFzZWxqcy5NYXRyaXgyRH1cblx0XHQgKi9cblx0fVxuXG5cdC8qKlxuXHQgKiBSZWluaXRpYWxpemVzIHRoZSBpbnN0YW5jZSB3aXRoIHRoZSBzcGVjaWZpZWQgdmFsdWVzLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3Zpc2libGU9dHJ1ZV0gVmlzaWJsZSB2YWx1ZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFthbHBoYT0xXSBBbHBoYSB2YWx1ZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtzaGFkb3ddIEEgU2hhZG93IGluc3RhbmNlIG9yIG51bGwuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbY29tcG9zaXRlT3BlcmF0aW9uXSBBIGNvbXBvc2l0ZU9wZXJhdGlvbiB2YWx1ZSBvciBudWxsLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW21hdHJpeF0gQSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXguIERlZmF1bHRzIHRvIGFuIGlkZW50aXR5IG1hdHJpeC5cblx0ICogQHJldHVybiB7ZWFzZWxqcy5EaXNwbGF5UHJvcHN9IFRoaXMgaW5zdGFuY2UuIFVzZWZ1bCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCovXG5cdHNldFZhbHVlcyAodmlzaWJsZSA9IHRydWUsIGFscGhhID0gMSwgc2hhZG93LCBjb21wb3NpdGVPcGVyYXRpb24sIG1hdHJpeCkge1xuXHRcdHRoaXMudmlzaWJsZSA9IHZpc2libGU7XG5cdFx0dGhpcy5hbHBoYSA9IGFscGhhO1xuXHRcdHRoaXMuc2hhZG93ID0gc2hhZG93O1xuXHRcdHRoaXMuY29tcG9zaXRlT3BlcmF0aW9uID0gY29tcG9zaXRlT3BlcmF0aW9uO1xuXHRcdHRoaXMubWF0cml4ID0gbWF0cml4IHx8ICh0aGlzLm1hdHJpeCYmdGhpcy5tYXRyaXguaWRlbnRpdHkoKSkgfHwgbmV3IE1hdHJpeDJEKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQXBwZW5kcyB0aGUgc3BlY2lmaWVkIGRpc3BsYXkgcHJvcGVydGllcy4gVGhpcyBpcyBnZW5lcmFsbHkgdXNlZCB0byBhcHBseSBhIGNoaWxkJ3MgcHJvcGVydGllcyBpdHMgcGFyZW50J3MuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gdmlzaWJsZSBkZXNpcmVkIHZpc2libGUgdmFsdWVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGFscGhhIGRlc2lyZWQgYWxwaGEgdmFsdWVcblx0ICogQHBhcmFtIHtlYXNlbGpzLlNoYWRvd30gc2hhZG93IGRlc2lyZWQgc2hhZG93IHZhbHVlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBjb21wb3NpdGVPcGVyYXRpb24gZGVzaXJlZCBjb21wb3NpdGUgb3BlcmF0aW9uIHZhbHVlXG5cdCAqIEBwYXJhbSB7ZWFzZWxqcy5NYXRyaXgyRH0gW21hdHJpeF0gYSBNYXRyaXgyRCBpbnN0YW5jZVxuXHQgKiBAcmV0dXJuIHtlYXNlbGpzLkRpc3BsYXlQcm9wc30gVGhpcyBpbnN0YW5jZS4gVXNlZnVsIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG5cdCAqIEBjaGFpbmFibGVcblx0Ki9cblx0YXBwZW5kICh2aXNpYmxlLCBhbHBoYSwgc2hhZG93LCBjb21wb3NpdGVPcGVyYXRpb24sIG1hdHJpeCkge1xuXHRcdHRoaXMuYWxwaGEgKj0gYWxwaGE7XG5cdFx0dGhpcy5zaGFkb3cgPSBzaGFkb3cgfHwgdGhpcy5zaGFkb3c7XG5cdFx0dGhpcy5jb21wb3NpdGVPcGVyYXRpb24gPSBjb21wb3NpdGVPcGVyYXRpb24gfHwgdGhpcy5jb21wb3NpdGVPcGVyYXRpb247XG5cdFx0dGhpcy52aXNpYmxlID0gdGhpcy52aXNpYmxlICYmIHZpc2libGU7XG5cdFx0bWF0cml4JiZ0aGlzLm1hdHJpeC5hcHBlbmRNYXRyaXgobWF0cml4KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBQcmVwZW5kcyB0aGUgc3BlY2lmaWVkIGRpc3BsYXkgcHJvcGVydGllcy4gVGhpcyBpcyBnZW5lcmFsbHkgdXNlZCB0byBhcHBseSBhIHBhcmVudCdzIHByb3BlcnRpZXMgdG8gYSBjaGlsZCdzLlxuXHQgKiBGb3IgZXhhbXBsZSwgdG8gZ2V0IHRoZSBjb21iaW5lZCBkaXNwbGF5IHByb3BlcnRpZXMgdGhhdCB3b3VsZCBiZSBhcHBsaWVkIHRvIGEgY2hpbGQsIHlvdSBjb3VsZCB1c2U6XG5cdCAqXG5cdCAqIEBleGFtcGxlXG5cdCAqIGxldCBvID0gZGlzcGxheU9iamVjdDtcblx0ICogbGV0IHByb3BzID0gbmV3IERpc3BsYXlQcm9wcygpO1xuXHQgKiBkbyB7XG5cdCAqIFx0IC8vIHByZXBlbmQgZWFjaCBwYXJlbnQncyBwcm9wcyBpbiB0dXJuOlxuXHQgKiBcdCBwcm9wcy5wcmVwZW5kKG8udmlzaWJsZSwgby5hbHBoYSwgby5zaGFkb3csIG8uY29tcG9zaXRlT3BlcmF0aW9uLCBvLmdldE1hdHJpeCgpKTtcblx0ICogfSB3aGlsZSAobyA9IG8ucGFyZW50KTtcblx0ICpcblx0ICogQHBhcmFtIHtCb29sZWFufSB2aXNpYmxlIGRlc2lyZWQgdmlzaWJsZSB2YWx1ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gYWxwaGEgZGVzaXJlZCBhbHBoYSB2YWx1ZVxuXHQgKiBAcGFyYW0ge2Vhc2VsanMuU2hhZG93fSBzaGFkb3cgZGVzaXJlZCBzaGFkb3cgdmFsdWVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGNvbXBvc2l0ZU9wZXJhdGlvbiBkZXNpcmVkIGNvbXBvc2l0ZSBvcGVyYXRpb24gdmFsdWVcblx0ICogQHBhcmFtIHtlYXNlbGpzLk1hdHJpeDJEfSBbbWF0cml4XSBhIE1hdHJpeDJEIGluc3RhbmNlXG5cdCAqIEByZXR1cm4ge2Vhc2VsanMuRGlzcGxheVByb3BzfSBUaGlzIGluc3RhbmNlLiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0ICogQGNoYWluYWJsZVxuXHQqL1xuXHRwcmVwZW5kICh2aXNpYmxlLCBhbHBoYSwgc2hhZG93LCBjb21wb3NpdGVPcGVyYXRpb24sIG1hdHJpeCkge1xuXHRcdHRoaXMuYWxwaGEgKj0gYWxwaGE7XG5cdFx0dGhpcy5zaGFkb3cgPSB0aGlzLnNoYWRvdyB8fCBzaGFkb3c7XG5cdFx0dGhpcy5jb21wb3NpdGVPcGVyYXRpb24gPSB0aGlzLmNvbXBvc2l0ZU9wZXJhdGlvbiB8fCBjb21wb3NpdGVPcGVyYXRpb247XG5cdFx0dGhpcy52aXNpYmxlID0gdGhpcy52aXNpYmxlICYmIHZpc2libGU7XG5cdFx0bWF0cml4JiZ0aGlzLm1hdHJpeC5wcmVwZW5kTWF0cml4KG1hdHJpeCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogUmVzZXRzIHRoaXMgaW5zdGFuY2UgYW5kIGl0cyBtYXRyaXggdG8gZGVmYXVsdCB2YWx1ZXMuXG5cdCAqIEByZXR1cm4ge2Vhc2VsanMuRGlzcGxheVByb3BzfSBUaGlzIGluc3RhbmNlLiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0ICogQGNoYWluYWJsZVxuXHQqL1xuXHRpZGVudGl0eSAoKSB7XG5cdFx0dGhpcy52aXNpYmxlID0gdHJ1ZTtcblx0XHR0aGlzLmFscGhhID0gMTtcblx0XHR0aGlzLnNoYWRvdyA9IHRoaXMuY29tcG9zaXRlT3BlcmF0aW9uID0gbnVsbDtcblx0XHR0aGlzLm1hdHJpeC5pZGVudGl0eSgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGUgRGlzcGxheVByb3BzIGluc3RhbmNlLiBDbG9uZXMgdGhlIGFzc29jaWF0ZWQgbWF0cml4LlxuXHQgKiBAcmV0dXJuIHtlYXNlbGpzLkRpc3BsYXlQcm9wc30gYSBjbG9uZSBvZiB0aGUgRGlzcGxheVByb3BzIGluc3RhbmNlLlxuXHQgKi9cblx0Y2xvbmUgKCkge1xuXHRcdHJldHVybiBuZXcgRGlzcGxheVByb3BzKHRoaXMuYWxwaGEsIHRoaXMuc2hhZG93LCB0aGlzLmNvbXBvc2l0ZU9wZXJhdGlvbiwgdGhpcy52aXNpYmxlLCB0aGlzLm1hdHJpeC5jbG9uZSgpKTtcblx0fVxuXG59XG4iLCIvKipcbiAqIEBsaWNlbnNlIFJlY3RhbmdsZVxuICogVmlzaXQgaHR0cDovL2NyZWF0ZWpzLmNvbS8gZm9yIGRvY3VtZW50YXRpb24sIHVwZGF0ZXMgYW5kIGV4YW1wbGVzLlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNyBnc2tpbm5lci5jb20sIGluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICogb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cbiAqIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxuICogcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsXG4gKiBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4gKiBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuICogY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAqIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xuICogT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAqIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4gKiBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcbiAqIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuICogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUlxuICogT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHJlY3RhbmdsZSBhcyBkZWZpbmVkIGJ5IHRoZSBwb2ludHMgKHgsIHkpIGFuZCAoeCt3aWR0aCwgeStoZWlnaHQpLlxuICogVXNlZCBieSB7QGxpbmsgZWFzZWxqcy5EaXNwbGF5T2JqZWN0cyNnZXRCb3VuZHN9LlxuICpcbiAqIEBtZW1iZXJvZiBlYXNlbGpzXG4gKiBAZXhhbXBsZVxuICogbGV0IHJlY3QgPSBuZXcgUmVjdGFuZ2xlKDAsIDAsIDEwMCwgMTAwKTtcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gW3hdIFggcG9zaXRpb24uXG4gKiBAcGFyYW0ge051bWJlcn0gW3ldIFkgcG9zaXRpb24uXG4gKiBAcGFyYW0ge051bWJlcn0gW3dpZHRoXSBUaGUgd2lkdGggb2YgdGhlIFJlY3RhbmdsZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbaGVpZ2h0XSBUaGUgaGVpZ2h0IG9mIHRoZSBSZWN0YW5nbGUuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlY3RhbmdsZSB7XG5cblx0Y29uc3RydWN0b3IgKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcblx0XHR0aGlzLnNldFZhbHVlcyh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcblxuXHRcdC8vIGFzc2lnbmVkIGluIHRoZSBzZXRWYWx1ZXMgbWV0aG9kLlxuXHRcdC8qKlxuXHRcdCAqIFggcG9zaXRpb24uXG5cdFx0ICogQHByb3BlcnR5IHhcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqL1xuXG5cdFx0LyoqXG5cdFx0ICogWSBwb3NpdGlvbi5cblx0XHQgKiBAcHJvcGVydHkgeVxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICovXG5cblx0XHQvKipcblx0XHQgKiBXaWR0aC5cblx0XHQgKiBAcHJvcGVydHkgd2lkdGhcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqL1xuXG5cdFx0LyoqXG5cdFx0ICogSGVpZ2h0LlxuXHRcdCAqIEBwcm9wZXJ0eSBoZWlnaHRcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqL1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHNwZWNpZmllZCB2YWx1ZXMgb24gdGhpcyBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt4PTBdIFggcG9zaXRpb24uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbeT0wXSBZIHBvc2l0aW9uLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3dpZHRoPTBdIFRoZSB3aWR0aCBvZiB0aGUgUmVjdGFuZ2xlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2hlaWdodD0wXSBUaGUgaGVpZ2h0IG9mIHRoZSBSZWN0YW5nbGUuXG5cdCAqIEByZXR1cm4ge2Vhc2VsanMuUmVjdGFuZ2xlfSBUaGlzIGluc3RhbmNlLiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0ICogQGNoYWluYWJsZVxuXHQqL1xuXHRzZXRWYWx1ZXMgKHggPSAwLCB5ID0gMCwgd2lkdGggPSAwLCBoZWlnaHQgPSAwKSB7XG5cdFx0Ly8gZG9uJ3QgZm9yZ2V0IHRvIHVwZGF0ZSBkb2NzIGluIHRoZSBjb25zdHJ1Y3RvciBpZiB0aGVzZSBjaGFuZ2U6XG5cdFx0dGhpcy54ID0geDtcblx0XHR0aGlzLnkgPSB5O1xuXHRcdHRoaXMud2lkdGggPSB3aWR0aDtcblx0XHR0aGlzLmhlaWdodCA9IGhlaWdodDtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBFeHRlbmRzIHRoZSByZWN0YW5nbGUncyBib3VuZHMgdG8gaW5jbHVkZSB0aGUgZGVzY3JpYmVkIHBvaW50IG9yIHJlY3RhbmdsZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggWCBwb3NpdGlvbiBvZiB0aGUgcG9pbnQgb3IgcmVjdGFuZ2xlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBZIHBvc2l0aW9uIG9mIHRoZSBwb2ludCBvciByZWN0YW5nbGUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbd2lkdGg9MF0gVGhlIHdpZHRoIG9mIHRoZSByZWN0YW5nbGUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbaGVpZ2h0PTBdIFRoZSBoZWlnaHQgb2YgdGhlIHJlY3RhbmdsZS5cblx0ICogQHJldHVybiB7ZWFzZWxqcy5SZWN0YW5nbGV9IFRoaXMgaW5zdGFuY2UuIFVzZWZ1bCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCovXG5cdGV4dGVuZCAoeCwgeSwgd2lkdGggPSAwLCBoZWlnaHQgPSAwKSB7XG5cdFx0aWYgKHgrd2lkdGggPiB0aGlzLngrdGhpcy53aWR0aCkgeyB0aGlzLndpZHRoID0geCt3aWR0aC10aGlzLng7IH1cblx0XHRpZiAoeStoZWlnaHQgPiB0aGlzLnkrdGhpcy5oZWlnaHQpIHsgdGhpcy5oZWlnaHQgPSB5K2hlaWdodC10aGlzLnk7IH1cblx0XHRpZiAoeCA8IHRoaXMueCkgeyB0aGlzLndpZHRoICs9IHRoaXMueC14OyB0aGlzLnggPSB4OyB9XG5cdFx0aWYgKHkgPCB0aGlzLnkpIHsgdGhpcy5oZWlnaHQgKz0gdGhpcy55LXk7IHRoaXMueSA9IHk7IH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIHRoZSBzcGVjaWZpZWQgcGFkZGluZyB0byB0aGUgcmVjdGFuZ2xlJ3MgYm91bmRzLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gdG9wXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBsZWZ0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBib3R0b21cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJpZ2h0XG5cdCAqIEByZXR1cm4ge2Vhc2VsanMuUmVjdGFuZ2xlfSBUaGlzIGluc3RhbmNlLiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0ICogQGNoYWluYWJsZVxuXHQqL1xuXHRwYWQgKHRvcCwgbGVmdCwgYm90dG9tLCByaWdodCkge1xuXHRcdHRoaXMueCAtPSBsZWZ0O1xuXHRcdHRoaXMueSAtPSB0b3A7XG5cdFx0dGhpcy53aWR0aCArPSBsZWZ0K3JpZ2h0O1xuXHRcdHRoaXMuaGVpZ2h0ICs9IHRvcCtib3R0b207XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQ29waWVzIGFsbCBwcm9wZXJ0aWVzIGZyb20gdGhlIHNwZWNpZmllZCByZWN0YW5nbGUgdG8gdGhpcyByZWN0YW5nbGUuXG5cdCAqIEBwYXJhbSB7ZWFzZWxqcy5SZWN0YW5nbGV9IHJlY3RhbmdsZSBUaGUgcmVjdGFuZ2xlIHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuXHQgKiBAcmV0dXJuIHtlYXNlbGpzLlJlY3RhbmdsZX0gVGhpcyByZWN0YW5nbGUuIFVzZWZ1bCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCovXG5cdGNvcHkgKHJlY3QpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRWYWx1ZXMocmVjdC54LCByZWN0LnksIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyByZWN0YW5nbGUgZnVsbHkgZW5jbG9zZXMgdGhlIGRlc2NyaWJlZCBwb2ludCBvciByZWN0YW5nbGUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFggcG9zaXRpb24gb2YgdGhlIHBvaW50IG9yIHJlY3RhbmdsZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBwb3NpdGlvbiBvZiB0aGUgcG9pbnQgb3IgcmVjdGFuZ2xlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3dpZHRoPTBdIFRoZSB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2hlaWdodD0wXSBUaGUgaGVpZ2h0IG9mIHRoZSByZWN0YW5nbGUuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIGRlc2NyaWJlZCBwb2ludCBvciByZWN0YW5nbGUgaXMgY29udGFpbmVkIHdpdGhpbiB0aGlzIHJlY3RhbmdsZS5cblx0Ki9cblx0Y29udGFpbnMgKHgsIHksIHdpZHRoID0gMCwgaGVpZ2h0ID0gMCkge1xuXHRcdHJldHVybiAoeCA+PSB0aGlzLnggJiYgeCt3aWR0aCA8PSB0aGlzLngrdGhpcy53aWR0aCAmJiB5ID49IHRoaXMueSAmJiB5K2hlaWdodCA8PSB0aGlzLnkrdGhpcy5oZWlnaHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBuZXcgcmVjdGFuZ2xlIHdoaWNoIGNvbnRhaW5zIHRoaXMgcmVjdGFuZ2xlIGFuZCB0aGUgc3BlY2lmaWVkIHJlY3RhbmdsZS5cblx0ICogQHBhcmFtIHtlYXNlbGpzLlJlY3RhbmdsZX0gcmVjdCBUaGUgcmVjdGFuZ2xlIHRvIGNhbGN1bGF0ZSBhIHVuaW9uIHdpdGguXG5cdCAqIEByZXR1cm4ge2Vhc2VsanMuUmVjdGFuZ2xlfSBBIG5ldyByZWN0YW5nbGUgZGVzY3JpYmluZyB0aGUgdW5pb24uXG5cdCovXG5cdHVuaW9uIChyZWN0KSB7XG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5leHRlbmQocmVjdC54LCByZWN0LnksIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgbmV3IHJlY3RhbmdsZSB3aGljaCBkZXNjcmliZXMgdGhlIGludGVyc2VjdGlvbiAob3ZlcmxhcCkgb2YgdGhpcyByZWN0YW5nbGUgYW5kIHRoZSBzcGVjaWZpZWQgcmVjdGFuZ2xlLFxuXHQgKiBvciBudWxsIGlmIHRoZXkgZG8gbm90IGludGVyc2VjdC5cblx0ICogQHBhcmFtIHtlYXNlbGpzLlJlY3RhbmdsZX0gcmVjdCBUaGUgcmVjdGFuZ2xlIHRvIGNhbGN1bGF0ZSBhbiBpbnRlcnNlY3Rpb24gd2l0aC5cblx0ICogQHJldHVybiB7ZWFzZWxqcy5SZWN0YW5nbGV9IEEgbmV3IHJlY3RhbmdsZSBkZXNjcmliaW5nIHRoZSBpbnRlcnNlY3Rpb24gb3IgbnVsbC5cblx0Ki9cblx0aW50ZXJzZWN0aW9uIChyZWN0KSB7XG5cdFx0bGV0IHgxID0gcmVjdC54LCB5MSA9IHJlY3QueSwgeDIgPSB4MStyZWN0LndpZHRoLCB5MiA9IHkxK3JlY3QuaGVpZ2h0O1xuXHRcdGlmICh0aGlzLnggPiB4MSkgeyB4MSA9IHRoaXMueDsgfVxuXHRcdGlmICh0aGlzLnkgPiB5MSkgeyB5MSA9IHRoaXMueTsgfVxuXHRcdGlmICh0aGlzLnggKyB0aGlzLndpZHRoIDwgeDIpIHsgeDIgPSB0aGlzLnggKyB0aGlzLndpZHRoOyB9XG5cdFx0aWYgKHRoaXMueSArIHRoaXMuaGVpZ2h0IDwgeTIpIHsgeTIgPSB0aGlzLnkgKyB0aGlzLmhlaWdodDsgfVxuXHRcdHJldHVybiAoeDIgPD0geDEgfHwgeTIgPD0geTEpID8gbnVsbCA6IG5ldyBSZWN0YW5nbGUoeDEsIHkxLCB4Mi14MSwgeTIteTEpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIHJlY3RhbmdsZSBpbnRlcnNlY3RzIChoYXMgYW55IG92ZXJsYXApIHdpdGggdGhpcyByZWN0YW5nbGUuXG5cdCAqIEBwYXJhbSB7ZWFzZWxqcy5SZWN0YW5nbGV9IHJlY3QgVGhlIHJlY3RhbmdsZSB0byBjb21wYXJlLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSByZWN0YW5nbGVzIGludGVyc2VjdC5cblx0Ki9cblx0aW50ZXJzZWN0cyAocmVjdCkge1xuXHRcdHJldHVybiAocmVjdC54IDw9IHRoaXMueCt0aGlzLndpZHRoICYmIHRoaXMueCA8PSByZWN0LngrcmVjdC53aWR0aCAmJiByZWN0LnkgPD0gdGhpcy55K3RoaXMuaGVpZ2h0ICYmIHRoaXMueSA8PSByZWN0LnkgKyByZWN0LmhlaWdodCk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSB3aWR0aCBvciBoZWlnaHQgYXJlIGVxdWFsIG9yIGxlc3MgdGhhbiAwLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSByZWN0YW5nbGUgaXMgZW1wdHkuXG5cdCovXG5cdGlzRW1wdHkgKCkge1xuXHRcdHJldHVybiB0aGlzLndpZHRoIDw9IDAgfHwgdGhpcy5oZWlnaHQgPD0gMDtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIFJlY3RhbmdsZSBpbnN0YW5jZS5cblx0ICogQHJldHVybiB7ZWFzZWxqcy5SZWN0YW5nbGV9IGEgY2xvbmUgb2YgdGhlIFJlY3RhbmdsZSBpbnN0YW5jZS5cblx0ICovXG5cdGNsb25lICgpIHtcblx0XHRyZXR1cm4gbmV3IFJlY3RhbmdsZSh0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxuXHQgKi9cblx0dG9TdHJpbmcgKCkge1xuXHRcdHJldHVybiBgWyR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfSAoeD0ke3RoaXMueH0geT0ke3RoaXMueX0gd2lkdGg9JHt0aGlzLndpZHRofSBoZWlnaHQ9JHt0aGlzLmhlaWdodH0pXWA7XG5cdH1cblxufVxuIiwiLyoqXG4gKiBAbGljZW5zZSBGaWx0ZXJcbiAqIFZpc2l0IGh0dHA6Ly9jcmVhdGVqcy5jb20vIGZvciBkb2N1bWVudGF0aW9uLCB1cGRhdGVzIGFuZCBleGFtcGxlcy5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgZ3NraW5uZXIuY29tLCBpbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAqIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXG4gKiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXRcbiAqIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxuICogY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuICogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbiAqIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAqIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gKiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcbiAqIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gKiBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuICogSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXG4gKiBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcbiAqIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgdGhhdCBhbGwgZmlsdGVycyBzaG91bGQgaW5oZXJpdCBmcm9tLiBGaWx0ZXJzIG5lZWQgdG8gYmUgYXBwbGllZCB0byBvYmplY3RzIHRoYXQgaGF2ZSBiZWVuIGNhY2hlZCB1c2luZ1xuICogdGhlIHtAbGluayBlYXNlbGpzLkRpc3BsYXlPYmplY3QjY2FjaGV9IG1ldGhvZC4gSWYgYW4gb2JqZWN0IGNoYW5nZXMsIHBsZWFzZSBjYWNoZSBpdCBhZ2Fpbiwgb3IgdXNlXG4gKiB7QGxpbmsgZWFzZWxqcy5EaXNwbGF5T2JqZWN0I3VwZGF0ZUNhY2hlfS4gTm90ZSB0aGF0IHRoZSBmaWx0ZXJzIG11c3QgYmUgYXBwbGllZCBiZWZvcmUgY2FjaGluZy5cbiAqXG4gKiBOb3RlIHRoYXQgZWFjaCBmaWx0ZXIgY2FuIGltcGxlbWVudCBhIHtAbGluayBlYXNlbGpzLkZpbHRlciNnZXRCb3VuZHN9IG1ldGhvZCwgd2hpY2ggcmV0dXJucyB0aGVcbiAqIG1hcmdpbnMgdGhhdCBuZWVkIHRvIGJlIGFwcGxpZWQgaW4gb3JkZXIgdG8gZnVsbHkgZGlzcGxheSB0aGUgZmlsdGVyLiBGb3IgZXhhbXBsZSwgdGhlIHtAbGluayBlYXNlbGpzLkJsdXJGaWx0ZXJ9XG4gKiB3aWxsIGNhdXNlIGFuIG9iamVjdCB0byBmZWF0aGVyIG91dHdhcmRzLCByZXN1bHRpbmcgaW4gYSBtYXJnaW4gYXJvdW5kIHRoZSBzaGFwZS5cbiAqXG4gKiA8aDQ+RWFzZWxKUyBGaWx0ZXJzPC9oND5cbiAqIEVhc2VsSlMgY29tZXMgd2l0aCBhIG51bWJlciBvZiBwcmUtYnVpbHQgZmlsdGVyczpcbiAqIDx1bD5cbiAqICAgPGxpPntAbGluayBlYXNlbGpzLkFscGhhTWFwRmlsdGVyfTogTWFwIGEgZ3JleXNjYWxlIGltYWdlIHRvIHRoZSBhbHBoYSBjaGFubmVsIG9mIGEgZGlzcGxheSBvYmplY3Q8L2xpPlxuICogICA8bGk+e0BsaW5rIGVhc2VsanMuQWxwaGFNYXNrRmlsdGVyfTogTWFwIGFuIGltYWdlJ3MgYWxwaGEgY2hhbm5lbCB0byB0aGUgYWxwaGEgY2hhbm5lbCBvZiBhIGRpc3BsYXkgb2JqZWN0PC9saT5cbiAqICAgPGxpPntAbGluayBlYXNlbGpzLkJsdXJGaWx0ZXJ9OiBBcHBseSB2ZXJ0aWNhbCBhbmQgaG9yaXpvbnRhbCBibHVyIHRvIGEgZGlzcGxheSBvYmplY3Q8L2xpPlxuICogICA8bGk+e0BsaW5rIGVhc2VsanMuQ29sb3JGaWx0ZXJ9OiBDb2xvciB0cmFuc2Zvcm0gYSBkaXNwbGF5IG9iamVjdDwvbGk+XG4gKiAgIDxsaT57QGxpbmsgZWFzZWxqcy5Db2xvck1hdHJpeEZpbHRlcn06IFRyYW5zZm9ybSBhbiBpbWFnZSB1c2luZyBhIHt7I2Nyb3NzTGluayBcIkNvbG9yTWF0cml4XCJ9fXt7L2Nyb3NzTGlua319PC9saT5cbiAqIDwvdWw+XG4gKlxuICogQG1lbWJlcm9mIGVhc2VsanNcbiAqIEBleGFtcGxlXG4gKiBzaGFwZS5maWx0ZXJzID0gW1xuICogICBuZXcgY3JlYXRlanMuQ29sb3JGaWx0ZXIoMCwgMCwgMCwgMSwgMjU1LCAwLCAwKSxcbiAqICAgbmV3IGNyZWF0ZWpzLkJsdXJGaWx0ZXIoNSwgNSwgMTApXG4gKiBdO1xuICogc2hhcGUuY2FjaGUoMCwgMCwgMTAwLCAxMDApO1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGaWx0ZXIge1xuXG5cdGNvbnN0cnVjdG9yICgpIHtcblx0XHQvKipcblx0XHQgKiBBIGZsYWcgc3RhdGluZyB0aGF0IHRoaXMgZmlsdGVyIHVzZXMgYSBjb250ZXh0IGRyYXcgbW9kZSBhbmQgY2Fubm90IGJlIGJhdGNoZWQgaW50byBpbWFnZURhdGEgcHJvY2Vzc2luZy5cblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqL1xuXHRcdHRoaXMudXNlc0NvbnRleHQgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIEFub3RoZXIgZmlsdGVyIHRoYXQgaXMgcmVxdWlyZWQgdG8gYWN0IGFzIHBhcnQgb2YgdGhpcyBmaWx0ZXIgYW5kIGNyZWF0ZWQgYW5kIG1hbmFnZWQgdW5kZXIgdGhlIGhvb2QuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAdHlwZSB7ZWFzZWxqcy5GaWx0ZXJ9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuX211bHRpUGFzcyA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBQcmUtcHJvY2Vzc2luZyBzaGFkZXIgY29kZSwgd2lsbCBiZSBwYXJzZWQgYmVmb3JlIGJlaW5nIGZlZCBpbi5cblx0XHQgKiBUaGlzIHNob3VsZCBiZSBiYXNlZCB1cG9uIFN0YWdlR0wuU0hBREVSX1ZFUlRFWF9CT0RZX1JFR1VMQVJcblx0XHQgKiBAdmlydHVhbFxuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICovXG5cdFx0dGhpcy5WVFhfU0hBREVSX0JPRFkgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogUHJlLXByb2Nlc3Npbmcgc2hhZGVyIGNvZGUsIHdpbGwgYmUgcGFyc2VkIGJlZm9yZSBiZWluZyBmZWQgaW4uXG5cdFx0ICogVGhpcyBzaG91bGQgYmUgYmFzZWQgdXBvbiBTdGFnZUdMLlNIQURFUl9GUkFHTUVOVF9CT0RZX1JFR1VMQVJcblx0XHQgKiBAdmlydHVhbFxuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICovXG5cdFx0dGhpcy5GUkFHX1NIQURFUl9CT0RZID0gbnVsbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBQcm92aWRlcyBwYWRkaW5nIHZhbHVlcyBmb3IgdGhpcyBmaWx0ZXIuIFRoYXQgaXMsIGhvdyBtdWNoIHRoZSBmaWx0ZXIgd2lsbCBleHRlbmQgdGhlIHZpc3VhbCBib3VuZHMgb2YgYW4gb2JqZWN0IGl0IGlzIGFwcGxpZWQgdG8uXG5cdCAqIEBhYnN0cmFjdFxuXHQgKiBAcGFyYW0ge2Vhc2VsanMuUmVjdGFuZ2xlfSBbcmVjdF0gSWYgc3BlY2lmaWVkLCB0aGUgcHJvdmlkZWQgUmVjdGFuZ2xlIGluc3RhbmNlIHdpbGwgYmUgZXhwYW5kZWQgYnkgdGhlIHBhZGRpbmcgYW1vdW50cyBhbmQgcmV0dXJuZWQuXG5cdCAqIEByZXR1cm4ge2Vhc2VsanMuUmVjdGFuZ2xlfSBJZiBhIGByZWN0YCBwYXJhbSB3YXMgcHJvdmlkZWQsIGl0IGlzIHJldHVybmVkLiBJZiBub3QsIGVpdGhlciBhIG5ldyByZWN0YW5nbGUgd2l0aCB0aGUgcGFkZGluZyB2YWx1ZXMsIG9yIG51bGwgaWYgbm8gcGFkZGluZyBpcyByZXF1aXJlZCBmb3IgdGhpcyBmaWx0ZXIuXG5cdCAqL1xuXHRnZXRCb3VuZHMgKHJlY3QpIHsgfVxuXG5cdC8qKlxuXHQgKiBAdmlydHVhbFxuXHQgKiBAYWJzdHJhY3Rcblx0ICogQHBhcmFtIHtXZWJHTENvbnRleHR9IGdsIFRoZSBjb250ZXh0IGFzc29jaWF0ZWQgd2l0aCB0aGUgc3RhZ2UgcGVyZm9ybWluZyB0aGUgcmVuZGVyLlxuXHQgKiBAcGFyYW0ge2Vhc2VsanMuU3RhZ2VHTH0gc3RhZ2UgVGhlIHN0YWdlIGluc3RhbmNlIHRoYXQgd2lsbCBiZSByZW5kZXJpbmcuXG5cdCAqIEBwYXJhbSB7U2hhZGVyUHJvZ3JhbX0gc2hhZGVyUHJvZ3JhbSBUaGUgY29tcGlsZWQgc2hhZGVyIHRoYXQgaXMgZ29pbmcgdG8gYmUgc3VlZCB0byBwZXJmb3JtIHRoZSByZW5kZXIuXG5cdCAqL1xuXHRzaGFkZXJQYXJhbVNldHVwIChnbCwgc3RhZ2UsIHNoYWRlclByb2dyYW0pIHsgfVxuXG5cdC8qKlxuXHQgKiBBcHBsaWVzIHRoZSBmaWx0ZXIgdG8gdGhlIHNwZWNpZmllZCBjb250ZXh0LlxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IFRoZSAyRCBjb250ZXh0IHRvIHVzZSBhcyB0aGUgc291cmNlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgeCBwb3NpdGlvbiB0byB1c2UgZm9yIHRoZSBzb3VyY2UgcmVjdC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHkgcG9zaXRpb24gdG8gdXNlIGZvciB0aGUgc291cmNlIHJlY3QuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCBUaGUgd2lkdGggdG8gdXNlIGZvciB0aGUgc291cmNlIHJlY3QuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgVGhlIGhlaWdodCB0byB1c2UgZm9yIHRoZSBzb3VyY2UgcmVjdC5cblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IFt0YXJnZXRDdHhdIFRoZSAyRCBjb250ZXh0IHRvIGRyYXcgdGhlIHJlc3VsdCB0by4gRGVmYXVsdHMgdG8gdGhlIGNvbnRleHQgcGFzc2VkIHRvIGN0eC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt0YXJnZXRYXSBUaGUgeCBwb3NpdGlvbiB0byBkcmF3IHRoZSByZXN1bHQgdG8uIERlZmF1bHRzIHRvIHRoZSB2YWx1ZSBwYXNzZWQgdG8geC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt0YXJnZXRZXSBUaGUgeSBwb3NpdGlvbiB0byBkcmF3IHRoZSByZXN1bHQgdG8uIERlZmF1bHRzIHRvIHRoZSB2YWx1ZSBwYXNzZWQgdG8geS5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gSWYgdGhlIGZpbHRlciB3YXMgYXBwbGllZCBzdWNjZXNzZnVsbHkuXG5cdCAqL1xuXHRhcHBseUZpbHRlciAoY3R4LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCB0YXJnZXRDdHgsIHRhcmdldFgsIHRhcmdldFkpIHtcblx0XHQvLyB0aGlzIGlzIHRoZSBkZWZhdWx0IGJlaGF2aW91ciBiZWNhdXNlIG1vc3QgZmlsdGVycyBhY2Nlc3MgcGl4ZWwgZGF0YS4gSXQgaXMgb3ZlcnJpZGRlbiB3aGVuIG5vdCBuZWVkZWQuXG5cdFx0dGFyZ2V0Q3R4ID0gdGFyZ2V0Q3R4IHx8IGN0eDtcblx0XHRpZiAodGFyZ2V0WCA9PSBudWxsKSB7IHRhcmdldFggPSB4OyB9XG5cdFx0aWYgKHRhcmdldFkgPT0gbnVsbCkgeyB0YXJnZXRZID0geTsgfVxuXHRcdHRyeSB7XG5cdFx0XHRsZXQgaW1hZ2VEYXRhID0gY3R4LmdldEltYWdlRGF0YSh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcblx0XHRcdGlmICh0aGlzLl9hcHBseUZpbHRlcihpbWFnZURhdGEpKSB7XG5cdFx0XHRcdHRhcmdldEN0eC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCB0YXJnZXRYLCB0YXJnZXRZKTtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZSkge31cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXG5cdCAqL1xuXHR0b1N0cmluZyAoKSB7XG5cdFx0cmV0dXJuIGBbJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9XWA7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIGNsb25lIG9mIHRoaXMgRmlsdGVyIGluc3RhbmNlLlxuXHQgKiBAcmV0dXJuIHtlYXNlbGpzLkZpbHRlcn0gQSBjbG9uZSBvZiB0aGUgY3VycmVudCBGaWx0ZXIgaW5zdGFuY2UuXG5cdCAqL1xuXHRjbG9uZSAoKSB7XG5cdFx0cmV0dXJuIG5ldyBGaWx0ZXIoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAYWJzdHJhY3Rcblx0ICogQHBhcmFtIHtJbWFnZURhdGF9IGltYWdlRGF0YSBUYXJnZXQgSW1hZ2VEYXRhIGluc3RhbmNlLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKi9cblx0X2FwcGx5RmlsdGVyIChpbWFnZURhdGEpIHsgfVxuXG59XG4iLCIvKipcbiAqIEBsaWNlbnNlIEJpdG1hcENhY2hlXG4gKiBWaXNpdCBodHRwOi8vY3JlYXRlanMuY29tLyBmb3IgZG9jdW1lbnRhdGlvbiwgdXBkYXRlcyBhbmQgZXhhbXBsZXMuXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IGdza2lubmVyLmNvbSwgaW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gKiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxuICogZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0XG4gKiByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSxcbiAqIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiAqIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXG4gKiBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gKiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICogRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTXG4gKiBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICogTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcbiAqIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLFxuICogV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4gKiBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SXG4gKiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gKi9cblxuaW1wb3J0IEZpbHRlciBmcm9tIFwiLi9GaWx0ZXJcIjtcbmltcG9ydCBSZWN0YW5nbGUgZnJvbSBcIi4uL2dlb20vUmVjdGFuZ2xlXCI7XG5pbXBvcnQgU3RhZ2VHTCBmcm9tIFwiLi4vZGlzcGxheS9TdGFnZUdMXCI7XG5cbi8qKlxuICogVGhlIEJpdG1hcENhY2hlIGlzIGFuIGludGVybmFsIHJlcHJlc2VudGF0aW9uIG9mIGFsbCB0aGUgY2FjaGUgcHJvcGVydGllcyBhbmQgbG9naWMgcmVxdWlyZWQgaW4gb3JkZXIgdG8gXCJjYWNoZVwiXG4gKiBhbiBvYmplY3QuIFRoaXMgaW5mb3JtYXRpb24gYW5kIGZ1bmN0aW9uYWxpdHkgdXNlZCB0byBiZSBsb2NhdGVkIG9uIGEge0BsaW5rIGVhc2VsanMuRGlzcGxheU9iamVjdCNjYWNoZX1cbiAqIG1ldGhvZCBpbiB7QGxpbmsgZWFzZWxqcy5EaXNwbGF5T2JqZWN0fSwgYnV0IHdhcyBtb3ZlZCB0byBpdHMgb3duIGNsYXNzLlxuICpcbiAqIENhY2hpbmcgaW4gdGhpcyBjb250ZXh0IGlzIHB1cmVseSB2aXN1YWwsIGFuZCB3aWxsIHJlbmRlciB0aGUgRGlzcGxheU9iamVjdCBvdXQgaW50byBhbiBpbWFnZSB0byBiZSB1c2VkIGluc3RlYWRcbiAqIG9mIHRoZSBvYmplY3QuIFRoZSBhY3R1YWwgY2FjaGUgaXRzZWxmIGlzIHN0aWxsIHN0b3JlZCBvbiB0aGUgdGFyZ2V0IHdpdGggdGhlIHtAbGluayBlYXNlbGpzLkRpc3BsYXlPYmplY3QjY2FjaGVDYW52YXN9LlxuICpcbiAqIFdvcmtpbmcgd2l0aCBhIHNpbmd1bGFyIGltYWdlIGxpa2UgYSB7QGxpbmsgZWFzZWxqcy5CaXRtYXB9LCB0aGVyZSBpcyBsaXR0bGUgYmVuZWZpdCB0byBwZXJmb3JtaW5nXG4gKiBhIGNhY2hlIG9wZXJhdGlvbiwgYXMgaXQgaXMgYWxyZWFkeSBhIHNpbmdsZSBpbWFnZS4gQ2FjaGluZyBpcyBiZXN0IGRvbmUgb24gY29udGFpbmVycyB0aGF0IGhhdmUgbXVsdGlwbGUgY29tcGxleFxuICogcGFydHMgdGhhdCBkbyBub3QgY2hhbmdlIG9mdGVuLCBzbyB0aGF0IHJlbmRlcmluZyB0aGUgaW1hZ2Ugd2lsbCBpbXByb3ZlIG92ZXJhbGwgcmVuZGVyaW5nIHNwZWVkLiBBIGNhY2hlZCBvYmplY3RcbiAqIHdpbGwgbm90IHZpc3VhbGx5IHVwZGF0ZSB1bnRpbCBleHBsaWNpdGx5IHRvbGQgdG8gZG8gc28gd2l0aCBhIGNhbGwgdG8ge0BsaW5rIGVhc2VsanMuU3RhZ2UjdXBkYXRlfSxcbiAqIG11Y2ggbGlrZSBhIFN0YWdlLiBJZiBhIGNhY2hlIGlzIGJlaW5nIHVwZGF0ZWQgZXZlcnkgZnJhbWUsIGl0IGlzIGxpa2VseSBub3QgaW1wcm92aW5nIHJlbmRlcmluZyBwZXJmb3JtYW5jZS5cbiAqIENhY2hlcyBhcmUgYmVzdCB1c2VkIHdoZW4gdXBkYXRlcyB3aWxsIGJlIHNwYXJzZS5cbiAqXG4gKiBDYWNoaW5nIGlzIGFsc28gYSBjby1yZXF1aXNpdGUgZm9yIGFwcGx5aW5nIGZpbHRlcnMgdG8gcHJldmVudCBleHBlbnNpdmUgZmlsdGVycyBydW5uaW5nIGNvbnN0YW50bHkgd2l0aG91dCBuZWVkLlxuICogVGhlIEJpdG1hcENhY2hlIGlzIGFsc28gcmVzcG9uc2libGUgZm9yIGFwcGx5aW5nIGZpbHRlcnMgdG8gb2JqZWN0cywgYW5kIHJlYWRzIGVhY2gge0BsaW5rIGVhc2VsanMuRmlsdGVyfS5cbiAqIFJlYWwtdGltZSBGaWx0ZXJzIGFyZSBub3QgcmVjb21tZW5kZWQgd2hlbiBkZWFsaW5nIHdpdGggYSBDb250ZXh0MkQgY2FudmFzIGlmIHBlcmZvcm1hbmNlIGlzIGEgY29uY2Vybi4gRm9yIGJlc3RcbiAqIHBlcmZvcm1hbmNlIGFuZCB0byBzdGlsbCBhbGxvdyBmb3Igc29tZSB2aXN1YWwgZWZmZWN0cywgdXNlIGEge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9jb21wb3NpdGVPcGVyYXRpb246cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cbiAqIHdoZW4gcG9zc2libGUuXG4gKlxuICogQG1lbWJlcm9mIGVhc2VsanNcbiAqIEBleHRlbmRzIGVhc2VsanMuRmlsdGVyXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJpdG1hcENhY2hlIGV4dGVuZHMgRmlsdGVyIHtcblxuXHRjb25zdHJ1Y3RvciAoKSB7XG5cdFx0c3VwZXIoKTtcblxuXHRcdC8qKlxuXHRcdCAqIFdpZHRoIG9mIHRoZSBjYWNoZSByZWxhdGl2ZSB0byB0aGUgdGFyZ2V0IG9iamVjdC5cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcblx0XHQgKi9cblx0XHR0aGlzLndpZHRoID0gdW5kZWZpbmVkO1xuXG5cdFx0LyoqXG5cdFx0ICogSGVpZ2h0IG9mIHRoZSBjYWNoZSByZWxhdGl2ZSB0byB0aGUgdGFyZ2V0IG9iamVjdC5cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcblx0XHQgKi9cblx0XHR0aGlzLmhlaWdodCA9IHVuZGVmaW5lZDtcblxuXHRcdC8qKlxuXHRcdCAqIEhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIGNhY2hlIHJlbGF0aXZlIHRvIHRoZSB0YXJnZXQncyBvcmlnaW4uXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXG5cdFx0ICovXG5cdFx0dGhpcy54ID0gdW5kZWZpbmVkO1xuXG5cdFx0LyoqXG5cdFx0ICogVmVydGljYWwgcG9zaXRpb24gb2YgdGhlIGNhY2hlIHJlbGF0aXZlIHRvIHRhcmdldCdzIG9yaWdpbi5cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcblx0XHQgKi9cblx0XHR0aGlzLnkgPSB1bmRlZmluZWQ7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgaW50ZXJuYWwgc2NhbGUgb2YgdGhlIGNhY2hlIGltYWdlLCBkb2VzIG5vdCBhZmZlY3RzIGRpc3BsYXkgc2l6ZS4gVGhpcyBpcyB1c2VmdWwgdG8gYm90aCBpbmNyZWFzZSBhbmRcblx0XHQgKiBkZWNyZWFzZSByZW5kZXIgcXVhbGl0eS4gT2JqZWN0cyB3aXRoIGluY3JlYXNlZCBzY2FsZXMgYXJlIG1vcmUgbGlrZWx5IHRvIGxvb2sgZ29vZCB3aGVuIHNjYWxlZCB1cC4gT2JqZWN0c1xuXHRcdCAqIHdpdGggZGVjcmVhc2VkIHNjYWxlcyBjYW4gc2F2ZSBvbiByZW5kZXJpbmcgcGVyZm9ybWFuY2UuXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMVxuXHRcdCAqL1xuXHRcdHRoaXMuc2NhbGUgPSAxO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHJlbGF0aXZlIG9mZnNldCBvZiB0aGUge0BsaW5rIGVhc2VsanMuQml0bWFwQ2FjaGUjeH0gcG9zaXRpb24sIHVzZWQgZm9yIGRyYXdpbmdcblx0XHQgKiBpbnRvIHRoZSBjYWNoZSB3aXRoIHRoZSBjb3JyZWN0IG9mZnNldHMuIFJlLWNhbGN1bGF0ZWQgZXZlcnkgdXBkYXRlIGNhbGwgYmVmb3JlIGRyYXdpbmcuXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqL1xuXHRcdHRoaXMub2ZmWCA9IDA7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgcmVsYXRpdmUgb2Zmc2V0IG9mIHRoZSB7QGxpbmsgZWFzZWxqcy5CaXRtYXBDYWNoZSN5fSBwb3NpdGlvbiwgdXNlZCBmb3IgZHJhd2luZ1xuXHRcdCAqIGludG8gdGhlIGNhY2hlIHdpdGggdGhlIGNvcnJlY3Qgb2Zmc2V0cy4gUmUtY2FsY3VsYXRlZCBldmVyeSB1cGRhdGUgY2FsbCBiZWZvcmUgZHJhd2luZy5cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0dGhpcy5vZmZZID0gMDtcblxuXHRcdC8qKlxuXHRcdCAqIFRyYWNrIGhvdyBtYW55IHRpbWVzIHRoZSBjYWNoZSBoYXMgYmVlbiB1cGRhdGVkLCBtb3N0bHkgdXNlZCBmb3IgcHJldmVudGluZyBkdXBsaWNhdGUgY2FjaGVVUkxzLiBUaGlzIGNhbiBiZVxuXHRcdCAqIHVzZWZ1bCB0byBzZWUgaWYgYSBjYWNoZSBoYXMgYmVlbiB1cGRhdGVkLlxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqL1xuXHRcdHRoaXMuY2FjaGVJRCA9IDA7XG5cblx0XHQvKipcblx0XHQgKiBSZWxhdGl2ZSBvZmZzZXQgb2YgdGhlIHggcG9zaXRpb24sIHVzZWQgZm9yIGRyYXdpbmcgdGhlIGNhY2hlIGludG8gb3RoZXIgc2NlbmVzLlxuXHRcdCAqIFJlLWNhbGN1bGF0ZWQgZXZlcnkgdXBkYXRlIGNhbGwgYmVmb3JlIGRyYXdpbmcuXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqIEB0b2RvIElzIHRoaXMgZGVzY3JpcHRpb24gcmlnaHQ/IEl0cyB0aGUgc2FtZSBhcyBvZmZYLlxuXHRcdCAqL1xuXHRcdHRoaXMuX2ZpbHRlck9mZlggPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogUmVsYXRpdmUgb2Zmc2V0IG9mIHRoZSB5IHBvc2l0aW9uLCB1c2VkIGZvciBkcmF3aW5nIGludG8gdGhlIGNhY2hlIGludG8gb3RoZXIgc2NlbmVzLlxuXHRcdCAqIFJlLWNhbGN1bGF0ZWQgZXZlcnkgdXBkYXRlIGNhbGwgYmVmb3JlIGRyYXdpbmcuXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqIEB0b2RvIElzIHRoaXMgZGVzY3JpcHRpb24gcmlnaHQ/IEl0cyB0aGUgc2FtZSBhcyBvZmZZLlxuXHRcdCAqL1xuXHRcdHRoaXMuX2ZpbHRlck9mZlkgPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGNhY2hlSUQgd2hlbiBhIERhdGFVUkwgd2FzIHJlcXVlc3RlZC5cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0dGhpcy5fY2FjaGVEYXRhVVJMSUQgPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGNhY2hlJ3MgRGF0YVVSTCwgZ2VuZXJhdGVkIG9uLWRlbWFuZCB1c2luZyB0aGUgZ2V0dGVyLlxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLl9jYWNoZURhdGFVUkwgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogSW50ZXJuYWwgdHJhY2tpbmcgb2YgZmluYWwgYm91bmRpbmcgd2lkdGgsIGFwcHJveGltYXRlbHkgYHdpZHRoKnNjYWxlO2AgaG93ZXZlciwgZmlsdGVycyBjYW4gY29tcGxpY2F0ZSB0aGUgYWN0dWFsIHZhbHVlLlxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKi9cblx0XHR0aGlzLl9kcmF3V2lkdGggPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogSW50ZXJuYWwgdHJhY2tpbmcgb2YgZmluYWwgYm91bmRpbmcgaGVpZ2h0LCBhcHByb3hpbWF0ZWx5IGBoZWlnaHQqc2NhbGU7YCBob3dldmVyLCBmaWx0ZXJzIGNhbiBjb21wbGljYXRlIHRoZSBhY3R1YWwgdmFsdWUuXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqL1xuXHRcdHRoaXMuX2RyYXdIZWlnaHQgPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogSW50ZXJuYWwgdHJhY2tpbmcgb2YgdGhlIGxhc3QgcmVxdWVzdGVkIGJvdW5kcywgbWF5IGhhcHBlbiByZXBlYWR0ZWRseSBzbyBzdG9yZWQgdG8gYXZvaWQgb2JqZWN0IGNyZWF0aW9uLlxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7ZWFzZWxqcy5SZWN0YW5nbGV9XG5cdFx0ICogQGRlZmF1bHQgZWFzZWxqcy5SZWN0YW5nbGVcblx0XHQgKi9cblx0XHR0aGlzLl9ib3VuZFJlY3QgPSBuZXcgUmVjdGFuZ2xlKCk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBib3VuZHMgdGhhdCBzdXJyb3VuZCBhbGwgYXBwbGllZCBmaWx0ZXJzLiBUaGlzIHJlbGllcyBvbiBlYWNoIGZpbHRlciB0byBkZXNjcmliZSBob3cgaXQgY2hhbmdlcyBib3VuZHMuXG5cdCAqIEBwYXJhbSB7ZWFzZWxqcy5EaXNwbGF5T2JqZWN0fSB0YXJnZXQgVGhlIG9iamVjdCB0byBjaGVjayB0aGUgZmlsdGVyIGJvdW5kcyBmb3IuXG5cdCAqIEBwYXJhbSB7ZWFzZWxqcy5SZWN0YW5nbGV9IFtvdXRwdXRdIENhbGN1bGF0ZWQgYm91bmRzIHdpbGwgYmUgYXBwbGllZCB0byB0aGlzIHJlY3QuXG5cdCAqIEByZXR1cm4ge2Vhc2VsanMuUmVjdGFuZ2xlfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgZ2V0RmlsdGVyQm91bmRzICh0YXJnZXQsIG91dHB1dCA9IG5ldyBSZWN0YW5nbGUoKSkge1xuXHRcdGxldCBmaWx0ZXJzID0gdGFyZ2V0LmZpbHRlcnM7XG5cdFx0bGV0IGZpbHRlckNvdW50ID0gZmlsdGVycyAmJiBmaWx0ZXJzLmxlbmd0aDtcblx0XHRpZiAoISFmaWx0ZXJDb3VudCA8PSAwKSB7IHJldHVybiBvdXRwdXQ7IH1cblxuXHRcdGZvciAobGV0IGk9MDsgaTxmaWx0ZXJDb3VudDsgaSsrKSB7XG5cdFx0XHRsZXQgZiA9IGZpbHRlcnNbaV07XG5cdFx0XHRpZiAoIWYgfHwgIWYuZ2V0Qm91bmRzKSB7IGNvbnRpbnVlOyB9XG5cdFx0XHRsZXQgdGVzdCA9IGYuZ2V0Qm91bmRzKCk7XG5cdFx0XHRpZiAoIXRlc3QpIHsgY29udGludWU7IH1cblx0XHRcdGlmIChpPT0wKSB7XG5cdFx0XHRcdG91dHB1dC5zZXRWYWx1ZXModGVzdC54LCB0ZXN0LnksIHRlc3Qud2lkdGgsIHRlc3QuaGVpZ2h0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dHB1dC5leHRlbmQodGVzdC54LCB0ZXN0LnksIHRlc3Qud2lkdGgsIHRlc3QuaGVpZ2h0KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0LyoqXG5cdCAqIERpcmVjdGx5IGNhbGxlZCB2aWEge0BsaW5rIGVhc2VsanMuRGlzcGxheU9iamVjdCNjYWNoZX0uIENyZWF0ZXMgYW5kIHNldHMgcHJvcGVydGllcyBuZWVkZWRcblx0ICogZm9yIGEgY2FjaGUgdG8gZnVuY3Rpb24sIGFuZCBwZXJmb3JtcyB0aGUgaW5pdGlhbCB1cGRhdGUuXG5cdCAqIEBwYXJhbSB7ZWFzZWxqcy5EaXNwbGF5T2JqZWN0fSB0YXJnZXQgVGhlIERpc3BsYXlPYmplY3QgdGhpcyBjYWNoZSBpcyBsaW5rZWQgdG8uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbeD0wXSBUaGUgeCBjb29yZGluYXRlIG9yaWdpbiBmb3IgdGhlIGNhY2hlIHJlZ2lvbi5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt5PTBdIFRoZSB5IGNvb3JkaW5hdGUgb3JpZ2luIGZvciB0aGUgY2FjaGUgcmVnaW9uLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3dpZHRoPTFdIFRoZSB3aWR0aCBvZiB0aGUgY2FjaGUgcmVnaW9uLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2hlaWdodD0xXSBUaGUgaGVpZ2h0IG9mIHRoZSBjYWNoZSByZWdpb24uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGU9MV0gVGhlIHNjYWxlIGF0IHdoaWNoIHRoZSBjYWNoZSB3aWxsIGJlIGNyZWF0ZWQuIEZvciBleGFtcGxlLCBpZiB5b3UgY2FjaGUgYSB2ZWN0b3Igc2hhcGVcblx0ICogdXNpbmcgYG15U2hhcGUuY2FjaGUoMCwwLDEwMCwxMDAsMilgLCB0aGVuIHRoZSByZXN1bHRpbmcgY2FjaGVDYW52YXMgd2lsbCBiZSAyMDB4MjAwIHBpeGVscy4gVGhpcyBsZXRzIHlvdSBzY2FsZVxuXHQgKiBhbmQgcm90YXRlIGNhY2hlZCBlbGVtZW50cyB3aXRoIGdyZWF0ZXIgZmlkZWxpdHkuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gV2hlbiB1c2luZyB0aGluZ3MgbGlrZSB7QGxpbmsgZWFzZWxqcy5TdGFnZUdMfSB0aGVyZSBtYXkgYmVcblx0ICogZXh0cmEgY2FjaGluZyBvcHBvcnR1bml0aWVzIG9yIHJlcXVpcmVtZW50cy5cblx0ICovXG5cdGRlZmluZSAodGFyZ2V0LCB4ID0gMCwgeSA9IDAsIHdpZHRoID0gMSwgaGVpZ2h0ID0gMSwgc2NhbGUgPSAxLCBvcHRpb25zKSB7XG5cdFx0aWYgKCF0YXJnZXQpIHsgdGhyb3cgXCJObyBzeW1ib2wgdG8gY2FjaGVcIjsgfVxuXHRcdHRoaXMuX29wdGlvbnMgPSBvcHRpb25zO1xuXHRcdHRoaXMuX3VzZVdlYkdMID0gb3B0aW9ucyAhPT0gdW5kZWZpbmVkO1xuXHRcdHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuXG5cdFx0dGhpcy53aWR0aCA9IHdpZHRoID49IDEgPyB3aWR0aCA6IDE7XG5cdFx0dGhpcy5oZWlnaHQgPSBoZWlnaHQgPj0gMSA/IGhlaWdodCA6IDE7XG5cdFx0dGhpcy54ID0geDtcblx0XHR0aGlzLnkgPSB5O1xuXHRcdHRoaXMuc2NhbGUgPSBzY2FsZTtcblxuXHRcdHRoaXMudXBkYXRlKCk7XG5cdH1cblxuXHQvKipcblx0ICogRGlyZWN0bHkgY2FsbGVkIHZpYSB7QGxpbmsgZWFzZWxqcy5EaXNwbGF5T2JqZWN0I3VwZGF0ZUNhY2hlfSwgYnV0IGFsc28gaW50ZXJuYWxseS4gVGhpc1xuXHQgKiBoYXMgdGhlIGR1YWwgcmVzcG9uc2liaWxpdHkgb2YgbWFraW5nIHN1cmUgdGhlIHN1cmZhY2UgaXMgcmVhZHkgdG8gYmUgZHJhd24gdG8sIGFuZCBwZXJmb3JtaW5nIHRoZSBkcmF3LiBGb3Jcblx0ICogZnVsbCBkZXRhaWxzIG9mIGVhY2ggYmVoYXZpb3VyLCBjaGVjayB0aGUgcHJvdGVjdGVkIGZ1bmN0aW9ucyB7QGxpbmsgZWFzZWxqcy5CaXRtYXBDYWNoZSNfdXBkYXRlU3VyZmFjZX1cblx0ICogYW5kIHtAbGluayBlYXNlbGpzLkJpdG1hcENhY2hlI19kcmF3VG9DYWNoZX0gcmVzcGVjdGl2ZWx5LlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW2NvbXBvc2l0ZU9wZXJhdGlvbl0gVGhlIERpc3BsYXlPYmplY3QgdGhpcyBjYWNoZSBpcyBsaW5rZWQgdG8uXG5cdCAqL1xuXHR1cGRhdGUgKGNvbXBvc2l0ZU9wZXJhdGlvbikge1xuXHRcdGlmICghdGhpcy50YXJnZXQpIHsgdGhyb3cgXCJkZWZpbmUoKSBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgdXBkYXRlKClcIjsgfVxuXG5cdFx0bGV0IGZpbHRlckJvdW5kcyA9IEJpdG1hcENhY2hlLmdldEZpbHRlckJvdW5kcyh0aGlzLnRhcmdldCk7XG5cdFx0bGV0IHN1cmZhY2UgPSB0aGlzLnRhcmdldC5jYWNoZUNhbnZhcztcblxuXHRcdHRoaXMuX2RyYXdXaWR0aCA9IE1hdGguY2VpbCh0aGlzLndpZHRoKnRoaXMuc2NhbGUpICsgZmlsdGVyQm91bmRzLndpZHRoO1xuXHRcdHRoaXMuX2RyYXdIZWlnaHQgPSBNYXRoLmNlaWwodGhpcy5oZWlnaHQqdGhpcy5zY2FsZSkgKyBmaWx0ZXJCb3VuZHMuaGVpZ2h0O1xuXG5cdFx0aWYgKCFzdXJmYWNlIHx8IHRoaXMuX2RyYXdXaWR0aCAhPSBzdXJmYWNlLndpZHRoIHx8IHRoaXMuX2RyYXdIZWlnaHQgIT0gc3VyZmFjZS5oZWlnaHQpIHtcblx0XHRcdHRoaXMuX3VwZGF0ZVN1cmZhY2UoKTtcblx0XHR9XG5cblx0XHR0aGlzLl9maWx0ZXJPZmZYID0gZmlsdGVyQm91bmRzLng7XG5cdFx0dGhpcy5fZmlsdGVyT2ZmWSA9IGZpbHRlckJvdW5kcy55O1xuXHRcdHRoaXMub2ZmWCA9IHRoaXMueCp0aGlzLnNjYWxlICsgdGhpcy5fZmlsdGVyT2ZmWDtcblx0XHR0aGlzLm9mZlkgPSB0aGlzLnkqdGhpcy5zY2FsZSArIHRoaXMuX2ZpbHRlck9mZlk7XG5cblx0XHR0aGlzLl9kcmF3VG9DYWNoZShjb21wb3NpdGVPcGVyYXRpb24pO1xuXG5cdFx0dGhpcy5jYWNoZUlEID0gdGhpcy5jYWNoZUlEP3RoaXMuY2FjaGVJRCsxOjE7XG5cdH1cblxuXHQvKipcblx0ICogUmVzZXQgYW5kIHJlbGVhc2UgYWxsIHRoZSBwcm9wZXJ0aWVzIGFuZCBtZW1vcnkgYXNzb2NpYXRlZCB3aXRoIHRoaXMgY2FjaGUuXG5cdCAqL1xuXHRyZWxlYXNlICgpIHtcblx0XHRsZXQgc3RhZ2UgPSB0aGlzLnRhcmdldC5zdGFnZTtcblx0XHRpZiAodGhpcy5fdXNlV2ViR0wgJiYgdGhpcy5fd2ViR0xDYWNoZSkge1xuXHRcdFx0Ly8gaWYgaXQgaXNuJ3QgY2FjaGUgY29udHJvbGxlZCBjbGVhbiB1cCBhZnRlciB5b3Vyc2VsZlxuXHRcdFx0aWYgKCF0aGlzLl93ZWJHTENhY2hlLmlzQ2FjaGVDb250cm9sbGVkKSB7XG5cdFx0XHRcdGlmICh0aGlzLl9fbGFzdFJUKSB7IHRoaXMuX19sYXN0UlQgPSB1bmRlZmluZWQ7IH1cblx0XHRcdFx0aWYgKHRoaXMuX19ydEEpIHsgdGhpcy5fd2ViR0xDYWNoZS5fa2lsbFRleHR1cmVPYmplY3QodGhpcy5fX3J0QSk7IH1cblx0XHRcdFx0aWYgKHRoaXMuX19ydEIpIHsgdGhpcy5fd2ViR0xDYWNoZS5fa2lsbFRleHR1cmVPYmplY3QodGhpcy5fX3J0Qik7IH1cblx0XHRcdFx0aWYgKHRoaXMudGFyZ2V0ICYmIHRoaXMudGFyZ2V0LmNhY2hlQ2FudmFzKSB7IHRoaXMuX3dlYkdMQ2FjaGUuX2tpbGxUZXh0dXJlT2JqZWN0KHRoaXMudGFyZ2V0LmNhY2hlQ2FudmFzKTsgfVxuXHRcdFx0fVxuXHRcdFx0Ly8gc2V0IHRoZSBjb250ZXh0IHRvIG5vbmUgYW5kIGxldCB0aGUgZ2FyYmFnZSBjb2xsZWN0b3IgZ2V0IHRoZSByZXN0IHdoZW4gdGhlIGNhbnZhcyBpdHNlbGYgZ2V0cyByZW1vdmVkXG5cdFx0XHR0aGlzLl93ZWJHTENhY2hlID0gZmFsc2U7XG5cdFx0fSBlbHNlIGlmIChzdGFnZSBpbnN0YW5jZW9mIFN0YWdlR0wpIHtcblx0XHRcdHN0YWdlLnJlbGVhc2VUZXh0dXJlKHRoaXMudGFyZ2V0LmNhY2hlQ2FudmFzKTtcblx0XHR9XG5cdFx0dGhpcy50YXJnZXQgPSB0aGlzLnRhcmdldC5jYWNoZUNhbnZhcyA9IG51bGw7XG5cdFx0dGhpcy5jYWNoZUlEID0gdGhpcy5fY2FjaGVEYXRhVVJMSUQgPSB0aGlzLl9jYWNoZURhdGFVUkwgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy53aWR0aCA9IHRoaXMuaGVpZ2h0ID0gdGhpcy54ID0gdGhpcy55ID0gdGhpcy5vZmZYID0gdGhpcy5vZmZZID0gMDtcblx0XHR0aGlzLnNjYWxlID0gMTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgZGF0YSBVUkwgZm9yIHRoZSBjYWNoZSwgb3IgYG51bGxgIGlmIHRoaXMgZGlzcGxheSBvYmplY3QgaXMgbm90IGNhY2hlZC5cblx0ICogVXNlcyB7QGxpbmsgZWFzZWxqcy5CaXRtYXBDYWNoZSNjYWNoZUlEfSB0byBlbnN1cmUgYSBuZXcgZGF0YSBVUkwgaXMgbm90IGdlbmVyYXRlZCBpZiB0aGVcblx0ICogY2FjaGUgaGFzIG5vdCBjaGFuZ2VkLlxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBpbWFnZSBkYXRhIHVybCBmb3IgdGhlIGNhY2hlLlxuXHQgKi9cblx0Z2V0Q2FjaGVEYXRhVVJMICgpIHtcblx0XHRsZXQgY2FjaGVDYW52YXMgPSB0aGlzLnRhcmdldCAmJiB0aGlzLnRhcmdldC5jYWNoZUNhbnZhcztcblx0XHRpZiAoIWNhY2hlQ2FudmFzKSB7IHJldHVybiBudWxsOyB9XG5cdFx0aWYgKHRoaXMuY2FjaGVJRCAhPSB0aGlzLl9jYWNoZURhdGFVUkxJRCkge1xuXHRcdFx0dGhpcy5fY2FjaGVEYXRhVVJMSUQgPSB0aGlzLmNhY2hlSUQ7XG5cdFx0XHR0aGlzLl9jYWNoZURhdGFVUkwgPSBjYWNoZUNhbnZhcy50b0RhdGFVUkw/Y2FjaGVDYW52YXMudG9EYXRhVVJMKCk6bnVsbDtcdC8vIGluY2FzZSBmdW5jdGlvbiBpc1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fY2FjaGVEYXRhVVJMO1xuXHR9XG5cblx0LyoqXG5cdCAqIFVzZSBjb250ZXh0MkQgZHJhd2luZyBjb21tYW5kcyB0byBkaXNwbGF5IHRoZSBjYWNoZSBjYW52YXMgYmVpbmcgdXNlZC5cblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBUaGUgY29udGV4dCB0byBkcmF3IGludG8uXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgdGhlIGRyYXcgd2FzIGhhbmRsZWQgc3VjY2Vzc2Z1bGx5LlxuXHQgKi9cblx0ZHJhdyAoY3R4KSB7XG5cdFx0aWYgKCF0aGlzLnRhcmdldCkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRjdHguZHJhd0ltYWdlKFxuXHRcdFx0dGhpcy50YXJnZXQuY2FjaGVDYW52YXMsXG5cdFx0XHR0aGlzLnggKyAodGhpcy5fZmlsdGVyT2ZmWC90aGlzLnNjYWxlKSxcblx0XHRcdHRoaXMueSArICh0aGlzLl9maWx0ZXJPZmZZL3RoaXMuc2NhbGUpLFxuXHRcdFx0dGhpcy5fZHJhd1dpZHRoL3RoaXMuc2NhbGUsXG5cdFx0XHR0aGlzLl9kcmF3SGVpZ2h0L3RoaXMuc2NhbGVcblx0XHQpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIERldGVybWluZSB0aGUgYm91bmRzIG9mIHRoZSBzaGFwZSBpbiBsb2NhbCBzcGFjZS5cblx0ICogQHJldHVybnMge2Vhc2VsanMuUmVjdGFuZ2xlfVxuXHQgKi9cblx0Z2V0Qm91bmRzICgpIHtcblx0XHRjb25zdCBzY2FsZSA9IHRoaXMuc2NhbGU7XG5cdFx0cmV0dXJuIHRoaXMuX2JvdW5kUmVjdC5zZXRWYWx1ZShcblx0XHRcdHRoaXMuX2ZpbHRlck9mZlgvc2NhbGUsXG5cdFx0XHR0aGlzLl9maWx0ZXJPZmZZL3NjYWxlLFxuXHRcdFx0dGhpcy53aWR0aC9zY2FsZSxcblx0XHRcdHRoaXMuaGVpZ2h0L3NjYWxlXG5cdFx0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCYXNpYyBjb250ZXh0MkQgY2FjaGluZyB3b3JrcyBieSBjcmVhdGluZyBhIG5ldyBjYW52YXMgZWxlbWVudCBhbmQgc2V0dGluZyBpdHMgcGh5c2ljYWwgc2l6ZS4gVGhpcyBmdW5jdGlvbiB3aWxsXG5cdCAqIGNyZWF0ZSBhbmQgb3Igc2l6ZSB0aGUgY2FudmFzIGFzIG5lZWRlZC5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0X3VwZGF0ZVN1cmZhY2UgKCkge1xuXHRcdGxldCBzdXJmYWNlO1xuXHRcdGlmICghdGhpcy5fdXNlV2ViR0wpIHtcblx0XHRcdHN1cmZhY2UgPSB0aGlzLnRhcmdldC5jYWNoZUNhbnZhcztcblx0XHRcdC8vIGNyZWF0ZSBpdCBpZiBpdCdzIG1pc3Npbmdcblx0XHRcdGlmICghc3VyZmFjZSkge1xuXHRcdFx0XHRzdXJmYWNlID0gdGhpcy50YXJnZXQuY2FjaGVDYW52YXMgPSB3aW5kb3cuY3JlYXRlanMmJmNyZWF0ZWpzLmNyZWF0ZUNhbnZhcz9jcmVhdGVqcy5jcmVhdGVDYW52YXMoKTpkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gbm93IHNpemUgaXRcblx0XHRcdHN1cmZhY2Uud2lkdGggPSB0aGlzLl9kcmF3V2lkdGg7XG5cdFx0XHRzdXJmYWNlLmhlaWdodCA9IHRoaXMuX2RyYXdIZWlnaHQ7XG5cdFx0XHQvLyBza2lwIHRoZSB3ZWJnbC1vbmx5IHVwZGF0ZXNcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBjcmVhdGUgaXQgaWYgaXQncyBtaXNzaW5nXG5cdFx0aWYgKCF0aGlzLl93ZWJHTENhY2hlKSB7XG5cdFx0XHRpZiAodGhpcy5fb3B0aW9ucy51c2VHTCA9PT0gXCJzdGFnZVwiKSB7XG5cdFx0XHRcdGlmKCEodGhpcy50YXJnZXQuc3RhZ2UgIT0gbnVsbCAmJiB0aGlzLnRhcmdldC5zdGFnZS5pc1dlYkdMKSkge1xuXHRcdFx0XHRcdHRocm93IGBDYW5ub3QgdXNlICdzdGFnZScgZm9yIGNhY2hlIGJlY2F1c2UgdGhlIG9iamVjdCdzIHBhcmVudCBzdGFnZSBpcyAke3RoaXMudGFyZ2V0LnN0YWdlICE9IG51bGwgPyBcIm5vbiBXZWJHTC5cIiA6IFwibm90IHNldCwgcGxlYXNlIGFkZENoaWxkIHRvIHRoZSBjb3JyZWN0IHN0YWdlLlwifWA7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy50YXJnZXQuY2FjaGVDYW52YXMgPSB0cnVlOyAvLyB3aWxsIGJlIHJlcGxhY2VkIHdpdGggUmVuZGVyVGV4dHVyZSwgdGVtcG9yYXJ5IHBvc2l0aXZlIHZhbHVlIGZvciBvbGQgXCJpc0NhY2hlZFwiIGNoZWNrc1xuXHRcdFx0XHR0aGlzLl93ZWJHTENhY2hlID0gdGhpcy50YXJnZXQuc3RhZ2U7XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMuX29wdGlvbnMudXNlR0wgPT09IFwibmV3XCIpIHtcblx0XHRcdFx0dGhpcy50YXJnZXQuY2FjaGVDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpOyAvLyB3ZSBjYW4gdHVybiBvZmYgYXV0b3B1cmdlIGJlY2F1c2Ugd2Ugd29udCBiZSBtYWtpbmcgdGV4dHVyZXMgaGVyZVxuXHRcdFx0XHR0aGlzLl93ZWJHTENhY2hlID0gbmV3IFN0YWdlR0wodGhpcy50YXJnZXQuY2FjaGVDYW52YXMsIHthbnRpYWxpYXM6IHRydWUsIHRyYW5zcGFyZW50OiB0cnVlLCBhdXRvUHVyZ2U6IC0xfSk7XG5cdFx0XHRcdHRoaXMuX3dlYkdMQ2FjaGUuaXNDYWNoZUNvbnRyb2xsZWQgPSB0cnVlOyAgICAvLyB1c2UgdGhpcyBmbGFnIHRvIGNvbnRyb2wgc3RhZ2Ugc2l6aW5nIGFuZCBmaW5hbCBvdXRwdXRcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IFwiSW52YWxpZCBvcHRpb24gcHJvdmlkZWQgdG8gdXNlR0wsIGV4cGVjdGVkIFsnc3RhZ2UnLCAnbmV3JywgU3RhZ2VHTCwgdW5kZWZpbmVkXSwgZ290IFwiKyB0aGlzLl9vcHRpb25zLnVzZUdMO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIG5vdyBzaXplIHJlbmRlciBzdXJmYWNlc1xuXHRcdGxldCBzdGFnZUdMID0gdGhpcy5fd2ViR0xDYWNoZTtcblx0XHRzdXJmYWNlID0gdGhpcy50YXJnZXQuY2FjaGVDYW52YXM7XG5cblx0XHQvLyBpZiB3ZSBoYXZlIGEgZGVkaWNhdGVkIHN0YWdlIHdlJ3ZlIGdvdHRhIHNpemUgaXRcblx0XHRpZiAoc3RhZ2VHTC5pc0NhY2hlQ29udHJvbGxlZCkge1xuXHRcdFx0c3VyZmFjZS53aWR0aCA9IHRoaXMuX2RyYXdXaWR0aDtcblx0XHRcdHN1cmZhY2UuaGVpZ2h0ID0gdGhpcy5fZHJhd0hlaWdodDtcblx0XHRcdHN0YWdlR0wudXBkYXRlVmlld3BvcnQodGhpcy5fZHJhd1dpZHRoLCB0aGlzLl9kcmF3SGVpZ2h0KTtcblx0XHR9XG5cdFx0aWYgKHRoaXMudGFyZ2V0LmZpbHRlcnMpIHtcblx0XHRcdC8vIHdpdGggZmlsdGVycyB3ZSBjYW4ndCB0ZWxsIGhvdyBtYW55IHdlJ2xsIG5lZWQgYnV0IHRoZSBtb3N0IHdlJ2xsIGV2ZXIgbmVlZCBpcyB0d28sIHNvIG1ha2UgdGhlbSBub3dcblx0XHRcdHN0YWdlR0wuZ2V0VGFyZ2V0UmVuZGVyVGV4dHVyZSh0aGlzLnRhcmdldCwgdGhpcy5fZHJhd1dpZHRoLHRoaXMuX2RyYXdIZWlnaHQpO1xuXHRcdFx0c3RhZ2VHTC5nZXRUYXJnZXRSZW5kZXJUZXh0dXJlKHRoaXMudGFyZ2V0LCB0aGlzLl9kcmF3V2lkdGgsdGhpcy5fZHJhd0hlaWdodCk7XG5cdFx0fSBlbHNlIGlmICghc3RhZ2VHTC5pc0NhY2hlQ29udHJvbGxlZCkge1xuXHRcdFx0Ly8gd2l0aG91dCBmaWx0ZXJzIHRoZW4gd2Ugb25seSBuZWVkIG9uZSBSZW5kZXJUZXh0dXJlLCBhbmQgdGhhdCdzIG9ubHkgaWYgaXRzIG5vdCBhIGRlZGljYXRlZCBzdGFnZVxuXHRcdFx0c3RhZ2VHTC5nZXRUYXJnZXRSZW5kZXJUZXh0dXJlKHRoaXMudGFyZ2V0LCB0aGlzLl9kcmF3V2lkdGgsdGhpcy5fZHJhd0hlaWdodCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFBlcmZvcm0gdGhlIGNhY2hlIGRyYXcgb3V0IGZvciBjb250ZXh0IDJEIG5vdyB0aGF0IHRoZSBzZXR1cCBwcm9wZXJ0aWVzIGhhdmUgYmVlbiBwZXJmb3JtZWQuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdF9kcmF3VG9DYWNoZSAoY29tcG9zaXRlT3BlcmF0aW9uKSB7XG5cdFx0bGV0IHRhcmdldCA9IHRoaXMudGFyZ2V0O1xuXHRcdGxldCBzdXJmYWNlID0gdGFyZ2V0LmNhY2hlQ2FudmFzO1xuXHRcdGxldCB3ZWJHTCA9IHRoaXMuX3dlYkdMQ2FjaGU7XG5cblx0XHRpZiAoIXRoaXMuX3VzZVdlYkdMIHx8ICF3ZWJHTCkge1xuXHRcdFx0bGV0IGN0eCA9IHN1cmZhY2UuZ2V0Q29udGV4dChcIjJkXCIpO1xuXG5cdFx0XHRpZiAoIWNvbXBvc2l0ZU9wZXJhdGlvbikge1xuXHRcdFx0XHRjdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuX2RyYXdXaWR0aCsxLCB0aGlzLl9kcmF3SGVpZ2h0KzEpO1xuXHRcdFx0fVxuXG5cdFx0XHRjdHguc2F2ZSgpO1xuXHRcdFx0Y3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IGNvbXBvc2l0ZU9wZXJhdGlvbjtcblx0XHRcdGN0eC5zZXRUcmFuc2Zvcm0odGhpcy5zY2FsZSwwLDAsdGhpcy5zY2FsZSwgLXRoaXMuX2ZpbHRlck9mZlgsLXRoaXMuX2ZpbHRlck9mZlkpO1xuXHRcdFx0Y3R4LnRyYW5zbGF0ZSgtdGhpcy54LCAtdGhpcy55KTtcblx0XHRcdHRhcmdldC5kcmF3KGN0eCwgdHJ1ZSk7XG5cdFx0XHRjdHgucmVzdG9yZSgpO1xuXG5cdFx0XHRpZiAodGFyZ2V0LmZpbHRlcnMgJiYgdGFyZ2V0LmZpbHRlcnMubGVuZ3RoKSB7XG5cdFx0XHRcdHRoaXMuX2FwcGx5RmlsdGVycyh0YXJnZXQpO1xuXHRcdFx0fVxuXHRcdFx0c3VyZmFjZS5faW52YWxpZCA9IHRydWU7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5fd2ViR0xDYWNoZS5jYWNoZURyYXcodGFyZ2V0LCB0YXJnZXQuZmlsdGVycywgdGhpcyk7XG5cdFx0Ly8gTk9URTogd2UgbWF5IG9mIHN3YXBwZWQgYXJvdW5kIHdoaWNoIGVsZW1lbnQgdGhlIHN1cmZhY2UgaXMsIHNvIHdlIHJlLWZldGNoIGl0XG5cdFx0c3VyZmFjZSA9IHRoaXMudGFyZ2V0LmNhY2hlQ2FudmFzO1xuXHRcdHN1cmZhY2Uud2lkdGggPSB0aGlzLl9kcmF3V2lkdGg7XG5cdFx0c3VyZmFjZS5oZWlnaHQgPSB0aGlzLl9kcmF3SGVpZ2h0O1xuXHRcdHN1cmZhY2UuX2ludmFsaWQgPSB0cnVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIFdvcmsgdGhyb3VnaCBldmVyeSBmaWx0ZXIgYW5kIGFwcGx5IGl0cyBpbmRpdmlkdWFsIHRyYW5zZm9ybWF0aW9uIHRvIGl0LlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRfYXBwbHlGaWx0ZXJzICgpIHtcblx0XHRsZXQgc3VyZmFjZSA9IHRoaXMudGFyZ2V0LmNhY2hlQ2FudmFzO1xuXHRcdGxldCBmaWx0ZXJzID0gdGhpcy50YXJnZXQuZmlsdGVycztcblxuXHRcdGxldCB3ID0gdGhpcy5fZHJhd1dpZHRoO1xuXHRcdGxldCBoID0gdGhpcy5fZHJhd0hlaWdodDtcblxuXHRcdC8vIHNldHVwXG5cdFx0bGV0IGRhdGEgPSBzdXJmYWNlLmdldENvbnRleHQoXCIyZFwiKS5nZXRJbWFnZURhdGEoMCwwLCB3LGgpO1xuXG5cdFx0Ly8gYXBwbHlcblx0XHRsZXQgbCA9IGZpbHRlcnMubGVuZ3RoO1xuXHRcdGZvciAobGV0IGk9MDsgaTxsOyBpKyspIHtcblx0XHRcdGZpbHRlcnNbaV0uX2FwcGx5RmlsdGVyKGRhdGEpO1xuXHRcdH1cblxuXHRcdC8vZG9uZVxuXHRcdHN1cmZhY2UuZ2V0Q29udGV4dChcIjJkXCIpLnB1dEltYWdlRGF0YShkYXRhLCAwLDApO1xuXHR9XG5cbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsaXR5IGluamVjdGVkIHRvIHtAbGluayBlYXNlbGpzLkJpdG1hcENhY2hlfS4gRW5zdXJlIFN0YWdlR0wgaXMgbG9hZGVkIGFmdGVyIGFsbCBvdGhlclxuICogc3RhbmRhcmQgRWFzZWxKUyBjbGFzc2VzIGFyZSBsb2FkZWQgYnV0IGJlZm9yZSBtYWtpbmcgYW55IERpc3BsYXlPYmplY3QgaW5zdGFuY2VzIGZvciBpbmplY3Rpb24gdG8gdGFrZSBmdWxsIGVmZmVjdC5cbiAqIFJlcGxhY2VzIHRoZSBjb250ZXh0MkQgY2FjaGUgZHJhdyB3aXRoIHRoZSBvcHRpb24gZm9yIFdlYkdMIG9yIGNvbnRleHQyRCBkcmF3aW5nLlxuICogSWYgb3B0aW9ucyBpcyBzZXQgdG8gXCJ0cnVlXCIgYSBTdGFnZUdMIGlzIGNyZWF0ZWQgYW5kIGNvbnRhaW5lZCBvbiB0aGUgb2JqZWN0IGZvciB1c2Ugd2hlbiByZW5kZXJpbmcgYSBjYWNoZS5cbiAqIElmIG9wdGlvbnMgaXMgYSBTdGFnZUdMIGluc3RhbmNlIGl0IHdpbGwgbm90IGNyZWF0ZSBhbiBpbnN0YW5jZSBidXQgdXNlIHRoZSBvbmUgcHJvdmlkZWQuXG4gKiBJZiBwb3NzaWJsZSBpdCBpcyBiZXN0IHRvIHByb3ZpZGUgdGhlIFN0YWdlR0wgaW5zdGFuY2UgdGhhdCBpcyBhIHBhcmVudCB0byB0aGlzIERpc3BsYXlPYmplY3QgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuXG4gKiBBIFN0YWdlR0wgY2FjaGUgZG9lcyBub3QgaW5mZXIgdGhlIGFiaWxpdHkgdG8gZHJhdyBvYmplY3RzIGEgU3RhZ2VHTCBjYW5ub3QgY3VycmVudGx5IGRyYXcsXG4gKiBpLmUuIGRvIG5vdCB1c2UgYSBXZWJHTCBjb250ZXh0IGNhY2hlIHdoZW4gY2FjaGluZyBhIFNoYXBlLCBUZXh0LCBldGMuXG4gKlxuICogWW91IGNhbiBtYWtlIHlvdXIgb3duIFN0YWdlR0wgYW5kIGhhdmUgaXQgcmVuZGVyIHRvIGEgY2FudmFzIGlmIHlvdSBzZXQgXCIuaXNDYWNoZUNvbnRyb2xsZWRcIiB0byB0cnVlIG9uIHlvdXIgc3RhZ2UuXG4gKiBZb3UgbWF5IHdpc2ggdG8gY3JlYXRlIHlvdXIgb3duIFN0YWdlR0wgaW5zdGFuY2UgdG8gY29udHJvbCBmYWN0b3JzIGxpa2UgYmFja2dyb3VuZCBjb2xvci90cmFuc3BhcmVuY3ksIEFBLCBhbmQgZXRjLlxuICogWW91IG11c3Qgc2V0IFwib3B0aW9uc1wiIHRvIGl0cyBvd24gc3RhZ2UgaWYgeW91IHdpc2ggdG8gdXNlIHRoZSBmYXN0IFJlbmRlciBUZXh0dXJlcyBhdmFpbGFibGUgb25seSB0byBTdGFnZUdMcy5cbiAqIElmIHlvdSB1c2UgV2ViR0wgY2FjaGUgb24gYSBjb250YWluZXIgd2l0aCBTaGFwZXMgeW91IHdpbGwgaGF2ZSB0byBjYWNoZSBlYWNoIHNoYXBlIGluZGl2aWR1YWxseSBiZWZvcmUgdGhlIGNvbnRhaW5lcixcbiAqIG90aGVyd2lzZSB0aGUgV2ViR0wgY2FjaGUgd2lsbCBub3QgcmVuZGVyIHRoZSBzaGFwZXMuXG4gKlxuICogQG5hbWUgZWFzZWxqcy5CaXRtYXBDYWNoZSNjYWNoZVxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPldlYkdMIGNhY2hlIHdpdGggMmQgY29udGV4dDwvY2FwdGlvbj5cbiAqIGxldCBzdGFnZSA9IG5ldyBTdGFnZSgpO1xuICogbGV0IGJtcCA9IG5ldyBCaXRtYXAoc3JjKTtcbiAqIGJtcC5jYWNoZSgwLCAwLCBibXAud2lkdGgsIGJtcC5oZWlnaHQsIDEsIHRydWUpOyAvLyBubyBTdGFnZUdMIHRvIHVzZSwgc28gbWFrZSBvbmVcbiAqIGxldCBzaGFwZSA9IG5ldyBTaGFwZSgpO1xuICogc2hhcGUuZ3JhcGhpY3MuY2xlYXIoKS5maWxsKFwicmVkXCIpLmRyYXdSZWN0KDAsMCwyMCwyMCk7XG4gKiBzaGFwZS5jYWNoZSgwLCAwLCAyMCwgMjAsIDEpOyAvLyBjYW5ub3QgdXNlIFdlYkdMIGNhY2hlXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+V2ViR0wgY2FjaGUgd2l0aCBXZWJHTCBjb250ZXh0PC9jYXB0aW9uPlxuICogbGV0IHN0YWdlR0wgPSBuZXcgU3RhZ2VHTCgpO1xuICogbGV0IGJtcCA9IG5ldyBCaXRtYXAoc3JjKTtcbiAqIGJtcC5jYWNoZSgwLCAwLCBibXAud2lkdGgsIGJtcC5oZWlnaHQsIDEsIHN0YWdlR0wpOyAvLyB1c2Ugb3VyIFN0YWdlR0wgdG8gY2FjaGVcbiAqIGxldCBzaGFwZSA9IG5ldyBTaGFwZSgpO1xuICogc2hhcGUuZ3JhcGhpY3MuY2xlYXIoKS5maWxsKFwicmVkXCIpLmRyYXdSZWN0KDAsMCwyMCwyMCk7XG4gKiBzaGFwZS5jYWNoZSgwLCAwLCAyMCwgMjAsIDEpOyAvLyBjYW5ub3QgdXNlIFdlYkdMIGNhY2hlXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIHggY29vcmRpbmF0ZSBvcmlnaW4gZm9yIHRoZSBjYWNoZSByZWdpb24uXG4gKiBAcGFyYW0ge051bWJlcn0geSBUaGUgeSBjb29yZGluYXRlIG9yaWdpbiBmb3IgdGhlIGNhY2hlIHJlZ2lvbi5cbiAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCBUaGUgd2lkdGggb2YgdGhlIGNhY2hlIHJlZ2lvbi5cbiAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgY2FjaGUgcmVnaW9uLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtzY2FsZT0xXSBUaGUgc2NhbGUgYXQgd2hpY2ggdGhlIGNhY2hlIHdpbGwgYmUgY3JlYXRlZC4gRm9yIGV4YW1wbGUsIGlmIHlvdSBjYWNoZSBhIHZlY3RvciBzaGFwZSB1c2luZ1xuICogXHRteVNoYXBlLmNhY2hlKDAsMCwxMDAsMTAwLDIpIHRoZW4gdGhlIHJlc3VsdGluZyBjYWNoZUNhbnZhcyB3aWxsIGJlIDIwMHgyMDAgcHguIFRoaXMgbGV0cyB5b3Ugc2NhbGUgYW5kIHJvdGF0ZVxuICogXHRjYWNoZWQgZWxlbWVudHMgd2l0aCBncmVhdGVyIGZpZGVsaXR5LlxuICogQHBhcmFtIHtCb29sZWFuIHwgZWFzZWxqcy5TdGFnZUdMfSBbb3B0aW9uc10gU2VsZWN0IHdoZXRoZXIgdG8gdXNlIGNvbnRleHQgMkQsIG9yIFdlYkdMIHJlbmRlcmluZywgYW5kIHdoZXRoZXIgdG8gbWFrZSBhIG5ldyBzdGFnZSBpbnN0YW5jZSBvciB1c2UgYW4gZXhpc3Rpbmcgb25lLlxuICovXG4iLCIvKipcbiAqIEBsaWNlbnNlIERpc3BsYXlPYmplY3RcbiAqIFZpc2l0IGh0dHA6Ly9jcmVhdGVqcy5jb20vIGZvciBkb2N1bWVudGF0aW9uLCB1cGRhdGVzIGFuZCBleGFtcGxlcy5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgZ3NraW5uZXIuY29tLCBpbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAqIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXG4gKiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXRcbiAqIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxuICogY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuICogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbiAqIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAqIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gKiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcbiAqIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gKiBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuICogSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXG4gKiBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcbiAqIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5pbXBvcnQgeyBFdmVudERpc3BhdGNoZXIgfSBmcm9tIFwiQGNyZWF0ZWpzL2NvcmVcIjtcbmltcG9ydCBTaGFkb3cgZnJvbSBcIi4vU2hhZG93XCI7XG5pbXBvcnQgdWlkIGZyb20gXCIuLi91dGlscy91aWRcIjtcbmltcG9ydCBEaXNwbGF5UHJvcHMgZnJvbSBcIi4uL2dlb20vRGlzcGxheVByb3BzXCI7XG5pbXBvcnQgUmVjdGFuZ2xlIGZyb20gXCIuLi9nZW9tL1JlY3RhbmdsZVwiO1xuaW1wb3J0IFBvaW50IGZyb20gXCIuLi9nZW9tL1BvaW50XCI7XG5pbXBvcnQgTWF0cml4MkQgZnJvbSBcIi4uL2dlb20vTWF0cml4MkRcIjtcbmltcG9ydCBCaXRtYXBDYWNoZSBmcm9tIFwiLi4vZmlsdGVycy9CaXRtYXBDYWNoZVwiO1xuXG4vKipcbiAqIERpc3BsYXlPYmplY3QgaXMgYW4gYWJzdHJhY3QgY2xhc3MgdGhhdCBzaG91bGQgbm90IGJlIGNvbnN0cnVjdGVkIGRpcmVjdGx5LiBJbnN0ZWFkIGNvbnN0cnVjdCBzdWJjbGFzc2VzIHN1Y2ggYXNcbiAqIHtAbGluayBlYXNlbGpzLkNvbnRhaW5lcn0sIHtAbGluayBlYXNlbGpzLkJpdG1hcH0sIGFuZCB7QGxpbmsgZWFzZWxqcy5TaGFwZX0uXG4gKiBEaXNwbGF5T2JqZWN0IGlzIHRoZSBiYXNlIGNsYXNzIGZvciBhbGwgZGlzcGxheSBjbGFzc2VzIGluIHRoZSBFYXNlbEpTIGxpYnJhcnkuIEl0IGRlZmluZXMgdGhlIGNvcmUgcHJvcGVydGllcyBhbmRcbiAqIG1ldGhvZHMgdGhhdCBhcmUgc2hhcmVkIGJldHdlZW4gYWxsIGRpc3BsYXkgb2JqZWN0cywgc3VjaCBhcyB0cmFuc2Zvcm1hdGlvbiBwcm9wZXJ0aWVzICh4LCB5LCBzY2FsZVgsIHNjYWxlWSwgZXRjKSxcbiAqIGNhY2hpbmcsIGFuZCBtb3VzZSBoYW5kbGVycy5cbiAqXG4gKiBAbWVtYmVyb2YgZWFzZWxqc1xuICogQGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERpc3BsYXlPYmplY3QgZXh0ZW5kcyBFdmVudERpc3BhdGNoZXIge1xuXG5cdGNvbnN0cnVjdG9yICgpIHtcblx0XHRzdXBlcigpO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGFscGhhICh0cmFuc3BhcmVuY3kpIGZvciB0aGlzIGRpc3BsYXkgb2JqZWN0LiAwIGlzIGZ1bGx5IHRyYW5zcGFyZW50LCAxIGlzIGZ1bGx5IG9wYXF1ZS5cblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDFcblx0XHQgKi9cblx0XHR0aGlzLmFscGhhID0gMTtcblxuXHRcdC8qKlxuXHRcdCAqIElmIGEgY2FjaGUgaXMgYWN0aXZlLCB0aGlzIHJldHVybnMgdGhlIGNhbnZhcyB0aGF0IGhvbGRzIHRoZSBpbWFnZSBvZiB0aGlzIGRpc3BsYXkgb2JqZWN0LlxuXHRcdCAqIFVzZSB0aGlzIHRvIGRpc3BsYXkgdGhlIHJlc3VsdCBvZiBhIGNhY2hlLiBUaGlzIHdpbGwgYmUgYSBIVE1MQ2FudmFzRWxlbWVudCB1bmxlc3Mgc3BlY2lhbCBjYWNoZSBydWxlcyBoYXZlIGJlZW4gZGVsaWJlcmF0ZWx5IGVuYWJsZWQgZm9yIHRoaXMgY2FjaGUuXG5cdFx0ICogQHNlZSB7QGxpbmsgZWFzZWxqcy5EaXNwbGF5T2JqZWN0I2NhY2hlfVxuXHRcdCAqIEB0eXBlIHtIVE1MQ2FudmFzRWxlbWVudCB8IE9iamVjdH1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICovXG5cdFx0dGhpcy5jYWNoZUNhbnZhcyA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBJZiBhIGNhY2hlIGhhcyBiZWVuIG1hZGUsIHRoaXMgcmV0dXJucyB0aGUgY2xhc3MgdGhhdCBpcyBtYW5hZ2luZyB0aGUgY2FjaGVDYW52YXMgYW5kIGl0cyBwcm9wZXJ0aWVzLlxuXHRcdCAqIEBzZWUge0BsaW5rIGVhc2VsanMuQml0bWFwQ2FjaGV9XG5cdFx0ICogQHR5cGUge2Vhc2VsanMuQml0bWFwQ2FjaGV9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqL1xuXHRcdHRoaXMuYml0bWFwQ2FjaGUgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogVW5pcXVlIElEIGZvciB0aGlzIGRpc3BsYXkgb2JqZWN0LiBNYWtlcyBkaXNwbGF5IG9iamVjdHMgZWFzaWVyIGZvciBzb21lIHVzZXMuXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKi9cblx0XHR0aGlzLmlkID0gdWlkKCk7XG5cblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0byBpbmNsdWRlIHRoaXMgb2JqZWN0IHdoZW4gcnVubmluZyBtb3VzZSBpbnRlcmFjdGlvbnMuIFNldHRpbmcgdGhpcyB0byBgZmFsc2VgIGZvciBjaGlsZHJlblxuXHRcdCAqIG9mIGEge0BsaW5rIGVhc2VsanMuQ29udGFpbmVyfSB3aWxsIGNhdXNlIGV2ZW50cyBvbiB0aGUgQ29udGFpbmVyIHRvIG5vdCBmaXJlIHdoZW4gdGhhdCBjaGlsZCBpc1xuXHRcdCAqIGNsaWNrZWQuIFNldHRpbmcgdGhpcyBwcm9wZXJ0eSB0byBgZmFsc2VgIGRvZXMgbm90IHByZXZlbnQgdGhlIHtAbGluayBlYXNlbGpzLkNvbnRhaW5lciNnZXRPYmplY3RzVW5kZXJQb2ludH1cblx0XHQgKiBtZXRob2QgZnJvbSByZXR1cm5pbmcgdGhlIGNoaWxkLlxuXHRcdCAqXG5cdFx0ICogPHN0cm9uZz5Ob3RlOjwvc3Ryb25nPiBJbiBFYXNlbEpTIDAuNy4wLCB0aGUgYG1vdXNlRW5hYmxlZGAgcHJvcGVydHkgd2lsbCBub3Qgd29yayBwcm9wZXJseSB3aXRoIG5lc3RlZCBDb250YWluZXJzLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdHRoaXMubW91c2VFbmFibGVkID0gdHJ1ZTtcblxuXHRcdC8qKlxuXHRcdCAqIElmIGZhbHNlLCB0aGUgdGljayB3aWxsIG5vdCBydW4gb24gdGhpcyBkaXNwbGF5IG9iamVjdCAob3IgaXRzIGNoaWxkcmVuKS4gVGhpcyBjYW4gcHJvdmlkZSBzb21lIHBlcmZvcm1hbmNlIGJlbmVmaXRzLlxuXHRcdCAqIEluIGFkZGl0aW9uIHRvIHByZXZlbnRpbmcgdGhlIHtAbGluayBjb3JlLlRpY2tlciNldmVudDp0aWNrfSBldmVudCBmcm9tIGJlaW5nIGRpc3BhdGNoZWQsIGl0IHdpbGwgYWxzbyBwcmV2ZW50IHRpY2sgcmVsYXRlZCB1cGRhdGVzXG5cdFx0ICogb24gc29tZSBkaXNwbGF5IG9iamVjdHMgKGV4LiBTcHJpdGUgJiBNb3ZpZUNsaXAgZnJhbWUgYWR2YW5jaW5nLCBET01FbGVtZW50IHZpc2liaWxpdHkgaGFuZGxpbmcpLlxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0dGhpcy50aWNrRW5hYmxlZCA9IHRydWU7XG5cblx0XHQvKipcblx0XHQgKiBBbiBvcHRpb25hbCBuYW1lIGZvciB0aGlzIGRpc3BsYXkgb2JqZWN0LiBJbmNsdWRlZCBpbiB7QGxpbmsgZWFzZWxqcy5EaXNwbGF5T2JqZWN0I3RvU3RyaW5nfS4gVXNlZnVsIGZvciBkZWJ1Z2dpbmcuXG5cdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5uYW1lID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEEgcmVmZXJlbmNlIHRvIHRoZSB7QGxpbmsgZWFzZWxqcy5Db250YWluZXJ9IG9yIHtAbGluayBlYXNlbGpzLlN0YWdlfSBvYmplY3QgdGhhdFxuXHRcdCAqIGNvbnRhaW5zIHRoaXMgZGlzcGxheSBvYmplY3QsIG9yIG51bGwgaWYgaXQgaGFzIG5vdCBiZWVuIGFkZGVkIHRvIG9uZS5cblx0XHQgKiBAdHlwZSB7ZWFzZWxqcy5Db250YWluZXJ9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqL1xuXHRcdHRoaXMucGFyZW50ID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBsZWZ0IG9mZnNldCBmb3IgdGhpcyBkaXNwbGF5IG9iamVjdCdzIHJlZ2lzdHJhdGlvbiBwb2ludC4gRm9yIGV4YW1wbGUsIHRvIG1ha2UgYSAxMDB4MTAwcHggQml0bWFwIHJvdGF0ZVxuXHRcdCAqIGFyb3VuZCBpdHMgY2VudGVyLCB5b3Ugd291bGQgc2V0IHJlZ1ggYW5kIHtAbGluayBlYXNlbGpzLkRpc3BsYXlPYmplY3QjcmVnWX0gdG8gNTAuXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0dGhpcy5yZWdYID0gMDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSB5IG9mZnNldCBmb3IgdGhpcyBkaXNwbGF5IG9iamVjdCdzIHJlZ2lzdHJhdGlvbiBwb2ludC4gRm9yIGV4YW1wbGUsIHRvIG1ha2UgYSAxMDB4MTAwcHggQml0bWFwIHJvdGF0ZSBhcm91bmRcblx0XHQgKiBpdHMgY2VudGVyLCB5b3Ugd291bGQgc2V0IHtAbGluayBlYXNlbGpzLkRpc3BsYXlPYmplY3QjcmVnWH0gYW5kIHJlZ1kgdG8gNTAuXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0dGhpcy5yZWdZID0gMDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSByb3RhdGlvbiBpbiBkZWdyZWVzIGZvciB0aGlzIGRpc3BsYXkgb2JqZWN0LlxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqL1xuXHRcdHRoaXMucm90YXRpb24gPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGZhY3RvciB0byBzdHJldGNoIHRoaXMgZGlzcGxheSBvYmplY3QgaG9yaXpvbnRhbGx5LiBGb3IgZXhhbXBsZSwgc2V0dGluZyBzY2FsZVggdG8gMiB3aWxsIHN0cmV0Y2ggdGhlIGRpc3BsYXlcblx0XHQgKiBvYmplY3QgdG8gdHdpY2UgaXRzIG5vbWluYWwgd2lkdGguIFRvIGhvcml6b250YWxseSBmbGlwIGFuIG9iamVjdCwgc2V0IHRoZSBzY2FsZSB0byBhIG5lZ2F0aXZlIG51bWJlci5cblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDFcblx0XHQgKi9cblx0XHR0aGlzLnNjYWxlWCA9IDE7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgZmFjdG9yIHRvIHN0cmV0Y2ggdGhpcyBkaXNwbGF5IG9iamVjdCB2ZXJ0aWNhbGx5LiBGb3IgZXhhbXBsZSwgc2V0dGluZyBzY2FsZVkgdG8gMC41IHdpbGwgc3RyZXRjaCB0aGUgZGlzcGxheVxuXHRcdCAqIG9iamVjdCB0byBoYWxmIGl0cyBub21pbmFsIGhlaWdodC4gVG8gdmVydGljYWxseSBmbGlwIGFuIG9iamVjdCwgc2V0IHRoZSBzY2FsZSB0byBhIG5lZ2F0aXZlIG51bWJlci5cblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDFcblx0XHQgKi9cblx0XHR0aGlzLnNjYWxlWSA9IDE7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgZmFjdG9yIHRvIHNrZXcgdGhpcyBkaXNwbGF5IG9iamVjdCBob3Jpem9udGFsbHkuXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0dGhpcy5za2V3WCA9IDA7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgZmFjdG9yIHRvIHNrZXcgdGhpcyBkaXNwbGF5IG9iamVjdCB2ZXJ0aWNhbGx5LlxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqL1xuXHRcdHRoaXMuc2tld1kgPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogQSBzaGFkb3cgb2JqZWN0IHRoYXQgZGVmaW5lcyB0aGUgc2hhZG93IHRvIHJlbmRlciBvbiB0aGlzIGRpc3BsYXkgb2JqZWN0LiBTZXQgdG8gYG51bGxgIHRvIHJlbW92ZSBhIHNoYWRvdy4gSWZcblx0XHQgKiBudWxsLCB0aGlzIHByb3BlcnR5IGlzIGluaGVyaXRlZCBmcm9tIHRoZSBwYXJlbnQgY29udGFpbmVyLlxuXHRcdCAqIEB0eXBlIHtlYXNlbGpzLlNoYWRvd31cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5zaGFkb3cgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBkaXNwbGF5IG9iamVjdCBzaG91bGQgYmUgcmVuZGVyZWQgdG8gdGhlIGNhbnZhcyBhbmQgaW5jbHVkZWQgd2hlbiBydW5uaW5nIHRoZSBTdGFnZVxuXHRcdCAqIHtAbGluayBlYXNlbGpzLlN0YWdlI2dldE9iamVjdHNVbmRlclBvaW50fSBtZXRob2QuXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdHRoaXMudmlzaWJsZSA9IHRydWU7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgeCAoaG9yaXpvbnRhbCkgcG9zaXRpb24gb2YgdGhlIGRpc3BsYXkgb2JqZWN0LCByZWxhdGl2ZSB0byBpdHMgcGFyZW50LlxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqL1xuXHRcdHRoaXMueCA9IDA7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgeSAodmVydGljYWwpIHBvc2l0aW9uIG9mIHRoZSBkaXNwbGF5IG9iamVjdCwgcmVsYXRpdmUgdG8gaXRzIHBhcmVudC5cblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKi9cblx0XHR0aGlzLnkgPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogSWYgc2V0LCBkZWZpbmVzIHRoZSB0cmFuc2Zvcm1hdGlvbiBmb3IgdGhpcyBkaXNwbGF5IG9iamVjdCwgb3ZlcnJpZGluZyBhbGwgb3RoZXIgdHJhbnNmb3JtYXRpb24gcHJvcGVydGllc1xuXHRcdCAqICh4LCB5LCByb3RhdGlvbiwgc2NhbGUsIHNrZXcpLlxuXHRcdCAqIEB0eXBlIHtlYXNlbGpzLk1hdHJpeDJEfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLnRyYW5zZm9ybU1hdHJpeCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgY29tcG9zaXRlIG9wZXJhdGlvbiBpbmRpY2F0ZXMgaG93IHRoZSBwaXhlbHMgb2YgdGhpcyBkaXNwbGF5IG9iamVjdCB3aWxsIGJlIGNvbXBvc2l0ZWQgd2l0aCB0aGUgZWxlbWVudHNcblx0XHQgKiBiZWhpbmQgaXQuIElmIGBudWxsYCwgdGhpcyBwcm9wZXJ0eSBpcyBpbmhlcml0ZWQgZnJvbSB0aGUgcGFyZW50IGNvbnRhaW5lci5cblx0XHQgKiBAc2VlIHtAbGluayBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aGUtY2FudmFzLWVsZW1lbnQuaHRtbCNjb21wb3NpdGluZyBcIldIQVRXRyBzcGVjIG9uIGNvbXBvc2l0aW5nXCJ9XG5cdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5jb21wb3NpdGVPcGVyYXRpb24gPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGRpc3BsYXkgb2JqZWN0IHNob3VsZCBiZSBkcmF3biB0byBhIHdob2xlIHBpeGVsIHdoZW4ge0BsaW5rIGVhc2VsanMuU3RhZ2Ujc25hcFRvUGl4ZWxFbmFibGVkfSBpcyB0cnVlLlxuXHRcdCAqIFRvIGVuYWJsZS9kaXNhYmxlIHNuYXBwaW5nIG9uIHdob2xlIGNhdGVnb3JpZXMgb2YgZGlzcGxheSBvYmplY3RzLCBzZXQgdGhpcyB2YWx1ZSBvbiB0aGUgcHJvdG90eXBlIChFeC4gVGV4dC5wcm90b3R5cGUuc25hcFRvUGl4ZWwgPSB0cnVlKS5cblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0dGhpcy5zbmFwVG9QaXhlbCA9IHRydWU7XG5cblx0XHQvKipcblx0XHQgKiBBbiBhcnJheSBvZiBGaWx0ZXIgb2JqZWN0cyB0byBhcHBseSB0byB0aGlzIGRpc3BsYXkgb2JqZWN0LiBGaWx0ZXJzIGFyZSBvbmx5IGFwcGxpZWQgLyB1cGRhdGVkIHdoZW4ge0BsaW5rIGVhc2VsanMuRGlzcGxheU9iamVjdCNjYWNoZX1cblx0XHQgKiBvciB7QGxpbmsgZWFzZWxqcy5EaXNwbGF5T2JqZWN0I3VwZGF0ZUNhY2hlfSBpcyBjYWxsZWQgb24gdGhlIGRpc3BsYXkgb2JqZWN0LCBhbmQgb25seSBhcHBseSB0byB0aGUgYXJlYSB0aGF0IGlzIGNhY2hlZC5cblx0XHQgKiBAdHlwZSB7QXJyYXk8ZWFzZWxqcy5GaWx0ZXI+fVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLmZpbHRlcnMgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQSBTaGFwZSBpbnN0YW5jZSB0aGF0IGRlZmluZXMgYSB2ZWN0b3IgbWFzayAoY2xpcHBpbmcgcGF0aCkgZm9yIHRoaXMgZGlzcGxheSBvYmplY3QuICBUaGUgc2hhcGUncyB0cmFuc2Zvcm1hdGlvblxuXHRcdCAqIHdpbGwgYmUgYXBwbGllZCByZWxhdGl2ZSB0byB0aGUgZGlzcGxheSBvYmplY3QncyBwYXJlbnQgY29vcmRpbmF0ZXMgKGFzIGlmIGl0IHdlcmUgYSBjaGlsZCBvZiB0aGUgcGFyZW50KS5cblx0XHQgKiBAdHlwZSB7ZWFzZWxqcy5TaGFwZX1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5tYXNrID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEEgZGlzcGxheSBvYmplY3QgdGhhdCB3aWxsIGJlIHRlc3RlZCB3aGVuIGNoZWNraW5nIG1vdXNlIGludGVyYWN0aW9ucyBvciB0ZXN0aW5nIHtAbGluayBlYXNlbGpzLkNvbnRhaW5lciNnZXRPYmplY3RzVW5kZXJQb2ludH0uXG5cdFx0ICogVGhlIGhpdCBhcmVhIHdpbGwgaGF2ZSBpdHMgdHJhbnNmb3JtYXRpb24gYXBwbGllZCByZWxhdGl2ZSB0byB0aGlzIGRpc3BsYXkgb2JqZWN0J3MgY29vcmRpbmF0ZSBzcGFjZSAoYXMgdGhvdWdoXG5cdFx0ICogdGhlIGhpdCB0ZXN0IG9iamVjdCB3ZXJlIGEgY2hpbGQgb2YgdGhpcyBkaXNwbGF5IG9iamVjdCBhbmQgcmVsYXRpdmUgdG8gaXRzIHJlZ1gvWSkuIFRoZSBoaXRBcmVhIHdpbGwgYmUgdGVzdGVkXG5cdFx0ICogdXNpbmcgb25seSBpdHMgb3duIGBhbHBoYWAgdmFsdWUgcmVnYXJkbGVzcyBvZiB0aGUgYWxwaGEgdmFsdWUgb24gdGhlIHRhcmdldCBkaXNwbGF5IG9iamVjdCwgb3IgdGhlIHRhcmdldCdzXG5cdFx0ICogYW5jZXN0b3JzIChwYXJlbnRzKS5cblx0XHQgKlxuXHRcdCAqIElmIHNldCBvbiBhIHtAbGluayBlYXNlbGpzLkNvbnRhaW5lcn0sIGNoaWxkcmVuIG9mIHRoZSBDb250YWluZXIgd2lsbCBub3QgcmVjZWl2ZSBtb3VzZSBldmVudHMuXG5cdFx0ICogVGhpcyBpcyBzaW1pbGFyIHRvIHNldHRpbmcge0BsaW5rIGVhc2VsanMuRGlzcGxheU9iamVjdCNtb3VzZUNoaWxkcmVufSB0byBmYWxzZS5cblx0XHQgKlxuXHRcdCAqIE5vdGUgdGhhdCBoaXRBcmVhIGlzIE5PVCBjdXJyZW50bHkgdXNlZCBieSB0aGUgYGhpdFRlc3QoKWAgbWV0aG9kLCBub3IgaXMgaXQgc3VwcG9ydGVkIGZvciB7QGxpbmsgZWFzZWxqcy5TdGFnZX0uXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7ZWFzZWxqcy5EaXNwbGF5T2JqZWN0fVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLmhpdEFyZWEgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQSBDU1MgY3Vyc29yIChleC4gXCJwb2ludGVyXCIsIFwiaGVscFwiLCBcInRleHRcIiwgZXRjKSB0aGF0IHdpbGwgYmUgZGlzcGxheWVkIHdoZW4gdGhlIHVzZXIgaG92ZXJzIG92ZXIgdGhpcyBkaXNwbGF5XG5cdFx0ICogb2JqZWN0LiBZb3UgbXVzdCBlbmFibGUgbW91c2VvdmVyIGV2ZW50cyB1c2luZyB0aGUge0BsaW5rIGVhc2VsanMuU3RhZ2UjZW5hYmxlTW91c2VPdmVyfSBtZXRob2QgdG9cblx0XHQgKiB1c2UgdGhpcyBwcm9wZXJ0eS4gU2V0dGluZyBhIG5vbi1udWxsIGN1cnNvciBvbiBhIENvbnRhaW5lciB3aWxsIG92ZXJyaWRlIHRoZSBjdXJzb3Igc2V0IG9uIGl0cyBkZXNjZW5kYW50cy5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuY3Vyc29yID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7ZWFzZWxqcy5EaXNwbGF5UHJvcHN9XG5cdFx0ICovXG5cdFx0dGhpcy5fcHJvcHMgPSBuZXcgRGlzcGxheVByb3BzKCk7XG5cblx0XHQvKipcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge2Vhc2VsanMuUmVjdGFuZ2xlfVxuXHRcdCAqL1xuXHRcdHRoaXMuX3JlY3RhbmdsZSA9IG5ldyBSZWN0YW5nbGUoKTtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7ZWFzZWxqcy5SZWN0YW5nbGV9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuX2JvdW5kcyA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBXaGVyZSBTdGFnZUdMIHNob3VsZCBsb29rIGZvciByZXF1aXJlZCBkaXNwbGF5IHByb3BlcnRpZXMsIG1hdHRlcnMgb25seSBmb3IgbGVhZiBkaXNwbGF5IG9iamVjdHMuIENvbnRhaW5lcnNcblx0XHQgKiBvciBjYWNoZWQgb2JqZWN0cyB3b24ndCB1c2UgdGhpcyBwcm9wZXJ0eSwgaXQncyBmb3IgbmF0aXZlIGRpc3BsYXkgb2YgdGVybWluYWwgZWxlbWVudHMuXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqL1xuXHRcdHRoaXMuX3dlYkdMUmVuZGVyU3R5bGUgPSBEaXNwbGF5T2JqZWN0Ll9TdGFnZUdMX05PTkU7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUge0BsaW5rIGVhc2VsanMuU3RhZ2V9IGluc3RhbmNlIHRoYXQgdGhpcyBkaXNwbGF5IG9iamVjdCB3aWxsIGJlIHJlbmRlcmVkIG9uLCBvciBudWxsIGlmIGl0IGhhcyBub3QgYmVlbiBhZGRlZCB0byBvbmUuXG5cdCAqIEB0eXBlIHtTdGFnZX1cblx0ICogQHJlYWRvbmx5XG5cdCAqL1xuXHRnZXQgc3RhZ2UgKCkge1xuXHRcdC8vIHVzZXMgZHluYW1pYyBhY2Nlc3MgdG8gYXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jaWVzO1xuXHRcdGxldCBvID0gdGhpcztcblx0XHR3aGlsZSAoby5wYXJlbnQpIHsgbyA9IG8ucGFyZW50OyB9XG5cdFx0aWYgKC9eXFxbU3RhZ2UoR0wpPyhcXHNcXChuYW1lPVxcdytcXCkpP1xcXSQvLnRlc3Qoby50b1N0cmluZygpKSkgeyByZXR1cm4gbzsgfVxuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldCBib3RoIHRoZSB7QGxpbmsgZWFzZWxqcy5EaXNwbGF5T2JqZWN0I3NjYWxlWH0gYW5kIHRoZSB7QGxpbmsgZWFzZWxqcy5EaXNwbGF5T2JqZWN0I3NjYWxlWX0gcHJvcGVydHkgdG8gdGhlIHNhbWUgdmFsdWUuXG5cdCAqIE5vdGUgdGhhdCB3aGVuIHlvdSBnZXQgdGhlIHZhbHVlLCBpZiB0aGUgYHNjYWxlWGAgYW5kIGBzY2FsZVlgIGFyZSBkaWZmZXJlbnQgdmFsdWVzLCBpdCB3aWxsIHJldHVybiBvbmx5IHRoZSBgc2NhbGVYYC5cblx0ICogQHR5cGUge051bWJlcn1cblx0ICogQGRlZmF1bHQgMVxuXHQgKi9cblx0c2V0IHNjYWxlICh2YWx1ZSkgeyB0aGlzLnNjYWxlWCA9IHRoaXMuc2NhbGVZID0gdmFsdWU7IH1cblx0Z2V0IHNjYWxlICgpIHsgcmV0dXJuIHRoaXMuc2NhbGVYOyB9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBvciBmYWxzZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGRpc3BsYXkgb2JqZWN0IHdvdWxkIGJlIHZpc2libGUgaWYgZHJhd24gdG8gYSBjYW52YXMuXG5cdCAqIFRoaXMgZG9lcyBub3QgYWNjb3VudCBmb3Igd2hldGhlciBpdCB3b3VsZCBiZSB2aXNpYmxlIHdpdGhpbiB0aGUgYm91bmRhcmllcyBvZiB0aGUgc3RhZ2UuXG5cdCAqIE5PVEU6IFRoaXMgbWV0aG9kIGlzIG1haW5seSBmb3IgaW50ZXJuYWwgdXNlLCB0aG91Z2ggaXQgbWF5IGJlIHVzZWZ1bCBmb3IgYWR2YW5jZWQgdXNlcy5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGRpc3BsYXkgb2JqZWN0IHdvdWxkIGJlIHZpc2libGUgaWYgZHJhd24gdG8gYSBjYW52YXNcblx0ICovXG5cdGlzVmlzaWJsZSAoKSB7XG5cdFx0cmV0dXJuICEhKHRoaXMudmlzaWJsZSAmJiB0aGlzLmFscGhhID4gMCAmJiB0aGlzLnNjYWxlWCAhPSAwICYmIHRoaXMuc2NhbGVZICE9IDApO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFsaWFzIGZvciBkcmF3Q2FjaGUoKS4gVXNlZCBieSBncmFuZGNoaWxkcmVuIChvciBkZWVwZXIpIGluIHRoZWlyIGRyYXcgbWV0aG9kIHRvIGRpcmVjdGx5XG5cdCAqIGNhbGwge0BsaW5rIGVhc2VsanMuRGlzcGxheU9iamVjdCNkcmF3Q2FjaGV9LCBieXBhc3NpbmcgdGhlaXIgcGFyZW50KHMpLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IFRoZSBjYW52YXMgMkQgY29udGV4dCBvYmplY3QgdG8gZHJhdyBpbnRvLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtpZ25vcmVDYWNoZT1mYWxzZV0gSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGRyYXcgb3BlcmF0aW9uIHNob3VsZCBpZ25vcmUgYW55IGN1cnJlbnQgY2FjaGUuIEZvciBleGFtcGxlLFxuXHQgKiB1c2VkIGZvciBkcmF3aW5nIHRoZSBjYWNoZSAodG8gcHJldmVudCBpdCBmcm9tIHNpbXBseSBkcmF3aW5nIGFuIGV4aXN0aW5nIGNhY2hlIGJhY2sgaW50byBpdHNlbGYpLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKi9cblx0ZHJhdyAoY3R4LCBpZ25vcmVDYWNoZSA9IGZhbHNlKSB7XG5cdFx0cmV0dXJuIHRoaXMuZHJhd0NhY2hlKGN0eCwgaWdub3JlQ2FjaGUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIERyYXdzIHRoZSBkaXNwbGF5IG9iamVjdCBpbnRvIHRoZSBzcGVjaWZpZWQgY29udGV4dCBpZ25vcmluZyBpdHMgdmlzaWJsZSwgYWxwaGEsIHNoYWRvdywgYW5kIHRyYW5zZm9ybS5cblx0ICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGRyYXcgd2FzIGhhbmRsZWQgKHVzZWZ1bCBmb3Igb3ZlcnJpZGluZyBmdW5jdGlvbmFsaXR5KS5cblx0ICpcblx0ICogTk9URTogVGhpcyBtZXRob2QgaXMgbWFpbmx5IGZvciBpbnRlcm5hbCB1c2UsIHRob3VnaCBpdCBtYXkgYmUgdXNlZnVsIGZvciBhZHZhbmNlZCB1c2VzLlxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IFRoZSBjYW52YXMgMkQgY29udGV4dCBvYmplY3QgdG8gZHJhdyBpbnRvLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtpZ25vcmVDYWNoZT1mYWxzZV0gSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGRyYXcgb3BlcmF0aW9uIHNob3VsZCBpZ25vcmUgYW55IGN1cnJlbnQgY2FjaGUuIEZvciBleGFtcGxlLFxuXHQgKiB1c2VkIGZvciBkcmF3aW5nIHRoZSBjYWNoZSAodG8gcHJldmVudCBpdCBmcm9tIHNpbXBseSBkcmF3aW5nIGFuIGV4aXN0aW5nIGNhY2hlIGJhY2sgaW50byBpdHNlbGYpLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKi9cblx0ZHJhd0NhY2hlIChjdHgsIGlnbm9yZUNhY2hlID0gZmFsc2UpIHtcblx0XHRsZXQgY2FjaGUgPSB0aGlzLmJpdG1hcENhY2hlO1xuXHRcdGlmIChjYWNoZSAmJiAhaWdub3JlQ2FjaGUpIHtcblx0XHRcdHJldHVybiBjYWNoZS5kcmF3KGN0eCk7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBcHBsaWVzIHRoaXMgZGlzcGxheSBvYmplY3QncyB0cmFuc2Zvcm1hdGlvbiwgYWxwaGEsIGdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiwgY2xpcHBpbmcgcGF0aCAobWFzayksIGFuZCBzaGFkb3dcblx0ICogdG8gdGhlIHNwZWNpZmllZCBjb250ZXh0LiBUaGlzIGlzIHR5cGljYWxseSBjYWxsZWQgcHJpb3IgdG8ge0BsaW5rIGVhc2VsanMuRGlzcGxheU9iamVjdCNkcmF3fS5cblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBUaGUgY2FudmFzIDJEIHRvIHVwZGF0ZS5cblx0ICovXG5cdHVwZGF0ZUNvbnRleHQgKGN0eCkge1xuXHRcdGxldCBvPXRoaXMsIG1hc2s9by5tYXNrLCBtdHg9by5fcHJvcHMubWF0cml4O1xuXG5cdFx0aWYgKG1hc2sgJiYgbWFzay5ncmFwaGljcyAmJiAhbWFzay5ncmFwaGljcy5pc0VtcHR5KCkpIHtcblx0XHRcdG1hc2suZ2V0TWF0cml4KG10eCk7XG5cdFx0XHRjdHgudHJhbnNmb3JtKG10eC5hLCBtdHguYiwgbXR4LmMsIG10eC5kLCBtdHgudHgsIG10eC50eSk7XG5cblx0XHRcdG1hc2suZ3JhcGhpY3MuZHJhd0FzUGF0aChjdHgpO1xuXHRcdFx0Y3R4LmNsaXAoKTtcblxuXHRcdFx0bXR4LmludmVydCgpO1xuXHRcdFx0Y3R4LnRyYW5zZm9ybShtdHguYSwgIG10eC5iLCBtdHguYywgbXR4LmQsIG10eC50eCwgbXR4LnR5KTtcblx0XHR9XG5cblx0XHR0aGlzLmdldE1hdHJpeChtdHgpO1xuXHRcdGxldCB0eCA9IG10eC50eCwgdHkgPSBtdHgudHk7XG5cdFx0aWYgKERpc3BsYXlPYmplY3QuX3NuYXBUb1BpeGVsRW5hYmxlZCAmJiBvLnNuYXBUb1BpeGVsKSB7XG5cdFx0XHR0eCA9IHR4ICsgKHR4IDwgMCA/IC0wLjUgOiAwLjUpIHwgMDtcblx0XHRcdHR5ID0gdHkgKyAodHkgPCAwID8gLTAuNSA6IDAuNSkgfCAwO1xuXHRcdH1cblx0XHRjdHgudHJhbnNmb3JtKG10eC5hLCAgbXR4LmIsIG10eC5jLCBtdHguZCwgdHgsIHR5KTtcblx0XHRjdHguZ2xvYmFsQWxwaGEgKj0gby5hbHBoYTtcblx0XHRpZiAoby5jb21wb3NpdGVPcGVyYXRpb24pIHsgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IG8uY29tcG9zaXRlT3BlcmF0aW9uOyB9XG5cdFx0aWYgKG8uc2hhZG93KSB7IHRoaXMuX2FwcGx5U2hhZG93KGN0eCwgby5zaGFkb3cpOyB9XG5cdH1cblxuXHQvKipcblx0ICogRHJhd3MgdGhlIGRpc3BsYXkgb2JqZWN0IGludG8gYSBuZXcgZWxlbWVudCwgd2hpY2ggaXMgdGhlbiB1c2VkIGZvciBzdWJzZXF1ZW50IGRyYXdzLiBJbnRlbmRlZCBmb3IgY29tcGxleCBjb250ZW50XG5cdCAqIHRoYXQgZG9lcyBub3QgY2hhbmdlIGZyZXF1ZW50bHkgKGV4LiBhIENvbnRhaW5lciB3aXRoIG1hbnkgY2hpbGRyZW4gdGhhdCBkbyBub3QgbW92ZSwgb3IgYSBjb21wbGV4IHZlY3RvciBTaGFwZSksXG5cdCAqIHRoaXMgY2FuIHByb3ZpZGUgZm9yIG11Y2ggZmFzdGVyIHJlbmRlcmluZyBiZWNhdXNlIHRoZSBjb250ZW50IGRvZXMgbm90IG5lZWQgdG8gYmUgcmUtcmVuZGVyZWQgZWFjaCB0aWNrLiBUaGVcblx0ICogY2FjaGVkIGRpc3BsYXkgb2JqZWN0IGNhbiBiZSBtb3ZlZCwgcm90YXRlZCwgZmFkZWQsIGV0YyBmcmVlbHksIGhvd2V2ZXIgaWYgaXRzIGNvbnRlbnQgY2hhbmdlcywgeW91IG11c3QgbWFudWFsbHlcblx0ICogdXBkYXRlIHRoZSBjYWNoZSBieSBjYWxsaW5nIGB1cGRhdGVDYWNoZSgpYCBhZ2Fpbi4gWW91IG11c3Qgc3BlY2lmeSB0aGUgY2FjaGVkIGFyZWEgdmlhIHRoZSB4LCB5LCB3LFxuXHQgKiBhbmQgaCBwYXJhbWV0ZXJzLiBUaGlzIGRlZmluZXMgdGhlIHJlY3RhbmdsZSB0aGF0IHdpbGwgYmUgcmVuZGVyZWQgYW5kIGNhY2hlZCB1c2luZyB0aGlzIGRpc3BsYXkgb2JqZWN0J3MgY29vcmRpbmF0ZXMuXG5cdCAqXG5cdCAqIE5vdGUgdGhhdCBmaWx0ZXJzIG5lZWQgdG8gYmUgZGVmaW5lZCA8ZW0+YmVmb3JlPC9lbT4gdGhlIGNhY2hlIGlzIGFwcGxpZWQgb3IgeW91IHdpbGwgaGF2ZSB0byBjYWxsIHVwZGF0ZUNhY2hlIGFmdGVyXG5cdCAqIGFwcGxpY2F0aW9uLiBDaGVjayBvdXQgdGhlIHtAbGluayBlYXNlbGpzLkZpbHRlcn0gY2xhc3MgZm9yIG1vcmUgaW5mb3JtYXRpb24uIFNvbWUgZmlsdGVyc1xuXHQgKiAoZXguIHtAbGluayBlYXNlbGpzLkJsdXJGaWx0ZXJ9KSBtYXkgbm90IHdvcmsgYXMgZXhwZWN0ZWQgaW4gY29uanVuY3Rpb24gd2l0aCB0aGUgc2NhbGUgcGFyYW0uXG5cdCAqXG5cdCAqIFVzdWFsbHksIHRoZSByZXN1bHRpbmcgY2FjaGVDYW52YXMgd2lsbCBoYXZlIHRoZSBkaW1lbnNpb25zIHdpZHRoKnNjYWxlIGJ5IGhlaWdodCpzY2FsZSwgaG93ZXZlciBzb21lIGZpbHRlcnMgKGV4LiBCbHVyRmlsdGVyKVxuXHQgKiB3aWxsIGFkZCBwYWRkaW5nIHRvIHRoZSBjYW52YXMgZGltZW5zaW9ucy5cblx0ICpcblx0ICogQWN0dWFsIGltcGxlbWVudGF0aW9uIG9mIHRoZSBjYWNoaW5nIG1lY2hhbmlzbSBjYW4gY2hhbmdlIHdpdGggYSB7QGxpbmsgZWFzZWxqcy5TdGFnZUdMfSBhbmQgc29cblx0ICogYWxsIGNhY2hpbmcgYW5kIGZpbHRlciBiZWhhdmlvdXIgaGFzIGJlZW4gbW92ZWQgdG8gdGhlIHtAbGluayBlYXNlbGpzLkJpdG1hcENhY2hlfVxuXHQgKlxuXHQgKiBAZXhhbXBsZVxuXHQgKiAvLyBJZiB5b3UgZGVmaW5lZCBhIFNoYXBlIHRoYXQgZHJldyBhIGNpcmNsZSBhdCAwLCAwIHdpdGggYSByYWRpdXMgb2YgMjU6XG5cdCAqIHZhciBzaGFwZSA9IG5ldyBjcmVhdGVqcy5TaGFwZSgpO1xuXHQgKiBzaGFwZS5ncmFwaGljcy5iZWdpbkZpbGwoXCIjZmYwMDAwXCIpLmRyYXdDaXJjbGUoMCwgMCwgMjUpO1xuXHQgKiBzaGFwZS5jYWNoZSgtMjUsIC0yNSwgNTAsIDUwKTtcblx0ICpcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIHggY29vcmRpbmF0ZSBvcmlnaW4gZm9yIHRoZSBjYWNoZSByZWdpb24uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IGNvb3JkaW5hdGUgb3JpZ2luIGZvciB0aGUgY2FjaGUgcmVnaW9uLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggVGhlIHdpZHRoIG9mIHRoZSBjYWNoZSByZWdpb24uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgY2FjaGUgcmVnaW9uLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3NjYWxlPTFdIFRoZSBzY2FsZSBhdCB3aGljaCB0aGUgY2FjaGUgd2lsbCBiZSBjcmVhdGVkLiBGb3IgZXhhbXBsZSwgaWYgeW91IGNhY2hlIGEgdmVjdG9yIHNoYXBlIHVzaW5nXG5cdCAqIFx0bXlTaGFwZS5jYWNoZSgwLDAsMTAwLDEwMCwyKSB0aGVuIHRoZSByZXN1bHRpbmcgY2FjaGVDYW52YXMgd2lsbCBiZSAyMDB4MjAwIHB4LiBUaGlzIGxldHMgeW91IHNjYWxlIGFuZCByb3RhdGVcblx0ICogXHRjYWNoZWQgZWxlbWVudHMgd2l0aCBncmVhdGVyIGZpZGVsaXR5LiBEZWZhdWx0IGlzIDEuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gV2hlbiB1c2luZyBhbHRlcm5hdGUgZGlzcGxheXMgdGhlcmUgbWF5IGJlIGV4dHJhIGNhY2hpbmcgb3Bwb3J0dW5pdGllcyBvciBuZWVkcy5cblx0ICovXG5cdGNhY2hlICh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBzY2FsZSA9IDEsIG9wdGlvbnMpIHtcblx0XHRpZiAoIXRoaXMuYml0bWFwQ2FjaGUpIHtcblx0XHRcdHRoaXMuYml0bWFwQ2FjaGUgPSBuZXcgQml0bWFwQ2FjaGUoKTtcblx0XHR9XG5cdFx0dGhpcy5iaXRtYXBDYWNoZS5kZWZpbmUodGhpcywgeCwgeSwgd2lkdGgsIGhlaWdodCwgc2NhbGUsIG9wdGlvbnMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlZHJhd3MgdGhlIGRpc3BsYXkgb2JqZWN0IHRvIGl0cyBjYWNoZS4gQ2FsbGluZyB1cGRhdGVDYWNoZSB3aXRob3V0IGFuIGFjdGl2ZSBjYWNoZSB3aWxsIHRocm93IGFuIGVycm9yLlxuXHQgKiBJZiBjb21wb3NpdGVPcGVyYXRpb24gaXMgbnVsbCB0aGUgY3VycmVudCBjYWNoZSB3aWxsIGJlIGNsZWFyZWQgcHJpb3IgdG8gZHJhd2luZy4gT3RoZXJ3aXNlIHRoZSBkaXNwbGF5IG9iamVjdFxuXHQgKiB3aWxsIGJlIGRyYXduIG92ZXIgdGhlIGV4aXN0aW5nIGNhY2hlIHVzaW5nIHRoZSBzcGVjaWZpZWQgY29tcG9zaXRlT3BlcmF0aW9uLlxuXHQgKlxuXHQgKiBBY3R1YWwgaW1wbGVtZW50YXRpb24gb2YgdGhlIGNhY2hpbmcgbWVjaGFuaXNtIGNhbiBjaGFuZ2Ugd2l0aCBhIHtAbGluayBlYXNlbGpzLlN0YWdlR0x9IGFuZCBzb1xuXHQgKiBhbGwgY2FjaGluZyBhbmQgZmlsdGVyIGJlaGF2aW91ciBoYXMgYmVlbiBtb3ZlZCB0byB0aGUge0BsaW5rIGVhc2VsanMuQml0bWFwQ2FjaGV9XG5cdCAqXG5cdCAqIEBleGFtcGxlXG5cdCAqIC8vIGNsZWFyIGN1cnJlbnQgZ3JhcGhpY3Ncblx0ICogc2hhcGVJbnN0YW5jZS5jbGVhcigpO1xuXHQgKiAvLyBkcmF3IG5ldyBpbnN0cnVjdGlvbnNcblx0ICogc2hhcGVJbnN0YW5jZS5zZXRTdHJva2VTdHlsZSgzKS5iZWdpblN0cm9rZShcIiNGRjAwMDBcIikubW92ZVRvKDEwMCwgMTAwKS5saW5lVG8oMjAwLDIwMCk7XG5cdCAqIC8vIHVwZGF0ZSBjYWNoZSwgZHJhd2luZyBuZXcgbGluZSBvbiB0b3Agb2Ygb2xkIG9uZVxuXHQgKiBzaGFwZUluc3RhbmNlLnVwZGF0ZUNhY2hlKCk7XG5cdCAqXG5cdCAqIEBzZWUge0BsaW5rIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3RoZS1jYW52YXMtZWxlbWVudC5odG1sI2NvbXBvc2l0aW5nIFwiV0hBVFdHIHNwZWMgb24gY29tcG9zaXRpbmdcIn1cblx0ICogQHBhcmFtIHtTdHJpbmd9IGNvbXBvc2l0ZU9wZXJhdGlvbiBUaGUgY29tcG9zaXRlT3BlcmF0aW9uIHRvIHVzZSwgb3IgbnVsbCB0byBjbGVhciB0aGUgY2FjaGUgYW5kIHJlZHJhdyBpdC5cblx0ICovXG5cdHVwZGF0ZUNhY2hlIChjb21wb3NpdGVPcGVyYXRpb24pIHtcblx0XHRpZiAoIXRoaXMuYml0bWFwQ2FjaGUpIHtcblx0XHRcdHRocm93IFwiTm8gY2FjaGUgZm91bmQuIGNhY2hlKCkgbXVzdCBiZSBjYWxsZWQgYmVmb3JlIHVwZGF0ZUNhY2hlKClcIjtcblx0XHR9XG5cdFx0dGhpcy5iaXRtYXBDYWNoZS51cGRhdGUoY29tcG9zaXRlT3BlcmF0aW9uKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDbGVhcnMgdGhlIGN1cnJlbnQgY2FjaGUuXG5cdCAqIEBzZWUge0BsaW5rIGVhc2VsanMuRGlzcGxheU9iamVjdC4jY2FjaGV9XG5cdCAqL1xuXHR1bmNhY2hlICgpIHtcblx0XHRpZiAodGhpcy5iaXRtYXBDYWNoZSkge1xuXHRcdFx0dGhpcy5iaXRtYXBDYWNoZS5yZWxlYXNlKCk7XG5cdFx0XHR0aGlzLmJpdG1hcENhY2hlID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgZGF0YSBVUkwgZm9yIHRoZSBjYWNoZSwgb3IgbnVsbCBpZiB0aGlzIGRpc3BsYXkgb2JqZWN0IGlzIG5vdCBjYWNoZWQuXG5cdCAqIE9ubHkgZ2VuZXJhdGVkIGlmIHRoZSBjYWNoZSBoYXMgY2hhbmdlZCwgb3RoZXJ3aXNlIHJldHVybnMgbGFzdCByZXN1bHQuXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGltYWdlIGRhdGEgdXJsIGZvciB0aGUgY2FjaGUuXG5cdCAqL1xuXHRnZXRDYWNoZURhdGFVUkwgKCkge1xuXHRcdHJldHVybiB0aGlzLmJpdG1hcENhY2hlID8gdGhpcy5iaXRtYXBDYWNoZS5nZXREYXRhVVJMKCkgOiBudWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRyYW5zZm9ybXMgdGhlIHNwZWNpZmllZCB4IGFuZCB5IHBvc2l0aW9uIGZyb20gdGhlIGNvb3JkaW5hdGUgc3BhY2Ugb2YgdGhlIGRpc3BsYXkgb2JqZWN0XG5cdCAqIHRvIHRoZSBnbG9iYWwgKHN0YWdlKSBjb29yZGluYXRlIHNwYWNlLiBGb3IgZXhhbXBsZSwgdGhpcyBjb3VsZCBiZSB1c2VkIHRvIHBvc2l0aW9uIGFuIEhUTUwgbGFiZWxcblx0ICogb3ZlciBhIHNwZWNpZmljIHBvaW50IG9uIGEgbmVzdGVkIGRpc3BsYXkgb2JqZWN0LiBSZXR1cm5zIGEgUG9pbnQgaW5zdGFuY2Ugd2l0aCB4IGFuZCB5IHByb3BlcnRpZXNcblx0ICogY29ycmVsYXRpbmcgdG8gdGhlIHRyYW5zZm9ybWVkIGNvb3JkaW5hdGVzIG9uIHRoZSBzdGFnZS5cblx0ICpcblx0ICogQGV4YW1wbGVcblx0ICogZGlzcGxheU9iamVjdC54ID0gMzAwO1xuXHQgKiBkaXNwbGF5T2JqZWN0LnkgPSAyMDA7XG5cdCAqIHN0YWdlLmFkZENoaWxkKGRpc3BsYXlPYmplY3QpO1xuXHQgKiBsZXQgcG9pbnQgPSBkaXNwbGF5T2JqZWN0LmxvY2FsVG9HbG9iYWwoMTAwLCAxMDApO1xuXHQgKiAvLyBSZXN1bHRzIGluIHg9NDAwLCB5PTMwMFxuXHQgKlxuXHQgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgeCBwb3NpdGlvbiBpbiB0aGUgc291cmNlIGRpc3BsYXkgb2JqZWN0IHRvIHRyYW5zZm9ybS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHkgcG9zaXRpb24gaW4gdGhlIHNvdXJjZSBkaXNwbGF5IG9iamVjdCB0byB0cmFuc2Zvcm0uXG5cdCAqIEBwYXJhbSB7ZWFzZWxqcy5Qb2ludCB8IE9iamVjdH0gW3B0PVBvaW50XSBBbiBvYmplY3QgdG8gY29weSB0aGUgcmVzdWx0IGludG8uIElmIG9taXR0ZWQgYSBuZXcgUG9pbnQgb2JqZWN0IHdpdGggeC95IHByb3BlcnRpZXMgd2lsbCBiZSByZXR1cm5lZC5cblx0ICogQHJldHVybiB7ZWFzZWxqcy5Qb2ludH0gQSBQb2ludCBpbnN0YW5jZSB3aXRoIHggYW5kIHkgcHJvcGVydGllcyBjb3JyZWxhdGluZyB0byB0aGUgdHJhbnNmb3JtZWQgY29vcmRpbmF0ZXNcblx0ICogb24gdGhlIHN0YWdlLlxuXHQgKi9cblx0bG9jYWxUb0dsb2JhbCAoeCwgeSwgcHQgPSBuZXcgUG9pbnQoKSkge1xuXHRcdHJldHVybiB0aGlzLmdldENvbmNhdGVuYXRlZE1hdHJpeCh0aGlzLl9wcm9wcy5tYXRyaXgpLnRyYW5zZm9ybVBvaW50KHgsIHksIHB0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUcmFuc2Zvcm1zIHRoZSBzcGVjaWZpZWQgeCBhbmQgeSBwb3NpdGlvbiBmcm9tIHRoZSBnbG9iYWwgKHN0YWdlKSBjb29yZGluYXRlIHNwYWNlIHRvIHRoZVxuXHQgKiBjb29yZGluYXRlIHNwYWNlIG9mIHRoZSBkaXNwbGF5IG9iamVjdC4gRm9yIGV4YW1wbGUsIHRoaXMgY291bGQgYmUgdXNlZCB0byBkZXRlcm1pbmVcblx0ICogdGhlIGN1cnJlbnQgbW91c2UgcG9zaXRpb24gd2l0aGluIHRoZSBkaXNwbGF5IG9iamVjdC4gUmV0dXJucyBhIFBvaW50IGluc3RhbmNlIHdpdGggeCBhbmQgeSBwcm9wZXJ0aWVzXG5cdCAqIGNvcnJlbGF0aW5nIHRvIHRoZSB0cmFuc2Zvcm1lZCBwb3NpdGlvbiBpbiB0aGUgZGlzcGxheSBvYmplY3QncyBjb29yZGluYXRlIHNwYWNlLlxuXHQgKlxuXHQgKiBAZXhhbXBsZVxuXHQgKiBkaXNwbGF5T2JqZWN0LnggPSAzMDA7XG5cdCAqIGRpc3BsYXlPYmplY3QueSA9IDIwMDtcblx0ICogc3RhZ2UuYWRkQ2hpbGQoZGlzcGxheU9iamVjdCk7XG5cdCAqIGxldCBwb2ludCA9IGRpc3BsYXlPYmplY3QuZ2xvYmFsVG9Mb2NhbCgxMDAsIDEwMCk7XG5cdCAqIC8vIFJlc3VsdHMgaW4geD0tMjAwLCB5PS0xMDBcblx0ICpcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIHggcG9zaXRpb24gb24gdGhlIHN0YWdlIHRvIHRyYW5zZm9ybS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHkgcG9zaXRpb24gb24gdGhlIHN0YWdlIHRvIHRyYW5zZm9ybS5cblx0ICogQHBhcmFtIHtlYXNlbGpzLlBvaW50IHwgT2JqZWN0fSBbcHQ9UG9pbnRdIEFuIG9iamVjdCB0byBjb3B5IHRoZSByZXN1bHQgaW50by4gSWYgb21pdHRlZCBhIG5ldyBQb2ludCBvYmplY3Qgd2l0aCB4L3kgcHJvcGVydGllcyB3aWxsIGJlIHJldHVybmVkLlxuXHQgKiBAcmV0dXJuIHtlYXNlbGpzLlBvaW50fSBBIFBvaW50IGluc3RhbmNlIHdpdGggeCBhbmQgeSBwcm9wZXJ0aWVzIGNvcnJlbGF0aW5nIHRvIHRoZSB0cmFuc2Zvcm1lZCBwb3NpdGlvbiBpbiB0aGVcblx0ICogZGlzcGxheSBvYmplY3QncyBjb29yZGluYXRlIHNwYWNlLlxuXHQgKi9cblx0Z2xvYmFsVG9Mb2NhbCAoeCwgeSwgcHQgPSBuZXcgUG9pbnQoKSkge1xuXHRcdHJldHVybiB0aGlzLmdldENvbmNhdGVuYXRlZE1hdHJpeCh0aGlzLl9wcm9wcy5tYXRyaXgpLmludmVydCgpLnRyYW5zZm9ybVBvaW50KHgsIHksIHB0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUcmFuc2Zvcm1zIHRoZSBzcGVjaWZpZWQgeCBhbmQgeSBwb3NpdGlvbiBmcm9tIHRoZSBjb29yZGluYXRlIHNwYWNlIG9mIHRoaXMgZGlzcGxheSBvYmplY3QgdG8gdGhlIGNvb3JkaW5hdGVcblx0ICogc3BhY2Ugb2YgdGhlIHRhcmdldCBkaXNwbGF5IG9iamVjdC4gUmV0dXJucyBhIFBvaW50IGluc3RhbmNlIHdpdGggeCBhbmQgeSBwcm9wZXJ0aWVzIGNvcnJlbGF0aW5nIHRvIHRoZVxuXHQgKiB0cmFuc2Zvcm1lZCBwb3NpdGlvbiBpbiB0aGUgdGFyZ2V0J3MgY29vcmRpbmF0ZSBzcGFjZS4gRWZmZWN0aXZlbHkgdGhlIHNhbWUgYXMgdXNpbmcgdGhlIGZvbGxvd2luZyBjb2RlIHdpdGhcblx0ICoge0BsaW5rIGVhc2VsanMuRGlzcGxheU9iamVjdCNsb2NhbFRvR2xvYmFsfSBhbmQge0BsaW5rIGVhc2VsanMuRGlzcGxheU9iamVjdCNnbG9iYWxUb0xvY2FsfS5cblx0ICpcblx0ICogQGV4YW1wbGVcblx0ICogLy8gbG9uZyB3YXlcblx0ICogbGV0IHB0ID0gdGhpcy5sb2NhbFRvR2xvYmFsKHgsIHkpO1xuXHQgKiBwdCA9IHRhcmdldC5nbG9iYWxUb0xvY2FsKHB0LngsIHB0LnkpO1xuXHQgKiAvLyBzaG9ydGhhbmRcblx0ICogbGV0IHB0ID0gdGhpcy5sb2NhbFRvTG9jYWwoeCwgeSwgdGFyZ2V0KTtcblx0ICpcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIHggcG9zaXRpb24gaW4gdGhlIHNvdXJjZSBkaXNwbGF5IG9iamVjdCB0byB0cmFuc2Zvcm0uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IHBvc2l0aW9uIG9uIHRoZSBzb3VyY2UgZGlzcGxheSBvYmplY3QgdG8gdHJhbnNmb3JtLlxuXHQgKiBAcGFyYW0ge2Vhc2VsanMuRGlzcGxheU9iamVjdH0gdGFyZ2V0IFRoZSB0YXJnZXQgZGlzcGxheSBvYmplY3QgdG8gd2hpY2ggdGhlIGNvb3JkaW5hdGVzIHdpbGwgYmUgdHJhbnNmb3JtZWQuXG5cdCAqIEBwYXJhbSB7ZWFzZWxqcy5Qb2ludCB8IE9iamVjdH0gW3B0XSBBbiBvYmplY3QgdG8gY29weSB0aGUgcmVzdWx0IGludG8uIElmIG9taXR0ZWQgYSBuZXcgUG9pbnQgb2JqZWN0IHdpdGggeC95IHByb3BlcnRpZXMgd2lsbCBiZSByZXR1cm5lZC5cblx0ICogQHJldHVybiB7ZWFzZWxqcy5Qb2ludH0gUmV0dXJucyBhIFBvaW50IGluc3RhbmNlIHdpdGggeCBhbmQgeSBwcm9wZXJ0aWVzIGNvcnJlbGF0aW5nIHRvIHRoZSB0cmFuc2Zvcm1lZCBwb3NpdGlvblxuXHQgKiBpbiB0aGUgdGFyZ2V0J3MgY29vcmRpbmF0ZSBzcGFjZS5cblx0ICovXG5cdGxvY2FsVG9Mb2NhbCAoeCwgeSwgdGFyZ2V0LCBwdCkge1xuXHRcdHB0ID0gdGhpcy5sb2NhbFRvR2xvYmFsKHgsIHksIHB0KTtcblx0XHRyZXR1cm4gdGFyZ2V0Lmdsb2JhbFRvTG9jYWwocHQueCwgcHQueSwgcHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IG1ldGhvZCB0byBxdWlja2x5IHNldCB0aGUgdHJhbnNmb3JtIHByb3BlcnRpZXMgb24gdGhlIGRpc3BsYXkgb2JqZWN0LiBBbGwgcGFyYW1ldGVycyBhcmUgb3B0aW9uYWwuXG5cdCAqIE9taXR0ZWQgcGFyYW1ldGVycyB3aWxsIGhhdmUgdGhlIGRlZmF1bHQgdmFsdWUgc2V0LlxuXHQgKlxuXHQgKiBAZXhhbXBsZVxuXHQgKiBkaXNwbGF5T2JqZWN0LnNldFRyYW5zZm9ybSgxMDAsIDEwMCwgMiwgMik7XG5cdCAqXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbeD0wXSBUaGUgaG9yaXpvbnRhbCB0cmFuc2xhdGlvbiAoeCBwb3NpdGlvbikgaW4gcGl4ZWxzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbeT0wXSBUaGUgdmVydGljYWwgdHJhbnNsYXRpb24gKHkgcG9zaXRpb24pIGluIHBpeGVsc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gW3NjYWxlWD0xXSBUaGUgaG9yaXpvbnRhbCBzY2FsZSwgYXMgYSBwZXJjZW50YWdlIG9mIDFcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtzY2FsZVk9MV0gdGhlIHZlcnRpY2FsIHNjYWxlLCBhcyBhIHBlcmNlbnRhZ2Ugb2YgMVxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3JvdGF0aW9uPTBdIFRoZSByb3RhdGlvbiwgaW4gZGVncmVlc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gW3NrZXdYPTBdIFRoZSBob3Jpem9udGFsIHNrZXcgZmFjdG9yXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbc2tld1k9MF0gVGhlIHZlcnRpY2FsIHNrZXcgZmFjdG9yXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbcmVnWD0wXSBUaGUgaG9yaXpvbnRhbCByZWdpc3RyYXRpb24gcG9pbnQgaW4gcGl4ZWxzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbcmVnWT0wXSBUaGUgdmVydGljYWwgcmVnaXN0cmF0aW9uIHBvaW50IGluIHBpeGVsc1xuXHQgKiBAcmV0dXJuIHtlYXNlbGpzLkRpc3BsYXlPYmplY3R9IFJldHVybnMgdGhpcyBpbnN0YW5jZS4gVXNlZnVsIGZvciBjaGFpbmluZyBjb21tYW5kcy5cblx0Ki9cblx0c2V0VHJhbnNmb3JtICh4PTAsIHk9MCwgc2NhbGVYPTEsIHNjYWxlWT0xLCByb3RhdGlvbj0wLCBza2V3WD0wLCBza2V3WT0wLCByZWdYPTAsIHJlZ1k9MCkge1xuXHRcdHRoaXMueCA9IHg7XG5cdFx0dGhpcy55ID0geTtcblx0XHR0aGlzLnNjYWxlWCA9IHNjYWxlWDtcblx0XHR0aGlzLnNjYWxlWSA9IHNjYWxlWTtcblx0XHR0aGlzLnJvdGF0aW9uID0gcm90YXRpb247XG5cdFx0dGhpcy5za2V3WCA9IHNrZXdYO1xuXHRcdHRoaXMuc2tld1kgPSBza2V3WTtcblx0XHR0aGlzLnJlZ1ggPSByZWdYO1xuXHRcdHRoaXMucmVnWSA9IHJlZ1k7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIG1hdHJpeCBiYXNlZCBvbiB0aGlzIG9iamVjdCdzIGN1cnJlbnQgdHJhbnNmb3JtLlxuXHQgKiBAcGFyYW0ge2Vhc2VsanMuTWF0cml4MkR9IFttYXRyaXhdIEEgTWF0cml4MkQgb2JqZWN0IHRvIHBvcHVsYXRlIHdpdGggdGhlIGNhbGN1bGF0ZWQgdmFsdWVzLiBJZiBudWxsLCBhIG5ldyBNYXRyaXggb2JqZWN0IGlzIHJldHVybmVkLlxuXHQgKiBAcmV0dXJuIHtlYXNlbGpzLk1hdHJpeDJEfSBBIG1hdHJpeCByZXByZXNlbnRpbmcgdGhpcyBkaXNwbGF5IG9iamVjdCdzIHRyYW5zZm9ybS5cblx0ICovXG5cdGdldE1hdHJpeCAobWF0cml4KSB7XG5cdFx0bGV0IG8gPSB0aGlzLCBtdHggPSBtYXRyaXgmJm1hdHJpeC5pZGVudGl0eSgpIHx8IG5ldyBNYXRyaXgyRCgpO1xuXHRcdHJldHVybiBvLnRyYW5zZm9ybU1hdHJpeCA/ICBtdHguY29weShvLnRyYW5zZm9ybU1hdHJpeCkgOiBtdHguYXBwZW5kVHJhbnNmb3JtKG8ueCwgby55LCBvLnNjYWxlWCwgby5zY2FsZVksIG8ucm90YXRpb24sIG8uc2tld1gsIG8uc2tld1ksIG8ucmVnWCwgby5yZWdZKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZW5lcmF0ZXMgYSBNYXRyaXgyRCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBjb21iaW5lZCB0cmFuc2Zvcm0gb2YgdGhlIGRpc3BsYXkgb2JqZWN0IGFuZCBhbGwgb2YgaXRzXG5cdCAqIHBhcmVudCBDb250YWluZXJzIHVwIHRvIHRoZSBoaWdoZXN0IGxldmVsIGFuY2VzdG9yICh1c3VhbGx5IHRoZSB7QGxpbmsgZWFzZWxqcy5TdGFnZX0pLiBUaGlzIGNhblxuXHQgKiBiZSB1c2VkIHRvIHRyYW5zZm9ybSBwb3NpdGlvbnMgYmV0d2VlbiBjb29yZGluYXRlIHNwYWNlcywgc3VjaCBhcyB3aXRoIHtAbGluayBlYXNlbGpzLkRpc3BsYXlPYmplY3QjbG9jYWxUb0dsb2JhbH1cblx0ICogYW5kIHtAbGluayBlYXNlbGpzLkRpc3BsYXlPYmplY3QjZ2xvYmFsVG9Mb2NhbH0uXG5cdCAqXG5cdCAqIEBwYXJhbSB7ZWFzZWxqcy5NYXRyaXgyRH0gW21hdHJpeF0gQSBNYXRyaXgyRCBvYmplY3QgdG8gcG9wdWxhdGUgd2l0aCB0aGUgY2FsY3VsYXRlZCB2YWx1ZXMuIElmIG51bGwsIGEgbmV3IE1hdHJpeDJEIG9iamVjdCBpcyByZXR1cm5lZC5cblx0ICogQHJldHVybiB7ZWFzZWxqcy5NYXRyaXgyRH0gVGhlIGNvbWJpbmVkIG1hdHJpeC5cblx0ICovXG5cdGdldENvbmNhdGVuYXRlZE1hdHJpeCAobWF0cml4KSB7XG5cdFx0bGV0IG8gPSB0aGlzLCBtdHggPSB0aGlzLmdldE1hdHJpeChtYXRyaXgpO1xuXHRcdHdoaWxlIChvID0gby5wYXJlbnQpIHtcblx0XHRcdG10eC5wcmVwZW5kTWF0cml4KG8uZ2V0TWF0cml4KG8uX3Byb3BzLm1hdHJpeCkpO1xuXHRcdH1cblx0XHRyZXR1cm4gbXR4O1xuXHR9XG5cblx0LyoqXG5cdCAqIEdlbmVyYXRlcyBhIERpc3BsYXlQcm9wcyBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBjb21iaW5lZCBkaXNwbGF5IHByb3BlcnRpZXMgb2YgdGhlICBvYmplY3QgYW5kIGFsbCBvZiBpdHNcblx0ICogcGFyZW50IENvbnRhaW5lcnMgdXAgdG8gdGhlIGhpZ2hlc3QgbGV2ZWwgYW5jZXN0b3IgKHVzdWFsbHkgdGhlIHtAbGluayBlYXNlbGpzLlN0YWdlfSkuXG5cdCAqIEBwYXJhbSB7ZWFzZWxqcy5EaXNwbGF5UHJvcHN9IFtwcm9wc10gQSBEaXNwbGF5UHJvcHMgb2JqZWN0IHRvIHBvcHVsYXRlIHdpdGggdGhlIGNhbGN1bGF0ZWQgdmFsdWVzLiBJZiBudWxsLCBhIG5ldyBEaXNwbGF5UHJvcHMgb2JqZWN0IGlzIHJldHVybmVkLlxuXHQgKiBAcmV0dXJuIHtlYXNlbGpzLkRpc3BsYXlQcm9wc30gVGhlIGNvbWJpbmVkIGRpc3BsYXkgcHJvcGVydGllcy5cblx0ICovXG5cdGdldENvbmNhdGVuYXRlZERpc3BsYXlQcm9wcyAocHJvcHMpIHtcblx0XHRwcm9wcyA9IHByb3BzID8gcHJvcHMuaWRlbnRpdHkoKSA6IG5ldyBEaXNwbGF5UHJvcHMoKTtcblx0XHRsZXQgbyA9IHRoaXMsIG10eCA9IG8uZ2V0TWF0cml4KHByb3BzLm1hdHJpeCk7XG5cdFx0ZG8ge1xuXHRcdFx0cHJvcHMucHJlcGVuZChvLnZpc2libGUsIG8uYWxwaGEsIG8uc2hhZG93LCBvLmNvbXBvc2l0ZU9wZXJhdGlvbik7XG5cblx0XHRcdC8vIHdlIGRvIHRoaXMgdG8gYXZvaWQgcHJvYmxlbXMgd2l0aCB0aGUgbWF0cml4IGJlaW5nIHVzZWQgZm9yIGJvdGggb3BlcmF0aW9ucyB3aGVuIG8uX3Byb3BzLm1hdHJpeCBpcyBwYXNzZWQgaW4gYXMgdGhlIHByb3BzIHBhcmFtLlxuXHRcdFx0Ly8gdGhpcyBjb3VsZCBiZSBzaW1wbGlmaWVkIChpZS4ganVzdCBkb25lIGFzIHBhcnQgb2YgdGhlIHByZXBlbmQgYWJvdmUpIGlmIHdlIHN3aXRjaGVkIHRvIHVzaW5nIGEgcG9vbC5cblx0XHRcdGlmIChvICE9IHRoaXMpIHsgbXR4LnByZXBlbmRNYXRyaXgoby5nZXRNYXRyaXgoby5fcHJvcHMubWF0cml4KSk7IH1cblx0XHR9IHdoaWxlIChvID0gby5wYXJlbnQpO1xuXHRcdHJldHVybiBwcm9wcztcblx0fVxuXG5cdC8qKlxuXHQgKiBUZXN0cyB3aGV0aGVyIHRoZSBkaXNwbGF5IG9iamVjdCBpbnRlcnNlY3RzIHRoZSBzcGVjaWZpZWQgcG9pbnQgaW4gbG9jYWwgY29vcmRpbmF0ZXMgKGllLiBkcmF3cyBhIHBpeGVsIHdpdGggYWxwaGEgPiAwIGF0XG5cdCAqIHRoZSBzcGVjaWZpZWQgcG9zaXRpb24pLiBUaGlzIGlnbm9yZXMgdGhlIGFscGhhLCBzaGFkb3csIGhpdEFyZWEsIG1hc2ssIGFuZCBjb21wb3NpdGVPcGVyYXRpb24gb2YgdGhlIGRpc3BsYXkgb2JqZWN0LlxuXHQgKlxuXHQgKiBQbGVhc2Ugbm90ZSB0aGF0IHNoYXBlLXRvLXNoYXBlIGNvbGxpc2lvbiBpcyBub3QgY3VycmVudGx5IHN1cHBvcnRlZCBieSBFYXNlbEpTLlxuXHQgKlxuXHQgKiBAZXhhbXBsZVxuXHQgKiBzdGFnZS5hZGRFdmVudExpc3RlbmVyKFwic3RhZ2Vtb3VzZWRvd25cIiwgZXZlbnQgPT4ge1xuXHQgKiAgIGxldCBoaXQgPSBzaGFwZS5oaXRUZXN0KGV2ZW50LnN0YWdlWCwgZXZlbnQuc3RhZ2VZKTtcblx0ICogICAvLyBoaXQgPT0gdHJ1ZSB3aGVuIHNoYXBlIGlzIGNsaWNrZWRcblx0ICogfSk7XG5cdCAqXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IHBvc2l0aW9uIHRvIGNoZWNrIGluIHRoZSBkaXNwbGF5IG9iamVjdCdzIGxvY2FsIGNvb3JkaW5hdGVzLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgeSBwb3NpdGlvbiB0byBjaGVjayBpbiB0aGUgZGlzcGxheSBvYmplY3QncyBsb2NhbCBjb29yZGluYXRlcy5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gQSBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciBhIHZpc2libGUgcG9ydGlvbiBvZiB0aGUgRGlzcGxheU9iamVjdCBpbnRlcnNlY3QgdGhlIHNwZWNpZmllZFxuXHQgKiBsb2NhbCBQb2ludC5cblx0Ki9cblx0aGl0VGVzdCAoeCwgeSkge1xuXHRcdGxldCBjdHggPSBEaXNwbGF5T2JqZWN0Ll9oaXRUZXN0Q29udGV4dDtcblx0XHRjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIC14LCAteSk7XG5cdFx0dGhpcy5kcmF3KGN0eCk7XG5cblx0XHRsZXQgaGl0ID0gdGhpcy5fdGVzdEhpdChjdHgpO1xuXHRcdGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG5cdFx0Y3R4LmNsZWFyUmVjdCgwLCAwLCAyLCAyKTtcblx0XHRyZXR1cm4gaGl0O1xuXHR9XG5cblx0LyoqXG5cdCAqIFByb3ZpZGVzIGEgY2hhaW5hYmxlIHNob3J0Y3V0IG1ldGhvZCBmb3Igc2V0dGluZyBhIG51bWJlciBvZiBwcm9wZXJ0aWVzIG9uIHRoZSBpbnN0YW5jZS5cblx0ICpcblx0ICogQGV4YW1wbGVcblx0ICogbGV0IGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKCkuYmVnaW5GaWxsKFwiI2ZmMDAwMFwiKS5kcmF3Q2lyY2xlKDAsIDAsIDI1KTtcblx0ICogbGV0IHNoYXBlID0gc3RhZ2UuYWRkQ2hpbGQobmV3IFNoYXBlKCkpLnNldCh7IGdyYXBoaWNzLCB4OiAxMDAsIHk6IDEwMCwgYWxwaGE6IDAuNSB9KTtcblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEEgZ2VuZXJpYyBvYmplY3QgY29udGFpbmluZyBwcm9wZXJ0aWVzIHRvIGNvcHkgdG8gdGhlIERpc3BsYXlPYmplY3QgaW5zdGFuY2UuXG5cdCAqIEByZXR1cm4ge2Vhc2VsanMuRGlzcGxheU9iamVjdH0gUmV0dXJucyB0aGUgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCovXG5cdHNldCAocHJvcHMpIHtcblx0XHRmb3IgKGxldCBuIGluIHByb3BzKSB7IHRoaXNbbl0gPSBwcm9wc1tuXTsgfVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSByZWN0YW5nbGUgcmVwcmVzZW50aW5nIHRoaXMgb2JqZWN0J3MgYm91bmRzIGluIGl0cyBsb2NhbCBjb29yZGluYXRlIHN5c3RlbSAoaWUuIHdpdGggbm8gdHJhbnNmb3JtYXRpb24pLlxuXHQgKiBPYmplY3RzIHRoYXQgaGF2ZSBiZWVuIGNhY2hlZCB3aWxsIHJldHVybiB0aGUgYm91bmRzIG9mIHRoZSBjYWNoZS5cblx0ICpcblx0ICogTm90IGFsbCBkaXNwbGF5IG9iamVjdHMgY2FuIGNhbGN1bGF0ZSB0aGVpciBvd24gYm91bmRzIChleC4gU2hhcGUpLiBGb3IgdGhlc2Ugb2JqZWN0cywgeW91IGNhbiB1c2Vcblx0ICoge0BsaW5rIGVhc2VsanMuRGlzcGxheU9iamVjdCNzZXRCb3VuZHN9IHNvIHRoYXQgdGhleSBhcmUgaW5jbHVkZWQgd2hlbiBjYWxjdWxhdGluZyBDb250YWluZXIgYm91bmRzLlxuXHQgKlxuXHQgKiA8dGFibGU+XG5cdCAqIFx0PHRyPjx0ZD48Yj5BbGw8L2I+PC90ZD48dGQ+XG5cdCAqIFx0XHRBbGwgZGlzcGxheSBvYmplY3RzIHN1cHBvcnQgc2V0dGluZyBib3VuZHMgbWFudWFsbHkgdXNpbmcgc2V0Qm91bmRzKCkuIExpa2V3aXNlLCBkaXNwbGF5IG9iamVjdHMgdGhhdFxuXHQgKiBcdFx0aGF2ZSBiZWVuIGNhY2hlZCB1c2luZyBjYWNoZSgpIHdpbGwgcmV0dXJuIHRoZSBib3VuZHMgb2YgdGhlaXIgY2FjaGUuIE1hbnVhbCBhbmQgY2FjaGUgYm91bmRzIHdpbGwgb3ZlcnJpZGVcblx0ICogXHRcdHRoZSBhdXRvbWF0aWMgY2FsY3VsYXRpb25zIGxpc3RlZCBiZWxvdy5cblx0ICogXHQ8L3RkPjwvdHI+XG5cdCAqIFx0PHRyPjx0ZD48Yj5CaXRtYXA8L2I+PC90ZD48dGQ+XG5cdCAqIFx0XHRSZXR1cm5zIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBzb3VyY2VSZWN0IChpZiBzcGVjaWZpZWQpIG9yIGltYWdlLCBleHRlbmRpbmcgZnJvbSAoeD0wLHk9MCkuXG5cdCAqIFx0PC90ZD48L3RyPlxuXHQgKiBcdDx0cj48dGQ+PGI+U3ByaXRlPC9iPjwvdGQ+PHRkPlxuXHQgKiBcdFx0UmV0dXJucyB0aGUgYm91bmRzIG9mIHRoZSBjdXJyZW50IGZyYW1lLiBNYXkgaGF2ZSBub24temVybyB4L3kgaWYgYSBmcmFtZSByZWdpc3RyYXRpb24gcG9pbnQgd2FzIHNwZWNpZmllZFxuXHQgKiBcdFx0aW4gdGhlIHNwcml0ZXNoZWV0IGRhdGEuIFNlZSBhbHNvIHtAbGluayBlYXNlbGpzLlNwcml0ZVNoZWV0I2dldEZyYW1lQm91bmRzfVxuXHQgKiBcdDwvdGQ+PC90cj5cblx0ICogXHQ8dHI+PHRkPjxiPkNvbnRhaW5lcjwvYj48L3RkPjx0ZD5cblx0ICogXHRcdFJldHVybnMgdGhlIGFnZ3JlZ2F0ZSAoY29tYmluZWQpIGJvdW5kcyBvZiBhbGwgY2hpbGRyZW4gdGhhdCByZXR1cm4gYSBub24tbnVsbCB2YWx1ZSBmcm9tIGdldEJvdW5kcygpLlxuXHQgKiBcdDwvdGQ+PC90cj5cblx0ICogXHQ8dHI+PHRkPjxiPlNoYXBlPC9iPjwvdGQ+PHRkPlxuXHQgKiBcdFx0RG9lcyBub3QgY3VycmVudGx5IHN1cHBvcnQgYXV0b21hdGljIGJvdW5kcyBjYWxjdWxhdGlvbnMuIFVzZSBzZXRCb3VuZHMoKSB0byBtYW51YWxseSBkZWZpbmUgYm91bmRzLlxuXHQgKiBcdDwvdGQ+PC90cj5cblx0ICogXHQ8dHI+PHRkPjxiPlRleHQ8L2I+PC90ZD48dGQ+XG5cdCAqIFx0XHRSZXR1cm5zIGFwcHJveGltYXRlIGJvdW5kcy4gSG9yaXpvbnRhbCB2YWx1ZXMgKHgvd2lkdGgpIGFyZSBxdWl0ZSBhY2N1cmF0ZSwgYnV0IHZlcnRpY2FsIHZhbHVlcyAoeS9oZWlnaHQpIGFyZVxuXHQgKiBcdFx0bm90LCBlc3BlY2lhbGx5IHdoZW4gdXNpbmcgdGV4dEJhc2VsaW5lIHZhbHVlcyBvdGhlciB0aGFuIFwidG9wXCIuXG5cdCAqIFx0PC90ZD48L3RyPlxuXHQgKiBcdDx0cj48dGQ+PGI+Qml0bWFwVGV4dDwvYj48L3RkPjx0ZD5cblx0ICogXHRcdFJldHVybnMgYXBwcm94aW1hdGUgYm91bmRzLiBWYWx1ZXMgd2lsbCBiZSBtb3JlIGFjY3VyYXRlIGlmIHNwcml0ZXNoZWV0IGZyYW1lIHJlZ2lzdHJhdGlvbiBwb2ludHMgYXJlIGNsb3NlXG5cdCAqIFx0XHR0byAoeD0wLHk9MCkuXG5cdCAqIFx0PC90ZD48L3RyPlxuXHQqIDwvdGFibGU+XG5cdCAqXG5cdCAqIEBleGFtcGxlXG5cdCAqIC8qIEJvdW5kcyBjYW4gYmUgZXhwZW5zaXZlIHRvIGNhbGN1bGF0ZSBmb3Igc29tZSBvYmplY3RzIChleC4gdGV4dCwgb3IgY29udGFpbmVycyB3aXRoIG1hbnkgY2hpbGRyZW4pLCBhbmRcblx0ICogYXJlIHJlY2FsY3VsYXRlZCBlYWNoIHRpbWUgeW91IGNhbGwgZ2V0Qm91bmRzKCkuIFlvdSBjYW4gcHJldmVudCByZWNhbGN1bGF0aW9uIG9uIHN0YXRpYyBvYmplY3RzIGJ5IHNldHRpbmcgdGhlXG5cdCAqIGJvdW5kcyBleHBsaWNpdGx5LiAqXFwvXG5cdCAqIGxldCBib3VuZHMgPSBvYmouZ2V0Qm91bmRzKCk7XG5cdCAqIG9iai5zZXRCb3VuZHMoYm91bmRzLngsIGJvdW5kcy55LCBib3VuZHMud2lkdGgsIGJvdW5kcy5oZWlnaHQpO1xuXHQgKiAvLyBnZXRCb3VuZHMgd2lsbCBub3cgdXNlIHRoZSBzZXQgdmFsdWVzLCBpbnN0ZWFkIG9mIHJlY2FsY3VsYXRpbmdcblx0ICpcblx0ICogQGV4YW1wbGVcblx0ICogLy8gVG8gcmVkdWNlIG1lbW9yeSBpbXBhY3QsIHRoZSByZXR1cm5lZCBSZWN0YW5nbGUgaW5zdGFuY2UgbWF5IGJlIHJldXNlZCBpbnRlcm5hbGx5XG5cdCAqIGxldCBib3VuZHMgPSBvYmouZ2V0Qm91bmRzKCkuY2xvbmUoKTtcblx0ICogLy8gT1I6XG5cdCAqIHJlY3QuY29weShvYmouZ2V0Qm91bmRzKCkpO1xuXHQgKlxuXHQgKiBAcmV0dXJuIHtlYXNlbGpzLlJlY3RhbmdsZX0gQSBSZWN0YW5nbGUgaW5zdGFuY2UgcmVwcmVzZW50aW5nIHRoZSBib3VuZHMsIG9yIG51bGwgaWYgYm91bmRzIGFyZSBub3QgYXZhaWxhYmxlIGZvciB0aGlzIG9iamVjdC5cblx0ICovXG5cdGdldEJvdW5kcyAoKSB7XG5cdFx0aWYgKHRoaXMuX2JvdW5kcykgeyByZXR1cm4gdGhpcy5fcmVjdGFuZ2xlLmNvcHkodGhpcy5fYm91bmRzKTsgfVxuXHRcdGxldCBjYWNoZUNhbnZhcyA9IHRoaXMuY2FjaGVDYW52YXM7XG5cdFx0aWYgKGNhY2hlQ2FudmFzKSB7XG5cdFx0XHRsZXQgc2NhbGUgPSB0aGlzLl9jYWNoZVNjYWxlO1xuXHRcdFx0cmV0dXJuIHRoaXMuX3JlY3RhbmdsZS5zZXRWYWx1ZXModGhpcy5fY2FjaGVPZmZzZXRYLCB0aGlzLl9jYWNoZU9mZnNldFksIGNhY2hlQ2FudmFzLndpZHRoL3NjYWxlLCBjYWNoZUNhbnZhcy5oZWlnaHQvc2NhbGUpO1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgcmVjdGFuZ2xlIHJlcHJlc2VudGluZyB0aGlzIG9iamVjdCdzIGJvdW5kcyBpbiBpdHMgcGFyZW50J3MgY29vcmRpbmF0ZSBzeXN0ZW0gKGllLiB3aXRoIHRyYW5zZm9ybWF0aW9ucyBhcHBsaWVkKS5cblx0ICogT2JqZWN0cyB0aGF0IGhhdmUgYmVlbiBjYWNoZWQgd2lsbCByZXR1cm4gdGhlIHRyYW5zZm9ybWVkIGJvdW5kcyBvZiB0aGUgY2FjaGUuXG5cdCAqXG5cdCAqIE5vdCBhbGwgZGlzcGxheSBvYmplY3RzIGNhbiBjYWxjdWxhdGUgdGhlaXIgb3duIGJvdW5kcyAoZXguIFNoYXBlKS4gRm9yIHRoZXNlIG9iamVjdHMsIHlvdSBjYW4gdXNlXG5cdCAqIHtAbGluayBlYXNlbGpzLkRpc3BsYXlPYmplY3Qjc2V0Qm91bmRzfSBzbyB0aGF0IHRoZXkgYXJlIGluY2x1ZGVkIHdoZW4gY2FsY3VsYXRpbmcgQ29udGFpbmVyIGJvdW5kcy5cblx0ICpcblx0ICogVG8gcmVkdWNlIG1lbW9yeSBpbXBhY3QsIHRoZSByZXR1cm5lZCBSZWN0YW5nbGUgaW5zdGFuY2UgbWF5IGJlIHJldXNlZCBpbnRlcm5hbGx5OyBjbG9uZSB0aGUgaW5zdGFuY2Ugb3IgY29weSBpdHNcblx0ICogdmFsdWVzIGlmIHlvdSBuZWVkIHRvIHJldGFpbiBpdC5cblx0ICpcblx0ICogQ29udGFpbmVyIGluc3RhbmNlcyBjYWxjdWxhdGUgYWdncmVnYXRlIGJvdW5kcyBmb3IgYWxsIGNoaWxkcmVuIHRoYXQgcmV0dXJuIGJvdW5kcyB2aWEgZ2V0Qm91bmRzLlxuXHQgKiBAcmV0dXJuIHtlYXNlbGpzLlJlY3RhbmdsZX0gQSBSZWN0YW5nbGUgaW5zdGFuY2UgcmVwcmVzZW50aW5nIHRoZSBib3VuZHMsIG9yIG51bGwgaWYgYm91bmRzIGFyZSBub3QgYXZhaWxhYmxlIGZvciB0aGlzIG9iamVjdC5cblx0ICovXG5cdGdldFRyYW5zZm9ybWVkQm91bmRzICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fZ2V0Qm91bmRzKCk7XG5cdH1cblxuXHQvKipcblx0ICogQWxsb3dzIHlvdSB0byBtYW51YWxseSBzcGVjaWZ5IHRoZSBib3VuZHMgb2YgYW4gb2JqZWN0IHRoYXQgZWl0aGVyIGNhbm5vdCBjYWxjdWxhdGUgdGhlaXIgb3duIGJvdW5kcyAoZXguIFNoYXBlICZcblx0ICogVGV4dCkgZm9yIGZ1dHVyZSByZWZlcmVuY2UsIG9yIHNvIHRoZSBvYmplY3QgY2FuIGJlIGluY2x1ZGVkIGluIENvbnRhaW5lciBib3VuZHMuIE1hbnVhbGx5IHNldCBib3VuZHMgd2lsbCBhbHdheXNcblx0ICogb3ZlcnJpZGUgY2FsY3VsYXRlZCBib3VuZHMuXG5cdCAqXG5cdCAqIFRoZSBib3VuZHMgc2hvdWxkIGJlIHNwZWNpZmllZCBpbiB0aGUgb2JqZWN0J3MgbG9jYWwgKHVudHJhbnNmb3JtZWQpIGNvb3JkaW5hdGVzLiBGb3IgZXhhbXBsZSwgYSBTaGFwZSBpbnN0YW5jZVxuXHQgKiB3aXRoIGEgMjVweCByYWRpdXMgY2lyY2xlIGNlbnRlcmVkIGF0IDAsMCB3b3VsZCBoYXZlIGJvdW5kcyBvZiAoLTI1LCAtMjUsIDUwLCA1MCkuXG5cdCAqXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IG9yaWdpbiBvZiB0aGUgYm91bmRzLiBQYXNzIG51bGwgdG8gcmVtb3ZlIHRoZSBtYW51YWwgYm91bmRzLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgeSBvcmlnaW4gb2YgdGhlIGJvdW5kcy5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIFRoZSB3aWR0aCBvZiB0aGUgYm91bmRzLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IFRoZSBoZWlnaHQgb2YgdGhlIGJvdW5kcy5cblx0ICovXG5cdHNldEJvdW5kcyAoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuXHRcdGlmICh4ID09IG51bGwpIHsgdGhpcy5fYm91bmRzID0gbnVsbDsgfVxuXHRcdHRoaXMuX2JvdW5kcyA9ICh0aGlzLl9ib3VuZHMgfHwgbmV3IFJlY3RhbmdsZSgpKS5zZXRWYWx1ZXMoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIGNsb25lIG9mIHRoaXMgRGlzcGxheU9iamVjdC4gU29tZSBwcm9wZXJ0aWVzIHRoYXQgYXJlIHNwZWNpZmljIHRvIHRoaXMgaW5zdGFuY2UncyBjdXJyZW50IGNvbnRleHQgYXJlXG5cdCAqIHJldmVydGVkIHRvIHRoZWlyIGRlZmF1bHRzIChmb3IgZXhhbXBsZSAucGFyZW50KS4gQ2FjaGVzIGFyZSBub3QgbWFpbnRhaW5lZCBhY3Jvc3MgY2xvbmVzLCBhbmQgc29tZSBlbGVtZW50c1xuXHQgKiBhcmUgY29waWVkIGJ5IHJlZmVyZW5jZSAobWFza3MsIGluZGl2aWR1YWwgZmlsdGVyIGluc3RhbmNlcywgaGl0IGFyZWEpXG5cdCAqXG5cdCAqIEByZXR1cm4ge2Vhc2VsanMuRGlzcGxheU9iamVjdH0gQSBjbG9uZSBvZiB0aGUgY3VycmVudCBEaXNwbGF5T2JqZWN0IGluc3RhbmNlLlxuXHQgKi9cblx0Y2xvbmUgKCkge1xuXHRcdHJldHVybiB0aGlzLl9jbG9uZVByb3BzKG5ldyBEaXNwbGF5T2JqZWN0KCkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxuXHQgKi9cblx0dG9TdHJpbmcgKCkge1xuXHRcdHJldHVybiBgWyR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfSR7dGhpcy5uYW1lID8gYCAobmFtZT0ke3RoaXMubmFtZX0pYCA6IFwiXCJ9XWA7XG5cdH1cblxuXHQvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge2Vhc2VsanMuRGlzcGxheU9iamVjdH0gbyBUaGUgRGlzcGxheU9iamVjdCBpbnN0YW5jZSB3aGljaCB3aWxsIGhhdmUgcHJvcGVydGllcyBmcm9tIHRoZSBjdXJyZW50IERpc3BsYXlPYmplY3Rcblx0ICogaW5zdGFuY2UgY29waWVkIGludG8uXG5cdCAqIEByZXR1cm4ge2Vhc2VsanMuRGlzcGxheU9iamVjdH0gb1xuXHQgKi9cblx0X2Nsb25lUHJvcHMgKG8pIHtcblx0XHRvLmFscGhhID0gdGhpcy5hbHBoYTtcblx0XHRvLm1vdXNlRW5hYmxlZCA9IHRoaXMubW91c2VFbmFibGVkO1xuXHRcdG8udGlja0VuYWJsZWQgPSB0aGlzLnRpY2tFbmFibGVkO1xuXHRcdG8ubmFtZSA9IHRoaXMubmFtZTtcblx0XHRvLnJlZ1ggPSB0aGlzLnJlZ1g7XG5cdFx0by5yZWdZID0gdGhpcy5yZWdZO1xuXHRcdG8ucm90YXRpb24gPSB0aGlzLnJvdGF0aW9uO1xuXHRcdG8uc2NhbGVYID0gdGhpcy5zY2FsZVg7XG5cdFx0by5zY2FsZVkgPSB0aGlzLnNjYWxlWTtcblx0XHRvLnNoYWRvdyA9IHRoaXMuc2hhZG93O1xuXHRcdG8uc2tld1ggPSB0aGlzLnNrZXdYO1xuXHRcdG8uc2tld1kgPSB0aGlzLnNrZXdZO1xuXHRcdG8udmlzaWJsZSA9IHRoaXMudmlzaWJsZTtcblx0XHRvLnggID0gdGhpcy54O1xuXHRcdG8ueSA9IHRoaXMueTtcblx0XHRvLmNvbXBvc2l0ZU9wZXJhdGlvbiA9IHRoaXMuY29tcG9zaXRlT3BlcmF0aW9uO1xuXHRcdG8uc25hcFRvUGl4ZWwgPSB0aGlzLnNuYXBUb1BpeGVsO1xuXHRcdG8uZmlsdGVycyA9IHRoaXMuZmlsdGVycz09bnVsbD9udWxsOnRoaXMuZmlsdGVycy5zbGljZSgwKTtcblx0XHRvLm1hc2sgPSB0aGlzLm1hc2s7XG5cdFx0by5oaXRBcmVhID0gdGhpcy5oaXRBcmVhO1xuXHRcdG8uY3Vyc29yID0gdGhpcy5jdXJzb3I7XG5cdFx0by5fYm91bmRzID0gdGhpcy5fYm91bmRzO1xuXHRcdHJldHVybiBvO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuXHQgKiBAcGFyYW0ge2Vhc2VsanMuU2hhZG93fSBbc2hhZG93PVNoYWRvd11cblx0ICovXG5cdF9hcHBseVNoYWRvdyAoY3R4LCBzaGFkb3cgPSBTaGFkb3cuaWRlbnRpdHkpIHtcblx0XHRzaGFkb3cgPSBzaGFkb3c7XG5cdFx0Y3R4LnNoYWRvd0NvbG9yID0gc2hhZG93LmNvbG9yO1xuXHRcdGN0eC5zaGFkb3dPZmZzZXRYID0gc2hhZG93Lm9mZnNldFg7XG5cdFx0Y3R4LnNoYWRvd09mZnNldFkgPSBzaGFkb3cub2Zmc2V0WTtcblx0XHRjdHguc2hhZG93Qmx1ciA9IHNoYWRvdy5ibHVyO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHBhcmFtIHtPYmplY3R9IGV2dE9iaiBBbiBldmVudCBvYmplY3QgdGhhdCB3aWxsIGJlIGRpc3BhdGNoZWQgdG8gYWxsIHRpY2sgbGlzdGVuZXJzLiBUaGlzIG9iamVjdCBpcyByZXVzZWQgYmV0d2VlbiBkaXNwYXRjaGVycyB0byByZWR1Y2UgY29uc3RydWN0aW9uICYgR0MgY29zdHMuXG5cdCAqL1xuXHRfdGljayAoZXZ0T2JqKSB7XG5cdFx0Ly8gYmVjYXVzZSB0aWNrIGNhbiBiZSByZWFsbHkgcGVyZm9ybWFuY2Ugc2Vuc2l0aXZlLCBjaGVjayBmb3IgbGlzdGVuZXJzIGJlZm9yZSBjYWxsaW5nIGRpc3BhdGNoRXZlbnQuXG5cdFx0bGV0IGxzID0gdGhpcy5fbGlzdGVuZXJzO1xuXHRcdGlmIChscyAmJiBsc1tcInRpY2tcIl0pIHtcblx0XHRcdC8vIHJlc2V0ICYgcmV1c2UgdGhlIGV2ZW50IG9iamVjdCB0byBhdm9pZCBjb25zdHJ1Y3Rpb24gLyBHQyBjb3N0czpcblx0XHRcdGV2dE9iai50YXJnZXQgPSBudWxsO1xuXHRcdFx0ZXZ0T2JqLnByb3BhZ2F0aW9uU3RvcHBlZCA9IGV2dE9iai5pbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSBmYWxzZTtcblx0XHRcdHRoaXMuZGlzcGF0Y2hFdmVudChldnRPYmopO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICovXG5cdF90ZXN0SGl0IChjdHgpIHtcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgMSwgMSkuZGF0YVszXSA+IDE7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0aWYgKCFEaXNwbGF5T2JqZWN0LnN1cHByZXNzQ3Jvc3NEb21haW5FcnJvcnMpIHtcblx0XHRcdFx0dGhyb3cgXCJBbiBlcnJvciBoYXMgb2NjdXJyZWQuIFRoaXMgaXMgbW9zdCBsaWtlbHkgZHVlIHRvIHNlY3VyaXR5IHJlc3RyaWN0aW9ucyBvbiByZWFkaW5nIGNhbnZhcyBwaXhlbCBkYXRhIHdpdGggbG9jYWwgb3IgY3Jvc3MtZG9tYWluIGltYWdlcy5cIjtcblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge2Vhc2VsanMuTWF0cml4MkR9IG1hdHJpeFxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlnbm9yZVRyYW5zZm9ybSBJZiB0cnVlLCBkb2VzIG5vdCBhcHBseSB0aGlzIG9iamVjdCdzIHRyYW5zZm9ybS5cblx0ICogQHJldHVybiB7ZWFzZWxqcy5SZWN0YW5nbGV9XG5cdCAqL1xuXHRfZ2V0Qm91bmRzIChtYXRyaXgsIGlnbm9yZVRyYW5zZm9ybSkge1xuXHRcdHJldHVybiB0aGlzLl90cmFuc2Zvcm1Cb3VuZHModGhpcy5nZXRCb3VuZHMoKSwgbWF0cml4LCBpZ25vcmVUcmFuc2Zvcm0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHBhcmFtIHtlYXNlbGpzLlJlY3RhbmdsZX0gYm91bmRzXG5cdCAqIEBwYXJhbSB7ZWFzZWxqcy5NYXRyaXgyRH0gbWF0cml4XG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaWdub3JlVHJhbnNmb3JtXG5cdCAqIEByZXR1cm4ge2Vhc2VsanMuUmVjdGFuZ2xlfVxuXHQgKi9cblx0X3RyYW5zZm9ybUJvdW5kcyAoYm91bmRzLCBtYXRyaXgsIGlnbm9yZVRyYW5zZm9ybSkge1xuXHRcdGlmICghYm91bmRzKSB7IHJldHVybiBib3VuZHM7IH1cblx0XHRsZXQgeyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH0gPSBib3VuZHM7XG5cdFx0bGV0IG10eCA9IHRoaXMuX3Byb3BzLm1hdHJpeDtcblx0XHRtdHggPSBpZ25vcmVUcmFuc2Zvcm0gPyBtdHguaWRlbnRpdHkoKSA6IHRoaXMuZ2V0TWF0cml4KG10eCk7XG5cblx0XHRpZiAoeCB8fCB5KSB7IG10eC5hcHBlbmRUcmFuc2Zvcm0oMCwwLDEsMSwwLDAsMCwteCwteSk7IH0gLy8gVE9ETzogc2ltcGxpZnkgdGhpcy5cblx0XHRpZiAobWF0cml4KSB7IG10eC5wcmVwZW5kTWF0cml4KG1hdHJpeCk7IH1cblxuXHRcdGxldCB4X2EgPSB3aWR0aCptdHguYSwgeF9iID0gd2lkdGgqbXR4LmI7XG5cdFx0bGV0IHlfYyA9IGhlaWdodCptdHguYywgeV9kID0gaGVpZ2h0Km10eC5kO1xuXHRcdGxldCB0eCA9IG10eC50eCwgdHkgPSBtdHgudHk7XG5cblx0XHRsZXQgbWluWCA9IHR4LCBtYXhYID0gdHgsIG1pblkgPSB0eSwgbWF4WSA9IHR5O1xuXG5cdFx0aWYgKCh4ID0geF9hICsgdHgpIDwgbWluWCkgeyBtaW5YID0geDsgfSBlbHNlIGlmICh4ID4gbWF4WCkgeyBtYXhYID0geDsgfVxuXHRcdGlmICgoeCA9IHhfYSArIHlfYyArIHR4KSA8IG1pblgpIHsgbWluWCA9IHg7IH0gZWxzZSBpZiAoeCA+IG1heFgpIHsgbWF4WCA9IHg7IH1cblx0XHRpZiAoKHggPSB5X2MgKyB0eCkgPCBtaW5YKSB7IG1pblggPSB4OyB9IGVsc2UgaWYgKHggPiBtYXhYKSB7IG1heFggPSB4OyB9XG5cblx0XHRpZiAoKHkgPSB4X2IgKyB0eSkgPCBtaW5ZKSB7IG1pblkgPSB5OyB9IGVsc2UgaWYgKHkgPiBtYXhZKSB7IG1heFkgPSB5OyB9XG5cdFx0aWYgKCh5ID0geF9iICsgeV9kICsgdHkpIDwgbWluWSkgeyBtaW5ZID0geTsgfSBlbHNlIGlmICh5ID4gbWF4WSkgeyBtYXhZID0geTsgfVxuXHRcdGlmICgoeSA9IHlfZCArIHR5KSA8IG1pblkpIHsgbWluWSA9IHk7IH0gZWxzZSBpZiAoeSA+IG1heFkpIHsgbWF4WSA9IHk7IH1cblxuXHRcdHJldHVybiBib3VuZHMuc2V0VmFsdWVzKG1pblgsIG1pblksIG1heFgtbWluWCwgbWF4WS1taW5ZKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZGlzcGxheSBvYmplY3QgaGFzIGFueSBtb3VzZSBldmVudCBsaXN0ZW5lcnMgb3IgYSBjdXJzb3IuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICovXG5cdF9oYXNNb3VzZUV2ZW50TGlzdGVuZXIgKCkge1xuXHRcdGxldCBldnRzID0gRGlzcGxheU9iamVjdC5fTU9VU0VfRVZFTlRTO1xuXHRcdGZvciAobGV0IGk9MCwgbD1ldnRzLmxlbmd0aDsgaTxsOyBpKyspIHtcblx0XHRcdGlmICh0aGlzLmhhc0V2ZW50TGlzdGVuZXIoZXZ0c1tpXSkpIHsgcmV0dXJuIHRydWU7IH1cblx0XHR9XG5cdFx0cmV0dXJuICEhdGhpcy5jdXJzb3I7XG5cdH1cblxufVxuXG57XG5cdGxldCBjYW52YXMgPSB3aW5kb3cuY3JlYXRlanMgJiYgY3JlYXRlanMuY3JlYXRlQ2FudmFzP2NyZWF0ZWpzLmNyZWF0ZUNhbnZhcygpOmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7IC8vIHByZXZlbnQgZXJyb3JzIG9uIGxvYWQgaW4gYnJvd3NlcnMgd2l0aG91dCBjYW52YXMuXG5cdGlmIChjYW52YXMuZ2V0Q29udGV4dCkge1xuXHRcdC8qKlxuXHRcdCAqIEB0eXBlIHtIVE1MQ2FudmFzRWxlbWVudCB8IE9iamVjdH1cblx0XHQgKiBAc3RhdGljXG5cdFx0ICovXG5cdFx0RGlzcGxheU9iamVjdC5faGl0VGVzdENhbnZhcyA9IGNhbnZhcztcblx0XHQvKipcblx0XHQgKiBAdHlwZSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfVxuXHRcdCAqIEBzdGF0aWNcblx0XHQgKi9cblx0XHREaXNwbGF5T2JqZWN0Ll9oaXRUZXN0Q29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5cdFx0Y2FudmFzLndpZHRoID0gY2FudmFzLmhlaWdodCA9IDE7XG5cdH1cbn1cblxuLyoqXG4gKiBMaXN0aW5nIG9mIG1vdXNlIGV2ZW50IG5hbWVzLiBVc2VkIGluIF9oYXNNb3VzZUV2ZW50TGlzdGVuZXIuXG4gKiBAc3RhdGljXG4gKiBAdHlwZSB7QXJyYXk8U3RyaW5nPn1cbiAqIEByZWFkb25seVxuICovXG5EaXNwbGF5T2JqZWN0Ll9NT1VTRV9FVkVOVFMgPSBbXCJjbGlja1wiLFwiZGJsY2xpY2tcIixcIm1vdXNlZG93blwiLFwibW91c2VvdXRcIixcIm1vdXNlb3ZlclwiLFwicHJlc3Ntb3ZlXCIsXCJwcmVzc3VwXCIsXCJyb2xsb3V0XCIsXCJyb2xsb3ZlclwiXTtcblxuLyoqXG4gKiBTdXBwcmVzc2VzIGVycm9ycyBnZW5lcmF0ZWQgd2hlbiB1c2luZyBmZWF0dXJlcyBsaWtlIGhpdFRlc3QsIG1vdXNlIGV2ZW50cywgYW5kIHt7I2Nyb3NzTGluayBcImdldE9iamVjdHNVbmRlclBvaW50XCJ9fXt7L2Nyb3NzTGlua319XG4gKiB3aXRoIGNyb3NzIGRvbWFpbiBjb250ZW50LlxuICogQHN0YXRpY1xuICogQHR5cGUge0Jvb2xlYW59XG4gKiBAZGVmYXVsdCBmYWxzZVxuICovXG5EaXNwbGF5T2JqZWN0LnN1cHByZXNzQ3Jvc3NEb21haW5FcnJvcnMgPSBmYWxzZTtcblxuLyoqXG4gKiBAc3RhdGljXG4gKiBAdHlwZSB7Qm9vbGVhbn1cbiAqIEBkZWZhdWx0IGZhbHNlXG4gKi9cbkRpc3BsYXlPYmplY3Quc25hcFRvUGl4ZWxFbmFibGVkID0gZmFsc2U7XG5cbi8qKlxuICogRW51bSBsaWtlIHByb3BlcnR5IGZvciBkZXRlcm1pbmluZyBTdGFnZUdMIHJlbmRlciBsb29rdXAsIGkuZS4gd2hlcmUgdG8gZXhwZWN0IHByb3BlcnRpZXMuXG4gKiBAc3RhdGljXG4gKiBAdHlwZSB7TnVtYmVyfVxuICovXG5EaXNwbGF5T2JqZWN0Ll9TdGFnZUdMX05PTkUgPSAwO1xuXG4vKipcbiAqIEVudW0gbGlrZSBwcm9wZXJ0eSBmb3IgZGV0ZXJtaW5pbmcgU3RhZ2VHTCByZW5kZXIgbG9va3VwLCBpLmUuIHdoZXJlIHRvIGV4cGVjdCBwcm9wZXJ0aWVzLlxuICogQHN0YXRpY1xuICogQHR5cGUge051bWJlcn1cbiAqL1xuRGlzcGxheU9iamVjdC5fU3RhZ2VHTF9TUFJJVEUgPSAxO1xuXG4vKipcbiAqIEVudW0gbGlrZSBwcm9wZXJ0eSBmb3IgZGV0ZXJtaW5pbmcgU3RhZ2VHTCByZW5kZXIgbG9va3VwLCBpLmUuIHdoZXJlIHRvIGV4cGVjdCBwcm9wZXJ0aWVzLlxuICogQHN0YXRpY1xuICogQHR5cGUge051bWJlcn1cbiAqL1xuRGlzcGxheU9iamVjdC5fU3RhZ2VHTF9CSVRNQVAgPSAyO1xuXG4vKipcbiAqIERpc3BhdGNoZWQgd2hlbiB0aGUgdXNlciBwcmVzc2VzIHRoZWlyIGxlZnQgbW91c2UgYnV0dG9uIG92ZXIgdGhlIGRpc3BsYXkgb2JqZWN0LlxuICogQHNlZSB7QGxpbmsgZWFzZWxqcy5Nb3VzZUV2ZW50fVxuICogQGV2ZW50IGVhc2VsanMuRGlzcGxheU9iamVjdCNtb3VzZWRvd25cbiAqIEBzaW5jZSAwLjYuMFxuICovXG5cbi8qKlxuICogRGlzcGF0Y2hlZCB3aGVuIHRoZSB1c2VyIHByZXNzZXMgdGhlaXIgbGVmdCBtb3VzZSBidXR0b24gYW5kIHRoZW4gcmVsZWFzZXMgaXQgd2hpbGUgb3ZlciB0aGUgZGlzcGxheSBvYmplY3QuXG4gKiBAc2VlIHtAbGluayBlYXNlbGpzLk1vdXNlRXZlbnR9XG4gKiBAZXZlbnQgZWFzZWxqcy5EaXNwbGF5T2JqZWN0I2NsaWNrXG4gKiBAc2luY2UgMC42LjBcbiAqL1xuXG4vKipcbiAqIERpc3BhdGNoZWQgd2hlbiB0aGUgdXNlciBkb3VibGUgY2xpY2tzIHRoZWlyIGxlZnQgbW91c2UgYnV0dG9uIG92ZXIgdGhpcyBkaXNwbGF5IG9iamVjdC5cbiAqIEBzZWUge0BsaW5rIGVhc2VsanMuTW91c2VFdmVudH1cbiAqIEBldmVudCBlYXNlbGpzLkRpc3BsYXlPYmplY3QjZGJsY2xpY2tcbiAqIEBzaW5jZSAwLjYuMFxuICovXG5cbi8qKlxuICogRGlzcGF0Y2hlZCB3aGVuIHRoZSB1c2VyJ3MgbW91c2UgZW50ZXJzIHRoaXMgZGlzcGxheSBvYmplY3QuIFRoaXMgZXZlbnQgbXVzdCBiZSBlbmFibGVkIHVzaW5nXG4gKiB7QGxpbmsgZWFzZWxqcy5TdGFnZSNlbmFibGVNb3VzZU92ZXJ9LlxuICogQHNlZSB7QGxpbmsgZWFzZWxqcy5EaXNwbGF5T2JqZWN0I2V2ZW50OnJvbGxvdmVyfVxuICogQHNlZSB7QGxpbmsgZWFzZWxqcy5Nb3VzZUV2ZW50fVxuICogQGV2ZW50IGVhc2VsanMuRGlzcGxheU9iamVjdCNtb3VzZW92ZXJcbiAqIEBzaW5jZSAwLjYuMFxuICovXG5cbi8qKlxuICogRGlzcGF0Y2hlZCB3aGVuIHRoZSB1c2VyJ3MgbW91c2UgbGVhdmVzIHRoaXMgZGlzcGxheSBvYmplY3QuIFRoaXMgZXZlbnQgbXVzdCBiZSBlbmFibGVkIHVzaW5nXG4gKiB7QGxpbmsgZWFzZWxqcy5TdGFnZSNlbmFibGVNb3VzZU92ZXJ9LlxuICogQHNlZSB7QGxpbmsgZWFzZWxqcy5EaXNwbGF5T2JqZWN0I2V2ZW50OnJvbGxvdXR9XG4gKiBAc2VlIHtAbGluayBlYXNlbGpzLk1vdXNlRXZlbnR9XG4gKiBAZXZlbnQgZWFzZWxqcy5EaXNwbGF5T2JqZWN0I21vdXNlb3V0XG4gKiBAc2luY2UgMC42LjBcbiAqL1xuXG4vKipcbiAqIFRoaXMgZXZlbnQgaXMgc2ltaWxhciB0byB7QGxpbmsgZWFzZWxqcy5EaXNwbGF5T2JqZWN0I2V2ZW50Om1vdXNlb3Zlcn0sIHdpdGggdGhlIGZvbGxvd2luZ1xuICogZGlmZmVyZW5jZXM6IGl0IGRvZXMgbm90IGJ1YmJsZSwgYW5kIGl0IGNvbnNpZGVycyB7QGxpbmsgZWFzZWxqcy5Db250YWluZXJ9IGluc3RhbmNlcyBhcyBhblxuICogYWdncmVnYXRlIG9mIHRoZWlyIGNvbnRlbnQuXG4gKlxuICogRm9yIGV4YW1wbGUsIG15Q29udGFpbmVyIGNvbnRhaW5zIHR3byBvdmVybGFwcGluZyBjaGlsZHJlbjogc2hhcGVBIGFuZCBzaGFwZUIuIFRoZSB1c2VyIG1vdmVzIHRoZWlyIG1vdXNlIG92ZXJcbiAqIHNoYXBlQSBhbmQgdGhlbiBkaXJlY3RseSBvbiB0byBzaGFwZUIuIFdpdGggYSBsaXN0ZW5lciBmb3Ige0BsaW5rIGVhc2VsanMuRGlzcGxheU9iamVjdCNldmVudDptb3VzZW92ZXJ9IG9uXG4gKiBteUNvbnRhaW5lciwgdHdvIGV2ZW50cyB3b3VsZCBiZSByZWNlaXZlZCwgZWFjaCB0YXJnZXRpbmcgYSBjaGlsZCBlbGVtZW50OlxuICogPG9sPlxuICogICA8bGk+d2hlbiB0aGUgbW91c2UgZW50ZXJzIHNoYXBlQSAodGFyZ2V0PXNoYXBlQSk8L2xpPlxuICogICA8bGk+d2hlbiB0aGUgbW91c2UgZW50ZXJzIHNoYXBlQiAodGFyZ2V0PXNoYXBlQik8L2xpPlxuICogPC9vbD5cbiAqIEhvd2V2ZXIsIHdpdGggYSBsaXN0ZW5lciBmb3IgXCJyb2xsb3ZlclwiIGluc3RlYWQsIG9ubHkgYSBzaW5nbGUgZXZlbnQgaXMgcmVjZWl2ZWQgd2hlbiB0aGUgbW91c2UgZmlyc3QgZW50ZXJzXG4gKiB0aGUgYWdncmVnYXRlIG15Q29udGFpbmVyIGNvbnRlbnQgKHRhcmdldD1teUNvbnRhaW5lcikuXG4gKlxuICogVGhpcyBldmVudCBtdXN0IGJlIGVuYWJsZWQgdXNpbmcge0BsaW5rIGVhc2VsanMuU3RhZ2UjZW5hYmxlTW91c2VPdmVyfS5cbiAqIEBzZWUge0BsaW5rIGVhc2VsanMuTW91c2VFdmVudH1cbiAqIEBldmVudCBlYXNlbGpzLkRpc3BsYXlPYmplY3Qjcm9sbG92ZXJcbiAqIEBzaW5jZSAwLjcuMFxuICovXG5cbi8qKlxuICogVGhpcyBldmVudCBpcyBzaW1pbGFyIHRvIHtAbGluayBlYXNlbGpzLkRpc3BsYXlPYmplY3QjZXZlbnQ6bW91c2VvdXR9LCB3aXRoIHRoZSBmb2xsb3dpbmdcbiAqIGRpZmZlcmVuY2VzOiBpdCBkb2VzIG5vdCBidWJibGUsIGFuZCBpdCBjb25zaWRlcnMge0BsaW5rIGVhc2VsanMuQ29udGFpbmVyfSBpbnN0YW5jZXMgYXMgYW5cbiAqIGFnZ3JlZ2F0ZSBvZiB0aGVpciBjb250ZW50LlxuICpcbiAqIEZvciBleGFtcGxlLCBteUNvbnRhaW5lciBjb250YWlucyB0d28gb3ZlcmxhcHBpbmcgY2hpbGRyZW46IHNoYXBlQSBhbmQgc2hhcGVCLiBUaGUgdXNlciBtb3ZlcyB0aGVpciBtb3VzZSBvdmVyXG4gKiBzaGFwZUEsIHRoZW4gZGlyZWN0bHkgb24gdG8gc2hhcGVCLCB0aGVuIG9mZiBib3RoLiBXaXRoIGEgbGlzdGVuZXIgZm9yIHtAbGluayBlYXNlbGpzLkRpc3BsYXlPYmplY3QjZXZlbnQ6bW91c2VvdXR9XG4gKiBvbiBteUNvbnRhaW5lciwgdHdvIGV2ZW50cyB3b3VsZCBiZSByZWNlaXZlZCwgZWFjaCB0YXJnZXRpbmcgYSBjaGlsZCBlbGVtZW50OjxPTD5cbiAqIDxMST53aGVuIHRoZSBtb3VzZSBsZWF2ZXMgc2hhcGVBICh0YXJnZXQ9c2hhcGVBKTwvTEk+XG4gKiA8TEk+d2hlbiB0aGUgbW91c2UgbGVhdmVzIHNoYXBlQiAodGFyZ2V0PXNoYXBlQik8L0xJPlxuICogPC9PTD5cbiAqIEhvd2V2ZXIsIHdpdGggYSBsaXN0ZW5lciBmb3IgXCJyb2xsb3V0XCIgaW5zdGVhZCwgb25seSBhIHNpbmdsZSBldmVudCBpcyByZWNlaXZlZCB3aGVuIHRoZSBtb3VzZSBsZWF2ZXNcbiAqIHRoZSBhZ2dyZWdhdGUgbXlDb250YWluZXIgY29udGVudCAodGFyZ2V0PW15Q29udGFpbmVyKS5cbiAqXG4gKiBUaGlzIGV2ZW50IG11c3QgYmUgZW5hYmxlZCB1c2luZyB7QGxpbmsgZWFzZWxqcy5TdGFnZSNlbmFibGVNb3VzZU92ZXJ9LlxuICogQHNlZSB7QGxpbmsgZWFzZWxqcy5Nb3VzZUV2ZW50fVxuICogQGV2ZW50IGVhc2VsanMuRGlzcGxheU9iamVjdCNyb2xsb3V0XG4gKiBAc2luY2UgMC43LjBcbiAqL1xuXG4vKipcbiAqIEFmdGVyIGEge0BsaW5rIGVhc2VsanMuRGlzcGxheU9iamVjdCNldmVudDptb3VzZWRvd259IG9jY3VycyBvbiBhIGRpc3BsYXkgb2JqZWN0LCBhIHByZXNzbW92ZVxuICogZXZlbnQgd2lsbCBiZSBnZW5lcmF0ZWQgb24gdGhhdCBvYmplY3Qgd2hlbmV2ZXIgdGhlIG1vdXNlIG1vdmVzIHVudGlsIHRoZSBtb3VzZSBwcmVzcyBpcyByZWxlYXNlZC4gVGhpcyBjYW4gYmVcbiAqIHVzZWZ1bCBmb3IgZHJhZ2dpbmcgYW5kIHNpbWlsYXIgb3BlcmF0aW9ucy5cbiAqIEBldmVudCBlYXNlbGpzLkRpc3BsYXlPYmplY3QjcHJlc3Ntb3ZlXG4gKiBAc2luY2UgMC43LjBcbiAqL1xuXG4vKipcbiAqIEFmdGVyIGEge0BsaW5rIGVhc2VsanMuRGlzcGxheU9iamVjdCNldmVudDptb3VzZWRvd259IG9jY3VycyBvbiBhIGRpc3BsYXkgb2JqZWN0LCBhIHByZXNzdXAgZXZlbnRcbiAqIHdpbGwgYmUgZ2VuZXJhdGVkIG9uIHRoYXQgb2JqZWN0IHdoZW4gdGhhdCBtb3VzZSBwcmVzcyBpcyByZWxlYXNlZC4gVGhpcyBjYW4gYmUgdXNlZnVsIGZvciBkcmFnZ2luZyBhbmQgc2ltaWxhclxuICogb3BlcmF0aW9ucy5cbiAqIEBldmVudCBlYXNlbGpzLkRpc3BsYXlPYmplY3QjcHJlc3N1cFxuICogQHNpbmNlIDAuNy4wXG4gKi9cblxuLyoqXG4gKiBEaXNwYXRjaGVkIHdoZW4gdGhlIGRpc3BsYXkgb2JqZWN0IGlzIGFkZGVkIHRvIGEgcGFyZW50IGNvbnRhaW5lci5cbiAqIEBldmVudCBlYXNlbGpzLkRpc3BsYXlPYmplY3QjYWRkZWRcbiAqL1xuXG4vKipcbiAqIERpc3BhdGNoZWQgd2hlbiB0aGUgZGlzcGxheSBvYmplY3QgaXMgcmVtb3ZlZCBmcm9tIGl0cyBwYXJlbnQgY29udGFpbmVyLlxuICogQGV2ZW50IGVhc2VsanMuRGlzcGxheU9iamVjdCNyZW1vdmVkXG4gKi9cblxuLyoqXG4gKiBEaXNwYXRjaGVkIG9uIGVhY2ggZGlzcGxheSBvYmplY3Qgb24gYSBzdGFnZSB3aGVuZXZlciB0aGUgc3RhZ2UgdXBkYXRlcy4gVGhpcyBvY2N1cnMgaW1tZWRpYXRlbHkgYmVmb3JlIHRoZVxuICogcmVuZGVyaW5nIChkcmF3KSBwYXNzLiBXaGVuIHtAbGluayBlYXNlbGpzLlN0YWdlI3VwZGF0ZX0gaXMgY2FsbGVkLCBmaXJzdCBhbGwgZGlzcGxheSBvYmplY3RzIG9uXG4gKiB0aGUgc3RhZ2UgZGlzcGF0Y2ggdGhlIHRpY2sgZXZlbnQsIHRoZW4gYWxsIG9mIHRoZSBkaXNwbGF5IG9iamVjdHMgYXJlIGRyYXduIHRvIHN0YWdlLiBDaGlsZHJlbiB3aWxsIGhhdmUgdGhlaXJcbiAqIHRpY2sgZXZlbnQgZGlzcGF0Y2hlZCBpbiBvcmRlciBvZiB0aGVpciBkZXB0aCBwcmlvciB0byB0aGUgZXZlbnQgYmVpbmcgZGlzcGF0Y2hlZCBvbiB0aGVpciBwYXJlbnQuXG4gKiBAZXZlbnQgZWFzZWxqcy5EaXNwbGF5T2JqZWN0I3RpY2tcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIG9iamVjdCB0aGF0IGRpc3BhdGNoZWQgdGhlIGV2ZW50LlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGUuXG4gKiBAcGFyYW0ge0FycmF5fSBwYXJhbXMgQW4gYXJyYXkgY29udGFpbmluZyBhbnkgYXJndW1lbnRzIHRoYXQgd2VyZSBwYXNzZWQgdG8gdGhlIFN0YWdlLnVwZGF0ZSgpIG1ldGhvZC5cbiAqIEBzaW5jZSAwLjYuMFxuICovXG4iLCIvKipcbiAqIEBsaWNlbnNlIENvbnRhaW5lclxuICogVmlzaXQgaHR0cDovL2NyZWF0ZWpzLmNvbS8gZm9yIGRvY3VtZW50YXRpb24sIHVwZGF0ZXMgYW5kIGV4YW1wbGVzLlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNyBnc2tpbm5lci5jb20sIGluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICogb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cbiAqIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxuICogcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsXG4gKiBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4gKiBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuICogY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAqIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xuICogT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAqIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4gKiBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcbiAqIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuICogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUlxuICogT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICovXG5cbmltcG9ydCBEaXNwbGF5T2JqZWN0IGZyb20gXCIuL0Rpc3BsYXlPYmplY3RcIjtcblxuLyoqXG4gKiBBIENvbnRhaW5lciBpcyBhIG5lc3RhYmxlIGRpc3BsYXkgbGlzdCB0aGF0IGFsbG93cyB5b3UgdG8gd29yayB3aXRoIGNvbXBvdW5kIGRpc3BsYXkgZWxlbWVudHMuIEZvciAgZXhhbXBsZSB5b3UgY291bGRcbiAqIGdyb3VwIGFybSwgbGVnLCB0b3JzbyBhbmQgaGVhZCB7eyNjcm9zc0xpbmsgXCJCaXRtYXBcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGFuY2VzIHRvZ2V0aGVyIGludG8gYSBQZXJzb24gQ29udGFpbmVyLCBhbmRcbiAqIHRyYW5zZm9ybSB0aGVtIGFzIGEgZ3JvdXAsIHdoaWxlIHN0aWxsIGJlaW5nIGFibGUgdG8gbW92ZSB0aGUgaW5kaXZpZHVhbCBwYXJ0cyByZWxhdGl2ZSB0byBlYWNoIG90aGVyLiBDaGlsZHJlbiBvZlxuICogY29udGFpbmVycyBoYXZlIHRoZWlyIGB0cmFuc2Zvcm1gIGFuZCBgYWxwaGFgIHByb3BlcnRpZXMgY29uY2F0ZW5hdGVkIHdpdGggdGhlaXIgcGFyZW50XG4gKiBDb250YWluZXIuXG4gKlxuICogRm9yIGV4YW1wbGUsIGEge3sjY3Jvc3NMaW5rIFwiU2hhcGVcIn19e3svY3Jvc3NMaW5rfX0gd2l0aCB4PTEwMCBhbmQgYWxwaGE9MC41LCBwbGFjZWQgaW4gYSBDb250YWluZXIgd2l0aCBgeD01MGBcbiAqIGFuZCBgYWxwaGE9MC43YCB3aWxsIGJlIHJlbmRlcmVkIHRvIHRoZSBjYW52YXMgYXQgYHg9MTUwYCBhbmQgYGFscGhhPTAuMzVgLlxuICogQ29udGFpbmVycyBoYXZlIHNvbWUgb3ZlcmhlYWQsIHNvIHlvdSBnZW5lcmFsbHkgc2hvdWxkbid0IGNyZWF0ZSBhIENvbnRhaW5lciB0byBob2xkIGEgc2luZ2xlIGNoaWxkLlxuICpcbiAqIEBtZW1iZXJvZiBlYXNlbGpzXG4gKiBAZXh0ZW5kcyBlYXNlbGpzLkRpc3BsYXlPYmplY3RcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBDb250YWluZXIgfSBmcm9tIFwiQGNyZWF0ZWpzL2Vhc2VsanNcIjtcbiAqIGNvbnN0IGNvbnRhaW5lciA9IG5ldyBDb250YWluZXIoKTtcbiAqIGNvbnRhaW5lci5hZGRDaGlsZChiaXRtYXBJbnN0YW5jZSwgc2hhcGVJbnN0YW5jZSk7XG4gKiBjb250YWluZXIueCA9IDEwMDtcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29udGFpbmVyIGV4dGVuZHMgRGlzcGxheU9iamVjdCB7XG5cblx0Y29uc3RydWN0b3IgKCkge1xuXHRcdHN1cGVyKCk7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgYXJyYXkgb2YgY2hpbGRyZW4gaW4gdGhlIGRpc3BsYXkgbGlzdC4gWW91IHNob3VsZCB1c3VhbGx5IHVzZSB0aGUgY2hpbGQgbWFuYWdlbWVudCBtZXRob2RzIHN1Y2ggYXNcblx0XHQgKiB7QGxpbmsgZWFzZWxqcy5Db250YWluZXIjYWRkQ2hpbGR9LCB7QGxpbmsgZWFzZWxqcy5Db250YWluZXIjcmVtb3ZlQ2hpbGR9LCB7QGxpbmsgZWFzZWxqcy5Db250YWluZXIjc3dhcENoaWxkcmVufSxcblx0XHQgKiBldGMsIHJhdGhlciB0aGFuIGFjY2Vzc2luZyB0aGlzIGRpcmVjdGx5LCBidXQgaXQgaXMgaW5jbHVkZWQgZm9yIGFkdmFuY2VkIHVzZXMuXG5cdFx0ICogQHR5cGUge0FycmF5fVxuXHRcdCAqIEBkZWZhdWx0IFtdXG5cdFx0ICovXG5cdFx0dGhpcy5jaGlsZHJlbiA9IFtdO1xuXG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGNoaWxkcmVuIG9mIHRoaXMgY29udGFpbmVyIGFyZSBpbmRlcGVuZGVudGx5IGVuYWJsZWQgZm9yIG1vdXNlL3BvaW50ZXIgaW50ZXJhY3Rpb24uXG5cdFx0ICogSWYgZmFsc2UsIHRoZSBjaGlsZHJlbiB3aWxsIGJlIGFnZ3JlZ2F0ZWQgdW5kZXIgdGhlIGNvbnRhaW5lciAtIGZvciBleGFtcGxlLCBhIGNsaWNrIG9uIGEgY2hpbGQgc2hhcGUgd291bGRcblx0XHQgKiB0cmlnZ2VyIGEgY2xpY2sgZXZlbnQgb24gdGhlIGNvbnRhaW5lci5cblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0dGhpcy5tb3VzZUNoaWxkcmVuID0gdHJ1ZTtcblxuXHRcdC8qKlxuXHRcdCAqIElmIGZhbHNlLCB0aGUgdGljayB3aWxsIG5vdCBiZSBwcm9wYWdhdGVkIHRvIGNoaWxkcmVuIG9mIHRoaXMgQ29udGFpbmVyLiBUaGlzIGNhbiBwcm92aWRlIHNvbWUgcGVyZm9ybWFuY2UgYmVuZWZpdHMuXG5cdFx0ICogSW4gYWRkaXRpb24gdG8gcHJldmVudGluZyB0aGUge0BsaW5rIGNvcmUuVGlja2VyI2V2ZW50OnRpY2t9IGV2ZW50IGZyb20gYmVpbmcgZGlzcGF0Y2hlZCwgaXQgd2lsbCBhbHNvIHByZXZlbnQgdGljayByZWxhdGVkIHVwZGF0ZXNcblx0XHQgKiBvbiBzb21lIGRpc3BsYXkgb2JqZWN0cyAoZXguIFNwcml0ZSAmIE1vdmllQ2xpcCBmcmFtZSBhZHZhbmNpbmcsIERPTUVsZW1lbnQgdmlzaWJpbGl0eSBoYW5kbGluZykuXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdHRoaXMudGlja0NoaWxkcmVuID0gdHJ1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gaW4gdGhlIGNvbnRhaW5lci5cblx0ICogQHR5cGUge051bWJlcn1cblx0ICogQHJlYWRvbmx5XG5cdCAqL1xuXHRnZXQgbnVtQ2hpbGRyZW4gKCkge1xuXHRcdHJldHVybiB0aGlzLmNoaWxkcmVuLmxlbmd0aDtcblx0fVxuXG5cdGlzVmlzaWJsZSAoKSB7XG5cdFx0bGV0IGhhc0NvbnRlbnQgPSB0aGlzLmNhY2hlQ2FudmFzIHx8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoO1xuXHRcdHJldHVybiAhISh0aGlzLnZpc2libGUgJiYgdGhpcy5hbHBoYSA+IDAgJiYgdGhpcy5zY2FsZVggIT0gMCAmJiB0aGlzLnNjYWxlWSAhPSAwICYmIGhhc0NvbnRlbnQpO1xuXHR9XG5cblx0ZHJhdyAoY3R4LCBpZ25vcmVDYWNoZSA9IGZhbHNlKSB7XG5cdFx0aWYgKHN1cGVyLmRyYXcoY3R4LCBpZ25vcmVDYWNoZSkpIHsgcmV0dXJuIHRydWU7IH1cblxuXHRcdC8vIHRoaXMgZW5zdXJlcyB3ZSBkb24ndCBoYXZlIGlzc3VlcyB3aXRoIGRpc3BsYXkgbGlzdCBjaGFuZ2VzIHRoYXQgb2NjdXIgZHVyaW5nIGEgZHJhdzpcblx0XHRsZXQgbGlzdCA9IHRoaXMuY2hpbGRyZW4uc2xpY2UoKTtcblx0XHRmb3IgKGxldCBpPTAsbD1saXN0Lmxlbmd0aDsgaTxsOyBpKyspIHtcblx0XHRcdGxldCBjaGlsZCA9IGxpc3RbaV07XG5cdFx0XHRpZiAoIWNoaWxkLmlzVmlzaWJsZSgpKSB7IGNvbnRpbnVlOyB9XG5cblx0XHRcdC8vIGRyYXcgdGhlIGNoaWxkOlxuXHRcdFx0Y3R4LnNhdmUoKTtcblx0XHRcdGNoaWxkLnVwZGF0ZUNvbnRleHQoY3R4KTtcblx0XHRcdGNoaWxkLmRyYXcoY3R4KTtcblx0XHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBjaGlsZCB0byB0aGUgdG9wIG9mIHRoZSBkaXNwbGF5IGxpc3QuXG5cdCAqXG5cdCAqIEBleGFtcGxlXG5cdCAqIGNvbnRhaW5lci5hZGRDaGlsZChiaXRtYXBJbnN0YW5jZSk7XG5cdCAqIC8vIFlvdSBjYW4gYWxzbyBhZGQgbXVsdGlwbGUgY2hpbGRyZW4gYXQgb25jZTpcblx0ICogY29udGFpbmVyLmFkZENoaWxkKGJpdG1hcEluc3RhbmNlLCBzaGFwZUluc3RhbmNlLCB0ZXh0SW5zdGFuY2UpO1xuXHQgKlxuXHQgKiBAcGFyYW0gey4uLmVhc2VsanMuRGlzcGxheU9iamVjdH0gY2hpbGRyZW4gVGhlIGRpc3BsYXkgb2JqZWN0KHMpIHRvIGFkZC5cblx0ICogQHJldHVybiB7ZWFzZWxqcy5EaXNwbGF5T2JqZWN0fSBUaGUgY2hpbGQgdGhhdCB3YXMgYWRkZWQsIG9yIHRoZSBsYXN0IGNoaWxkIGlmIG11bHRpcGxlIGNoaWxkcmVuIHdlcmUgYWRkZWQuXG5cdCAqL1xuXHRhZGRDaGlsZCAoLi4uY2hpbGRyZW4pIHtcblx0XHRjb25zdCBsID0gY2hpbGRyZW4ubGVuZ3RoO1xuXHRcdGlmIChsID09PSAwKSB7IHJldHVybiBudWxsOyB9XG5cdFx0bGV0IGNoaWxkID0gY2hpbGRyZW5bMF07XG5cdFx0aWYgKGwgPiAxKSB7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGw7IGkrKykgeyBjaGlsZCA9IHRoaXMuYWRkQ2hpbGQoY2hpbGRyZW5baV0pOyB9XG5cdFx0XHRyZXR1cm4gY2hpbGQ7XG5cdFx0fVxuICAgIC8vIE5vdGU6IGEgbG90IG9mIGR1cGxpY2F0aW9uIHdpdGggYWRkQ2hpbGRBdCwgYnV0IHB1c2ggaXMgV0FZIGZhc3RlciB0aGFuIHNwbGljZS5cbiAgICBsZXQgcGFyZW50ID0gY2hpbGQucGFyZW50LCBzaWxlbnQgPSBwYXJlbnQgPT09IHRoaXM7XG4gICAgcGFyZW50ICYmIHBhcmVudC5fcmVtb3ZlQ2hpbGRBdChwYXJlbnQuY2hpbGRyZW4uaW5kZXhPZihjaGlsZCksIHNpbGVudCk7XG5cdFx0Y2hpbGQucGFyZW50ID0gdGhpcztcblx0XHR0aGlzLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgIGlmICghc2lsZW50KSB7IGNoaWxkLmRpc3BhdGNoRXZlbnQoXCJhZGRlZFwiKTsgfVxuXHRcdHJldHVybiBjaGlsZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgY2hpbGQgdG8gdGhlIGRpc3BsYXkgbGlzdCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LCBidW1waW5nIGNoaWxkcmVuIGF0IGVxdWFsIG9yIGdyZWF0ZXIgaW5kZXhlcyB1cCBvbmUsIGFuZFxuXHQgKiBzZXR0aW5nIGl0cyBwYXJlbnQgdG8gdGhpcyBjb250YWluZXIuXG5cdCAqXG5cdCAqIEBleGFtcGxlXG5cdCAqIGNvbnRhaW5lci5hZGRDaGlsZEF0KGNoaWxkMSwgaW5kZXgpO1xuXHQgKiAvLyBZb3UgY2FuIGFsc28gYWRkIG11bHRpcGxlIGNoaWxkcmVuLCBzdWNoIGFzOlxuXHQgKiBjb250YWluZXIuYWRkQ2hpbGRBdChjaGlsZDEsIGNoaWxkMiwgLi4uLCBpbmRleCk7XG5cdCAqIC8vIFRoZSBpbmRleCBtdXN0IGJlIGJldHdlZW4gMCBhbmQgbnVtQ2hpbGRyZW4uIEZvciBleGFtcGxlLCB0byBhZGQgbXlTaGFwZSB1bmRlciBvdGhlclNoYXBlIGluIHRoZSBkaXNwbGF5IGxpc3QsIHlvdSBjb3VsZCB1c2U6XG5cdCAqIGNvbnRhaW5lci5hZGRDaGlsZEF0KG15U2hhcGUsIGNvbnRhaW5lci5nZXRDaGlsZEluZGV4KG90aGVyU2hhcGUpKTtcblx0ICogLy8gVGhpcyB3b3VsZCBhbHNvIGJ1bXAgb3RoZXJTaGFwZSdzIGluZGV4IHVwIGJ5IG9uZS4gRmFpbHMgc2lsZW50bHkgaWYgdGhlIGluZGV4IGlzIG91dCBvZiByYW5nZS5cblx0ICpcblx0ICogQHBhcmFtIHsuLi5lYXNlbGpzLkRpc3BsYXlPYmplY3R9IGNoaWxkcmVuIFRoZSBkaXNwbGF5IG9iamVjdChzKSB0byBhZGQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBUaGUgaW5kZXggdG8gYWRkIHRoZSBjaGlsZCBhdC5cblx0ICogQHJldHVybiB7ZWFzZWxqcy5EaXNwbGF5T2JqZWN0fSBSZXR1cm5zIHRoZSBsYXN0IGNoaWxkIHRoYXQgd2FzIGFkZGVkLCBvciB0aGUgbGFzdCBjaGlsZCBpZiBtdWx0aXBsZSBjaGlsZHJlbiB3ZXJlIGFkZGVkLlxuXHQgKi9cblx0YWRkQ2hpbGRBdCAoLi4uY2hpbGRyZW4pIHtcblx0XHRjb25zdCBsID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgIGlmIChsID09PSAwKSB7IHJldHVybiBudWxsOyB9XG4gICAgbGV0IGluZGV4ID0gY2hpbGRyZW4ucG9wKCk7XG5cdFx0aWYgKGluZGV4IDwgMCB8fCBpbmRleCA+IHRoaXMuY2hpbGRyZW4ubGVuZ3RoKSB7IHJldHVybiBjaGlsZHJlbltsIC0gMl07IH1cblx0XHRpZiAobCA+IDIpIHtcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbCAtIDE7IGkrKykgeyB0aGlzLmFkZENoaWxkQXQoY2hpbGRyZW5baV0sIGluZGV4KyspOyB9XG5cdFx0XHRyZXR1cm4gY2hpbGRyZW5bbCAtIDJdO1xuXHRcdH1cblx0XHRsZXQgY2hpbGQgPSBjaGlsZHJlblswXTtcbiAgICBsZXQgcGFyZW50ID0gY2hpbGQucGFyZW50LCBzaWxlbnQgPSBwYXJlbnQgPT09IHRoaXM7XG4gICAgcGFyZW50ICYmIHBhcmVudC5fcmVtb3ZlQ2hpbGRBdChwYXJlbnQuY2hpbGRyZW4uaW5kZXhPZihjaGlsZCksIHNpbGVudCk7XG5cdFx0Y2hpbGQucGFyZW50ID0gdGhpcztcblx0XHR0aGlzLmNoaWxkcmVuLnNwbGljZShpbmRleCsrLCAwLCBjaGlsZCk7XG4gICAgaWYgKCFzaWxlbnQpIHsgY2hpbGQuZGlzcGF0Y2hFdmVudChcImFkZGVkXCIpOyB9XG5cdFx0cmV0dXJuIGNoaWxkO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgdGhlIHNwZWNpZmllZCBjaGlsZCBmcm9tIHRoZSBkaXNwbGF5IGxpc3QuIE5vdGUgdGhhdCBpdCBpcyBmYXN0ZXIgdG8gdXNlIHJlbW92ZUNoaWxkQXQoKSBpZiB0aGUgaW5kZXggaXNcblx0ICogYWxyZWFkeSBrbm93bi5cblx0ICpcblx0ICogQGV4YW1wbGVcblx0ICogY29udGFpbmVyLnJlbW92ZUNoaWxkKGNoaWxkKTtcblx0ICogLy8gWW91IGNhbiBhbHNvIHJlbW92ZSBtdWx0aXBsZSBjaGlsZHJlbjpcblx0ICogY29udGFpbmVyLnJlbW92ZUNoaWxkKGNoaWxkMSwgY2hpbGQyLCAuLi4pO1xuXHQgKlxuXHQgKiBAcGFyYW0gey4uLmVhc2VsanMuRGlzcGxheU9iamVjdH0gY2hpbGRyZW4gVGhlIGRpc3BsYXkgb2JqZWN0KHMpIHRvIHJlbW92ZS5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgY2hpbGQgKG9yIGNoaWxkcmVuKSB3YXMgcmVtb3ZlZCwgb3IgZmFsc2UgaWYgaXQgd2FzIG5vdCBpbiB0aGUgZGlzcGxheSBsaXN0LlxuXHQgKi9cblx0cmVtb3ZlQ2hpbGQgKC4uLmNoaWxkcmVuKSB7XG5cdFx0Y29uc3QgbCA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICBpZiAobCA9PT0gMCkgeyByZXR1cm4gdHJ1ZTsgfVxuXHRcdGlmIChsID4gMSkge1xuXHRcdFx0bGV0IGdvb2QgPSB0cnVlO1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpKyspIHsgZ29vZCA9IGdvb2QgJiYgdGhpcy5yZW1vdmVDaGlsZChjaGlsZHJlbltpXSk7IH1cblx0XHRcdHJldHVybiBnb29kO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fcmVtb3ZlQ2hpbGRBdCh0aGlzLmNoaWxkcmVuLmluZGV4T2YoY2hpbGRyZW5bMF0pKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIHRoZSBjaGlsZCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4IGZyb20gdGhlIGRpc3BsYXkgbGlzdCwgYW5kIHNldHMgaXRzIHBhcmVudCB0byBudWxsLlxuXHQgKlxuXHQgKiBAZXhhbXBsZVxuXHQgKiBjb250YWluZXIucmVtb3ZlQ2hpbGRBdCgyKTtcblx0ICogLy8gWW91IGNhbiBhbHNvIHJlbW92ZSBtdWx0aXBsZSBjaGlsZHJlbjpcblx0ICogY29udGFpbmVyLnJlbW92ZUNoaWxkQXQoMiwgNywgLi4uKVxuXHQgKlxuXHQgKiBAcGFyYW0gey4uLk51bWJlcn0gaW5kZXhlcyBUaGUgaW5kZXhlcyBvZiBjaGlsZHJlbiB0byByZW1vdmUuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIGNoaWxkIChvciBjaGlsZHJlbikgd2FzIHJlbW92ZWQsIG9yIGZhbHNlIGlmIGFueSBpbmRleCB3YXMgb3V0IG9mIHJhbmdlLlxuXHQgKi9cblx0cmVtb3ZlQ2hpbGRBdCAoLi4uaW5kZXhlcykge1xuXHRcdGNvbnN0IGwgPSBpbmRleGVzLmxlbmd0aDtcbiAgICBpZiAobCA9PT0gMCkgeyByZXR1cm4gdHJ1ZTsgfVxuXHRcdGlmIChsID4gMSkge1xuXHRcdFx0aW5kZXhlcy5zb3J0KChhLCBiKSA9PiBiIC0gYSk7XG5cdFx0XHRsZXQgZ29vZCA9IHRydWU7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGw7IGkrKykgeyBnb29kID0gZ29vZCAmJiB0aGlzLl9yZW1vdmVDaGlsZEF0KGluZGV4ZXNbaV0pOyB9XG5cdFx0XHRyZXR1cm4gZ29vZDtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX3JlbW92ZUNoaWxkQXQoaW5kZXhlc1swXSk7XG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlcyBhbGwgY2hpbGRyZW4gZnJvbSB0aGUgZGlzcGxheSBsaXN0LlxuXHQgKi9cblx0cmVtb3ZlQWxsQ2hpbGRyZW4gKCkge1xuXHRcdGxldCBraWRzID0gdGhpcy5jaGlsZHJlbjtcblx0XHR3aGlsZSAoa2lkcy5sZW5ndGgpIHsgdGhpcy5fcmVtb3ZlQ2hpbGRBdCgwKTsgfVxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGNoaWxkIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXguXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIGNoaWxkIHRvIHJldHVybi5cblx0ICogQHJldHVybiB7ZWFzZWxqcy5EaXNwbGF5T2JqZWN0fSBUaGUgY2hpbGQgYXQgdGhlIHNwZWNpZmllZCBpbmRleC4gUmV0dXJucyBudWxsIGlmIHRoZXJlIGlzIG5vIGNoaWxkIGF0IHRoZSBpbmRleC5cblx0ICovXG5cdGdldENoaWxkQXQgKGluZGV4KSB7XG5cdFx0cmV0dXJuIHRoaXMuY2hpbGRyZW5baW5kZXhdO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGNoaWxkIHdpdGggdGhlIHNwZWNpZmllZCBuYW1lLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgY2hpbGQgdG8gcmV0dXJuLlxuXHQgKiBAcmV0dXJuIHtlYXNlbGpzLkRpc3BsYXlPYmplY3R9IFRoZSBjaGlsZCB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZS5cblx0ICovXG5cdGdldENoaWxkQnlOYW1lIChuYW1lKSB7XG5cdFx0bGV0IGtpZHMgPSB0aGlzLmNoaWxkcmVuO1xuXHRcdGNvbnN0IGwgPSBraWRzLmxlbmd0aDtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGw7IGkrKykge1xuXHRcdFx0aWYgKGtpZHNbaV0ubmFtZSA9PT0gbmFtZSkgeyByZXR1cm4ga2lkc1tpXTsgfVxuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBQZXJmb3JtcyBhbiBhcnJheSBzb3J0IG9wZXJhdGlvbiBvbiB0aGUgY2hpbGQgbGlzdC5cblx0ICpcblx0ICogQGV4YW1wbGVcblx0ICogLy8gRGlzcGxheSBjaGlsZHJlbiB3aXRoIGEgaGlnaGVyIHkgaW4gZnJvbnQuXG5cdCAqIGNvbnRhaW5lci5zb3J0Q2hpbGRyZW4oKG9iajEsIG9iajIsIG9wdGlvbnMpID0+IHtcblx0ICogXHQgaWYgKG9iajEueSA+IG9iajIueSkgeyByZXR1cm4gMTsgfVxuXHQgKiAgIGlmIChvYmoxLnkgPCBvYmoyLnkpIHsgcmV0dXJuIC0xOyB9XG5cdCAqICAgcmV0dXJuIDA7XG5cdCAqIH0pO1xuXHQgKlxuXHQgKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9zb3J0fVxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzb3J0RnVuY3Rpb24gdGhlIGZ1bmN0aW9uIHRvIHVzZSB0byBzb3J0IHRoZSBjaGlsZCBsaXN0LlxuXHQgKi9cblx0c29ydENoaWxkcmVuIChzb3J0RnVuY3Rpb24pIHtcblx0XHR0aGlzLmNoaWxkcmVuLnNvcnQoc29ydEZ1bmN0aW9uKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgc3BlY2lmaWVkIGNoaWxkIGluIHRoZSBkaXNwbGF5IGxpc3QsIG9yIC0xIGlmIGl0IGlzIG5vdCBpbiB0aGUgZGlzcGxheSBsaXN0LlxuXHQgKiBAcGFyYW0ge2Vhc2VsanMuRGlzcGxheU9iamVjdH0gY2hpbGQgVGhlIGNoaWxkIHRvIHJldHVybiB0aGUgaW5kZXggb2YuXG5cdCAqIEByZXR1cm4ge051bWJlcn0gVGhlIGluZGV4IG9mIHRoZSBzcGVjaWZpZWQgY2hpbGQuIC0xIGlmIHRoZSBjaGlsZCBpcyBub3QgZm91bmQuXG5cdCAqL1xuXHRnZXRDaGlsZEluZGV4IChjaGlsZCkge1xuXHRcdHJldHVybiB0aGlzLmNoaWxkcmVuLmluZGV4T2YoY2hpbGQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFN3YXBzIHRoZSBjaGlsZHJlbiBhdCB0aGUgc3BlY2lmaWVkIGluZGV4ZXMuIEZhaWxzIHNpbGVudGx5IGlmIGVpdGhlciBpbmRleCBpcyBvdXQgb2YgcmFuZ2UuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleDFcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4MlxuXHQgKi9cblx0c3dhcENoaWxkcmVuQXQgKGluZGV4MSwgaW5kZXgyKSB7XG5cdFx0bGV0IGtpZHMgPSB0aGlzLmNoaWxkcmVuO1xuXHRcdGxldCBvMSA9IGtpZHNbaW5kZXgxXTtcblx0XHRsZXQgbzIgPSBraWRzW2luZGV4Ml07XG5cdFx0aWYgKCFvMSB8fCAhbzIpIHsgcmV0dXJuOyB9XG5cdFx0a2lkc1tpbmRleDFdID0gbzI7XG5cdFx0a2lkc1tpbmRleDJdID0gbzE7XG5cdH07XG5cblx0LyoqXG5cdCAqIFN3YXBzIHRoZSBzcGVjaWZpZWQgY2hpbGRyZW4ncyBkZXB0aCBpbiB0aGUgZGlzcGxheSBsaXN0LiBGYWlscyBzaWxlbnRseSBpZiBlaXRoZXIgY2hpbGQgaXMgbm90IGEgY2hpbGQgb2YgdGhpc1xuXHQgKiBDb250YWluZXIuXG5cdCAqIEBwYXJhbSB7ZWFzZWxqcy5EaXNwbGF5T2JqZWN0fSBjaGlsZDFcblx0ICogQHBhcmFtIHtlYXNlbGpzLkRpc3BsYXlPYmplY3R9IGNoaWxkMlxuXHQgKi9cblx0c3dhcENoaWxkcmVuIChjaGlsZDEsIGNoaWxkMikge1xuXHRcdGxldCBraWRzID0gdGhpcy5jaGlsZHJlbjtcblx0XHRjb25zdCBsID0ga2lkcy5sZW5ndGg7XG5cdFx0bGV0IGluZGV4MSxpbmRleDI7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcblx0XHRcdGlmIChraWRzW2ldID09PSBjaGlsZDEpIHsgaW5kZXgxID0gaTsgfVxuXHRcdFx0aWYgKGtpZHNbaV0gPT09IGNoaWxkMikgeyBpbmRleDIgPSBpOyB9XG5cdFx0XHRpZiAoaW5kZXgxICE9IG51bGwgJiYgaW5kZXgyICE9IG51bGwpIHsgYnJlYWs7IH1cblx0XHR9XG5cdFx0aWYgKGkgPT09IGwpIHsgcmV0dXJuOyB9IC8vIFRPRE86IHRocm93IGVycm9yP1xuXHRcdGtpZHNbaW5kZXgxXSA9IGNoaWxkMjtcblx0XHRraWRzW2luZGV4Ml0gPSBjaGlsZDE7XG5cdH1cblxuXHQvKipcblx0ICogQ2hhbmdlcyB0aGUgZGVwdGggb2YgdGhlIHNwZWNpZmllZCBjaGlsZC4gRmFpbHMgc2lsZW50bHkgaWYgdGhlIGNoaWxkIGlzIG5vdCBhIGNoaWxkIG9mIHRoaXMgY29udGFpbmVyLCBvciB0aGUgaW5kZXggaXMgb3V0IG9mIHJhbmdlLlxuXHQgKiBAcGFyYW0ge2Vhc2VsanMuRGlzcGxheU9iamVjdH0gY2hpbGRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG5cdCAqL1xuXHRzZXRDaGlsZEluZGV4IChjaGlsZCwgaW5kZXgpIHtcblx0XHRsZXQga2lkcyA9IHRoaXMuY2hpbGRyZW47XG5cdFx0Y29uc3QgbCA9IGtpZHMubGVuZ3RoO1xuXHRcdGlmIChjaGlsZC5wYXJlbnQgIT0gdGhpcyB8fCBpbmRleCA8IDAgfHwgaW5kZXggPj0gbCkgeyByZXR1cm47IH1cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuXHRcdFx0aWYgKGtpZHNbaV0gPT09IGNoaWxkKSB7IGJyZWFrOyB9XG5cdFx0fVxuXHRcdGlmIChpID09PSBsIHx8IGkgPT09IGluZGV4KSB7IHJldHVybjsgfVxuXHRcdGtpZHMuc3BsaWNlKGksIDEpO1xuXHRcdGtpZHMuc3BsaWNlKGluZGV4LCAwLCBjaGlsZCk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgZGlzcGxheSBvYmplY3QgZWl0aGVyIGlzIHRoaXMgY29udGFpbmVyIG9yIGlzIGEgZGVzY2VuZGVudCAoY2hpbGQsIGdyYW5kY2hpbGQsIGV0Yylcblx0ICogb2YgdGhpcyBjb250YWluZXIuXG5cdCAqIEBwYXJhbSB7ZWFzZWxqcy5EaXNwbGF5T2JqZWN0fSBjaGlsZCBUaGUgRGlzcGxheU9iamVjdCB0byBiZSBjaGVja2VkLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgZGlzcGxheSBvYmplY3QgZWl0aGVyIGlzIHRoaXMgY29udGFpbmVyIG9yIGlzIGEgZGVzY2VuZGVudC5cblx0ICovXG5cdGNvbnRhaW5zIChjaGlsZCkge1xuXHRcdHdoaWxlIChjaGlsZCkge1xuXHRcdFx0aWYgKGNoaWxkID09PSB0aGlzKSB7IHJldHVybiB0cnVlOyB9XG5cdFx0XHRjaGlsZCA9IGNoaWxkLnBhcmVudDtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRlc3RzIHdoZXRoZXIgdGhlIGRpc3BsYXkgb2JqZWN0IGludGVyc2VjdHMgdGhlIHNwZWNpZmllZCBsb2NhbCBwb2ludCAoaWUuIGRyYXdzIGEgcGl4ZWwgd2l0aCBhbHBoYSA+IDAgYXQgdGhlXG5cdCAqIHNwZWNpZmllZCBwb3NpdGlvbikuIFRoaXMgaWdub3JlcyB0aGUgYWxwaGEsIHNoYWRvdyBhbmQgY29tcG9zaXRlT3BlcmF0aW9uIG9mIHRoZSBkaXNwbGF5IG9iamVjdCwgYW5kIGFsbFxuXHQgKiB0cmFuc2Zvcm0gcHJvcGVydGllcyBpbmNsdWRpbmcgcmVnWC9ZLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgeCBwb3NpdGlvbiB0byBjaGVjayBpbiB0aGUgZGlzcGxheSBvYmplY3QncyBsb2NhbCBjb29yZGluYXRlcy5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHkgcG9zaXRpb24gdG8gY2hlY2sgaW4gdGhlIGRpc3BsYXkgb2JqZWN0J3MgbG9jYWwgY29vcmRpbmF0ZXMuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IEEgQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlcmUgaXMgYSB2aXNpYmxlIHNlY3Rpb24gb2YgYSBEaXNwbGF5T2JqZWN0IHRoYXQgb3ZlcmxhcHMgdGhlIHNwZWNpZmllZFxuXHQgKiBjb29yZGluYXRlcy5cblx0ICovXG5cdGhpdFRlc3QgKHgsIHkpIHtcblx0XHQvLyBUT0RPOiBvcHRpbWl6ZSB0byB1c2UgdGhlIGZhc3QgY2FjaGUgY2hlY2sgd2hlcmUgcG9zc2libGUuXG5cdFx0cmV0dXJuIHRoaXMuZ2V0T2JqZWN0VW5kZXJQb2ludCh4LCB5KSAhPSBudWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYW4gYXJyYXkgb2YgYWxsIGRpc3BsYXkgb2JqZWN0cyB1bmRlciB0aGUgc3BlY2lmaWVkIGNvb3JkaW5hdGVzIHRoYXQgYXJlIGluIHRoaXMgY29udGFpbmVyJ3MgZGlzcGxheVxuXHQgKiBsaXN0LiBUaGlzIHJvdXRpbmUgaWdub3JlcyBhbnkgZGlzcGxheSBvYmplY3RzIHdpdGgge0BsaW5rIGVhc2VsanMuRGlzcGxheU9iamVjdCNtb3VzZUVuYWJsZWR9IHNldCB0byBgZmFsc2VgLlxuXHQgKiBUaGUgYXJyYXkgd2lsbCBiZSBzb3J0ZWQgaW4gb3JkZXIgb2YgdmlzdWFsIGRlcHRoLCB3aXRoIHRoZSB0b3AtbW9zdCBkaXNwbGF5IG9iamVjdCBhdCBpbmRleCAwLlxuXHQgKiBUaGlzIHVzZXMgc2hhcGUgYmFzZWQgaGl0IGRldGVjdGlvbiwgYW5kIGNhbiBiZSBhbiBleHBlbnNpdmUgb3BlcmF0aW9uIHRvIHJ1biwgc28gaXQgaXMgYmVzdCB0byB1c2UgaXQgY2FyZWZ1bGx5LlxuXHQgKiBGb3IgZXhhbXBsZSwgaWYgdGVzdGluZyBmb3Igb2JqZWN0cyB1bmRlciB0aGUgbW91c2UsIHRlc3Qgb24gdGljayAoaW5zdGVhZCBvZiBvbiB7QGxpbmsgZWFzZWxqcy5EaXNwbGF5T2JqZWN0I2V2ZW50Om1vdXNlbW92ZX0pLFxuXHQgKiBhbmQgb25seSBpZiB0aGUgbW91c2UncyBwb3NpdGlvbiBoYXMgY2hhbmdlZC5cblx0ICpcblx0ICogPHVsPlxuXHQgKiAgIDxsaT5CeSBkZWZhdWx0IChtb2RlPTApIHRoaXMgbWV0aG9kIGV2YWx1YXRlcyBhbGwgZGlzcGxheSBvYmplY3RzLjwvbGk+XG5cdCAqICAgPGxpPkJ5IHNldHRpbmcgdGhlIGBtb2RlYCBwYXJhbWV0ZXIgdG8gYDFgLCB0aGUge0BsaW5rIGVhc2VsanMuRGlzcGxheU9iamVjdCNtb3VzZUVuYWJsZWR9XG5cdCAqICAgICAgIGFuZCB7QGxpbmsgZWFzZWxqcy5EaXNwbGF5T2JqZWN0I21vdXNlQ2hpbGRyZW59IHByb3BlcnRpZXMgd2lsbCBiZSByZXNwZWN0ZWQuPC9saT5cblx0ICogICA8bGk+U2V0dGluZyB0aGUgYG1vZGVgIHRvIGAyYCBhZGRpdGlvbmFsbHkgZXhjbHVkZXMgZGlzcGxheSBvYmplY3RzIHRoYXQgZG8gbm90IGhhdmUgYWN0aXZlIG1vdXNlIGV2ZW50XG5cdCAqICAgICAgIGxpc3RlbmVycyBvciBhIHtAbGluayBlYXNlbGpzLkRpc3BsYXlPYmplY3QjY3Vyc29yfSBwcm9wZXJ0eS4gVGhhdCBpcywgb25seSBvYmplY3RzXG5cdCAqICAgICAgIHRoYXQgd291bGQgbm9ybWFsbHkgaW50ZXJjZXB0IG1vdXNlIGludGVyYWN0aW9uIHdpbGwgYmUgaW5jbHVkZWQuIFRoaXMgY2FuIHNpZ25pZmljYW50bHkgaW1wcm92ZSBwZXJmb3JtYW5jZVxuXHQgKiAgICAgICBpbiBzb21lIGNhc2VzIGJ5IHJlZHVjaW5nIHRoZSBudW1iZXIgb2YgZGlzcGxheSBvYmplY3RzIHRoYXQgbmVlZCB0byBiZSB0ZXN0ZWQuPC9saT5cblx0ICogPC91bD5cblx0ICpcblx0ICogVGhpcyBtZXRob2QgYWNjb3VudHMgZm9yIGJvdGgge0BsaW5rIGVhc2VsanMuRGlzcGxheU9iamVjdCNoaXRBcmVhfSBhbmQge0BsaW5rIGVhc2VsanMuRGlzcGxheU9iamVjdCNtYXNrfS5cblx0ICpcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIHggcG9zaXRpb24gaW4gdGhlIGNvbnRhaW5lciB0byB0ZXN0LlxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgeSBwb3NpdGlvbiBpbiB0aGUgY29udGFpbmVyIHRvIHRlc3QuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbbW9kZT0wXSBUaGUgbW9kZSB0byB1c2UgdG8gZGV0ZXJtaW5lIHdoaWNoIGRpc3BsYXkgb2JqZWN0cyB0byBpbmNsdWRlLiAwLWFsbCwgMS1yZXNwZWN0IG1vdXNlRW5hYmxlZC9tb3VzZUNoaWxkcmVuLCAyLW9ubHkgbW91c2Ugb3BhcXVlIG9iamVjdHMuXG5cdCAqIEByZXR1cm4ge0FycmF5PGVhc2VsanMuRGlzcGxheU9iamVjdD59IEFuIGFycmF5IG9mIERpc3BsYXlPYmplY3RzIHVuZGVyIHRoZSBzcGVjaWZpZWQgY29vcmRpbmF0ZXMuXG5cdCAqL1xuXHRnZXRPYmplY3RzVW5kZXJQb2ludCAoeCwgeSwgbW9kZSA9IDApIHtcblx0XHRsZXQgYXJyID0gW107XG5cdFx0bGV0IHB0ID0gdGhpcy5sb2NhbFRvR2xvYmFsKHgsIHkpO1xuXHRcdHRoaXMuX2dldE9iamVjdHNVbmRlclBvaW50KHB0LngsIHB0LnksIGFyciwgbW9kZSA+IDAsIG1vZGUgPT09IDEpO1xuXHRcdHJldHVybiBhcnI7XG5cdH1cblxuXHQvKipcblx0ICogU2ltaWxhciB0byB7QGxpbmsgZWFzZWxqcy5Db250YWluZXIjZ2V0T2JqZWN0c1VuZGVyUG9pbnR9LCBidXQgcmV0dXJucyBvbmx5IHRoZSB0b3AtbW9zdCBkaXNwbGF5XG5cdCAqIG9iamVjdC4gVGhpcyBydW5zIHNpZ25pZmljYW50bHkgZmFzdGVyIHRoYW4gYGdldE9iamVjdHNVbmRlclBvaW50KClgLCBidXQgaXMgc3RpbGwgcG90ZW50aWFsbHkgYW4gZXhwZW5zaXZlXG5cdCAqIG9wZXJhdGlvbi5cblx0ICpcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIHggcG9zaXRpb24gaW4gdGhlIGNvbnRhaW5lciB0byB0ZXN0LlxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgeSBwb3NpdGlvbiBpbiB0aGUgY29udGFpbmVyIHRvIHRlc3QuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbbW9kZT0wXSBUaGUgbW9kZSB0byB1c2UgdG8gZGV0ZXJtaW5lIHdoaWNoIGRpc3BsYXkgb2JqZWN0cyB0byBpbmNsdWRlLiAgMC1hbGwsIDEtcmVzcGVjdCBtb3VzZUVuYWJsZWQvbW91c2VDaGlsZHJlbiwgMi1vbmx5IG1vdXNlIG9wYXF1ZSBvYmplY3RzLlxuXHQgKiBAcmV0dXJuIHtlYXNlbGpzLkRpc3BsYXlPYmplY3R9IFRoZSB0b3AtbW9zdCBkaXNwbGF5IG9iamVjdCB1bmRlciB0aGUgc3BlY2lmaWVkIGNvb3JkaW5hdGVzLlxuXHQgKi9cblx0Z2V0T2JqZWN0VW5kZXJQb2ludCAoeCwgeSwgbW9kZSA9IDApIHtcblx0XHRsZXQgcHQgPSB0aGlzLmxvY2FsVG9HbG9iYWwoeCwgeSk7XG5cdFx0cmV0dXJuIHRoaXMuX2dldE9iamVjdHNVbmRlclBvaW50KHB0LngsIHB0LnksIG51bGwsIG1vZGUgPiAwLCBtb2RlID09PSAxKTtcblx0fVxuXG5cdGdldEJvdW5kcyAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2dldEJvdW5kcyhudWxsLCB0cnVlKTtcblx0fVxuXG5cdGdldFRyYW5zZm9ybWVkQm91bmRzICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fZ2V0Qm91bmRzKCk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIGNsb25lIG9mIHRoaXMgQ29udGFpbmVyLiBTb21lIHByb3BlcnRpZXMgdGhhdCBhcmUgc3BlY2lmaWMgdG8gdGhpcyBpbnN0YW5jZSdzIGN1cnJlbnQgY29udGV4dCBhcmVcblx0ICogcmV2ZXJ0ZWQgdG8gdGhlaXIgZGVmYXVsdHMgKGZvciBleGFtcGxlIGAucGFyZW50YCkuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3JlY3Vyc2l2ZT1mYWxzZV0gSWYgdHJ1ZSwgYWxsIG9mIHRoZSBkZXNjZW5kYW50cyBvZiB0aGlzIGNvbnRhaW5lciB3aWxsIGJlIGNsb25lZCByZWN1cnNpdmVseS4gSWYgZmFsc2UsIHRoZVxuXHQgKiBwcm9wZXJ0aWVzIG9mIHRoZSBjb250YWluZXIgd2lsbCBiZSBjbG9uZWQsIGJ1dCB0aGUgbmV3IGluc3RhbmNlIHdpbGwgbm90IGhhdmUgYW55IGNoaWxkcmVuLlxuXHQgKiBAcmV0dXJuIHtlYXNlbGpzLkNvbnRhaW5lcn0gQSBjbG9uZSBvZiB0aGUgY3VycmVudCBDb250YWluZXIgaW5zdGFuY2UuXG5cdCAqL1xuXHRjbG9uZSAocmVjdXJzaXZlID0gZmFsc2UpIHtcblx0XHRsZXQgbyA9IHRoaXMuX2Nsb25lUHJvcHMobmV3IENvbnRhaW5lcigpKTtcblx0XHRpZiAocmVjdXJzaXZlKSB7IHRoaXMuX2Nsb25lQ2hpbGRyZW4obyk7IH1cblx0XHRyZXR1cm4gbztcblx0fVxuXG5cdF90aWNrIChldnRPYmopIHtcblx0XHRpZiAodGhpcy50aWNrQ2hpbGRyZW4pIHtcblx0XHRcdGZvciAobGV0IGkgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG5cdFx0XHRcdGlmIChjaGlsZC50aWNrRW5hYmxlZCAmJiBjaGlsZC5fdGljaykgeyBjaGlsZC5fdGljayhldnRPYmopOyB9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHN1cGVyLl90aWNrKGV2dE9iaik7XG5cdH1cblxuXHQvKipcblx0ICogUmVjdXJzaXZlbHkgY2xvbmVzIGFsbCBjaGlsZHJlbiBvZiB0aGlzIGNvbnRhaW5lciwgYW5kIGFkZHMgdGhlbSB0byB0aGUgdGFyZ2V0IGNvbnRhaW5lci5cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge2Vhc2VsanMuQ29udGFpbmVyfSBvIFRoZSB0YXJnZXQgY29udGFpbmVyLlxuXHQgKi9cblx0X2Nsb25lQ2hpbGRyZW4gKG8pIHtcblx0XHRpZiAoby5jaGlsZHJlbi5sZW5ndGgpIHsgby5yZW1vdmVBbGxDaGlsZHJlbigpOyB9XG5cdFx0bGV0IGFyciA9IG8uY2hpbGRyZW47XG5cdFx0Y29uc3QgbCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRsZXQgY2xvbmUgPSB0aGlzLmNoaWxkcmVuW2ldLmNsb25lKHRydWUpO1xuXHRcdFx0Y2xvbmUucGFyZW50ID0gbztcblx0XHRcdGFyci5wdXNoKGNsb25lKTtcblx0XHR9XG5cdH1cblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgY2hpbGQgYXQgdGhlIHNwZWNpZmllZCBpbmRleCBmcm9tIHRoZSBkaXNwbGF5IGxpc3QsIGFuZCBzZXRzIGl0cyBwYXJlbnQgdG8gbnVsbC5cbiAgICogVXNlZCBieSBgcmVtb3ZlQ2hpbGRBdGAsIGBhZGRDaGlsZGAsIGFuZCBgYWRkQ2hpbGRBdGAuXG4gICAqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgY2hpbGQgdG8gcmVtb3ZlLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzaWxlbnQ9ZmFsc2VdIFByZXZlbnRzIGRpc3BhdGNoIG9mIGByZW1vdmVkYCBldmVudCBpZiB0cnVlLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoZSBjaGlsZCAob3IgY2hpbGRyZW4pIHdhcyByZW1vdmVkLCBvciBmYWxzZSBpZiBhbnkgaW5kZXggd2FzIG91dCBvZiByYW5nZS5cbiAgICovXG4gIF9yZW1vdmVDaGlsZEF0IChpbmRleCwgc2lsZW50ID0gZmFsc2UpIHtcblx0XHRpZiAoaW5kZXggPCAwIHx8IGluZGV4ID4gdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baW5kZXhdO1xuXHRcdGlmIChjaGlsZCkgeyBjaGlsZC5wYXJlbnQgPSBudWxsOyB9XG5cdFx0dGhpcy5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdGlmICghc2lsZW50KSB7IGNoaWxkLmRpc3BhdGNoRXZlbnQoXCJyZW1vdmVkXCIpOyB9XG5cdFx0cmV0dXJuIHRydWU7XG4gIH1cblxuXHQvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcnJcblx0ICogQHBhcmFtIHtCb29sZWFufSBtb3VzZSBJZiB0cnVlLCBpdCB3aWxsIHJlc3BlY3QgbW91c2UgaW50ZXJhY3Rpb24gcHJvcGVydGllcyBsaWtlIG1vdXNlRW5hYmxlZCwgbW91c2VDaGlsZHJlbiwgYW5kIGFjdGl2ZSBsaXN0ZW5lcnMuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gYWN0aXZlTGlzdGVuZXIgSWYgdHJ1ZSwgdGhlcmUgaXMgYW4gYWN0aXZlIG1vdXNlIGV2ZW50IGxpc3RlbmVyIG9uIGEgcGFyZW50IG9iamVjdC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtjdXJyZW50RGVwdGg9MF0gSW5kaWNhdGVzIHRoZSBjdXJyZW50IGRlcHRoIG9mIHRoZSBzZWFyY2guXG5cdCAqIEByZXR1cm4ge2Vhc2VsanMuRGlzcGxheU9iamVjdH1cblx0ICovXG5cdF9nZXRPYmplY3RzVW5kZXJQb2ludCAoeCwgeSwgYXJyLCBtb3VzZSwgYWN0aXZlTGlzdGVuZXIsIGN1cnJlbnREZXB0aCA9IDApIHtcblx0XHRpZiAoIWN1cnJlbnREZXB0aCAmJiAhdGhpcy5fdGVzdE1hc2sodGhpcywgeCwgeSkpIHsgcmV0dXJuIG51bGw7IH1cblx0XHRsZXQgbXR4LCBjdHggPSBEaXNwbGF5T2JqZWN0Ll9oaXRUZXN0Q29udGV4dDtcblx0XHRhY3RpdmVMaXN0ZW5lciA9IGFjdGl2ZUxpc3RlbmVyIHx8IChtb3VzZSAmJiB0aGlzLl9oYXNNb3VzZUV2ZW50TGlzdGVuZXIoKSk7XG5cblx0XHQvLyBkcmF3IGNoaWxkcmVuIG9uZSBhdCBhIHRpbWUsIGFuZCBjaGVjayBpZiB3ZSBnZXQgYSBoaXQ6XG5cdFx0bGV0IGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcblx0XHRjb25zdCBsID0gY2hpbGRyZW4ubGVuZ3RoO1xuXHRcdGZvciAobGV0IGkgPSBsIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdGxldCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuXHRcdFx0bGV0IGhpdEFyZWEgPSBjaGlsZC5oaXRBcmVhO1xuXHRcdFx0aWYgKCFjaGlsZC52aXNpYmxlIHx8ICghaGl0QXJlYSAmJiAhY2hpbGQuaXNWaXNpYmxlKCkpIHx8IChtb3VzZSAmJiAhY2hpbGQubW91c2VFbmFibGVkKSkgeyBjb250aW51ZTsgfVxuXHRcdFx0aWYgKCFoaXRBcmVhICYmICF0aGlzLl90ZXN0TWFzayhjaGlsZCwgeCwgeSkpIHsgY29udGludWU7IH1cblxuXHRcdFx0Ly8gaWYgYSBjaGlsZCBjb250YWluZXIgaGFzIGEgaGl0QXJlYSB0aGVuIHdlIG9ubHkgbmVlZCB0byBjaGVjayBpdHMgaGl0QXJlYSwgc28gd2UgY2FuIHRyZWF0IGl0IGFzIGEgbm9ybWFsIERPOlxuXHRcdFx0aWYgKCFoaXRBcmVhICYmIGNoaWxkIGluc3RhbmNlb2YgQ29udGFpbmVyKSB7XG5cdFx0XHRcdGxldCByZXN1bHQgPSBjaGlsZC5fZ2V0T2JqZWN0c1VuZGVyUG9pbnQoeCwgeSwgYXJyLCBtb3VzZSwgYWN0aXZlTGlzdGVuZXIsIGN1cnJlbnREZXB0aCArIDEpO1xuXHRcdFx0XHRpZiAoIWFyciAmJiByZXN1bHQpIHsgcmV0dXJuIChtb3VzZSAmJiAhdGhpcy5tb3VzZUNoaWxkcmVuKSA/IHRoaXMgOiByZXN1bHQ7IH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmIChtb3VzZSAmJiAhYWN0aXZlTGlzdGVuZXIgJiYgIWNoaWxkLl9oYXNNb3VzZUV2ZW50TGlzdGVuZXIoKSkgeyBjb250aW51ZTsgfVxuXG5cdFx0XHRcdC8vIFRPRE86IGNhbiB3ZSBwYXNzIGRpc3BsYXlQcm9wcyBmb3J3YXJkLCB0byBhdm9pZCBoYXZpbmcgdG8gY2FsY3VsYXRlIHRoaXMgYmFja3dhcmRzIGV2ZXJ5IHRpbWU/IEl0J3Mga2luZCBvZiBhIG1peGVkIGJhZy4gV2hlbiB3ZSdyZSBvbmx5IGh1bnRpbmcgZm9yIERPcyB3aXRoIGV2ZW50IGxpc3RlbmVycywgaXQgbWF5IG5vdCBtYWtlIHNlbnNlLlxuXHRcdFx0XHRsZXQgcHJvcHMgPSBjaGlsZC5nZXRDb25jYXRlbmF0ZWREaXNwbGF5UHJvcHMoY2hpbGQuX3Byb3BzKTtcblx0XHRcdFx0bXR4ID0gcHJvcHMubWF0cml4O1xuXG5cdFx0XHRcdGlmIChoaXRBcmVhKSB7XG5cdFx0XHRcdFx0bXR4LmFwcGVuZE1hdHJpeChoaXRBcmVhLmdldE1hdHJpeChoaXRBcmVhLl9wcm9wcy5tYXRyaXgpKTtcblx0XHRcdFx0XHRwcm9wcy5hbHBoYSA9IGhpdEFyZWEuYWxwaGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjdHguZ2xvYmFsQWxwaGEgPSBwcm9wcy5hbHBoYTtcblx0XHRcdFx0Y3R4LnNldFRyYW5zZm9ybShtdHguYSwgbXR4LmIsIG10eC5jLCBtdHguZCwgbXR4LnR4LXgsIG10eC50eS15KTtcblx0XHRcdFx0KGhpdEFyZWEgfHwgY2hpbGQpLmRyYXcoY3R4KTtcblx0XHRcdFx0aWYgKCF0aGlzLl90ZXN0SGl0KGN0eCkpIHsgY29udGludWU7IH1cblx0XHRcdFx0Y3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcblx0XHRcdFx0Y3R4LmNsZWFyUmVjdCgwLCAwLCAyLCAyKTtcblx0XHRcdFx0aWYgKGFycikgeyBhcnIucHVzaChjaGlsZCk7IH1cblx0XHRcdFx0ZWxzZSB7IHJldHVybiAobW91c2UgJiYgIXRoaXMubW91c2VDaGlsZHJlbikgPyB0aGlzIDogY2hpbGQ7IH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge2Vhc2VsanMuRGlzcGxheU9iamVjdH0gdGFyZ2V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IEluZGljYXRlcyB3aGV0aGVyIHRoZSB4L3kgaXMgd2l0aGluIHRoZSBtYXNrZWQgcmVnaW9uLlxuXHQgKi9cblx0X3Rlc3RNYXNrICh0YXJnZXQsIHgsIHkpIHtcblx0XHRsZXQgbWFzayA9IHRhcmdldC5tYXNrO1xuXHRcdGlmICghbWFzayB8fCAhbWFzay5ncmFwaGljcyB8fCBtYXNrLmdyYXBoaWNzLmlzRW1wdHkoKSkgeyByZXR1cm4gdHJ1ZTsgfVxuXG5cdFx0bGV0IG10eCA9IHRoaXMuX3Byb3BzLm1hdHJpeCwgcGFyZW50ID0gdGFyZ2V0LnBhcmVudDtcblx0XHRtdHggPSBwYXJlbnQgPyBwYXJlbnQuZ2V0Q29uY2F0ZW5hdGVkTWF0cml4KG10eCkgOiBtdHguaWRlbnRpdHkoKTtcblx0XHRtdHggPSBtYXNrLmdldE1hdHJpeChtYXNrLl9wcm9wcy5tYXRyaXgpLnByZXBlbmRNYXRyaXgobXR4KTtcblxuXHRcdGxldCBjdHggPSBEaXNwbGF5T2JqZWN0Ll9oaXRUZXN0Q29udGV4dDtcblx0XHRjdHguc2V0VHJhbnNmb3JtKG10eC5hLCBtdHguYiwgbXR4LmMsIG10eC5kLCBtdHgudHgteCwgbXR4LnR5LXkpO1xuXG5cdFx0Ly8gZHJhdyB0aGUgbWFzayBhcyBhIHNvbGlkIGZpbGw6XG5cdFx0bWFzay5ncmFwaGljcy5kcmF3QXNQYXRoKGN0eCk7XG5cdFx0Y3R4LmZpbGxTdHlsZSA9IFwiIzAwMFwiO1xuXHRcdGN0eC5maWxsKCk7XG5cblx0XHRpZiAoIXRoaXMuX3Rlc3RIaXQoY3R4KSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuXHRcdGN0eC5jbGVhclJlY3QoMCwgMCwgMiwgMik7XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwYXJhbSB7ZWFzZWxqcy5NYXRyaXgyRH0gbWF0cml4XG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaWdub3JlVHJhbnNmb3JtIElmIHRydWUsIGRvZXMgbm90IGFwcGx5IHRoaXMgb2JqZWN0J3MgdHJhbnNmb3JtLlxuXHQgKiBAcmV0dXJuIHtlYXNlbGpzLlJlY3RhbmdsZX1cblx0ICovXG5cdF9nZXRCb3VuZHMgKG1hdHJpeCwgaWdub3JlVHJhbnNmb3JtKSB7XG5cdFx0bGV0IGJvdW5kcyA9IHN1cGVyLmdldEJvdW5kcygpO1xuXHRcdGlmIChib3VuZHMpIHsgcmV0dXJuIHRoaXMuX3RyYW5zZm9ybUJvdW5kcyhib3VuZHMsIG1hdHJpeCwgaWdub3JlVHJhbnNmb3JtKTsgfVxuXG5cdFx0bGV0IG10eCA9IHRoaXMuX3Byb3BzLm1hdHJpeDtcblx0XHRtdHggPSBpZ25vcmVUcmFuc2Zvcm0gPyBtdHguaWRlbnRpdHkoKSA6IHRoaXMuZ2V0TWF0cml4KG10eCk7XG5cdFx0aWYgKG1hdHJpeCkgeyBtdHgucHJlcGVuZE1hdHJpeChtYXRyaXgpOyB9XG5cblx0XHRjb25zdCBsID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7XG5cdFx0bGV0IHJlY3QgPSBudWxsO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuXHRcdFx0aWYgKCFjaGlsZC52aXNpYmxlIHx8ICEoYm91bmRzID0gY2hpbGQuX2dldEJvdW5kcyhtdHgpKSkgeyBjb250aW51ZTsgfVxuXHRcdFx0aWYgKHJlY3QpIHsgcmVjdC5leHRlbmQoYm91bmRzLngsIGJvdW5kcy55LCBib3VuZHMud2lkdGgsIGJvdW5kcy5oZWlnaHQpOyB9XG5cdFx0XHRlbHNlIHsgcmVjdCA9IGJvdW5kcy5jbG9uZSgpOyB9XG5cdFx0fVxuXHRcdHJldHVybiByZWN0O1xuXHR9XG5cbn1cbiIsIi8qKlxuICogQGxpY2Vuc2UgTW91c2VFdmVudFxuICogVmlzaXQgaHR0cDovL2NyZWF0ZWpzLmNvbS8gZm9yIGRvY3VtZW50YXRpb24sIHVwZGF0ZXMgYW5kIGV4YW1wbGVzLlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNyBnc2tpbm5lci5jb20sIGluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICogb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cbiAqIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxuICogcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsXG4gKiBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4gKiBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuICogY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAqIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xuICogT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAqIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4gKiBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcbiAqIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuICogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUlxuICogT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICovXG5cbmltcG9ydCB7IEV2ZW50IH0gZnJvbSBcIkBjcmVhdGVqcy9jb3JlXCI7XG5cbi8qKlxuICogUGFzc2VkIGFzIHRoZSBwYXJhbWV0ZXIgdG8gYWxsIG1vdXNlL3BvaW50ZXIvdG91Y2ggcmVsYXRlZCBldmVudHMuIEZvciBhIGxpc3Rpbmcgb2YgbW91c2UgZXZlbnRzIGFuZCB0aGVpciBwcm9wZXJ0aWVzLFxuICogc2VlIHRoZSB7QGxpbmsgZWFzZWxqcy5EaXNwbGF5T2JqZWN0fSBhbmQge0BsaW5rIGVhc2VsanMuU3RhZ2V9IGV2ZW50IGxpc3RpbmdzLlxuICogQG1lbWJlcm9mIGVhc2VsanNcbiAqIEBleHRlbmRzIGNvcmUuRXZlbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlLlxuICogQHBhcmFtIHtCb29sZWFufSBidWJibGVzIEluZGljYXRlcyB3aGV0aGVyIHRoZSBldmVudCB3aWxsIGJ1YmJsZSB0aHJvdWdoIHRoZSBkaXNwbGF5IGxpc3QuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGNhbmNlbGFibGUgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGRlZmF1bHQgYmVoYXZpb3VyIG9mIHRoaXMgZXZlbnQgY2FuIGJlIGNhbmNlbGxlZC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBzdGFnZVggVGhlIG5vcm1hbGl6ZWQgeCBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgc3RhZ2UuXG4gKiBAcGFyYW0ge051bWJlcn0gc3RhZ2VZIFRoZSBub3JtYWxpemVkIHkgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIHN0YWdlLlxuICogQHBhcmFtIHtlYXNlbGpzLk1vdXNlRXZlbnR9IG5hdGl2ZUV2ZW50IFRoZSBuYXRpdmUgRE9NIGV2ZW50IHJlbGF0ZWQgdG8gdGhpcyBtb3VzZSBldmVudC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBwb2ludGVySUQgVGhlIHVuaXF1ZSBpZCBmb3IgdGhlIHBvaW50ZXIuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHByaW1hcnkgSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBpcyB0aGUgcHJpbWFyeSBwb2ludGVyIGluIGEgbXVsdGl0b3VjaCBlbnZpcm9ubWVudC5cbiAqIEBwYXJhbSB7TnVtYmVyfSByYXdYIFRoZSByYXcgeCBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgc3RhZ2UuXG4gKiBAcGFyYW0ge051bWJlcn0gcmF3WSBUaGUgcmF3IHkgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIHN0YWdlLlxuICogQHBhcmFtIHtlYXNlbGpzLkRpc3BsYXlPYmplY3R9IHJlbGF0ZWRUYXJnZXQgVGhlIHNlY29uZGFyeSB0YXJnZXQgZm9yIHRoZSBldmVudC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTW91c2VFdmVudCBleHRlbmRzIEV2ZW50IHtcblxuXHRjb25zdHJ1Y3RvciAodHlwZSwgYnViYmxlcywgY2FuY2VsYWJsZSwgc3RhZ2VYLCBzdGFnZVksIG5hdGl2ZUV2ZW50LCBwb2ludGVySUQsIHByaW1hcnksIHJhd1gsIHJhd1ksIHJlbGF0ZWRUYXJnZXQpIHtcblx0XHRzdXBlcih0eXBlLCBidWJibGVzLCBjYW5jZWxhYmxlKTtcblxuLy8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogVGhlIG5vcm1hbGl6ZWQgeCBwb3NpdGlvbiBvbiB0aGUgc3RhZ2UuIFRoaXMgd2lsbCBhbHdheXMgYmUgd2l0aGluIHRoZSByYW5nZSAwIHRvIHN0YWdlIHdpZHRoLlxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0Ki9cblx0XHR0aGlzLnN0YWdlWCA9IHN0YWdlWDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBub3JtYWxpemVkIHkgcG9zaXRpb24gb24gdGhlIHN0YWdlLiBUaGlzIHdpbGwgYWx3YXlzIGJlIHdpdGhpbiB0aGUgcmFuZ2UgMCB0byBzdGFnZSBoZWlnaHQuXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKi9cblx0XHR0aGlzLnN0YWdlWSA9IHN0YWdlWTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSByYXcgeCBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgc3RhZ2UuIE5vcm1hbGx5IHRoaXMgd2lsbCBiZSB0aGUgc2FtZSBhcyB0aGUgc3RhZ2VYIHZhbHVlLCB1bmxlc3Ncblx0XHQgKiBzdGFnZS5tb3VzZU1vdmVPdXRzaWRlIGlzIHRydWUgYW5kIHRoZSBwb2ludGVyIGlzIG91dHNpZGUgb2YgdGhlIHN0YWdlIGJvdW5kcy5cblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCovXG5cdFx0dGhpcy5yYXdYID0gKHJhd1g9PW51bGwpP3N0YWdlWDpyYXdYO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHJhdyB5IHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSBzdGFnZS4gTm9ybWFsbHkgdGhpcyB3aWxsIGJlIHRoZSBzYW1lIGFzIHRoZSBzdGFnZVkgdmFsdWUsIHVubGVzc1xuXHRcdCAqIHN0YWdlLm1vdXNlTW92ZU91dHNpZGUgaXMgdHJ1ZSBhbmQgdGhlIHBvaW50ZXIgaXMgb3V0c2lkZSBvZiB0aGUgc3RhZ2UgYm91bmRzLlxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0Ki9cblx0XHR0aGlzLnJhd1kgPSAocmF3WT09bnVsbCk/c3RhZ2VZOnJhd1k7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbmF0aXZlIE1vdXNlRXZlbnQgZ2VuZXJhdGVkIGJ5IHRoZSBicm93c2VyLiBUaGUgcHJvcGVydGllcyBhbmQgQVBJIGZvciB0aGlzXG5cdFx0ICogZXZlbnQgbWF5IGRpZmZlciBiZXR3ZWVuIGJyb3dzZXJzLiBUaGlzIHByb3BlcnR5IHdpbGwgYmUgbnVsbCBpZiB0aGVcblx0XHQgKiBFYXNlbEpTIHByb3BlcnR5IHdhcyBub3QgZGlyZWN0bHkgZ2VuZXJhdGVkIGZyb20gYSBuYXRpdmUgTW91c2VFdmVudC5cblx0XHQgKiBAdHlwZSB7SFRNTE1vdXNlRXZlbnR9XG5cdFx0ICovXG5cdFx0dGhpcy5uYXRpdmVFdmVudCA9IG5hdGl2ZUV2ZW50O1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHVuaXF1ZSBpZCBmb3IgdGhlIHBvaW50ZXIgKHRvdWNoIHBvaW50IG9yIGN1cnNvcikuIFRoaXMgd2lsbCBiZSBlaXRoZXIgLTEgZm9yIHRoZSBtb3VzZSwgb3IgdGhlIHN5c3RlbVxuXHRcdCAqIHN1cHBsaWVkIGlkIHZhbHVlLlxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICovXG5cdFx0dGhpcy5wb2ludGVySUQgPSBwb2ludGVySUQ7XG5cblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIGlzIHRoZSBwcmltYXJ5IHBvaW50ZXIgaW4gYSBtdWx0aXRvdWNoIGVudmlyb25tZW50LiBUaGlzIHdpbGwgYWx3YXlzIGJlIHRydWUgZm9yIHRoZSBtb3VzZS5cblx0XHQgKiBGb3IgdG91Y2ggcG9pbnRlcnMsIHRoZSBmaXJzdCBwb2ludGVyIGluIHRoZSBjdXJyZW50IHN0YWNrIHdpbGwgYmUgY29uc2lkZXJlZCB0aGUgcHJpbWFyeSBwb2ludGVyLlxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqL1xuXHRcdHRoaXMucHJpbWFyeSA9ICEhcHJpbWFyeTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBzZWNvbmRhcnkgdGFyZ2V0IGZvciB0aGUgZXZlbnQsIGlmIGFwcGxpY2FibGUuIFRoaXMgaXMgdXNlZCBmb3IgbW91c2VvdXQvcm9sbG91dFxuXHRcdCAqIGV2ZW50cyB0byBpbmRpY2F0ZSB0aGUgb2JqZWN0IHRoYXQgdGhlIG1vdXNlIGVudGVyZWQgZnJvbSwgbW91c2VvdmVyL3JvbGxvdmVyIGZvciB0aGUgb2JqZWN0IHRoZSBtb3VzZSBleGl0ZWQsXG5cdFx0ICogYW5kIHN0YWdlbW91c2Vkb3duL3N0YWdlbW91c2V1cCBldmVudHMgZm9yIHRoZSBvYmplY3QgdGhhdCB3YXMgdGhlIHVuZGVyIHRoZSBjdXJzb3IsIGlmIGFueS5cblx0XHQgKlxuXHRcdCAqIE9ubHkgdmFsaWQgaW50ZXJhY3Rpb24gdGFyZ2V0cyB3aWxsIGJlIHJldHVybmVkIChpZS4gb2JqZWN0cyB3aXRoIG1vdXNlIGxpc3RlbmVycyBvciBhIGN1cnNvciBzZXQpLlxuXHRcdCAqIEB0eXBlIHtlYXNlbGpzLkRpc3BsYXlPYmplY3R9XG5cdFx0ICovXG5cdFx0dGhpcy5yZWxhdGVkVGFyZ2V0ID0gcmVsYXRlZFRhcmdldDtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSB4IHBvc2l0aW9uIG9mIHRoZSBtb3VzZSBpbiB0aGUgbG9jYWwgY29vcmRpbmF0ZSBzeXN0ZW0gb2YgdGhlIGN1cnJlbnQgdGFyZ2V0IChpZS4gdGhlIGRpc3BhdGNoZXIpLlxuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAcmVhZG9ubHlcblx0ICovXG5cdGdldCBsb2NhbFggKCkge1xuXHRcdHJldHVybiB0aGlzLmN1cnJlbnRUYXJnZXQuZ2xvYmFsVG9Mb2NhbCh0aGlzLnJhd1gsIHRoaXMucmF3WSkueDtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSB5IHBvc2l0aW9uIG9mIHRoZSBtb3VzZSBpbiB0aGUgbG9jYWwgY29vcmRpbmF0ZSBzeXN0ZW0gb2YgdGhlIGN1cnJlbnQgdGFyZ2V0IChpZS4gdGhlIGRpc3BhdGNoZXIpLlxuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAcmVhZG9ubHlcblx0ICovXG5cdGdldCBsb2NhbFkgKCkge1xuXHRcdHJldHVybiB0aGlzLmN1cnJlbnRUYXJnZXQuZ2xvYmFsVG9Mb2NhbCh0aGlzLnJhd1gsIHRoaXMucmF3WSkueTtcblx0fVxuXG5cdC8qKlxuXHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZXZlbnQgd2FzIGdlbmVyYXRlZCBieSBhIHRvdWNoIGlucHV0ICh2ZXJzdXMgYSBtb3VzZSBpbnB1dCkuXG5cdCAqIEB0eXBlIHtCb29sZWFufVxuXHQgKiBAcmVhZG9ubHlcblx0ICovXG5cdGdldCBpc1RvdWNoICgpIHtcblx0XHRyZXR1cm4gdGhpcy5wb2ludGVySUQgIT09IC0xO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGUgTW91c2VFdmVudCBpbnN0YW5jZS5cblx0ICogQHJldHVybiB7ZWFzZWxqcy5Nb3VzZUV2ZW50fSBhIGNsb25lIG9mIHRoZSBNb3VzZUV2ZW50IGluc3RhbmNlLlxuXHQgKi9cblx0Y2xvbmUgKCkge1xuXHRcdHJldHVybiBuZXcgTW91c2VFdmVudCh0aGlzLnR5cGUsIHRoaXMuYnViYmxlcywgdGhpcy5jYW5jZWxhYmxlLCB0aGlzLnN0YWdlWCwgdGhpcy5zdGFnZVksIHRoaXMubmF0aXZlRXZlbnQsIHRoaXMucG9pbnRlcklELCB0aGlzLnByaW1hcnksIHRoaXMucmF3WCwgdGhpcy5yYXdZKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZS5cblx0ICovXG5cdHRvU3RyaW5nICgpIHtcblx0XHRyZXR1cm4gYFske3RoaXMuY29uc3RydWN0b3IubmFtZX0gKHR5cGU9JHt0aGlzLnR5cGV9IHN0YWdlWD0ke3RoaXMuc3RhZ2VYfSBzdGFnZVk9JHt0aGlzLnN0YWdlWX0pXWA7XG5cdH1cblxufVxuIiwiLyoqXG4gKiBAbGljZW5zZSBTdGFnZVxuICogVmlzaXQgaHR0cDovL2NyZWF0ZWpzLmNvbS8gZm9yIGRvY3VtZW50YXRpb24sIHVwZGF0ZXMgYW5kIGV4YW1wbGVzLlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNyBnc2tpbm5lci5jb20sIGluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICogb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cbiAqIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxuICogcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsXG4gKiBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4gKiBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuICogY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAqIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xuICogT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAqIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4gKiBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcbiAqIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuICogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUlxuICogT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICovXG5cbmltcG9ydCBDb250YWluZXIgZnJvbSBcIi4vQ29udGFpbmVyXCI7XG5pbXBvcnQgRGlzcGxheU9iamVjdCBmcm9tIFwiLi9EaXNwbGF5T2JqZWN0XCI7XG5pbXBvcnQgeyBFdmVudCB9IGZyb20gXCJAY3JlYXRlanMvY29yZVwiO1xuaW1wb3J0IE1vdXNlRXZlbnQgZnJvbSBcIi4uL2V2ZW50cy9Nb3VzZUV2ZW50XCI7XG5cbi8qKlxuICogQSBzdGFnZSBpcyB0aGUgcm9vdCBsZXZlbCB7QGxpbmsgZWFzZWxqcy5Db250YWluZXJ9IGZvciBhIGRpc3BsYXkgbGlzdC4gRWFjaCB0aW1lIGl0cyB7QGxpbmsgZWFzZWxqcy5TdGFnZSN0aWNrfVxuICogbWV0aG9kIGlzIGNhbGxlZCwgaXQgd2lsbCByZW5kZXIgaXRzIGRpc3BsYXkgbGlzdCB0byBpdHMgdGFyZ2V0IGNhbnZhcy5cbiAqXG4gKiBAbWVtYmVyb2YgZWFzZWxqc1xuICogQGV4dGVuZHMgZWFzZWxqcy5Db250YWluZXJcbiAqIEBleGFtcGxlXG4gKiBsZXQgc3RhZ2UgPSBuZXcgU3RhZ2UoXCJjYW52YXNFbGVtZW50SWRcIik7XG4gKiBsZXQgaW1hZ2UgPSBuZXcgQml0bWFwKFwiaW1hZ2VQYXRoLnBuZ1wiKTtcbiAqIHN0YWdlLmFkZENoaWxkKGltYWdlKTtcbiAqIFRpY2tlci5hZGRFdmVudExpc3RlbmVyKFwidGlja1wiLCBldmVudCA9PiB7XG4gKiAgIGltYWdlLnggKz0gMTA7XG4gKiBcdCBzdGFnZS51cGRhdGUoKTtcbiAqIH0pO1xuICpcbiAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnQgfCBTdHJpbmcgfCBPYmplY3R9IGNhbnZhcyBBIGNhbnZhcyBvYmplY3QgdGhhdCB0aGUgU3RhZ2Ugd2lsbCByZW5kZXIgdG8sIG9yIHRoZSBzdHJpbmcgaWRcbiAqIG9mIGEgY2FudmFzIG9iamVjdCBpbiB0aGUgY3VycmVudCBkb2N1bWVudC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RhZ2UgZXh0ZW5kcyBDb250YWluZXIge1xuXG5cdGNvbnN0cnVjdG9yIChjYW52YXMpIHtcblx0XHRzdXBlcigpO1xuXG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHN0YWdlIHNob3VsZCBhdXRvbWF0aWNhbGx5IGNsZWFyIHRoZSBjYW52YXMgYmVmb3JlIGVhY2ggcmVuZGVyLiBZb3UgY2FuIHNldCB0aGlzIHRvIGBmYWxzZWBcblx0XHQgKiB0byBtYW51YWxseSBjb250cm9sIGNsZWFyaW5nIChmb3IgZ2VuZXJhdGl2ZSBhcnQsIG9yIHdoZW4gcG9pbnRpbmcgbXVsdGlwbGUgc3RhZ2VzIGF0IHRoZSBzYW1lIGNhbnZhcyBmb3Jcblx0XHQgKiBleGFtcGxlKS5cblx0XHQgKlxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogbGV0IHN0YWdlID0gbmV3IFN0YWdlKFwiY2FudmFzSWRcIik7XG5cdFx0ICogc3RhZ2UuYXV0b0NsZWFyID0gZmFsc2U7XG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0dGhpcy5hdXRvQ2xlYXIgPSB0cnVlO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGNhbnZhcyB0aGUgc3RhZ2Ugd2lsbCByZW5kZXIgdG8uIE11bHRpcGxlIHN0YWdlcyBjYW4gc2hhcmUgYSBzaW5nbGUgY2FudmFzLCBidXQgeW91IG11c3QgZGlzYWJsZSBhdXRvQ2xlYXIgZm9yIGFsbCBidXQgdGhlXG5cdFx0ICogZmlyc3Qgc3RhZ2UgdGhhdCB3aWxsIGJlIHRpY2tlZCAob3IgdGhleSB3aWxsIGNsZWFyIGVhY2ggb3RoZXIncyByZW5kZXIpLlxuXHRcdCAqXG5cdFx0ICogV2hlbiBjaGFuZ2luZyB0aGUgY2FudmFzIHByb3BlcnR5IHlvdSBtdXN0IGRpc2FibGUgdGhlIGV2ZW50cyBvbiB0aGUgb2xkIGNhbnZhcywgYW5kIGVuYWJsZSBldmVudHMgb24gdGhlXG5cdFx0ICogbmV3IGNhbnZhcyBvciBtb3VzZSBldmVudHMgd2lsbCBub3Qgd29yayBhcyBleHBlY3RlZC5cblx0XHQgKlxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogc3RhZ2UuZW5hYmxlRE9NRXZlbnRzKGZhbHNlKTtcblx0XHQgKiBzdGFnZS5jYW52YXMgPSBhbm90aGVyQ2FudmFzO1xuXHRcdCAqIHN0YWdlLmVuYWJsZURPTUV2ZW50cyh0cnVlKTtcblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtIVE1MQ2FudmFzRWxlbWVudCB8IE9iamVjdH1cblx0XHQgKi9cblx0XHR0aGlzLmNhbnZhcyA9ICh0eXBlb2YgY2FudmFzID09PSBcInN0cmluZ1wiKSA/IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNhbnZhcykgOiBjYW52YXM7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgY3VycmVudCBtb3VzZSBYIHBvc2l0aW9uIG9uIHRoZSBjYW52YXMuIElmIHRoZSBtb3VzZSBsZWF2ZXMgdGhlIGNhbnZhcywgdGhpcyB3aWxsIGluZGljYXRlIHRoZSBtb3N0IHJlY2VudFxuXHRcdCAqIHBvc2l0aW9uIG92ZXIgdGhlIGNhbnZhcywgYW5kIG1vdXNlSW5Cb3VuZHMgd2lsbCBiZSBzZXQgdG8gZmFsc2UuXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICovXG5cdFx0dGhpcy5tb3VzZVggPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGN1cnJlbnQgbW91c2UgWSBwb3NpdGlvbiBvbiB0aGUgY2FudmFzLiBJZiB0aGUgbW91c2UgbGVhdmVzIHRoZSBjYW52YXMsIHRoaXMgd2lsbCBpbmRpY2F0ZSB0aGUgbW9zdCByZWNlbnRcblx0XHQgKiBwb3NpdGlvbiBvdmVyIHRoZSBjYW52YXMsIGFuZCBtb3VzZUluQm91bmRzIHdpbGwgYmUgc2V0IHRvIGZhbHNlLlxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqL1xuXHRcdHRoaXMubW91c2VZID0gMDtcblxuXHRcdC8qKlxuXHRcdCAqIFNwZWNpZmllcyB0aGUgYXJlYSBvZiB0aGUgc3RhZ2UgdG8gYWZmZWN0IHdoZW4gY2FsbGluZyB1cGRhdGUuIFRoaXMgY2FuIGJlIHVzZSB0byBzZWxlY3RpdmVseVxuXHRcdCAqIHJlLWRyYXcgc3BlY2lmaWMgcmVnaW9ucyBvZiB0aGUgY2FudmFzLiBJZiBudWxsLCB0aGUgd2hvbGUgY2FudmFzIGFyZWEgaXMgZHJhd24uXG5cdFx0ICogQHR5cGUge2Vhc2VsanMuUmVjdGFuZ2xlfVxuXHRcdCAqL1xuXHRcdHRoaXMuZHJhd1JlY3QgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHdoZXRoZXIgZGlzcGxheSBvYmplY3RzIHNob3VsZCBiZSByZW5kZXJlZCBvbiB3aG9sZSBwaXhlbHMuIFlvdSBjYW4gc2V0IHRoZSB7QGxpbmsgZWFzZWxqcy5EaXNwbGF5T2JqZWN0LnNuYXBUb1BpeGVsRW5hYmxlZH1cblx0XHQgKiBwcm9wZXJ0eSBvZiBkaXNwbGF5IG9iamVjdHMgdG8gZmFsc2UgdG8gZW5hYmxlL2Rpc2FibGUgdGhpcyBiZWhhdmlvdXIgb24gYSBwZXIgaW5zdGFuY2UgYmFzaXMuXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKi9cblx0XHR0aGlzLnNuYXBUb1BpeGVsRW5hYmxlZCA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIG1vdXNlIGlzIGN1cnJlbnRseSB3aXRoaW4gdGhlIGJvdW5kcyBvZiB0aGUgY2FudmFzLlxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICovXG5cdFx0dGhpcy5tb3VzZUluQm91bmRzID0gZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBJZiB0cnVlLCB0aWNrIGNhbGxiYWNrcyB3aWxsIGJlIGNhbGxlZCBvbiBhbGwgZGlzcGxheSBvYmplY3RzIG9uIHRoZSBzdGFnZSBwcmlvciB0byByZW5kZXJpbmcgdG8gdGhlIGNhbnZhcy5cblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0dGhpcy50aWNrT25VcGRhdGUgPSB0cnVlO1xuXG5cdFx0LyoqXG5cdFx0ICogSWYgdHJ1ZSwgbW91c2UgbW92ZSBldmVudHMgd2lsbCBjb250aW51ZSB0byBiZSBjYWxsZWQgd2hlbiB0aGUgbW91c2UgbGVhdmVzIHRoZSB0YXJnZXQgY2FudmFzLlxuXHRcdCAqIFNlZSB7QGxpbmsgZWFzZWxqcy5TdGFnZSNtb3VzZUluQm91bmRzfSwgYW5kIHtAbGluayBlYXNlbGpzLk1vdXNlRXZlbnR9IHgveS9yYXdYL3Jhd1kuXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKi9cblx0XHR0aGlzLm1vdXNlTW92ZU91dHNpZGUgPSBmYWxzZTtcblxuXG5cdFx0LyoqXG5cdFx0ICogUHJldmVudHMgc2VsZWN0aW9uIG9mIG90aGVyIGVsZW1lbnRzIGluIHRoZSBodG1sIHBhZ2UgaWYgdGhlIHVzZXIgY2xpY2tzIGFuZCBkcmFncywgb3IgZG91YmxlIGNsaWNrcyBvbiB0aGUgY2FudmFzLlxuXHRcdCAqIFRoaXMgd29ya3MgYnkgY2FsbGluZyBgcHJldmVudERlZmF1bHQoKWAgb24gYW55IG1vdXNlZG93biBldmVudHMgKG9yIHRvdWNoIGVxdWl2YWxlbnQpIG9yaWdpbmF0aW5nIG9uIHRoZSBjYW52YXMuXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdHRoaXMucHJldmVudFNlbGVjdGlvbiA9IHRydWU7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgaGl0QXJlYSBwcm9wZXJ0eSBpcyBub3Qgc3VwcG9ydGVkIGZvciBTdGFnZS5cblx0XHQgKiBAcHJvcGVydHkgaGl0QXJlYVxuXHRcdCAqIEBvdmVycmlkZVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXG5cdFx0LyoqXG5cdFx0ICogSG9sZHMgb2JqZWN0cyB3aXRoIGRhdGEgZm9yIGVhY2ggYWN0aXZlIHBvaW50ZXIgaWQuIEVhY2ggb2JqZWN0IGhhcyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG5cdFx0ICogeCwgeSwgZXZlbnQsIHRhcmdldCwgb3ZlclRhcmdldCwgb3ZlclgsIG92ZXJZLCBpbkJvdW5kcywgcG9zRXZ0T2JqIChuYXRpdmUgZXZlbnQgdGhhdCBsYXN0IHVwZGF0ZWQgcG9zaXRpb24pXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX3BvaW50ZXJEYXRhID0ge307XG5cblx0XHQvKipcblx0XHQgKiBOdW1iZXIgb2YgYWN0aXZlIHBvaW50ZXJzLlxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9wb2ludGVyQ291bnQgPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIElEIG9mIHRoZSBwcmltYXJ5IHBvaW50ZXIuXG5cdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX3ByaW1hcnlQb2ludGVySUQgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICovXG5cdFx0dGhpcy5fbW91c2VPdmVySW50ZXJ2YWxJRCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge2Vhc2VsanMuU3RhZ2V9XG5cdFx0ICovXG5cdFx0dGhpcy5fbmV4dFN0YWdlID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7ZWFzZWxqcy5TdGFnZX1cblx0XHQgKi9cblx0XHR0aGlzLl9wcmV2U3RhZ2UgPSBudWxsO1xuXG5cdFx0dGhpcy5lbmFibGVET01FdmVudHModHJ1ZSk7XG5cdH1cblxuXHQvKipcblx0ICogU3BlY2lmaWVzIGEgdGFyZ2V0IHN0YWdlIHRoYXQgd2lsbCBoYXZlIG1vdXNlL3RvdWNoIGludGVyYWN0aW9ucyByZWxheWVkIHRvIGl0IGFmdGVyIHRoaXMgc3RhZ2UgaGFuZGxlcyB0aGVtLlxuXHQgKiBUaGlzIGNhbiBiZSB1c2VmdWwgaW4gY2FzZXMgd2hlcmUgeW91IGhhdmUgbXVsdGlwbGUgbGF5ZXJlZCBjYW52YXNlcyBhbmQgd2FudCB1c2VyIGludGVyYWN0aW9uc1xuXHQgKiBldmVudHMgdG8gcGFzcyB0aHJvdWdoLlxuXHQgKlxuXHQgKiBNb3VzZU92ZXIsIE1vdXNlT3V0LCBSb2xsT3ZlciwgYW5kIFJvbGxPdXQgaW50ZXJhY3Rpb25zIGFyZSBhbHNvIHBhc3NlZCB0aHJvdWdoIHVzaW5nIHRoZSBtb3VzZSBvdmVyIHNldHRpbmdzXG5cdCAqIG9mIHRoZSB0b3AtbW9zdCBzdGFnZSwgYnV0IGFyZSBvbmx5IHByb2Nlc3NlZCBpZiB0aGUgdGFyZ2V0IHN0YWdlIGhhcyBtb3VzZSBvdmVyIGludGVyYWN0aW9ucyBlbmFibGVkLlxuXHQgKiBDb25zaWRlcmF0aW9ucyB3aGVuIHVzaW5nIHJvbGwgb3ZlciBpbiByZWxheSB0YXJnZXRzOlxuXHQgKiA8b2w+XG5cdCAqICAgPGxpPiBUaGUgdG9wLW1vc3QgKGZpcnN0KSBzdGFnZSBtdXN0IGhhdmUgbW91c2Ugb3ZlciBpbnRlcmFjdGlvbnMgZW5hYmxlZCAodmlhIGVuYWJsZU1vdXNlT3Zlcik8L2xpPlxuXHQgKiAgIDxsaT4gQWxsIHN0YWdlcyB0aGF0IHdpc2ggdG8gcGFydGljaXBhdGUgaW4gbW91c2Ugb3ZlciBpbnRlcmFjdGlvbiBtdXN0IGVuYWJsZSB0aGVtIHZpYSBlbmFibGVNb3VzZU92ZXI8L2xpPlxuXHQgKiAgIDxsaT4gQWxsIHJlbGF5IHRhcmdldHMgd2lsbCBzaGFyZSB0aGUgZnJlcXVlbmN5IHZhbHVlIG9mIHRoZSB0b3AtbW9zdCBzdGFnZTwvbGk+XG5cdCAqIDwvb2w+XG5cdCAqXG5cdCAqIEBleGFtcGxlIDxjYXB0aW9uPlJlbGF5IG1vdXNlIGV2ZW50cyBmcm9tIHRvcFN0YWdlIHRvIGJvdHRvbVN0YWdlPC9jYXB0aW9uPlxuXHQgKiB0b3BTdGFnZS5uZXh0U3RhZ2UgPSBib3R0b21TdGFnZTtcblx0ICpcblx0ICogQGV4YW1wbGUgPGNhcHRpb24+RGlzYWJsZSBET00gZXZlbnRzPC9jYXB0aW9uPlxuXHQgKiBzdGFnZS5lbmFibGVET01FdmVudHMoZmFsc2UpO1xuXHQgKlxuXHQgKiBAdHlwZSB7ZWFzZWxqcy5TdGFnZX1cblx0ICovXG5cdGdldCBuZXh0U3RhZ2UgKCkgeyByZXR1cm4gdGhpcy5fbmV4dFN0YWdlOyB9XG5cdHNldCBuZXh0U3RhZ2UgKHN0YWdlKSB7XG5cdFx0aWYgKHRoaXMuX25leHRTdGFnZSkgeyB0aGlzLl9uZXh0U3RhZ2UuX3ByZXZTdGFnZSA9IG51bGw7IH1cblx0XHRpZiAoc3RhZ2UpIHsgc3RhZ2UuX3ByZXZTdGFnZSA9IHRoaXM7IH1cblx0XHR0aGlzLl9uZXh0U3RhZ2UgPSBzdGFnZTtcblx0fVxuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIEVhY2ggdGltZSB0aGUgdXBkYXRlIG1ldGhvZCBpcyBjYWxsZWQsIHRoZSBzdGFnZSB3aWxsIGNhbGwge0BsaW5rIGVhc2VsanMuU3RhZ2UjdGlja31cblx0ICogdW5sZXNzIHtAbGluayBlYXNlbGpzLlN0YWdlI3RpY2tPbnVwZGF0ZX0gaXMgc2V0IHRvIGZhbHNlLFxuXHQgKiBhbmQgdGhlbiByZW5kZXIgdGhlIGRpc3BsYXkgbGlzdCB0byB0aGUgY2FudmFzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW3Byb3BzXSBQcm9wcyBvYmplY3QgdG8gcGFzcyB0byBgdGljaygpYC4gU2hvdWxkIHVzdWFsbHkgYmUgYSB7QGxpbmsgY29yZS5UaWNrZXJ9IGV2ZW50IG9iamVjdCwgb3Igc2ltaWxhciBvYmplY3Qgd2l0aCBhIGRlbHRhIHByb3BlcnR5LlxuXHQgKi9cblx0dXBkYXRlIChwcm9wcykge1xuXHRcdGlmICghdGhpcy5jYW52YXMpIHsgcmV0dXJuOyB9XG5cdFx0aWYgKHRoaXMudGlja09uVXBkYXRlKSB7IHRoaXMudGljayhwcm9wcyk7IH1cblx0XHRpZiAodGhpcy5kaXNwYXRjaEV2ZW50KFwiZHJhd3N0YXJ0XCIsIGZhbHNlLCB0cnVlKSA9PT0gZmFsc2UpIHsgcmV0dXJuOyB9XG5cdFx0RGlzcGxheU9iamVjdC5fc25hcFRvUGl4ZWxFbmFibGVkID0gdGhpcy5zbmFwVG9QaXhlbEVuYWJsZWQ7XG5cdFx0bGV0IHIgPSB0aGlzLmRyYXdSZWN0LCBjdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5cdFx0Y3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcblx0XHRpZiAodGhpcy5hdXRvQ2xlYXIpIHtcblx0XHRcdGlmIChyKSB7IGN0eC5jbGVhclJlY3Qoci54LCByLnksIHIud2lkdGgsIHIuaGVpZ2h0KTsgfVxuXHRcdFx0ZWxzZSB7IGN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5jYW52YXMud2lkdGgrMSwgdGhpcy5jYW52YXMuaGVpZ2h0KzEpOyB9XG5cdFx0fVxuXHRcdGN0eC5zYXZlKCk7XG5cdFx0aWYgKHRoaXMuZHJhd1JlY3QpIHtcblx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdGN0eC5yZWN0KHIueCwgci55LCByLndpZHRoLCByLmhlaWdodCk7XG5cdFx0XHRjdHguY2xpcCgpO1xuXHRcdH1cblx0XHR0aGlzLnVwZGF0ZUNvbnRleHQoY3R4KTtcblx0XHR0aGlzLmRyYXcoY3R4LCBmYWxzZSk7XG5cdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoXCJkcmF3ZW5kXCIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFByb3BhZ2F0ZXMgYSB0aWNrIGV2ZW50IHRocm91Z2ggdGhlIGRpc3BsYXkgbGlzdC4gVGhpcyBpcyBhdXRvbWF0aWNhbGx5IGNhbGxlZCBieSB7QGxpbmsgZWFzZWxqcy5TdGFnZSN1cGRhdGV9XG5cdCAqIHVubGVzcyB7QGxpbmsgZWFzZWxqcy5TdGFnZSN0aWNrT25VcGRhdGV9IGlzIHNldCB0byBmYWxzZS5cblx0ICpcblx0ICogSWYgYSBwcm9wcyBvYmplY3QgaXMgcGFzc2VkIHRvIGB0aWNrKClgLCB0aGVuIGFsbCBvZiBpdHMgcHJvcGVydGllcyB3aWxsIGJlIGNvcGllZCB0byB0aGUgZXZlbnQgb2JqZWN0IHRoYXQgaXNcblx0ICogcHJvcGFnYXRlZCB0byBsaXN0ZW5lcnMuXG5cdCAqXG5cdCAqIFNvbWUgdGltZS1iYXNlZCBmZWF0dXJlcyBpbiBFYXNlbEpTIChmb3IgZXhhbXBsZSB7QGxpbmsgZWFzZWxqcy5TcHJpdGUjZnJhbWVyYXRlfSByZXF1aXJlIHRoYXRcblx0ICogYSB7QGxpbmsgY29yZS5UaWNrZXIjZXZlbnQ6dGlja30gZXZlbnQgb2JqZWN0IChvciBlcXVpdmFsZW50IG9iamVjdCB3aXRoIGEgZGVsdGEgcHJvcGVydHkpIGJlXG5cdCAqIHBhc3NlZCBhcyB0aGUgYHByb3BzYCBwYXJhbWV0ZXIgdG8gYHRpY2soKWAuXG5cdCAqXG5cdCAqIEBleGFtcGxlXG5cdCAqIFRpY2tlci5vbihcInRpY2tcIiwgKGV2dCkgPT4ge1xuXHQgKiAgIC8vIGNsb25lIHRoZSBldmVudCBvYmplY3QgZnJvbSBUaWNrZXIsIGFuZCBhZGQgc29tZSBjdXN0b20gZGF0YSB0byBpdDpcblx0ICogXHQgbGV0IGRhdGEgPSBldnQuY2xvbmUoKS5zZXQoeyBncmVldGluZzogXCJoZWxsb1wiLCBuYW1lOiBcIndvcmxkXCIgfSk7XG5cdCAqIFx0IC8vIHBhc3MgaXQgdG8gc3RhZ2UudXBkYXRlKCk6XG5cdCAqIFx0IHN0YWdlLnVwZGF0ZShkYXRhKTsgLy8gc3Vic2VxdWVudGx5IGNhbGxzIHRpY2soKSB3aXRoIHRoZSBzYW1lIHBhcmFtXG5cdCAqIH0pO1xuXHQgKlxuXHQgKiBzaGFwZS5vbihcInRpY2tcIiwgKGV2dCkgPT4ge1xuXHQgKiAgIGNvbnNvbGUubG9nKGV2dC5kZWx0YSk7IC8vIHRoZSBkZWx0YSBwcm9wZXJ0eSBmcm9tIHRoZSBUaWNrZXIgdGljayBldmVudCBvYmplY3Rcblx0ICogXHQgY29uc29sZS5sb2coZXZ0LmdyZWV0aW5nLCBldnQubmFtZSk7IC8vIGN1c3RvbSBkYXRhOiBcImhlbGxvIHdvcmxkXCJcblx0ICogfSk7XG5cdCAqXG5cdCAqIEBlbWl0cyBlYXNlbGpzLlN0YWdlI2V2ZW50OnRpY2tzdGFydFxuXHQgKiBAZW1pdHMgZWFzZWxqcy5TdGFnZSNldmVudDp0aWNrZW5kXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHNdIEFuIG9iamVjdCB3aXRoIHByb3BlcnRpZXMgdGhhdCBzaG91bGQgYmUgY29waWVkIHRvIHRoZSBldmVudCBvYmplY3QuIFNob3VsZCB1c3VhbGx5IGJlIGEgVGlja2VyIGV2ZW50IG9iamVjdCwgb3Igc2ltaWxhciBvYmplY3Qgd2l0aCBhIGRlbHRhIHByb3BlcnR5LlxuXHQgKi9cblx0dGljayAocHJvcHMpIHtcblx0XHRpZiAoIXRoaXMudGlja0VuYWJsZWQgfHwgdGhpcy5kaXNwYXRjaEV2ZW50KFwidGlja3N0YXJ0XCIsIGZhbHNlLCB0cnVlKSA9PT0gZmFsc2UpIHsgcmV0dXJuOyB9XG5cdFx0bGV0IGV2dE9iaiA9IG5ldyBFdmVudChcInRpY2tcIik7XG5cdFx0aWYgKHByb3BzKSB7XG5cdFx0XHRmb3IgKGxldCBuIGluIHByb3BzKSB7XG5cdFx0XHRcdGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eShuKSkgeyBldnRPYmpbbl0gPSBwcm9wc1tuXTsgfVxuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLl90aWNrKGV2dE9iaik7XG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KFwidGlja2VuZFwiKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEZWZhdWx0IGV2ZW50IGhhbmRsZXIgdGhhdCBjYWxscyB0aGUgU3RhZ2Uge0BsaW5rIGVhc2VsanMuU3RhZ2UjdXBkYXRlfSBtZXRob2Qgd2hlbiBhIHtAbGluayBlYXNlbGpzLkRpc3BsYXlPYmplY3QjZXZlbnQ6dGlja31cblx0ICogZXZlbnQgaXMgcmVjZWl2ZWQuIFRoaXMgYWxsb3dzIHlvdSB0byByZWdpc3RlciBhIFN0YWdlIGluc3RhbmNlIGFzIGEgZXZlbnQgbGlzdGVuZXIgb24ge0BsaW5rIGNvcmUuVGlja2VyfSBkaXJlY3RseS5cblx0ICogTm90ZSB0aGF0IGlmIHlvdSBzdWJzY3JpYmUgdG8gdGlja3MgdXNpbmcgdGhpcyBwYXR0ZXJuLCB0aGVuIHRoZSB0aWNrIGV2ZW50IG9iamVjdCB3aWxsIGJlIHBhc3NlZCB0aHJvdWdoIHRvXG5cdCAqIGRpc3BsYXkgb2JqZWN0IHRpY2sgaGFuZGxlcnMsIGluc3RlYWQgb2YgYGRlbHRhYCBhbmQgYHBhdXNlZGAgcGFyYW1ldGVycy5cblx0ICovXG5cdGhhbmRsZUV2ZW50IChldnQpIHtcblx0XHRpZiAoZXZ0LnR5cGUgPT09IFwidGlja1wiKSB7IHRoaXMudXBkYXRlKGV2dCk7IH1cblx0fVxuXG5cdC8qKlxuXHQgKiBDbGVhcnMgdGhlIHRhcmdldCBjYW52YXMuIFVzZWZ1bCBpZiB7QGxpbmsgZWFzZWxqcy5TdGF0ZSNhdXRvQ2xlYXJ9IGlzIHNldCB0byBgZmFsc2VgLlxuXHQgKi9cblx0Y2xlYXIgKCkge1xuXHRcdGlmICghdGhpcy5jYW52YXMpIHsgcmV0dXJuOyB9XG5cdFx0bGV0IGN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcblx0XHRjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuXHRcdGN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5jYW52YXMud2lkdGgrMSwgdGhpcy5jYW52YXMuaGVpZ2h0KzEpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBkYXRhIHVybCB0aGF0IGNvbnRhaW5zIGEgQmFzZTY0LWVuY29kZWQgaW1hZ2Ugb2YgdGhlIGNvbnRlbnRzIG9mIHRoZSBzdGFnZS4gVGhlIHJldHVybmVkIGRhdGEgdXJsIGNhblxuXHQgKiBiZSBzcGVjaWZpZWQgYXMgdGhlIHNyYyB2YWx1ZSBvZiBhbiBpbWFnZSBlbGVtZW50LlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW2JhY2tncm91bmRDb2xvcl0gVGhlIGJhY2tncm91bmQgY29sb3IgdG8gYmUgdXNlZCBmb3IgdGhlIGdlbmVyYXRlZCBpbWFnZS4gQW55IHZhbGlkIENTUyBjb2xvclxuXHQgKiB2YWx1ZSBpcyBhbGxvd2VkLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBhIHRyYW5zcGFyZW50IGJhY2tncm91bmQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbbWltZVR5cGU9XCJpbWFnZS9wbmdcIl0gVGhlIE1JTUUgdHlwZSBvZiB0aGUgaW1hZ2UgZm9ybWF0IHRvIGJlIGNyZWF0ZS4gSWYgYW4gdW5rbm93biBNSU1FIHR5cGVcblx0ICogaXMgcGFzc2VkIGluLCBvciBpZiB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHRoZSBzcGVjaWZpZWQgTUlNRSB0eXBlLCB0aGUgZGVmYXVsdCB2YWx1ZSB3aWxsIGJlIHVzZWQuXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYSBCYXNlNjQgZW5jb2RlZCBpbWFnZS5cblx0ICovXG5cdHRvRGF0YVVSTCAoYmFja2dyb3VuZENvbG9yLCBtaW1lVHlwZSA9IFwiaW1hZ2UvcG5nXCIpIHtcblx0XHRsZXQgZGF0YSwgY3R4ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKSwgdyA9IHRoaXMuY2FudmFzLndpZHRoLCBoID0gdGhpcy5jYW52YXMuaGVpZ2h0O1xuXG5cdFx0aWYgKGJhY2tncm91bmRDb2xvcikge1xuXHRcdFx0ZGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgdywgaCk7XG5cdFx0XHR2YXIgY29tcG9zaXRlT3BlcmF0aW9uID0gY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbjtcblx0XHRcdGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcImRlc3RpbmF0aW9uLW92ZXJcIjtcblxuXHRcdFx0Y3R4LmZpbGxTdHlsZSA9IGJhY2tncm91bmRDb2xvcjtcblx0XHRcdGN0eC5maWxsUmVjdCgwLCAwLCB3LCBoKTtcblx0XHR9XG5cblx0XHRsZXQgZGF0YVVSTCA9IHRoaXMuY2FudmFzLnRvRGF0YVVSTChtaW1lVHlwZSk7XG5cblx0XHRpZiAoYmFja2dyb3VuZENvbG9yKSB7XG5cdFx0XHRjdHgucHV0SW1hZ2VEYXRhKGRhdGEsIDAsIDApO1xuXHRcdFx0Y3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IGNvbXBvc2l0ZU9wZXJhdGlvbjtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YVVSTDtcblx0fVxuXG5cdC8qKlxuXHQgKiBFbmFibGVzIG9yIGRpc2FibGVzIChieSBwYXNzaW5nIGEgZnJlcXVlbmN5IG9mIDApIG1vdXNlIG92ZXIge0BsaW5rIGVhc2VsanMuRGlzcGxheU9iamVjdCNldmVudDptb3VzZW92ZXJ9XG5cdCAqIGFuZCB7QGxpbmsgZWFzZWxqcy5EaXNwbGF5T2JqZWN0I2V2ZW50Om1vdXNlb3V0fSBhbmQgcm9sbCBvdmVyIGV2ZW50cyB7QGxpbmsgZWFzZWxqcy5EaXNwbGF5T2JqZWN0I2V2ZW50OnJvbGxvdmVyfVxuXHQgKiBhbmQge0BsaW5rIGVhc2VsanMuRGlzcGxheU9iamVjdCNldmVudDpyb2xsb3V0fSBmb3IgdGhpcyBzdGFnZSdzIGRpc3BsYXkgbGlzdC4gVGhlc2UgZXZlbnRzIGNhblxuXHQgKiBiZSBleHBlbnNpdmUgdG8gZ2VuZXJhdGUsIHNvIHRoZXkgYXJlIGRpc2FibGVkIGJ5IGRlZmF1bHQuIFRoZSBmcmVxdWVuY3kgb2YgdGhlIGV2ZW50cyBjYW4gYmUgY29udHJvbGxlZFxuXHQgKiBpbmRlcGVuZGVudGx5IG9mIG1vdXNlIG1vdmUgZXZlbnRzIHZpYSB0aGUgb3B0aW9uYWwgYGZyZXF1ZW5jeWAgcGFyYW1ldGVyLlxuXHQgKlxuXHQgKiBAZXhhbXBsZVxuXHQgKiBjb25zdCBzdGFnZSA9IG5ldyBTdGFnZShcImNhbnZhc0lkXCIpO1xuXHQgKiBzdGFnZS5lbmFibGVNb3VzZU92ZXIoMTApOyAvLyAxMCB1cGRhdGVzIHBlciBzZWNvbmRcblx0ICpcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtmcmVxdWVuY3k9MjBdIE9wdGlvbmFsIHBhcmFtIHNwZWNpZnlpbmcgdGhlIG1heGltdW0gbnVtYmVyIG9mIHRpbWVzIHBlciBzZWNvbmQgdG8gYnJvYWRjYXN0XG5cdCAqIG1vdXNlIG92ZXIvb3V0IGV2ZW50cy4gU2V0IHRvIDAgdG8gZGlzYWJsZSBtb3VzZSBvdmVyIGV2ZW50cyBjb21wbGV0ZWx5LiBNYXhpbXVtIGlzIDUwLiBBIGxvd2VyIGZyZXF1ZW5jeSBpcyBsZXNzXG5cdCAqIHJlc3BvbnNpdmUsIGJ1dCB1c2VzIGxlc3MgQ1BVLlxuXHQgKi9cblx0ZW5hYmxlTW91c2VPdmVyIChmcmVxdWVuY3kgPSAyMCkge1xuXHRcdGlmICh0aGlzLl9tb3VzZU92ZXJJbnRlcnZhbElEKSB7XG5cdFx0XHRjbGVhckludGVydmFsKHRoaXMuX21vdXNlT3ZlckludGVydmFsSUQpO1xuXHRcdFx0dGhpcy5fbW91c2VPdmVySW50ZXJ2YWxJRCA9IG51bGw7XG5cdFx0XHRpZiAoZnJlcXVlbmN5ID09PSAwKSB7XG5cdFx0XHRcdHRoaXMuX3Rlc3RNb3VzZU92ZXIodHJ1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChmcmVxdWVuY3kgPD0gMCkgeyByZXR1cm47IH1cblx0XHR0aGlzLl9tb3VzZU92ZXJJbnRlcnZhbElEID0gc2V0SW50ZXJ2YWwoKCkgPT4gdGhpcy5fdGVzdE1vdXNlT3ZlcigpLCAxMDAwL01hdGgubWluKDUwLGZyZXF1ZW5jeSkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGV2ZW50IGxpc3RlbmVycyB0aGF0IHN0YWdlIGFkZHMgdG8gRE9NIGVsZW1lbnRzICh3aW5kb3csIGRvY3VtZW50IGFuZCBjYW52YXMpLiBJdCBpcyBnb29kXG5cdCAqIHByYWN0aWNlIHRvIGRpc2FibGUgZXZlbnRzIHdoZW4gZGlzcG9zaW5nIG9mIGEgU3RhZ2UgaW5zdGFuY2UsIG90aGVyd2lzZSB0aGUgc3RhZ2Ugd2lsbCBjb250aW51ZSB0byByZWNlaXZlXG5cdCAqIGV2ZW50cyBmcm9tIHRoZSBwYWdlLlxuXHQgKiBXaGVuIGNoYW5naW5nIHRoZSBjYW52YXMgcHJvcGVydHkgeW91IG11c3QgZGlzYWJsZSB0aGUgZXZlbnRzIG9uIHRoZSBvbGQgY2FudmFzLCBhbmQgZW5hYmxlIGV2ZW50cyBvbiB0aGVcblx0ICogbmV3IGNhbnZhcyBvciBtb3VzZSBldmVudHMgd2lsbCBub3Qgd29yayBhcyBleHBlY3RlZC5cblx0ICpcblx0ICogQGV4YW1wbGVcblx0ICogc3RhZ2UuZW5hYmxlRE9NRXZlbnRzKGZhbHNlKTtcblx0ICogc3RhZ2UuY2FudmFzID0gYW5vdGhlckNhbnZhcztcblx0ICogc3RhZ2UuZW5hYmxlRE9NRXZlbnRzKHRydWUpO1xuXHQgKlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtlbmFibGU9dHJ1ZV0gSW5kaWNhdGVzIHdoZXRoZXIgdG8gZW5hYmxlIG9yIGRpc2FibGUgdGhlIGV2ZW50cy5cblx0ICovXG5cdGVuYWJsZURPTUV2ZW50cyAoZW5hYmxlID0gdHJ1ZSkge1xuXHRcdGxldCBscyA9IHRoaXMuX2V2ZW50TGlzdGVuZXJzO1xuXHRcdGlmICghZW5hYmxlICYmIGxzKSB7XG5cdFx0XHRmb3IgKGxldCBuIGluIGxzKSB7XG5cdFx0XHRcdGxldCBvID0gbHNbbl07XG5cdFx0XHRcdG8udC5yZW1vdmVFdmVudExpc3RlbmVyKG4sIG8uZiwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fZXZlbnRMaXN0ZW5lcnMgPSBudWxsO1xuXHRcdH0gZWxzZSBpZiAoZW5hYmxlICYmICFscyAmJiB0aGlzLmNhbnZhcykge1xuXHRcdFx0bGV0IHQgPSB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciA/IHdpbmRvdyA6IGRvY3VtZW50O1xuXHRcdFx0bHMgPSB0aGlzLl9ldmVudExpc3RlbmVycyA9IHtcblx0XHRcdFx0bW91c2V1cDoge3QsIGY6ZSA9PiB0aGlzLl9oYW5kbGVNb3VzZVVwKGUpIH0sXG5cdFx0XHRcdG1vdXNlbW92ZToge3QsIGY6ZSA9PiB0aGlzLl9oYW5kbGVNb3VzZU1vdmUoZSkgfSxcblx0XHRcdFx0ZGJsY2xpY2s6IHt0OnRoaXMuY2FudmFzLCBmOmUgPT4gdGhpcy5faGFuZGxlRG91YmxlQ2xpY2soZSkgfSxcblx0XHRcdFx0bW91c2Vkb3duOiB7dDp0aGlzLmNhbnZhcywgZjplID0+IHRoaXMuX2hhbmRsZU1vdXNlRG93bihlKSB9XG5cdFx0XHR9O1xuXHRcdFx0Zm9yIChsZXQgbiBpbiBscykge1xuXHRcdFx0XHRsZXQgbyA9IGxzW25dO1xuXHRcdFx0XHRvLnQuYWRkRXZlbnRMaXN0ZW5lciAmJiBvLnQuYWRkRXZlbnRMaXN0ZW5lcihuLCBvLmYsIGZhbHNlKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogU3RhZ2UgaW5zdGFuY2VzIGNhbm5vdCBiZSBjbG9uZWQuXG5cdCAqIEB0aHJvd3MgU3RhZ2UgY2Fubm90IGJlIGNsb25lZFxuXHQgKiBAb3ZlcnJpZGVcblx0ICovXG5cdGNsb25lICgpIHtcblx0XHR0aHJvdyBcIlN0YWdlIGNhbm5vdCBiZSBjbG9uZWQuXCI7XG5cdH1cblxuXHQvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9XG5cdCAqL1xuXHRfZ2V0RWxlbWVudFJlY3QgKGUpIHtcblx0XHRsZXQgYm91bmRzO1xuXHRcdHRyeSB7IGJvdW5kcyA9IGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7IH0gLy8gdGhpcyBjYW4gZmFpbCBvbiBkaXNjb25uZWN0ZWQgRE9NIGVsZW1lbnRzIGluIElFOVxuXHRcdGNhdGNoIChlcnIpIHsgYm91bmRzID0ge3RvcDplLm9mZnNldFRvcCwgbGVmdDplLm9mZnNldExlZnQsIHdpZHRoOmUub2Zmc2V0V2lkdGgsIGhlaWdodDplLm9mZnNldEhlaWdodH07IH1cblxuXHRcdGxldCBvZmZYID0gKHdpbmRvdy5wYWdlWE9mZnNldCB8fCBkb2N1bWVudC5zY3JvbGxMZWZ0IHx8IDApIC0gKGRvY3VtZW50LmNsaWVudExlZnQgfHwgZG9jdW1lbnQuYm9keS5jbGllbnRMZWZ0IHx8IDApO1xuXHRcdGxldCBvZmZZID0gKHdpbmRvdy5wYWdlWU9mZnNldCB8fCBkb2N1bWVudC5zY3JvbGxUb3AgfHwgMCkgLSAoZG9jdW1lbnQuY2xpZW50VG9wICB8fCBkb2N1bWVudC5ib2R5LmNsaWVudFRvcCAgfHwgMCk7XG5cblx0XHRsZXQgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUgPyBnZXRDb21wdXRlZFN0eWxlKGUsIG51bGwpIDogZS5jdXJyZW50U3R5bGU7IC8vIElFIDw5IGNvbXBhdGliaWxpdHkuXG5cdFx0bGV0IHBhZEwgPSBwYXJzZUludChzdHlsZXMucGFkZGluZ0xlZnQpK3BhcnNlSW50KHN0eWxlcy5ib3JkZXJMZWZ0V2lkdGgpO1xuXHRcdGxldCBwYWRUID0gcGFyc2VJbnQoc3R5bGVzLnBhZGRpbmdUb3ApK3BhcnNlSW50KHN0eWxlcy5ib3JkZXJUb3BXaWR0aCk7XG5cdFx0bGV0IHBhZFIgPSBwYXJzZUludChzdHlsZXMucGFkZGluZ1JpZ2h0KStwYXJzZUludChzdHlsZXMuYm9yZGVyUmlnaHRXaWR0aCk7XG5cdFx0bGV0IHBhZEIgPSBwYXJzZUludChzdHlsZXMucGFkZGluZ0JvdHRvbSkrcGFyc2VJbnQoc3R5bGVzLmJvcmRlckJvdHRvbVdpZHRoKTtcblxuXHRcdC8vIG5vdGU6IGluIHNvbWUgYnJvd3NlcnMgYm91bmRzIHByb3BlcnRpZXMgYXJlIHJlYWQgb25seS5cblx0XHRyZXR1cm4ge1xuXHRcdFx0bGVmdDogYm91bmRzLmxlZnQrb2ZmWCtwYWRMLFxuXHRcdFx0cmlnaHQ6IGJvdW5kcy5yaWdodCtvZmZYLXBhZFIsXG5cdFx0XHR0b3A6IGJvdW5kcy50b3Arb2ZmWStwYWRULFxuXHRcdFx0Ym90dG9tOiBib3VuZHMuYm90dG9tK29mZlktcGFkQlxuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge051bWJlcn0gaWRcblx0ICogQHJldHVybnMge09iamVjdH1cblx0ICovXG5cdF9nZXRQb2ludGVyRGF0YSAoaWQpIHtcblx0XHRsZXQgZGF0YSA9IHRoaXMuX3BvaW50ZXJEYXRhW2lkXTtcblx0XHRpZiAoIWRhdGEpIHsgZGF0YSA9IHRoaXMuX3BvaW50ZXJEYXRhW2lkXSA9IHt4OjAsIHk6MH07IH1cblx0XHRyZXR1cm4gZGF0YTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwYXJhbSB7ZWFzZWxqcy5Nb3VzZUV2ZW50fSBbZT13aW5kb3cuZXZlbnRdXG5cdCAqL1xuXHRfaGFuZGxlTW91c2VNb3ZlIChlID0gd2luZG93LmV2ZW50KSB7XG5cdFx0dGhpcy5faGFuZGxlUG9pbnRlck1vdmUoLTEsIGUsIGUucGFnZVgsIGUucGFnZVkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBlbWl0cyB7QGxpbmsgZWFzZWxqcy5EaXNwbGF5T2JqZWN0I2V2ZW50Om1vdXNlbGVhdmV9XG5cdCAqIEBlbWl0cyB7QGxpbmsgZWFzZWxqcy5EaXNwbGF5T2JqZWN0I2V2ZW50Om1vdXNlZW50ZXJ9XG5cdCAqIEBlbWl0cyB7QGxpbmsgZWFzZWxqcy5EaXNwbGF5T2JqZWN0I2V2ZW50OnByZXNzbW92ZX1cblx0ICogQGVtaXRzIHtAbGluayBlYXNlbGpzLlN0YWdlI2V2ZW50OnN0YWdlbW91c2Vtb3ZlfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBpZFxuXHQgKiBAcGFyYW0ge2Vhc2VsanMuTW91c2VFdmVudCB8IEV2ZW50fSBlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBwYWdlWFxuXHQgKiBAcGFyYW0ge051bWJlcn0gcGFnZVlcblx0ICogQHBhcmFtIHtlYXNlbGpzLlN0YWdlfSBvd25lciBJbmRpY2F0ZXMgdGhhdCB0aGUgZXZlbnQgaGFzIGFscmVhZHkgYmVlbiBjYXB0dXJlZCAmIGhhbmRsZWQgYnkgdGhlIGluZGljYXRlZCBzdGFnZS5cblx0ICovXG5cdF9oYW5kbGVQb2ludGVyTW92ZSAoaWQsIGUsIHBhZ2VYLCBwYWdlWSwgb3duZXIpIHtcblx0XHRpZiAodGhpcy5fcHJldlN0YWdlICYmIG93bmVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuOyB9IC8vIHJlZHVuZGFudCBsaXN0ZW5lci5cblx0XHRpZiAoIXRoaXMuY2FudmFzKSB7IHJldHVybjsgfVxuXHRcdGxldCBuZXh0U3RhZ2U9dGhpcy5fbmV4dFN0YWdlLCBvPXRoaXMuX2dldFBvaW50ZXJEYXRhKGlkKTtcblxuXHRcdGxldCBpbkJvdW5kcyA9IG8uaW5Cb3VuZHM7XG5cdFx0dGhpcy5fdXBkYXRlUG9pbnRlclBvc2l0aW9uKGlkLCBlLCBwYWdlWCwgcGFnZVkpO1xuXHRcdGlmIChpbkJvdW5kcyB8fCBvLmluQm91bmRzIHx8IHRoaXMubW91c2VNb3ZlT3V0c2lkZSkge1xuXHRcdFx0aWYgKGlkID09PSAtMSAmJiBvLmluQm91bmRzID09PSAhaW5Cb3VuZHMpIHtcblx0XHRcdFx0dGhpcy5fZGlzcGF0Y2hNb3VzZUV2ZW50KHRoaXMsIChpbkJvdW5kcyA/IFwibW91c2VsZWF2ZVwiIDogXCJtb3VzZWVudGVyXCIpLCBmYWxzZSwgaWQsIG8sIGUpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9kaXNwYXRjaE1vdXNlRXZlbnQodGhpcywgXCJzdGFnZW1vdXNlbW92ZVwiLCBmYWxzZSwgaWQsIG8sIGUpO1xuXHRcdFx0dGhpcy5fZGlzcGF0Y2hNb3VzZUV2ZW50KG8udGFyZ2V0LCBcInByZXNzbW92ZVwiLCB0cnVlLCBpZCwgbywgZSk7XG5cdFx0fVxuXG5cdFx0bmV4dFN0YWdlJiZuZXh0U3RhZ2UuX2hhbmRsZVBvaW50ZXJNb3ZlKGlkLCBlLCBwYWdlWCwgcGFnZVksIG51bGwpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGlkXG5cdCAqIEBwYXJhbSB7ZWFzZWxqcy5Nb3VzZUV2ZW50IHwgRXZlbnR9IGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBhZ2VYXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBwYWdlWVxuXHQgKi9cblx0X3VwZGF0ZVBvaW50ZXJQb3NpdGlvbiAoaWQsIGUsIHBhZ2VYLCBwYWdlWSkge1xuXHRcdGxldCByZWN0ID0gdGhpcy5fZ2V0RWxlbWVudFJlY3QodGhpcy5jYW52YXMpO1xuXHRcdHBhZ2VYIC09IHJlY3QubGVmdDtcblx0XHRwYWdlWSAtPSByZWN0LnRvcDtcblxuXHRcdGxldCB3ID0gdGhpcy5jYW52YXMud2lkdGg7XG5cdFx0bGV0IGggPSB0aGlzLmNhbnZhcy5oZWlnaHQ7XG5cdFx0cGFnZVggLz0gKHJlY3QucmlnaHQtcmVjdC5sZWZ0KS93O1xuXHRcdHBhZ2VZIC89IChyZWN0LmJvdHRvbS1yZWN0LnRvcCkvaDtcblx0XHRsZXQgbyA9IHRoaXMuX2dldFBvaW50ZXJEYXRhKGlkKTtcblx0XHRpZiAoby5pbkJvdW5kcyA9IChwYWdlWCA+PSAwICYmIHBhZ2VZID49IDAgJiYgcGFnZVggPD0gdy0xICYmIHBhZ2VZIDw9IGgtMSkpIHtcblx0XHRcdG8ueCA9IHBhZ2VYO1xuXHRcdFx0by55ID0gcGFnZVk7XG5cdFx0fSBlbHNlIGlmICh0aGlzLm1vdXNlTW92ZU91dHNpZGUpIHtcblx0XHRcdG8ueCA9IHBhZ2VYIDwgMCA/IDAgOiAocGFnZVggPiB3LTEgPyB3LTEgOiBwYWdlWCk7XG5cdFx0XHRvLnkgPSBwYWdlWSA8IDAgPyAwIDogKHBhZ2VZID4gaC0xID8gaC0xIDogcGFnZVkpO1xuXHRcdH1cblxuXHRcdG8ucG9zRXZ0T2JqID0gZTtcblx0XHRvLnJhd1ggPSBwYWdlWDtcblx0XHRvLnJhd1kgPSBwYWdlWTtcblxuXHRcdGlmIChpZCA9PT0gdGhpcy5fcHJpbWFyeVBvaW50ZXJJRCB8fCBpZCA9PT0gLTEpIHtcblx0XHRcdHRoaXMubW91c2VYID0gby54O1xuXHRcdFx0dGhpcy5tb3VzZVkgPSBvLnk7XG5cdFx0XHR0aGlzLm1vdXNlSW5Cb3VuZHMgPSBvLmluQm91bmRzO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwYXJhbSB7ZWFzZWxqcy5Nb3VzZUV2ZW50fSBlXG5cdCAqL1xuXHRfaGFuZGxlTW91c2VVcCAoZSkge1xuXHRcdHRoaXMuX2hhbmRsZVBvaW50ZXJVcCgtMSwgZSwgZmFsc2UpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBlbWl0cyB7QGxpbmsgZWFzZWxqcy5TdGFnZSNldmVudDpzdGFnZW1vdXNldXB9XG5cdCAqIEBlbWl0cyB7QGxpbmsgZWFzZWxqcy5EaXNwbGF5T2JqZWN0I2V2ZW50OmNsaWNrfVxuXHQgKiBAZW1pdHMge0BsaW5rIGVhc2VsanMuRGlzcGxheU9iamVjdCNldmVudDpwcmVzc3VwfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBpZFxuXHQgKiBAcGFyYW0ge2Vhc2VsanMuTW91c2VFdmVudCB8IEV2ZW50fSBlXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gY2xlYXJcblx0ICogQHBhcmFtIHtlYXNlbGpzLlN0YWdlfSBvd25lciBJbmRpY2F0ZXMgdGhhdCB0aGUgZXZlbnQgaGFzIGFscmVhZHkgYmVlbiBjYXB0dXJlZCAmIGhhbmRsZWQgYnkgdGhlIGluZGljYXRlZCBzdGFnZS5cblx0ICovXG5cdF9oYW5kbGVQb2ludGVyVXAgKGlkLCBlLCBjbGVhciwgb3duZXIpIHtcblx0XHRsZXQgbmV4dFN0YWdlID0gdGhpcy5fbmV4dFN0YWdlLCBvID0gdGhpcy5fZ2V0UG9pbnRlckRhdGEoaWQpO1xuXHRcdGlmICh0aGlzLl9wcmV2U3RhZ2UgJiYgb3duZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm47IH0gLy8gcmVkdW5kYW50IGxpc3RlbmVyLlxuXG5cdFx0bGV0IHRhcmdldD1udWxsLCBvVGFyZ2V0ID0gby50YXJnZXQ7XG5cdFx0aWYgKCFvd25lciAmJiAob1RhcmdldCB8fCBuZXh0U3RhZ2UpKSB7IHRhcmdldCA9IHRoaXMuX2dldE9iamVjdHNVbmRlclBvaW50KG8ueCwgby55LCBudWxsLCB0cnVlKTsgfVxuXG5cdFx0aWYgKG8uZG93bikgeyB0aGlzLl9kaXNwYXRjaE1vdXNlRXZlbnQodGhpcywgXCJzdGFnZW1vdXNldXBcIiwgZmFsc2UsIGlkLCBvLCBlLCB0YXJnZXQpOyBvLmRvd24gPSBmYWxzZTsgfVxuXG5cdFx0aWYgKHRhcmdldCA9PT0gb1RhcmdldCkgeyB0aGlzLl9kaXNwYXRjaE1vdXNlRXZlbnQob1RhcmdldCwgXCJjbGlja1wiLCB0cnVlLCBpZCwgbywgZSk7IH1cblx0XHR0aGlzLl9kaXNwYXRjaE1vdXNlRXZlbnQob1RhcmdldCwgXCJwcmVzc3VwXCIsIHRydWUsIGlkLCBvLCBlKTtcblxuXHRcdGlmIChjbGVhcikge1xuXHRcdFx0aWYgKGlkPT10aGlzLl9wcmltYXJ5UG9pbnRlcklEKSB7IHRoaXMuX3ByaW1hcnlQb2ludGVySUQgPSBudWxsOyB9XG5cdFx0XHRkZWxldGUodGhpcy5fcG9pbnRlckRhdGFbaWRdKTtcblx0XHR9IGVsc2UgeyBvLnRhcmdldCA9IG51bGw7IH1cblxuXHRcdG5leHRTdGFnZSYmbmV4dFN0YWdlLl9oYW5kbGVQb2ludGVyVXAoaWQsIGUsIGNsZWFyLCBvd25lciB8fCB0YXJnZXQgJiYgdGhpcyk7XG5cdH1cblxuXHQvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge2Vhc2VsanMuTW91c2VFdmVudH0gZVxuXHQgKi9cblx0X2hhbmRsZU1vdXNlRG93biAoZSkge1xuXHRcdHRoaXMuX2hhbmRsZVBvaW50ZXJEb3duKC0xLCBlLCBlLnBhZ2VYLCBlLnBhZ2VZKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAZW1pdHMge0BsaW5rIGVhc2VsanMuU3RhZ2UjZXZlbnQ6c3RhZ2Vtb3VzZWRvd259XG5cdCAqIEBlbWl0cyB7QGxpbmsgZWFzZWxqcy5EaXNwbGF5T2JqZWN0I2V2ZW50Om1vdXNlZG93bn1cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge051bWJlcn0gaWRcblx0ICogQHBhcmFtIHtlYXNlbGpzLk1vdXNlRXZlbnQgfCBFdmVudH0gZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gcGFnZVhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBhZ2VZXG5cdCAqIEBwYXJhbSB7ZWFzZWxqcy5TdGFnZX0gb3duZXIgSW5kaWNhdGVzIHRoYXQgdGhlIGV2ZW50IGhhcyBhbHJlYWR5IGJlZW4gY2FwdHVyZWQgJiBoYW5kbGVkIGJ5IHRoZSBpbmRpY2F0ZWQgc3RhZ2UuXG5cdCAqL1xuXHRfaGFuZGxlUG9pbnRlckRvd24gKGlkLCBlLCBwYWdlWCwgcGFnZVksIG93bmVyKSB7XG5cdFx0aWYgKHRoaXMucHJldmVudFNlbGVjdGlvbikgeyBlLnByZXZlbnREZWZhdWx0KCk7IH1cblx0XHRpZiAodGhpcy5fcHJpbWFyeVBvaW50ZXJJRCA9PSBudWxsIHx8IGlkID09PSAtMSkgeyB0aGlzLl9wcmltYXJ5UG9pbnRlcklEID0gaWQ7IH0gLy8gbW91c2UgYWx3YXlzIHRha2VzIG92ZXIuXG5cblx0XHRpZiAocGFnZVkgIT0gbnVsbCkgeyB0aGlzLl91cGRhdGVQb2ludGVyUG9zaXRpb24oaWQsIGUsIHBhZ2VYLCBwYWdlWSk7IH1cblx0XHRsZXQgdGFyZ2V0ID0gbnVsbCwgbmV4dFN0YWdlID0gdGhpcy5fbmV4dFN0YWdlLCBvID0gdGhpcy5fZ2V0UG9pbnRlckRhdGEoaWQpO1xuXHRcdGlmICghb3duZXIpIHsgdGFyZ2V0ID0gby50YXJnZXQgPSB0aGlzLl9nZXRPYmplY3RzVW5kZXJQb2ludChvLngsIG8ueSwgbnVsbCwgdHJ1ZSk7IH1cblxuXHRcdGlmIChvLmluQm91bmRzKSB7IHRoaXMuX2Rpc3BhdGNoTW91c2VFdmVudCh0aGlzLCBcInN0YWdlbW91c2Vkb3duXCIsIGZhbHNlLCBpZCwgbywgZSwgdGFyZ2V0KTsgby5kb3duID0gdHJ1ZTsgfVxuXHRcdHRoaXMuX2Rpc3BhdGNoTW91c2VFdmVudCh0YXJnZXQsIFwibW91c2Vkb3duXCIsIHRydWUsIGlkLCBvLCBlKTtcblxuXHRcdG5leHRTdGFnZSYmbmV4dFN0YWdlLl9oYW5kbGVQb2ludGVyRG93bihpZCwgZSwgcGFnZVgsIHBhZ2VZLCBvd25lciB8fCB0YXJnZXQgJiYgdGhpcyk7XG5cdH1cblxuXHQvKipcblx0ICogQGVtaXRzIHtAbGluayBlYXNlbGpzLkRpc3BsYXlPYmplY3QjZXZlbnQ6bW91c2VvdXR9XG5cdCAqIEBlbWl0cyB7QGxpbmsgZWFzZWxqcy5EaXNwbGF5T2JqZWN0I2V2ZW50OnJvbGxvdXR9XG5cdCAqIEBlbWl0cyB7QGxpbmsgZWFzZWxqcy5EaXNwbGF5T2JqZWN0I2V2ZW50OnJvbGxvdmVyfVxuXHQgKiBAZW1pdHMge0BsaW5rIGVhc2VsanMuRGlzcGxheU9iamVjdCNldmVudDptb3VzZW92ZXJ9XG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gY2xlYXIgSWYgdHJ1ZSwgY2xlYXJzIHRoZSBtb3VzZW92ZXIgLyByb2xsb3ZlciAoaWUuIG5vIHRhcmdldClcblx0ICogQHBhcmFtIHtlYXNlbGpzLlN0YWdlfSBvd25lciBJbmRpY2F0ZXMgdGhhdCB0aGUgZXZlbnQgaGFzIGFscmVhZHkgYmVlbiBjYXB0dXJlZCAmIGhhbmRsZWQgYnkgdGhlIGluZGljYXRlZCBzdGFnZS5cblx0ICogQHBhcmFtIHtlYXNlbGpzLlN0YWdlfSBldmVudFRhcmdldCBUaGUgc3RhZ2UgdGhhdCB0aGUgY3Vyc29yIGlzIGFjdGl2ZWx5IG92ZXIuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdF90ZXN0TW91c2VPdmVyIChjbGVhciwgb3duZXIsIGV2ZW50VGFyZ2V0KSB7XG5cdFx0aWYgKHRoaXMuX3ByZXZTdGFnZSAmJiBvd25lciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybjsgfSAvLyByZWR1bmRhbnQgbGlzdGVuZXIuXG5cblx0XHRsZXQgbmV4dFN0YWdlID0gdGhpcy5fbmV4dFN0YWdlO1xuXHRcdGlmICghdGhpcy5fbW91c2VPdmVySW50ZXJ2YWxJRCkge1xuXHRcdFx0Ly8gbm90IGVuYWJsZWQgZm9yIG1vdXNlb3ZlciwgYnV0IHNob3VsZCBzdGlsbCByZWxheSB0aGUgZXZlbnQuXG5cdFx0XHRuZXh0U3RhZ2UmJm5leHRTdGFnZS5fdGVzdE1vdXNlT3ZlcihjbGVhciwgb3duZXIsIGV2ZW50VGFyZ2V0KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0bGV0IG8gPSB0aGlzLl9nZXRQb2ludGVyRGF0YSgtMSk7XG5cdFx0Ly8gb25seSB1cGRhdGUgaWYgdGhlIG1vdXNlIHBvc2l0aW9uIGhhcyBjaGFuZ2VkLiBUaGlzIHByb3ZpZGVzIGEgbG90IG9mIG9wdGltaXphdGlvbiwgYnV0IGhhcyBzb21lIHRyYWRlLW9mZnMuXG5cdFx0aWYgKCFvIHx8ICghY2xlYXIgJiYgdGhpcy5tb3VzZVggPT09IHRoaXMuX21vdXNlT3ZlclggJiYgdGhpcy5tb3VzZVkgPT09IHRoaXMuX21vdXNlT3ZlclkgJiYgdGhpcy5tb3VzZUluQm91bmRzKSkgeyByZXR1cm47IH1cblxuXHRcdGxldCBlID0gby5wb3NFdnRPYmo7XG5cdFx0bGV0IGlzRXZlbnRUYXJnZXQgPSBldmVudFRhcmdldCB8fCBlJiYoZS50YXJnZXQgPT09IHRoaXMuY2FudmFzKTtcblx0XHRsZXQgdGFyZ2V0PW51bGwsIGNvbW1vbiA9IC0xLCBjdXJzb3I9XCJcIjtcblxuXHRcdGlmICghb3duZXIgJiYgKGNsZWFyIHx8IHRoaXMubW91c2VJbkJvdW5kcyAmJiBpc0V2ZW50VGFyZ2V0KSkge1xuXHRcdFx0dGFyZ2V0ID0gdGhpcy5fZ2V0T2JqZWN0c1VuZGVyUG9pbnQodGhpcy5tb3VzZVgsIHRoaXMubW91c2VZLCBudWxsLCB0cnVlKTtcblx0XHRcdHRoaXMuX21vdXNlT3ZlclggPSB0aGlzLm1vdXNlWDtcblx0XHRcdHRoaXMuX21vdXNlT3ZlclkgPSB0aGlzLm1vdXNlWTtcblx0XHR9XG5cblx0XHRsZXQgb2xkTGlzdCA9IHRoaXMuX21vdXNlT3ZlclRhcmdldHx8W107XG5cdFx0bGV0IG9sZFRhcmdldCA9IG9sZExpc3Rbb2xkTGlzdC5sZW5ndGgtMV07XG5cdFx0bGV0IGxpc3QgPSB0aGlzLl9tb3VzZU92ZXJUYXJnZXQgPSBbXTtcblxuXHRcdC8vIGdlbmVyYXRlIGFuY2VzdG9yIGxpc3QgYW5kIGNoZWNrIGZvciBjdXJzb3I6XG5cdFx0bGV0IHQgPSB0YXJnZXQ7XG5cdFx0d2hpbGUgKHQpIHtcblx0XHRcdGxpc3QudW5zaGlmdCh0KTtcblx0XHRcdGlmICghY3Vyc29yKSB7IGN1cnNvciA9IHQuY3Vyc29yOyB9XG5cdFx0XHR0ID0gdC5wYXJlbnQ7XG5cdFx0fVxuXHRcdHRoaXMuY2FudmFzLnN0eWxlLmN1cnNvciA9IGN1cnNvcjtcblx0XHRpZiAoIW93bmVyICYmIGV2ZW50VGFyZ2V0KSB7IGV2ZW50VGFyZ2V0LmNhbnZhcy5zdHlsZS5jdXJzb3IgPSBjdXJzb3I7IH1cblxuXHRcdC8vIGZpbmQgY29tbW9uIGFuY2VzdG9yOlxuXHRcdGZvciAobGV0IGk9MCxsPWxpc3QubGVuZ3RoOyBpPGw7IGkrKykge1xuXHRcdFx0aWYgKGxpc3RbaV0gIT0gb2xkTGlzdFtpXSkgeyBicmVhazsgfVxuXHRcdFx0Y29tbW9uID0gaTtcblx0XHR9XG5cblx0XHRpZiAob2xkVGFyZ2V0ICE9IHRhcmdldCkge1xuXHRcdFx0dGhpcy5fZGlzcGF0Y2hNb3VzZUV2ZW50KG9sZFRhcmdldCwgXCJtb3VzZW91dFwiLCB0cnVlLCAtMSwgbywgZSwgdGFyZ2V0KTtcblx0XHR9XG5cblx0XHRmb3IgKGxldCBpPW9sZExpc3QubGVuZ3RoLTE7IGk+Y29tbW9uOyBpLS0pIHtcblx0XHRcdHRoaXMuX2Rpc3BhdGNoTW91c2VFdmVudChvbGRMaXN0W2ldLCBcInJvbGxvdXRcIiwgZmFsc2UsIC0xLCBvLCBlLCB0YXJnZXQpO1xuXHRcdH1cblxuXHRcdGZvciAobGV0IGk9bGlzdC5sZW5ndGgtMTsgaT5jb21tb247IGktLSkge1xuXHRcdFx0dGhpcy5fZGlzcGF0Y2hNb3VzZUV2ZW50KGxpc3RbaV0sIFwicm9sbG92ZXJcIiwgZmFsc2UsIC0xLCBvLCBlLCBvbGRUYXJnZXQpO1xuXHRcdH1cblxuXHRcdGlmIChvbGRUYXJnZXQgIT0gdGFyZ2V0KSB7XG5cdFx0XHR0aGlzLl9kaXNwYXRjaE1vdXNlRXZlbnQodGFyZ2V0LCBcIm1vdXNlb3ZlclwiLCB0cnVlLCAtMSwgbywgZSwgb2xkVGFyZ2V0KTtcblx0XHR9XG5cblx0XHRuZXh0U3RhZ2UmJm5leHRTdGFnZS5fdGVzdE1vdXNlT3ZlcihjbGVhciwgb3duZXIgfHwgdGFyZ2V0ICYmIHRoaXMsIGV2ZW50VGFyZ2V0IHx8IGlzRXZlbnRUYXJnZXQgJiYgdGhpcyk7XG5cdH1cblxuXHQvKipcblx0ICogQGVtaXRzIHtAbGluayBlYXNlbGpzLkRpc3BsYXlPYmplY3QjZXZlbnQ6ZGJsY2xpY2t9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHBhcmFtIHtlYXNlbGpzLk1vdXNlRXZlbnR9IGVcblx0ICogQHBhcmFtIHtlYXNlbGpzLlN0YWdlfSBvd25lciBJbmRpY2F0ZXMgdGhhdCB0aGUgZXZlbnQgaGFzIGFscmVhZHkgYmVlbiBjYXB0dXJlZCAmIGhhbmRsZWQgYnkgdGhlIGluZGljYXRlZCBzdGFnZS5cblx0ICovXG5cdF9oYW5kbGVEb3VibGVDbGljayAoZSwgb3duZXIpIHtcblx0XHRsZXQgdGFyZ2V0PW51bGwsIG5leHRTdGFnZT10aGlzLl9uZXh0U3RhZ2UsIG89dGhpcy5fZ2V0UG9pbnRlckRhdGEoLTEpO1xuXHRcdGlmICghb3duZXIpIHtcblx0XHRcdHRhcmdldCA9IHRoaXMuX2dldE9iamVjdHNVbmRlclBvaW50KG8ueCwgby55LCBudWxsLCB0cnVlKTtcblx0XHRcdHRoaXMuX2Rpc3BhdGNoTW91c2VFdmVudCh0YXJnZXQsIFwiZGJsY2xpY2tcIiwgdHJ1ZSwgLTEsIG8sIGUpO1xuXHRcdH1cblx0XHRuZXh0U3RhZ2UmJm5leHRTdGFnZS5faGFuZGxlRG91YmxlQ2xpY2soZSwgb3duZXIgfHwgdGFyZ2V0ICYmIHRoaXMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHBhcmFtIHtlYXNlbGpzLkRpc3BsYXlPYmplY3R9IHRhcmdldFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGJ1YmJsZXNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBvaW50ZXJJZFxuXHQgKiBAcGFyYW0ge09iamVjdH0gb1xuXHQgKiBAcGFyYW0ge2Vhc2VsanMuTW91c2VFdmVudH0gW25hdGl2ZUV2ZW50XVxuXHQgKiBAcGFyYW0ge2Vhc2VsanMuRGlzcGxheU9iamVjdH0gW3JlbGF0ZWRUYXJnZXRdXG5cdCAqL1xuXHRfZGlzcGF0Y2hNb3VzZUV2ZW50ICh0YXJnZXQsIHR5cGUsIGJ1YmJsZXMsIHBvaW50ZXJJZCwgbywgbmF0aXZlRXZlbnQsIHJlbGF0ZWRUYXJnZXQpIHtcblx0XHQvLyBUT0RPOiBtaWdodCBiZSB3b3J0aCBlaXRoZXIgcmV1c2luZyBNb3VzZUV2ZW50IGluc3RhbmNlcywgb3IgYWRkaW5nIGEgd2lsbFRyaWdnZXIgbWV0aG9kIHRvIGF2b2lkIEdDLlxuXHRcdGlmICghdGFyZ2V0IHx8ICghYnViYmxlcyAmJiAhdGFyZ2V0Lmhhc0V2ZW50TGlzdGVuZXIodHlwZSkpKSB7IHJldHVybjsgfVxuXHRcdC8qXG5cdFx0Ly8gVE9ETzogYWNjb3VudCBmb3Igc3RhZ2UgdHJhbnNmb3JtYXRpb25zP1xuXHRcdHRoaXMuX210eCA9IHRoaXMuZ2V0Q29uY2F0ZW5hdGVkTWF0cml4KHRoaXMuX210eCkuaW52ZXJ0KCk7XG5cdFx0bGV0IHB0ID0gdGhpcy5fbXR4LnRyYW5zZm9ybVBvaW50KG8ueCwgby55KTtcblx0XHRsZXQgZXZ0ID0gbmV3IE1vdXNlRXZlbnQodHlwZSwgYnViYmxlcywgZmFsc2UsIHB0LngsIHB0LnksIG5hdGl2ZUV2ZW50LCBwb2ludGVySWQsIHBvaW50ZXJJZD09dGhpcy5fcHJpbWFyeVBvaW50ZXJJRCB8fCBwb2ludGVySWQ9PS0xLCBvLnJhd1gsIG8ucmF3WSk7XG5cdFx0Ki9cblx0XHRsZXQgZXZ0ID0gbmV3IE1vdXNlRXZlbnQodHlwZSwgYnViYmxlcywgZmFsc2UsIG8ueCwgby55LCBuYXRpdmVFdmVudCwgcG9pbnRlcklkLCBwb2ludGVySWQgPT09IHRoaXMuX3ByaW1hcnlQb2ludGVySUQgfHwgcG9pbnRlcklkID09PSAtMSwgby5yYXdYLCBvLnJhd1ksIHJlbGF0ZWRUYXJnZXQpO1xuXHRcdHRhcmdldC5kaXNwYXRjaEV2ZW50KGV2dCk7XG5cdH1cblxufVxuXG4vKipcbiAqIERpc3BhdGNoZWQgd2hlbiB0aGUgdXNlciBtb3ZlcyB0aGUgbW91c2Ugb3ZlciB0aGUgY2FudmFzLlxuICogQHNlZSB7QGxpbmsgZWFzZWxqcy5Nb3VzZUV2ZW50fVxuICogQGV2ZW50IGVhc2VsanMuU3RhZ2Ujc3RhZ2Vtb3VzZW1vdmVcbiAqIEBzaW5jZSAwLjYuMFxuICovXG4vKipcbiAqIERpc3BhdGNoZWQgd2hlbiB0aGUgdXNlciBwcmVzc2VzIHRoZWlyIGxlZnQgbW91c2UgYnV0dG9uIG9uIHRoZSBjYW52YXMuXG4gKiBZb3UgY2FuIHVzZSB7QGxpbmsgZWFzZWxqcy5TdGFnZSNtb3VzZUluQm91bmRzfSB0byBjaGVjayB3aGV0aGVyIHRoZSBtb3VzZSBpcyBjdXJyZW50bHkgd2l0aGluIHRoZSBzdGFnZSBib3VuZHMuXG4gKiBAc2VlIHtAbGluayBlYXNlbGpzLk1vdXNlRXZlbnR9XG4gKiBAZXZlbnQgZWFzZWxqcy5TdGFnZSNzdGFnZW1vdXNlZG93blxuICogQHNpbmNlIDAuNi4wXG4gKi9cbi8qKlxuICogRGlzcGF0Y2hlZCB3aGVuIHRoZSB1c2VyIHRoZSB1c2VyIHByZXNzZXMgc29tZXdoZXJlIG9uIHRoZSBzdGFnZSwgdGhlbiByZWxlYXNlcyB0aGUgbW91c2UgYnV0dG9uIGFueXdoZXJlIHRoYXQgdGhlIHBhZ2UgY2FuIGRldGVjdCBpdCAodGhpcyB2YXJpZXMgc2xpZ2h0bHkgYmV0d2VlbiBicm93c2VycykuXG4gKiBZb3UgY2FuIHVzZSB7QGxpbmsgZWFzZWxqcy5TdGFnZSNtb3VzZUluQm91bmRzfSB0byBjaGVjayB3aGV0aGVyIHRoZSBtb3VzZSBpcyBjdXJyZW50bHkgd2l0aGluIHRoZSBzdGFnZSBib3VuZHMuXG4gKiBAc2VlIHtAbGluayBlYXNlbGpzLk1vdXNlRXZlbnR9XG4gKiBAZXZlbnQgZWFzZWxqcy5TdGFnZSNzdGFnZW1vdXNldXBcbiAqIEBzaW5jZSAwLjYuMFxuICovXG4vKipcbiAqIERpc3BhdGNoZWQgd2hlbiB0aGUgbW91c2UgbW92ZXMgZnJvbSB3aXRoaW4gdGhlIGNhbnZhcyBhcmVhIChtb3VzZUluQm91bmRzID09PSB0cnVlKSB0byBvdXRzaWRlIGl0IChtb3VzZUluQm91bmRzID09PSBmYWxzZSkuXG4gKiBUaGlzIGlzIGN1cnJlbnRseSBvbmx5IGRpc3BhdGNoZWQgZm9yIG1vdXNlIGlucHV0IChub3QgdG91Y2gpLlxuICogQHNlZSB7QGxpbmsgZWFzZWxqcy5Nb3VzZUV2ZW50fVxuICogQGV2ZW50IGVhc2VsanMuU3RhZ2UjbW91c2VsZWF2ZVxuICogQHNpbmNlIDAuNy4wXG4gKi9cbi8qKlxuICogRGlzcGF0Y2hlZCB3aGVuIHRoZSBtb3VzZSBtb3ZlcyBpbnRvIHRoZSBjYW52YXMgYXJlYSAobW91c2VJbkJvdW5kcyA9PT0gZmFsc2UpIGZyb20gb3V0c2lkZSBpdCAobW91c2VJbkJvdW5kcyA9PT0gdHJ1ZSkuXG4gKiBUaGlzIGlzIGN1cnJlbnRseSBvbmx5IGRpc3BhdGNoZWQgZm9yIG1vdXNlIGlucHV0IChub3QgdG91Y2gpLlxuICogQHNlZSB7QGxpbmsgZWFzZWxqcy5Nb3VzZUV2ZW50fVxuICogQGV2ZW50IGVhc2VsanMuU3RhZ2UjbW91c2VlbnRlclxuICogQHNpbmNlIDAuNy4wXG4gKi9cbi8qKlxuICogRGlzcGF0Y2hlZCBlYWNoIHVwZGF0ZSBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIHRpY2sgZXZlbnQgaXMgcHJvcGFnYXRlZCB0aHJvdWdoIHRoZSBkaXNwbGF5IGxpc3QuXG4gKiBZb3UgY2FuIGNhbGwgcHJldmVudERlZmF1bHQgb24gdGhlIGV2ZW50IG9iamVjdCB0byBjYW5jZWwgcHJvcGFnYXRpbmcgdGhlIHRpY2sgZXZlbnQuXG4gKiBAZXZlbnQgZWFzZWxqcy5TdGFnZSN0aWNrc3RhcnRcbiAqIEBzaW5jZSAwLjcuMFxuICovXG4vKipcbiAqIERpc3BhdGNoZWQgZWFjaCB1cGRhdGUgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIHRpY2sgZXZlbnQgaXMgcHJvcGFnYXRlZCB0aHJvdWdoIHRoZSBkaXNwbGF5IGxpc3QuIERvZXMgbm90IGZpcmUgaWZcbiAqIHRpY2tPblVwZGF0ZSBpcyBmYWxzZS4gUHJlY2VkZXMgdGhlIFwiZHJhd3N0YXJ0XCIgZXZlbnQuXG4gKiBAZXZlbnQgZWFzZWxqcy5TdGFnZSN0aWNrZW5kXG4gKiBAc2luY2UgMC43LjBcbiAqL1xuLyoqXG4gKiBEaXNwYXRjaGVkIGVhY2ggdXBkYXRlIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgY2FudmFzIGlzIGNsZWFyZWQgYW5kIHRoZSBkaXNwbGF5IGxpc3QgaXMgZHJhd24gdG8gaXQuXG4gKiBZb3UgY2FuIGNhbGwgcHJldmVudERlZmF1bHQgb24gdGhlIGV2ZW50IG9iamVjdCB0byBjYW5jZWwgdGhlIGRyYXcuXG4gKiBAZXZlbnQgZWFzZWxqcy5TdGFnZSNkcmF3c3RhcnRcbiAqIEBzaW5jZSAwLjcuMFxuICovXG4vKipcbiAqIERpc3BhdGNoZWQgZWFjaCB1cGRhdGUgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGRpc3BsYXkgbGlzdCBpcyBkcmF3biB0byB0aGUgY2FudmFzIGFuZCB0aGUgY2FudmFzIGNvbnRleHQgaXMgcmVzdG9yZWQuXG4gKiBAZXZlbnQgZWFzZWxqcy5TdGFnZSNkcmF3ZW5kXG4gKiBAc2luY2UgMC43LjBcbiAqL1xuIiwiLyoqXHJcbiAqIEBsaWNlbnNlIENhbnZhc1xyXG4gKiBWaXNpdCBodHRwOi8vY3JlYXRlanMuY29tLyBmb3IgZG9jdW1lbnRhdGlvbiwgdXBkYXRlcyBhbmQgZXhhbXBsZXMuXHJcbiAqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyBnc2tpbm5lci5jb20sIGluYy5cclxuICpcclxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cclxuICogb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cclxuICogZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0XHJcbiAqIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxyXG4gKiBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxyXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcclxuICogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcclxuICogY29uZGl0aW9uczpcclxuICpcclxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcclxuICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcbiAqXHJcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXHJcbiAqIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xyXG4gKiBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxyXG4gKiBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxyXG4gKiBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcclxuICogV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXHJcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcclxuICogT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBHbG9iYWwgdXRpbGl0eSBmb3IgY3JlYXRpbmcgY2FudmFzZXMuXHJcbiAqIEBtZW1iZXJvZiBlYXNlbGpzXG4gKiBAbmFtZSBlYXNlbGpzLmNyZWF0ZUNhbnZhc1xuICogQHBhcmFtIHtOdW1iZXJ9IFt3aWR0aD0xXVxuICogQHBhcmFtIHtOdW1iZXJ9IFtoZWlnaHQ9MV1cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNyZWF0ZUNhbnZhcyh3aWR0aD0xLCBoZWlnaHQ9MSkge1xuXHRsZXQgYztcblx0aWYgKHdpbmRvdy5jcmVhdGVqcyAhPT0gdW5kZWZpbmVkICYmIHdpbmRvdy5jcmVhdGVqcy5jcmVhdGVDYW52YXMgIT09IHVuZGVmaW5lZCkge1xuXHRcdGMgPSB3aW5kb3cuY3JlYXRlanMuY3JlYXRlQ2FudmFzKCk7XG5cdH1cblx0aWYgKHdpbmRvdy5kb2N1bWVudCAhPT0gdW5kZWZpbmVkICYmIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSB1bmRlZmluZWQpIHtcblx0XHRjID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcblx0fVxuXHRpZiAoYyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0Yy53aWR0aCA9IHdpZHRoO1xuXHRcdGMuaGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdHJldHVybiBjO1xuXHR9XG5cblx0dGhyb3cgXCJDYW52YXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGVudmlyb25tZW50LlwiO1xyXG59XHJcbiIsIi8qKlxuICogQGxpY2Vuc2UgVmlkZW9CdWZmZXJcbiAqIFZpc2l0IGh0dHA6Ly9jcmVhdGVqcy5jb20vIGZvciBkb2N1bWVudGF0aW9uLCB1cGRhdGVzIGFuZCBleGFtcGxlcy5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAgZ3NraW5uZXIuY29tLCBpbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAqIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXG4gKiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXRcbiAqIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxuICogY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuICogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbiAqIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAqIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gKiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcbiAqIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gKiBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuICogSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXG4gKiBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcbiAqIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5pbXBvcnQgY3JlYXRlQ2FudmFzIGZyb20gXCIuL0NhbnZhc1wiO1xuXG4vKipcbiAqIFdoZW4gYW4gSFRNTCB2aWRlbyBzZWVrcywgaW5jbHVkaW5nIHdoZW4gbG9vcGluZywgdGhlcmUgaXMgYW4gaW5kZXRlcm1pbmF0ZSBwZXJpb2QgYmVmb3JlIGEgbmV3IGZyYW1lIGlzIGF2YWlsYWJsZS5cbiAqIFRoaXMgY2FuIHJlc3VsdCBpbiB0aGUgdmlkZW8gYmxpbmtpbmcgb3IgZmxhc2hpbmcgd2hlbiBpdCBpcyBkcmF3biB0byBhIGNhbnZhcy4gVGhlIFZpZGVvQnVmZmVyIGNsYXNzIHJlc29sdmVzXG4gKiB0aGlzIGlzc3VlIGJ5IGRyYXdpbmcgZWFjaCBmcmFtZSB0byBhbiBvZmYtc2NyZWVuIGNhbnZhcyBhbmQgcHJlc2VydmluZyB0aGUgcHJpb3IgZnJhbWUgZHVyaW5nIGEgc2Vlay5cbiAqXG4gKiBAZXhhbXBsZVxuICogbGV0IGJ1ZmZlciA9IG5ldyBWaWRlb0J1ZmZlcih2aWRlbyk7XG4gKiBsZXQgYml0bWFwID0gbmV3IEJpdG1hcChidWZmZXIpO1xuICpcbiAqIEBwYXJhbSB7SFRNTFZpZGVvRWxlbWVudH0gdmlkZW8gVGhlIEhUTUwgdmlkZW8gZWxlbWVudCB0byBidWZmZXIuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZpZGVvQnVmZmVyIHtcblxuICBjb25zdHJ1Y3RvciAodmlkZW8pIHtcblxuICBcdC8qKlxuICBcdCAqIFVzZWQgYnkgQml0bWFwIHRvIGRldGVybWluZSB3aGVuIHRoZSB2aWRlbyBidWZmZXIgaXMgcmVhZHkgdG8gYmUgZHJhd24uIE5vdCBpbnRlbmRlZCBmb3IgZ2VuZXJhbCB1c2UuXG4gIFx0ICogQHByb3RlY3RlZFxuICBcdCAqIEB0eXBlIHtOdW1iZXJ9XG4gIFx0ICovXG4gIFx0dGhpcy5yZWFkeVN0YXRlID0gdmlkZW8ucmVhZHlTdGF0ZTtcblxuICBcdC8qKlxuICBcdCAqIEBwcm90ZWN0ZWRcbiAgXHQgKiBAdHlwZSB7SFRNTFZpZGVvRWxlbWVudH1cbiAgXHQgKi9cbiAgXHR0aGlzLl92aWRlbyA9IHZpZGVvO1xuXG4gIFx0LyoqXG4gIFx0ICogQHByb3RlY3RlZFxuICBcdCAqIEB0eXBlIHtIVE1MQ2FudmFzRWxlbWVudH1cbiAgXHQgKi9cbiAgXHR0aGlzLl9jYW52YXMgPSBudWxsO1xuXG4gIFx0LyoqXG4gIFx0ICogQHByb3RlY3RlZFxuICBcdCAqIEB0eXBlIHtOdW1iZXJ9XG4gIFx0ICogQGRlZmF1bHQgLTFcbiAgXHQgKi9cbiAgXHR0aGlzLl9sYXN0VGltZSA9IC0xO1xuXG4gIFx0aWYgKHRoaXMucmVhZHlTdGF0ZSA8IDIpIHtcbiAgICAgIHZpZGVvLmFkZEV2ZW50TGlzdGVuZXIoXCJjYW5wbGF5dGhyb3VnaFwiLCB0aGlzLl92aWRlb1JlYWR5LmJpbmQodGhpcykpO1xuICAgIH1cbiAgICAvLyB7b25jZTogdHJ1ZX0gaXNuJ3Qgc3VwcG9ydGVkIGV2ZXJ5d2hlcmUsIGJ1dCBpdHMgYSBub24tY3JpdGljYWwgb3B0aW1pemF0aW9uIGhlcmUuXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhbiBIVE1MIGNhbnZhcyBlbGVtZW50IHNob3dpbmcgdGhlIGN1cnJlbnQgdmlkZW8gZnJhbWUsIG9yIHRoZSBwcmV2aW91cyBmcmFtZSBpZiBpbiBhIHNlZWsgLyBsb29wLlxuICAgKiBQcmltYXJpbHkgZm9yIHVzZSBieSB7QGxpbmsgZWFzZWxqcy5CaXRtYXB9LlxuICAgKi9cbiAgZ2V0SW1hZ2UgKCkge1xuICBcdGlmICh0aGlzLnJlYWR5U3RhdGUgPCAyKSB7IHJldHVybjsgfVxuICBcdGxldCBjYW52YXMgPSB0aGlzLl9jYW52YXMsIHZpZGVvID0gdGhpcy5fdmlkZW87XG4gIFx0aWYgKCFjYW52YXMpIHtcblx0XHRcdGNhbnZhcyA9IHRoaXMuX2NhbnZhcyA9IGNyZWF0ZUNhbnZhcygpO1xuICBcdFx0Y2FudmFzLndpZHRoID0gdmlkZW8udmlkZW9XaWR0aDtcbiAgXHRcdGNhbnZhcy5oZWlnaHQgPSB2aWRlby52aWRlb0hlaWdodDtcbiAgXHR9XG4gIFx0aWYgKHZpZGVvLnJlYWR5U3RhdGUgPj0gMiAmJiB2aWRlby5jdXJyZW50VGltZSAhPT0gdGhpcy5fbGFzdFRpbWUpIHtcbiAgXHRcdGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gIFx0XHRjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gIFx0XHRjdHguZHJhd0ltYWdlKHZpZGVvLCAwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICBcdFx0dGhpcy5fbGFzdFRpbWUgPSB2aWRlby5jdXJyZW50VGltZTtcbiAgXHR9XG4gIFx0cmV0dXJuIGNhbnZhcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfdmlkZW9SZWFkeSAoKSB7XG4gIFx0dGhpcy5yZWFkeVN0YXRlID0gMjtcbiAgfVxuXG59XG4iLCIvKipcbiAqIEBsaWNlbnNlIEJpdG1hcFxuICogVmlzaXQgaHR0cDovL2NyZWF0ZWpzLmNvbS8gZm9yIGRvY3VtZW50YXRpb24sIHVwZGF0ZXMgYW5kIGV4YW1wbGVzLlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNyBnc2tpbm5lci5jb20sIGluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICogb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cbiAqIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxuICogcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsXG4gKiBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4gKiBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuICogY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAqIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xuICogT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAqIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4gKiBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcbiAqIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuICogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUlxuICogT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICovXG5cbmltcG9ydCBEaXNwbGF5T2JqZWN0IGZyb20gXCIuL0Rpc3BsYXlPYmplY3RcIjtcbmltcG9ydCBWaWRlb0J1ZmZlciBmcm9tIFwiLi4vdXRpbHMvVmlkZW9CdWZmZXJcIjtcblxuLyoqXG4gKiBBIEJpdG1hcCByZXByZXNlbnRzIGFuIEltYWdlLCBDYW52YXMsIG9yIFZpZGVvIGluIHRoZSBkaXNwbGF5IGxpc3QuIEEgQml0bWFwIGNhbiBiZSBpbnN0YW50aWF0ZWQgdXNpbmcgYW4gZXhpc3RpbmdcbiAqIEhUTUwgZWxlbWVudCwgb3IgYSBzdHJpbmcuXG4gKlxuICogPHN0cm9uZz5Ob3Rlczo8L3N0cm9uZz5cbiAqIDxvbD5cbiAqICAgICA8bGk+V2hlbiB1c2luZyBhIHZpZGVvIHNvdXJjZSB0aGF0IG1heSBsb29wIG9yIHNlZWssIHVzZSBhIHtAbGluayBlYXNlbGpzLlZpZGVvQnVmZmVyfSBvYmplY3QgdG9cbiAqICAgICAgYmxpbmtpbmcgLyBmbGFzaGluZy5cbiAqICAgICA8bGk+V2hlbiBhIHN0cmluZyBwYXRoIG9yIGltYWdlIHRhZyB0aGF0IGlzIG5vdCB5ZXQgbG9hZGVkIGlzIHVzZWQsIHRoZSBzdGFnZSBtYXkgbmVlZCB0byBiZSByZWRyYXduIGJlZm9yZSBpdFxuICogICAgICB3aWxsIGJlIGRpc3BsYXllZC48L2xpPlxuICogICAgIDxsaT5CaXRtYXBzIHdpdGggYW4gU1ZHIHNvdXJjZSBjdXJyZW50bHkgd2lsbCBub3QgcmVzcGVjdCBhbiBhbHBoYSB2YWx1ZSBvdGhlciB0aGFuIDAgb3IgMS4gVG8gZ2V0IGFyb3VuZCB0aGlzLFxuICogICAgIHRoZSBCaXRtYXAgY2FuIGJlIGNhY2hlZC48L2xpPlxuICogICAgIDxsaT5CaXRtYXBzIHdpdGggYW4gU1ZHIHNvdXJjZSB3aWxsIHRhaW50IHRoZSBjYW52YXMgd2l0aCBjcm9zcy1vcmlnaW4gZGF0YSwgd2hpY2ggcHJldmVudHMgaW50ZXJhY3Rpdml0eS4gVGhpc1xuICogICAgIGhhcHBlbnMgaW4gYWxsIGJyb3dzZXJzIGV4Y2VwdCByZWNlbnQgRmlyZWZveCBidWlsZHMuPC9saT5cbiAqICAgICA8bGk+SW1hZ2VzIGxvYWRlZCBjcm9zcy1vcmlnaW4gd2lsbCB0aHJvdyBjcm9zcy1vcmlnaW4gc2VjdXJpdHkgZXJyb3JzIHdoZW4gaW50ZXJhY3RlZCB3aXRoIHVzaW5nIGEgbW91c2UsIHVzaW5nXG4gKiAgICAgbWV0aG9kcyBzdWNoIGFzIGBnZXRPYmplY3RVbmRlclBvaW50YCwgb3IgdXNpbmcgZmlsdGVycywgb3IgY2FjaGluZy4gWW91IGNhbiBnZXQgYXJvdW5kIHRoaXMgYnkgc2V0dGluZ1xuICogICAgIGBjcm9zc09yaWdpbmAgZmxhZ3Mgb24geW91ciBpbWFnZXMgYmVmb3JlIHBhc3NpbmcgdGhlbSB0byBFYXNlbEpTLCBlZzogYGltZy5jcm9zc09yaWdpbj1cIkFub255bW91c1wiO2A8L2xpPlxuICogPC9vbD5cbiAqXG4gKiBAbWVtYmVyb2YgZWFzZWxqc1xuICogQGV4dGVuZHMgZWFzZWxqcy5EaXNwbGF5T2JqZWN0XG4gKiBAZXhhbXBsZVxuICogY29uc3QgYml0bWFwID0gbmV3IEJpdG1hcChcImltYWdlUGF0aC5qcGdcIik7XG4gKlxuICogQHBhcmFtIHtDYW52YXNJbWFnZVNvdXJjZSB8IFN0cmluZyB8IE9iamVjdH0gaW1hZ2VPclVyaSBUaGUgc291cmNlIGltYWdlIHRvIGRpc3BsYXkuIFRoaXMgY2FuIGJlIGEgQ2FudmFzSW1hZ2VTb3VyY2VcbiAqIChpbWFnZSwgdmlkZW8sIGNhbnZhcyksIGFuIG9iamVjdCB3aXRoIGEgYGdldEltYWdlYCBtZXRob2QgdGhhdCByZXR1cm5zIGEgQ2FudmFzSW1hZ2VTb3VyY2UsIG9yIGEgc3RyaW5nIFVSTCB0byBhbiBpbWFnZS5cbiAqIElmIHRoZSBsYXR0ZXIsIGEgbmV3IEltYWdlIGluc3RhbmNlIHdpdGggdGhlIFVSTCBhcyBpdHMgc3JjIHdpbGwgYmUgdXNlZC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQml0bWFwIGV4dGVuZHMgRGlzcGxheU9iamVjdCB7XG5cblx0Y29uc3RydWN0b3IgKGltYWdlT3JVcmkpIHtcblx0XHRzdXBlcigpO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHNvdXJjZSBpbWFnZSB0byBkaXNwbGF5LiBUaGlzIGNhbiBiZSBhIENhbnZhc0ltYWdlU291cmNlXG5cdFx0ICogKGltYWdlLCB2aWRlbywgY2FudmFzKSwgYW4gb2JqZWN0IHdpdGggYSBgZ2V0SW1hZ2VgIG1ldGhvZCB0aGF0IHJldHVybnMgYSBDYW52YXNJbWFnZVNvdXJjZSwgb3IgYSBzdHJpbmcgVVJMIHRvIGFuIGltYWdlLlxuXHRcdCAqIElmIHRoZSBsYXR0ZXIsIGEgbmV3IEltYWdlIGluc3RhbmNlIHdpdGggdGhlIFVSTCBhcyBpdHMgc3JjIHdpbGwgYmUgdXNlZC5cblx0XHQgKiBAcHJvcGVydHkgaW1hZ2Vcblx0XHQgKiBAdHlwZSB7Q2FudmFzSW1hZ2VTb3VyY2UgfCBPYmplY3R9XG5cdFx0ICovXG5cdFx0aWYgKHR5cGVvZiBpbWFnZU9yVXJpID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHR0aGlzLmltYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcblx0XHRcdHRoaXMuaW1hZ2Uuc3JjID0gaW1hZ2VPclVyaTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5pbWFnZSA9IGltYWdlT3JVcmk7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogU3BlY2lmaWVzIGFuIGFyZWEgb2YgdGhlIHNvdXJjZSBpbWFnZSB0byBkcmF3LiBJZiBvbWl0dGVkLCB0aGUgd2hvbGUgaW1hZ2Ugd2lsbCBiZSBkcmF3bi5cblx0XHQgKiBOb3RlIHRoYXQgdmlkZW8gc291cmNlcyBtdXN0IGhhdmUgYSB3aWR0aCAvIGhlaWdodCBzZXQgdG8gd29yayBjb3JyZWN0bHkgd2l0aCBgc291cmNlUmVjdGAuXG5cdFx0ICogQHR5cGUge2Vhc2VsanMuUmVjdGFuZ2xlfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLnNvdXJjZVJlY3QgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogU2V0IGFzIGNvbXBhdGlibGUgd2l0aCBXZWJHTC5cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKi9cblx0XHR0aGlzLl93ZWJHTFJlbmRlclN0eWxlID0gRGlzcGxheU9iamVjdC5fU3RhZ2VHTF9CSVRNQVA7XG5cdH1cblxuXHRpc1Zpc2libGUgKCkge1xuXHRcdGxldCBpbWFnZSA9IHRoaXMuaW1hZ2U7XG5cdFx0bGV0IGhhc0NvbnRlbnQgPSB0aGlzLmNhY2hlQ2FudmFzIHx8IChpbWFnZSAmJiAoaW1hZ2UubmF0dXJhbFdpZHRoIHx8IGltYWdlLmdldENvbnRleHQgfHwgaW1hZ2UucmVhZHlTdGF0ZSA+PSAyKSk7XG5cdFx0cmV0dXJuICEhKHRoaXMudmlzaWJsZSAmJiB0aGlzLmFscGhhID4gMCAmJiB0aGlzLnNjYWxlWCAhPSAwICYmIHRoaXMuc2NhbGVZICE9IDAgJiYgaGFzQ29udGVudCk7XG5cdH1cblxuXHRkcmF3IChjdHgsIGlnbm9yZUNhY2hlID0gZmFsc2UpIHtcblx0XHRpZiAoc3VwZXIuZHJhdyhjdHgsIGlnbm9yZUNhY2hlKSkgeyByZXR1cm4gdHJ1ZTsgfVxuXHRcdGxldCBpbWcgPSB0aGlzLmltYWdlLCByZWN0ID0gdGhpcy5zb3VyY2VSZWN0O1xuXHRcdGlmIChpbWcgaW5zdGFuY2VvZiBWaWRlb0J1ZmZlcikgeyBpbWcgPSBpbWcuZ2V0SW1hZ2UoKTsgfVxuXHRcdGlmIChpbWcgPT0gbnVsbCkgeyByZXR1cm4gdHJ1ZTsgfVxuXHRcdGlmIChyZWN0KSB7XG5cdFx0XHQvLyBzb21lIGJyb3dzZXJzIGNob2tlIG9uIG91dCBvZiBib3VuZCB2YWx1ZXMsIHNvIHdlJ2xsIGZpeCB0aGVtOlxuXHRcdFx0bGV0IHgxID0gcmVjdC54LCB5MSA9IHJlY3QueSwgeDIgPSB4MSArIHJlY3Qud2lkdGgsIHkyID0geTEgKyByZWN0LmhlaWdodCwgeCA9IDAsIHkgPSAwLCB3ID0gaW1nLndpZHRoLCBoID0gaW1nLmhlaWdodDtcblx0XHRcdGlmICh4MSA8IDApIHsgeCAtPSB4MTsgeDEgPSAwOyB9XG5cdFx0XHRpZiAoeDIgPiB3KSB7IHgyID0gdzsgfVxuXHRcdFx0aWYgKHkxIDwgMCkgeyB5IC09IHkxOyB5MSA9IDA7IH1cblx0XHRcdGlmICh5MiA+IGgpIHsgeTIgPSBoOyB9XG5cdFx0XHRjdHguZHJhd0ltYWdlKGltZywgeDEsIHkxLCB4Mi14MSwgeTIteTEsIHgsIHksIHgyLXgxLCB5Mi15MSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGN0eC5kcmF3SW1hZ2UoaW1nLCAwLCAwKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvLyBOb3RlLCB0aGUgZG9jIHNlY3Rpb25zIGJlbG93IGRvY3VtZW50IHVzaW5nIHRoZSBzcGVjaWZpZWQgQVBJcyAoZnJvbSBEaXNwbGF5T2JqZWN0KSBmcm9tXG5cdC8vIEJpdG1hcC4gVGhpcyBpcyB3aHkgdGhleSBoYXZlIG5vIG1ldGhvZCBpbXBsZW1lbnRhdGlvbnMuXG5cblx0LyoqXG5cdCAqIEJlY2F1c2UgdGhlIGNvbnRlbnQgb2YgYSBCaXRtYXAgaXMgYWxyZWFkeSBpbiBhIHNpbXBsZSBmb3JtYXQsIGNhY2hlIGlzIHVubmVjZXNzYXJ5IGZvciBCaXRtYXAgaW5zdGFuY2VzLlxuXHQgKiBZb3Ugc2hvdWxkIDxiPm5vdDwvYj4gY2FjaGUgQml0bWFwIGluc3RhbmNlcyBhcyBpdCBjYW4gZGVncmFkZSBwZXJmb3JtYW5jZS5cblx0ICpcblx0ICogPHN0cm9uZz5Ib3dldmVyOiBJZiB5b3Ugd2FudCB0byB1c2UgYSBmaWx0ZXIgb24gYSBCaXRtYXAsIHlvdSA8ZW0+TVVTVDwvZW0+IGNhY2hlIGl0LCBvciBpdCB3aWxsIG5vdCB3b3JrLjwvc3Ryb25nPlxuXHQgKiBUbyBzZWUgdGhlIEFQSSBmb3IgY2FjaGluZywgcGxlYXNlIHZpc2l0IHRoZSB7QGxpbmsgZWFzZWxqcy5EaXNwbGF5T2JqZWN0I2NhY2hlfSBtZXRob2QuXG5cdCAqXG5cdCAqIEBhbGlhcyBlYXNlbGpzLkJpdG1hcCNjYWNoZVxuXHQgKi9cblxuXHQvKipcblx0ICogQmVjYXVzZSB0aGUgY29udGVudCBvZiBhIEJpdG1hcCBpcyBhbHJlYWR5IGluIGEgc2ltcGxlIGZvcm1hdCwgY2FjaGUgaXMgdW5uZWNlc3NhcnkgZm9yIEJpdG1hcCBpbnN0YW5jZXMuXG5cdCAqIFlvdSBzaG91bGQgPGI+bm90PC9iPiBjYWNoZSBCaXRtYXAgaW5zdGFuY2VzIGFzIGl0IGNhbiBkZWdyYWRlIHBlcmZvcm1hbmNlLlxuXHQgKlxuXHQgKiA8c3Ryb25nPkhvd2V2ZXI6IElmIHlvdSB3YW50IHRvIHVzZSBhIGZpbHRlciBvbiBhIEJpdG1hcCwgeW91IDxlbT5NVVNUPC9lbT4gY2FjaGUgaXQsIG9yIGl0IHdpbGwgbm90IHdvcmsuPC9zdHJvbmc+XG5cdCAqIFRvIHNlZSB0aGUgQVBJIGZvciBjYWNoaW5nLCBwbGVhc2UgdmlzaXQgdGhlIHtAbGluayBlYXNlbGpzLkRpc3BsYXlPYmplY3QjY2FjaGV9IG1ldGhvZC5cblx0ICpcblx0ICogQGFsaWFzIGVhc2VsanMuQml0bWFwI3VwZGF0ZUNhY2hlXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBCZWNhdXNlIHRoZSBjb250ZW50IG9mIGEgQml0bWFwIGlzIGFscmVhZHkgaW4gYSBzaW1wbGUgZm9ybWF0LCBjYWNoZSBpcyB1bm5lY2Vzc2FyeSBmb3IgQml0bWFwIGluc3RhbmNlcy5cblx0ICogWW91IHNob3VsZCA8Yj5ub3Q8L2I+IGNhY2hlIEJpdG1hcCBpbnN0YW5jZXMgYXMgaXQgY2FuIGRlZ3JhZGUgcGVyZm9ybWFuY2UuXG5cdCAqXG5cdCAqIDxzdHJvbmc+SG93ZXZlcjogSWYgeW91IHdhbnQgdG8gdXNlIGEgZmlsdGVyIG9uIGEgQml0bWFwLCB5b3UgPGVtPk1VU1Q8L2VtPiBjYWNoZSBpdCwgb3IgaXQgd2lsbCBub3Qgd29yay48L3N0cm9uZz5cblx0ICogVG8gc2VlIHRoZSBBUEkgZm9yIGNhY2hpbmcsIHBsZWFzZSB2aXNpdCB0aGUge0BsaW5rIGVhc2VsanMuRGlzcGxheU9iamVjdCNjYWNoZX0gbWV0aG9kLlxuXHQgKlxuXHQgKiBAYWxpYXMgZWFzZWxqcy5CaXRtYXAjdW5jYWNoZVxuXHQgKi9cblxuXHRnZXRCb3VuZHMgKCkge1xuXHRcdGxldCByZWN0ID0gc3VwZXIuZ2V0Qm91bmRzKCk7XG5cdFx0aWYgKHJlY3QpIHsgcmV0dXJuIHJlY3Q7IH1cblx0XHRsZXQgaW1hZ2UgPSB0aGlzLmltYWdlLCBvID0gdGhpcy5zb3VyY2VSZWN0IHx8IGltYWdlO1xuXHRcdGxldCBoYXNDb250ZW50ID0gKGltYWdlICYmIChpbWFnZS5uYXR1cmFsV2lkdGggfHwgaW1hZ2UuZ2V0Q29udGV4dCB8fCBpbWFnZS5yZWFkeVN0YXRlID49IDIpKTtcblx0XHRyZXR1cm4gaGFzQ29udGVudCA/IHRoaXMuX3JlY3RhbmdsZS5zZXRWYWx1ZXMoMCwgMCwgby53aWR0aCwgby5oZWlnaHQpIDogbnVsbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIEJpdG1hcCBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbbm9kZV0gV2hldGhlciB0aGUgdW5kZXJseWluZyBET00gZWxlbWVudCBzaG91bGQgYmUgY2xvbmVkIGFzIHdlbGwuXG5cdCAqIEByZXR1cm4ge2Vhc2VsanMuQml0bWFwfSBBIGNsb25lIG9mIHRoZSBCaXRtYXAgaW5zdGFuY2UuXG5cdCAqL1xuXHRjbG9uZSAobm9kZSkge1xuXHRcdGxldCBpbWcgPSB0aGlzLmltYWdlO1xuXHRcdGlmIChpbWcgIT0gbnVsbCAmJiBub2RlICE9IG51bGwpIHsgaW1nID0gaW1nLmNsb25lTm9kZSgpOyB9XG5cdFx0bGV0IGJtcCA9IG5ldyBCaXRtYXAoaW1nKTtcblx0XHRpZiAodGhpcy5zb3VyY2VSZWN0KSB7IGJtcC5zb3VyY2VSZWN0ID0gdGhpcy5zb3VyY2VSZWN0LmNsb25lKCk7IH1cblx0XHR0aGlzLl9jbG9uZVByb3BzKGJtcCk7XG5cdFx0cmV0dXJuIGJtcDtcblx0fVxuXG59XG4iLCIvKipcbiAqIEBsaWNlbnNlIFNwcml0ZVxuICogVmlzaXQgaHR0cDovL2NyZWF0ZWpzLmNvbS8gZm9yIGRvY3VtZW50YXRpb24sIHVwZGF0ZXMgYW5kIGV4YW1wbGVzLlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNyBnc2tpbm5lci5jb20sIGluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICogb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cbiAqIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxuICogcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsXG4gKiBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4gKiBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuICogY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAqIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xuICogT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAqIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4gKiBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcbiAqIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuICogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUlxuICogT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICovXG5cbmltcG9ydCBEaXNwbGF5T2JqZWN0IGZyb20gXCIuL0Rpc3BsYXlPYmplY3RcIjtcbmltcG9ydCB7IEV2ZW50IH0gZnJvbSBcIkBjcmVhdGVqcy9jb3JlXCI7XG5cbi8qKlxuICogRGlzcGxheXMgYSBmcmFtZSBvciBzZXF1ZW5jZSBvZiBmcmFtZXMgKGllLiBhbiBhbmltYXRpb24pIGZyb20gYSBTcHJpdGVTaGVldCBpbnN0YW5jZS4gQSBzcHJpdGUgc2hlZXQgaXMgYSBzZXJpZXMgb2ZcbiAqIGltYWdlcyAodXN1YWxseSBhbmltYXRpb24gZnJhbWVzKSBjb21iaW5lZCBpbnRvIGEgc2luZ2xlIGltYWdlLiBGb3IgZXhhbXBsZSwgYW4gYW5pbWF0aW9uIGNvbnNpc3Rpbmcgb2YgOCAxMDB4MTAwXG4gKiBpbWFnZXMgY291bGQgYmUgY29tYmluZWQgaW50byBhIDQwMHgyMDAgc3ByaXRlIHNoZWV0ICg0IGZyYW1lcyBhY3Jvc3MgYnkgMiBoaWdoKS4gWW91IGNhbiBkaXNwbGF5IGluZGl2aWR1YWwgZnJhbWVzLFxuICogcGxheSBmcmFtZXMgYXMgYW4gYW5pbWF0aW9uLCBhbmQgZXZlbiBzZXF1ZW5jZSBhbmltYXRpb25zIHRvZ2V0aGVyLlxuICpcbiAqIEBtZW1iZXJvZiBlYXNlbGpzXG4gKiBAZXh0ZW5kcyBlYXNlbGpzLkRpc3BsYXlPYmplY3RcbiAqIEBleGFtcGxlXG4gKiBsZXQgc3ByaXRlID0gbmV3IFNwcml0ZShzcHJpdGVTaGVldCk7XG4gKiBzcHJpdGUuZ290b0FuZFN0b3AoXCJmcmFtZU5hbWVcIik7XG4gKlxuICogVW50aWwge0BsaW5rIGVhc2VsanMuU3ByaXRlI2dvdG9BbmRTdG9wfSBvciB7QGxpbmsgZWFzZWxqcy5TcHJpdGUjZ290b0FuZFBsYXl9IGlzIGNhbGxlZCxcbiAqIG9ubHkgdGhlIGZpcnN0IGRlZmluZWQgZnJhbWUgZGVmaW5lZCBpbiB0aGUgc3ByaXRlIHNoZWV0IHdpbGwgYmUgZGlzcGxheWVkLlxuICpcbiAqIEBzZWUge0BsaW5rIGVhc2VsanMuU3ByaXRlU2hlZXQgXCJNb3JlIGluZm9ybWF0aW9uIG9uIHNldHRpbmcgdXAgZnJhbWVzIGFuZCBhbmltYXRpb25zLlwifVxuICogQHBhcmFtIHtTcHJpdGVTaGVldH0gc3ByaXRlU2hlZXQgVGhlIFNwcml0ZVNoZWV0IGluc3RhbmNlIHRvIHBsYXkgYmFjay4gVGhpcyBpbmNsdWRlcyB0aGUgc291cmNlIGltYWdlKHMpLCBmcmFtZVxuICogZGltZW5zaW9ucywgYW5kIGZyYW1lIGRhdGEuXG4gKiBAcGFyYW0ge1N0cmluZyB8IE51bWJlcn0gW2ZyYW1lT3JBbmltYXRpb25dIFRoZSBmcmFtZSBudW1iZXIgb3IgYW5pbWF0aW9uIHRvIHBsYXkgaW5pdGlhbGx5LlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTcHJpdGUgZXh0ZW5kcyBEaXNwbGF5T2JqZWN0IHtcblxuXHRjb25zdHJ1Y3RvciAoc3ByaXRlU2hlZXQsIGZyYW1lT3JBbmltYXRpb24pIHtcblx0XHRzdXBlcigpO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGZyYW1lIGluZGV4IHRoYXQgd2lsbCBiZSBkcmF3biB3aGVuIGRyYXcgaXMgY2FsbGVkLiBOb3RlIHRoYXQgd2l0aCBzb21lIHtAbGluayBlYXNlbGpzLlNwcml0ZVNoZWV0fVxuXHRcdCAqIGRlZmluaXRpb25zLCB0aGlzIHdpbGwgYWR2YW5jZSBub24tc2VxdWVudGlhbGx5LiBUaGlzIHdpbGwgYWx3YXlzIGJlIGFuIGludGVnZXIgdmFsdWUuXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICovXG5cdFx0dGhpcy5jdXJyZW50RnJhbWUgPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyB0aGUgbmFtZSBvZiB0aGUgY3VycmVudGx5IHBsYXlpbmcgYW5pbWF0aW9uLlxuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICovXG5cdFx0dGhpcy5jdXJyZW50QW5pbWF0aW9uID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIFByZXZlbnRzIHRoZSBhbmltYXRpb24gZnJvbSBhZHZhbmNpbmcgZWFjaCB0aWNrIGF1dG9tYXRpY2FsbHkuIEZvciBleGFtcGxlLCB5b3UgY291bGQgY3JlYXRlIGEgc3ByaXRlXG5cdFx0ICogc2hlZXQgb2YgaWNvbnMsIHNldCBwYXVzZWQgdG8gdHJ1ZSwgYW5kIGRpc3BsYXkgdGhlIGFwcHJvcHJpYXRlIGljb24gYnkgc2V0dGluZyBgY3VycmVudEZyYW1lYC5cblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0dGhpcy5wYXVzZWQgPSB0cnVlO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIFNwcml0ZVNoZWV0IGluc3RhbmNlIHRvIHBsYXkgYmFjay4gVGhpcyBpbmNsdWRlcyB0aGUgc291cmNlIGltYWdlLCBmcmFtZSBkaW1lbnNpb25zLCBhbmQgZnJhbWUgZGF0YS5cblx0XHQgKiBAdHlwZSB7ZWFzZWxqcy5TcHJpdGVTaGVldH1cblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKi9cblx0XHR0aGlzLnNwcml0ZVNoZWV0ID0gc3ByaXRlU2hlZXQ7XG5cblx0XHQvKipcblx0XHQgKiBTcGVjaWZpZXMgdGhlIGN1cnJlbnQgZnJhbWUgaW5kZXggd2l0aGluIHRoZSBjdXJyZW50bHkgcGxheWluZyBhbmltYXRpb24uIFdoZW4gcGxheWluZyBub3JtYWxseSwgdGhpcyB3aWxsIGluY3JlYXNlXG5cdFx0ICogZnJvbSAwIHRvIG4tMSwgd2hlcmUgbiBpcyB0aGUgbnVtYmVyIG9mIGZyYW1lcyBpbiB0aGUgY3VycmVudCBhbmltYXRpb24uXG5cdFx0ICogVGhpcyBjb3VsZCBiZSBhIG5vbi1pbnRlZ2VyIHZhbHVlIGlmIHVzaW5nIHRpbWUtYmFzZWQgcGxheWJhY2ssIG9yIGlmIHRoZSBhbmltYXRpb24ncyBzcGVlZCBpcyBub3QgYW4gaW50ZWdlci5cblx0XHQgKiBAc2VlIHtAbGluayBlYXNlbGpzLlNwcml0ZSNmcmFtZXJhdGV9XG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0dGhpcy5jdXJyZW50QW5pbWF0aW9uRnJhbWUgPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogQnkgZGVmYXVsdCBTcHJpdGUgaW5zdGFuY2VzIGFkdmFuY2Ugb25lIGZyYW1lIHBlciB0aWNrLiBTcGVjaWZ5aW5nIGEgZnJhbWVyYXRlIGZvciB0aGUgU3ByaXRlIChvciBpdHMgcmVsYXRlZFxuXHRcdCAqIFNwcml0ZVNoZWV0KSB3aWxsIGNhdXNlIGl0IHRvIGFkdmFuY2UgYmFzZWQgb24gZWxhcHNlZCB0aW1lIGJldHdlZW4gdGlja3MgYXMgYXBwcm9wcmlhdGUgdG8gbWFpbnRhaW4gdGhlIHRhcmdldFxuXHRcdCAqIGZyYW1lcmF0ZS5cblx0XHQgKlxuXHRcdCAqIEZvciBleGFtcGxlLCBpZiBhIFNwcml0ZSB3aXRoIGEgZnJhbWVyYXRlIG9mIDEwIGlzIHBsYWNlZCBvbiBhIFN0YWdlIGJlaW5nIHVwZGF0ZWQgYXQgNDBmcHMsIHRoZW4gdGhlIFNwcml0ZSB3aWxsXG5cdFx0ICogYWR2YW5jZSByb3VnaGx5IG9uZSBmcmFtZSBldmVyeSA0IHRpY2tzLiBUaGlzIHdpbGwgbm90IGJlIGV4YWN0LCBiZWNhdXNlIHRoZSB0aW1lIGJldHdlZW4gZWFjaCB0aWNrIHdpbGxcblx0XHQgKiB2YXJ5IHNsaWdodGx5IGJldHdlZW4gZnJhbWVzLlxuXHRcdCAqXG5cdFx0ICogVGhpcyBmZWF0dXJlIGlzIGRlcGVuZGVudCBvbiB0aGUgdGljayBldmVudCBvYmplY3QgKG9yIGFuIG9iamVjdCB3aXRoIGFuIGFwcHJvcHJpYXRlIFwiZGVsdGFcIiBwcm9wZXJ0eSkgYmVpbmdcblx0XHQgKiBwYXNzZWQgaW50byB7QGxpbmsgZWFzZWxqcy5TdGFnZSN1cGRhdGV9LlxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqL1xuXHRcdHRoaXMuZnJhbWVyYXRlID0gMDtcblxuXHRcdC8qKlxuXHRcdCAqIEN1cnJlbnQgYW5pbWF0aW9uIG9iamVjdC5cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5fYW5pbWF0aW9uID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEN1cnJlbnQgZnJhbWUgaW5kZXguXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuX2N1cnJlbnRGcmFtZSA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBTa2lwcyB0aGUgbmV4dCBhdXRvIGFkdmFuY2UuIFVzZWQgYnkgZ290b0FuZFBsYXkgdG8gYXZvaWQgaW1tZWRpYXRlbHkganVtcGluZyB0byB0aGUgbmV4dCBmcmFtZVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqL1xuXHRcdHRoaXMuX3NraXBBZHZhbmNlID0gZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBTZXQgYXMgY29tcGF0aWJsZSB3aXRoIFdlYkdMLlxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDFcblx0XHQgKi9cblx0XHR0aGlzLl93ZWJHTFJlbmRlclN0eWxlID0gRGlzcGxheU9iamVjdC5fU3RhZ2VHTF9TUFJJVEU7XG5cblx0XHRpZiAoZnJhbWVPckFuaW1hdGlvbiAhPSBudWxsKSB7XG5cdFx0XHR0aGlzLmdvdG9BbmRQbGF5KGZyYW1lT3JBbmltYXRpb24pO1xuXHRcdH1cblx0fVxuXG5cdGlzVmlzaWJsZSAoKSB7XG5cdFx0bGV0IGhhc0NvbnRlbnQgPSB0aGlzLmNhY2hlQ2FudmFzIHx8IHRoaXMuc3ByaXRlU2hlZXQuY29tcGxldGU7XG5cdFx0cmV0dXJuICEhKHRoaXMudmlzaWJsZSAmJiB0aGlzLmFscGhhID4gMCAmJiB0aGlzLnNjYWxlWCAhPSAwICYmIHRoaXMuc2NhbGVZICE9IDAgJiYgaGFzQ29udGVudCk7XG5cdH1cblxuXHRkcmF3IChjdHgsIGlnbm9yZUNhY2hlKSB7XG5cdFx0aWYgKHN1cGVyLmRyYXcoY3R4LCBpZ25vcmVDYWNoZSkpIHsgcmV0dXJuIHRydWU7IH1cblx0XHR0aGlzLl9ub3JtYWxpemVGcmFtZSgpO1xuXHRcdGxldCBvID0gdGhpcy5zcHJpdGVTaGVldC5nZXRGcmFtZSh0aGlzLl9jdXJyZW50RnJhbWV8MCk7XG5cdFx0aWYgKCFvKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdGxldCByZWN0ID0gby5yZWN0O1xuXHRcdGlmIChyZWN0LndpZHRoICYmIHJlY3QuaGVpZ2h0KSB7IGN0eC5kcmF3SW1hZ2Uoby5pbWFnZSwgcmVjdC54LCByZWN0LnksIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0LCAtby5yZWdYLCAtby5yZWdZLCByZWN0LndpZHRoLCByZWN0LmhlaWdodCk7IH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8vIE5vdGUsIHRoZSBkb2Mgc2VjdGlvbnMgYmVsb3cgZG9jdW1lbnQgdXNpbmcgdGhlIHNwZWNpZmllZCBBUElzIChmcm9tIERpc3BsYXlPYmplY3QpIGZyb21cblx0Ly8gQml0bWFwLiBUaGlzIGlzIHdoeSB0aGV5IGhhdmUgbm8gbWV0aG9kIGltcGxlbWVudGF0aW9ucy5cblxuXHQvKipcblx0ICogQmVjYXVzZSB0aGUgY29udGVudCBvZiBhIFNwcml0ZSBpcyBhbHJlYWR5IGluIGEgcmFzdGVyIGZvcm1hdCwgY2FjaGUgaXMgdW5uZWNlc3NhcnkgZm9yIFNwcml0ZSBpbnN0YW5jZXMuXG5cdCAqIFlvdSBzaG91bGQgbm90IGNhY2hlIFNwcml0ZSBpbnN0YW5jZXMgYXMgaXQgY2FuIGRlZ3JhZGUgcGVyZm9ybWFuY2UuXG5cdCAqIEBuYW1lIGVhc2VsanMuU3ByaXRlI2NhY2hlXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBCZWNhdXNlIHRoZSBjb250ZW50IG9mIGEgU3ByaXRlIGlzIGFscmVhZHkgaW4gYSByYXN0ZXIgZm9ybWF0LCBjYWNoZSBpcyB1bm5lY2Vzc2FyeSBmb3IgU3ByaXRlIGluc3RhbmNlcy5cblx0ICogWW91IHNob3VsZCBub3QgY2FjaGUgU3ByaXRlIGluc3RhbmNlcyBhcyBpdCBjYW4gZGVncmFkZSBwZXJmb3JtYW5jZS5cblx0ICogQG5hbWUgZWFzZWxqcy5TcHJpdGUjdXBkYXRlQ2FjaGVcblx0ICovXG5cblx0LyoqXG5cdCAqIEJlY2F1c2UgdGhlIGNvbnRlbnQgb2YgYSBTcHJpdGUgaXMgYWxyZWFkeSBpbiBhIHJhc3RlciBmb3JtYXQsIGNhY2hlIGlzIHVubmVjZXNzYXJ5IGZvciBTcHJpdGUgaW5zdGFuY2VzLlxuXHQgKiBZb3Ugc2hvdWxkIG5vdCBjYWNoZSBTcHJpdGUgaW5zdGFuY2VzIGFzIGl0IGNhbiBkZWdyYWRlIHBlcmZvcm1hbmNlLlxuXHQgKiBAbmFtZSBlYXNlbGpzLlNwcml0ZSN1bmNhY2hlXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBQbGF5ICh1bnBhdXNlKSB0aGUgY3VycmVudCBhbmltYXRpb24uIFRoZSBTcHJpdGUgd2lsbCBiZSBwYXVzZWQgaWYgZWl0aGVyIHtAbGluayBlYXNlbGpzLlNwcml0ZSNzdG9wfVxuXHQgKiBvciB7QGxpbmsgZWFzZWxqcy5TcHJpdGUjZ290b0FuZFN0b3B9IGlzIGNhbGxlZC4gU2luZ2xlIGZyYW1lIGFuaW1hdGlvbnMgd2lsbCByZW1haW4gdW5jaGFuZ2VkLlxuXHQgKi9cblx0cGxheSAoKSB7XG5cdFx0dGhpcy5wYXVzZWQgPSBmYWxzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTdG9wIHBsYXlpbmcgYSBydW5uaW5nIGFuaW1hdGlvbi4gVGhlIFNwcml0ZSB3aWxsIGJlIHBsYXlpbmcgaWYge0BsaW5rIGVhc2VsanMuU3ByaXRlI2dvdG9BbmRQbGF5fSBpcyBjYWxsZWQuXG5cdCAqIE5vdGUgdGhhdCBjYWxsaW5nIGBnb3RvQW5kUGxheSgpYCBvciB7QGxpbmsgZWFzZWxqcy5TcHJpdGUjcGxheX0gd2lsbCByZXN1bWUgcGxheWJhY2suXG5cdCAqL1xuXHRzdG9wICgpIHtcblx0XHR0aGlzLnBhdXNlZCA9IHRydWU7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyBwYXVzZWQgdG8gZmFsc2UgYW5kIHBsYXlzIHRoZSBzcGVjaWZpZWQgYW5pbWF0aW9uIG5hbWUsIG5hbWVkIGZyYW1lLCBvciBmcmFtZSBudW1iZXIuXG5cdCAqIEBwYXJhbSB7U3RyaW5nIHwgTnVtYmVyfSBmcmFtZU9yQW5pbWF0aW9uIFRoZSBmcmFtZSBudW1iZXIgb3IgYW5pbWF0aW9uIG5hbWUgdGhhdCB0aGUgcGxheWhlYWQgc2hvdWxkIG1vdmUgdG9cblx0ICogYW5kIGJlZ2luIHBsYXlpbmcuXG5cdCAqL1xuXHRnb3RvQW5kUGxheSAoZnJhbWVPckFuaW1hdGlvbikge1xuXHRcdHRoaXMucGF1c2VkID0gZmFsc2U7XG5cdFx0dGhpcy5fc2tpcEFkdmFuY2UgPSB0cnVlO1xuXHRcdHRoaXMuX2dvdG8oZnJhbWVPckFuaW1hdGlvbik7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyBwYXVzZWQgdG8gdHJ1ZSBhbmQgc2Vla3MgdG8gdGhlIHNwZWNpZmllZCBhbmltYXRpb24gbmFtZSwgbmFtZWQgZnJhbWUsIG9yIGZyYW1lIG51bWJlci5cblx0ICogQHBhcmFtIHtTdHJpbmcgfCBOdW1iZXJ9IGZyYW1lT3JBbmltYXRpb24gVGhlIGZyYW1lIG51bWJlciBvciBhbmltYXRpb24gbmFtZSB0aGF0IHRoZSBwbGF5aGVhZCBzaG91bGQgbW92ZSB0b1xuXHQgKiBhbmQgc3RvcC5cblx0ICovXG5cdGdvdG9BbmRTdG9wIChmcmFtZU9yQW5pbWF0aW9uKSB7XG5cdFx0dGhpcy5wYXVzZWQgPSB0cnVlO1xuXHRcdHRoaXMuX2dvdG8oZnJhbWVPckFuaW1hdGlvbik7XG5cdH1cblxuXHQvKipcblx0ICogQWR2YW5jZXMgdGhlIHBsYXloZWFkLiBUaGlzIG9jY3VycyBhdXRvbWF0aWNhbGx5IGVhY2ggdGljayBieSBkZWZhdWx0LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3RpbWVdIFRoZSBhbW91bnQgb2YgdGltZSBpbiBtcyB0byBhZHZhbmNlIGJ5LiBPbmx5IGFwcGxpY2FibGUgaWYgZnJhbWVyYXRlIGlzIHNldCBvbiB0aGUgU3ByaXRlXG5cdCAqIG9yIGl0cyBTcHJpdGVTaGVldC5cblx0Ki9cblx0YWR2YW5jZSAodGltZSkge1xuXHRcdGxldCBmcHMgPSB0aGlzLmZyYW1lcmF0ZSB8fCB0aGlzLnNwcml0ZVNoZWV0LmZyYW1lcmF0ZTtcblx0XHRsZXQgdCA9IChmcHMgJiYgdGltZSAhPSBudWxsKSA/IHRpbWUvKDEwMDAvZnBzKSA6IDE7XG5cdFx0dGhpcy5fbm9ybWFsaXplRnJhbWUodCk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIHtAbGluayBlYXNlbGpzLlJlY3RhbmdsZX0gaW5zdGFuY2UgZGVmaW5pbmcgdGhlIGJvdW5kcyBvZiB0aGUgY3VycmVudCBmcmFtZSByZWxhdGl2ZSB0b1xuXHQgKiB0aGUgb3JpZ2luLiBGb3IgZXhhbXBsZSwgYSA5MCB4IDcwIGZyYW1lIHdpdGggYHJlZ1g9NTBgIGFuZCBgcmVnWT00MGAgd291bGQgcmV0dXJuIGFcblx0ICogcmVjdGFuZ2xlIHdpdGggW3g9LTUwLCB5PS00MCwgd2lkdGg9OTAsIGhlaWdodD03MF0uIFRoaXMgaWdub3JlcyB0cmFuc2Zvcm1hdGlvbnMgb24gdGhlIGRpc3BsYXkgb2JqZWN0LlxuXHQgKlxuXHQgKiBAc2VlIHtAbGluayBlYXNlbGpzLlNwcml0ZVNoZWV0I2ZyYW1lQm91bmRzfVxuXHQgKiBAcmV0dXJuIHtlYXNlbGpzLlJlY3RhbmdsZX0gQSBSZWN0YW5nbGUgaW5zdGFuY2UuIFJldHVybnMgbnVsbCBpZiB0aGUgZnJhbWUgZG9lcyBub3QgZXhpc3QsIG9yIHRoZSBpbWFnZSBpcyBub3QgZnVsbHkgbG9hZGVkLlxuXHQgKi9cblx0Z2V0Qm91bmRzICgpIHtcblx0XHQvLyBUT0RPOiBzaG91bGQgdGhpcyBub3JtYWxpemVGcmFtZT9cblx0XHRyZXR1cm4gc3VwZXIuZ2V0Qm91bmRzKCkgfHwgdGhpcy5zcHJpdGVTaGVldC5nZXRGcmFtZUJvdW5kcyh0aGlzLmN1cnJlbnRGcmFtZSwgdGhpcy5fcmVjdGFuZ2xlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIFNwcml0ZSBpbnN0YW5jZS4gTm90ZSB0aGF0IHRoZSBzYW1lIFNwcml0ZVNoZWV0IGlzIHNoYXJlZCBiZXR3ZWVuIGNsb25lZCBpbnN0YW5jZXMuXG5cdCAqIEByZXR1cm4ge2Vhc2VsanMuU3ByaXRlfSBhIGNsb25lIG9mIHRoZSBTcHJpdGUgaW5zdGFuY2UuXG5cdCAqL1xuXHRjbG9uZSAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2Nsb25lUHJvcHMobmV3IFNwcml0ZSh0aGlzLnNwcml0ZVNoZWV0KSk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtlYXNlbGpzLlNwcml0ZX0gb1xuXHQgKiBAcmV0dXJuIHtlYXNlbGpzLlNwcml0ZX0gb1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRfY2xvbmVQcm9wcyAobykge1xuXHRcdHN1cGVyLl9jbG9uZVByb3BzKG8pO1xuXHRcdG8uY3VycmVudEZyYW1lID0gdGhpcy5jdXJyZW50RnJhbWU7XG5cdFx0by5jdXJyZW50QW5pbWF0aW9uID0gdGhpcy5jdXJyZW50QW5pbWF0aW9uO1xuXHRcdG8ucGF1c2VkID0gdGhpcy5wYXVzZWQ7XG5cdFx0by5jdXJyZW50QW5pbWF0aW9uRnJhbWUgPSB0aGlzLmN1cnJlbnRBbmltYXRpb25GcmFtZTtcblx0XHRvLmZyYW1lcmF0ZSA9IHRoaXMuZnJhbWVyYXRlO1xuXG5cdFx0by5fYW5pbWF0aW9uID0gdGhpcy5fYW5pbWF0aW9uO1xuXHRcdG8uX2N1cnJlbnRGcmFtZSA9IHRoaXMuX2N1cnJlbnRGcmFtZTtcblx0XHRvLl9za2lwQWR2YW5jZSA9IHRoaXMuX3NraXBBZHZhbmNlO1xuXHRcdHJldHVybiBvO1xuXHR9XG5cblx0X3RpY2sgKGV2dE9iaikge1xuXHRcdGlmICghdGhpcy5wYXVzZWQpIHtcblx0XHRcdGlmICghdGhpcy5fc2tpcEFkdmFuY2UpIHsgdGhpcy5hZHZhbmNlKGV2dE9iaiYmZXZ0T2JqLmRlbHRhKTsgfVxuXHRcdFx0dGhpcy5fc2tpcEFkdmFuY2UgPSBmYWxzZTtcblx0XHR9XG5cdFx0c3VwZXIuX3RpY2soZXZ0T2JqKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBOb3JtYWxpemVzIHRoZSBjdXJyZW50IGZyYW1lLCBhZHZhbmNpbmcgYW5pbWF0aW9ucyBhbmQgZGlzcGF0Y2hpbmcgY2FsbGJhY2tzIGFzIGFwcHJvcHJpYXRlLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbZnJhbWVEZWx0YT0wXVxuXHQgKi9cblx0X25vcm1hbGl6ZUZyYW1lIChmcmFtZURlbHRhID0gMCkge1xuXHRcdGxldCBhbmltYXRpb24gPSB0aGlzLl9hbmltYXRpb247XG5cdFx0bGV0IHBhdXNlZCA9IHRoaXMucGF1c2VkO1xuXHRcdGxldCBmcmFtZSA9IHRoaXMuX2N1cnJlbnRGcmFtZTtcblxuXHRcdGlmIChhbmltYXRpb24pIHtcblx0XHRcdGxldCBzcGVlZCA9IGFuaW1hdGlvbi5zcGVlZCB8fCAxO1xuXHRcdFx0bGV0IGFuaW1GcmFtZSA9IHRoaXMuY3VycmVudEFuaW1hdGlvbkZyYW1lO1xuXHRcdFx0bGV0IGwgPSBhbmltYXRpb24uZnJhbWVzLmxlbmd0aDtcblx0XHRcdGlmIChhbmltRnJhbWUgKyBmcmFtZURlbHRhICogc3BlZWQgPj0gbCkge1xuXHRcdFx0XHRsZXQgbmV4dCA9IGFuaW1hdGlvbi5uZXh0O1xuXHRcdFx0XHRpZiAodGhpcy5fZGlzcGF0Y2hBbmltYXRpb25FbmQoYW5pbWF0aW9uLCBmcmFtZSwgcGF1c2VkLCBuZXh0LCBsIC0gMSkpIHtcblx0XHRcdFx0XHQvLyBzb21ldGhpbmcgY2hhbmdlZCBpbiB0aGUgZXZlbnQgc3RhY2ssIHNvIHdlIHNob3VsZG4ndCBtYWtlIGFueSBtb3JlIGNoYW5nZXMgaGVyZS5cblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH0gZWxzZSBpZiAobmV4dCkge1xuXHRcdFx0XHRcdC8vIHNlcXVlbmNlLiBBdXRvbWF0aWNhbGx5IGNhbGxzIF9ub3JtYWxpemVGcmFtZSBhZ2FpbiB3aXRoIHRoZSByZW1haW5pbmcgZnJhbWVzLlxuXHRcdFx0XHRcdHJldHVybiB0aGlzLl9nb3RvKG5leHQsIGZyYW1lRGVsdGEgLSAobCAtIGFuaW1GcmFtZSkgLyBzcGVlZCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gZW5kLlxuXHRcdFx0XHRcdHRoaXMucGF1c2VkID0gdHJ1ZTtcblx0XHRcdFx0XHRhbmltRnJhbWUgPSBhbmltYXRpb24uZnJhbWVzLmxlbmd0aCAtIDE7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGFuaW1GcmFtZSArPSBmcmFtZURlbHRhICogc3BlZWQ7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmN1cnJlbnRBbmltYXRpb25GcmFtZSA9IGFuaW1GcmFtZTtcblx0XHRcdHRoaXMuX2N1cnJlbnRGcmFtZSA9IGFuaW1hdGlvbi5mcmFtZXNbYW5pbUZyYW1lIHwgMF1cblx0XHR9IGVsc2Uge1xuXHRcdFx0ZnJhbWUgPSAodGhpcy5fY3VycmVudEZyYW1lICs9IGZyYW1lRGVsdGEpO1xuXHRcdFx0bGV0IGwgPSB0aGlzLnNwcml0ZVNoZWV0LmdldE51bUZyYW1lcygpO1xuXHRcdFx0aWYgKGZyYW1lID49IGwgJiYgbCA+IDApIHtcblx0XHRcdFx0aWYgKCF0aGlzLl9kaXNwYXRjaEFuaW1hdGlvbkVuZChhbmltYXRpb24sIGZyYW1lLCBwYXVzZWQsIGwgLSAxKSkge1xuXHRcdFx0XHRcdC8vIGxvb3BlZC5cblx0XHRcdFx0XHRpZiAoKHRoaXMuX2N1cnJlbnRGcmFtZSAtPSBsKSA+PSBsKSB7IHJldHVybiB0aGlzLl9ub3JtYWxpemVGcmFtZSgpOyB9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZnJhbWUgPSB0aGlzLl9jdXJyZW50RnJhbWUgfCAwO1xuXHRcdGlmICh0aGlzLmN1cnJlbnRGcmFtZSAhPSBmcmFtZSkge1xuXHRcdFx0dGhpcy5jdXJyZW50RnJhbWUgPSBmcmFtZTtcblx0XHRcdHRoaXMuZGlzcGF0Y2hFdmVudChcImNoYW5nZVwiKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIERpc3BhdGNoZXMgdGhlIFwiYW5pbWF0aW9uZW5kXCIgZXZlbnQuIFJldHVybnMgdHJ1ZSBpZiBhIGhhbmRsZXIgY2hhbmdlZCB0aGUgYW5pbWF0aW9uIChleC4gY2FsbGluZyB7QGxpbmsgZWFzbGVqcy5TcHJpdGUjc3RvcH0sXG5cdCAqIHtAbGluayBlYXNlbGpzLlNwcml0ZSNnb3RvQW5kUGxheX0sIGV0Yy4pXG5cdCAqIEBwYXJhbSBhbmltYXRpb25cblx0ICogQHBhcmFtIGZyYW1lXG5cdCAqIEBwYXJhbSBwYXVzZWRcblx0ICogQHBhcmFtIG5leHRcblx0ICogQHBhcmFtIGVuZFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2Rpc3BhdGNoQW5pbWF0aW9uRW5kIChhbmltYXRpb24sIGZyYW1lLCBwYXVzZWQsIG5leHQsIGVuZCkge1xuXHRcdGxldCBuYW1lID0gYW5pbWF0aW9uID8gYW5pbWF0aW9uLm5hbWUgOiBudWxsO1xuXHRcdGlmICh0aGlzLmhhc0V2ZW50TGlzdGVuZXIoXCJhbmltYXRpb25lbmRcIikpIHtcblx0XHRcdGxldCBldnQgPSBuZXcgRXZlbnQoXCJhbmltYXRpb25lbmRcIik7XG5cdFx0XHRldnQubmFtZSA9IG5hbWU7XG5cdFx0XHRldnQubmV4dCA9IG5leHQ7XG5cdFx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoZXZ0KTtcblx0XHR9XG5cdFx0Ly8gZGlkIHRoZSBhbmltYXRpb24gZ2V0IGNoYW5nZWQgaW4gdGhlIGV2ZW50IHN0YWNrPzpcblx0XHRsZXQgY2hhbmdlZCA9ICh0aGlzLl9hbmltYXRpb24gIT0gYW5pbWF0aW9uIHx8IHRoaXMuX2N1cnJlbnRGcmFtZSAhPSBmcmFtZSk7XG5cdFx0Ly8gaWYgdGhlIGFuaW1hdGlvbiBoYXNuJ3QgY2hhbmdlZCwgYnV0IHRoZSBzcHJpdGUgd2FzIHBhdXNlZCwgdGhlbiB3ZSB3YW50IHRvIHN0aWNrIHRvIHRoZSBsYXN0IGZyYW1lOlxuXHRcdGlmICghY2hhbmdlZCAmJiAhcGF1c2VkICYmIHRoaXMucGF1c2VkKSB7IHRoaXMuY3VycmVudEFuaW1hdGlvbkZyYW1lID0gZW5kOyBjaGFuZ2VkID0gdHJ1ZTsgfVxuXHRcdHJldHVybiBjaGFuZ2VkO1xuXHR9XG5cblx0LyoqXG5cdCAqIE1vdmVzIHRoZSBwbGF5aGVhZCB0byB0aGUgc3BlY2lmaWVkIGZyYW1lIG51bWJlciBvciBhbmltYXRpb24uXG5cdCAqIEBwYXJhbSB7U3RyaW5nIHwgTnVtYmVyfSBmcmFtZU9yQW5pbWF0aW9uIFRoZSBmcmFtZSBudW1iZXIgb3IgYW5pbWF0aW9uIHRoYXQgdGhlIHBsYXloZWFkIHNob3VsZCBtb3ZlIHRvLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2ZyYW1lPTBdIFRoZSBmcmFtZSBvZiB0aGUgYW5pbWF0aW9uIHRvIGdvIHRvLiBEZWZhdWx0cyB0byAwLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRfZ290byAoZnJhbWVPckFuaW1hdGlvbiwgZnJhbWUgPSAwKSB7XG5cdFx0dGhpcy5jdXJyZW50QW5pbWF0aW9uRnJhbWUgPSAwO1xuXHRcdGlmIChpc05hTihmcmFtZU9yQW5pbWF0aW9uKSkge1xuXHRcdFx0bGV0IGRhdGEgPSB0aGlzLnNwcml0ZVNoZWV0LmdldEFuaW1hdGlvbihmcmFtZU9yQW5pbWF0aW9uKTtcblx0XHRcdGlmIChkYXRhKSB7XG5cdFx0XHRcdHRoaXMuX2FuaW1hdGlvbiA9IGRhdGE7XG5cdFx0XHRcdHRoaXMuY3VycmVudEFuaW1hdGlvbiA9IGZyYW1lT3JBbmltYXRpb247XG5cdFx0XHRcdHRoaXMuX25vcm1hbGl6ZUZyYW1lKGZyYW1lKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5jdXJyZW50QW5pbWF0aW9uID0gdGhpcy5fYW5pbWF0aW9uID0gbnVsbDtcblx0XHRcdHRoaXMuX2N1cnJlbnRGcmFtZSA9IGZyYW1lT3JBbmltYXRpb247XG5cdFx0XHR0aGlzLl9ub3JtYWxpemVGcmFtZSgpO1xuXHRcdH1cblx0fVxuXG59XG5cbi8qKlxuICogRGlzcGF0Y2hlZCB3aGVuIGFuIGFuaW1hdGlvbiByZWFjaGVzIGl0cyBlbmRzLlxuICogQGV2ZW50IGVhc2VsanMuU3ByaXRlI2FuaW1hdGlvbmVuZFxuICogQHByb3BlcnR5IHtPYmplY3R9IHRhcmdldCBUaGUgb2JqZWN0IHRoYXQgZGlzcGF0Y2hlZCB0aGUgZXZlbnQuXG4gKiBAcHJvcGVydHkge1N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZS5cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBhbmltYXRpb24gdGhhdCBqdXN0IGVuZGVkLlxuICogQHByb3BlcnR5IHtTdHJpbmd9IG5leHQgVGhlIG5hbWUgb2YgdGhlIG5leHQgYW5pbWF0aW9uIHRoYXQgd2lsbCBiZSBwbGF5ZWQsIG9yIG51bGwuIFRoaXMgd2lsbCBiZSB0aGUgc2FtZSBhcyBuYW1lIGlmIHRoZSBhbmltYXRpb24gaXMgbG9vcGluZy5cbiAqIEBzaW5jZSAwLjYuMFxuICovXG5cbi8qKlxuICogRGlzcGF0Y2hlZCBhbnkgdGltZSB0aGUgY3VycmVudCBmcmFtZSBjaGFuZ2VzLiBGb3IgZXhhbXBsZSwgdGhpcyBjb3VsZCBiZSBkdWUgdG8gYXV0b21hdGljIGFkdmFuY2VtZW50IG9uIGEgdGljayxcbiAqIG9yIGNhbGxpbmcgZ290b0FuZFBsYXkoKSBvciBnb3RvQW5kU3RvcCgpLlxuICogQGV2ZW50IGVhc2VsanMuU3ByaXRlI2NoYW5nZVxuICogQHByb3BlcnR5IHtPYmplY3R9IHRhcmdldCBUaGUgb2JqZWN0IHRoYXQgZGlzcGF0Y2hlZCB0aGUgZXZlbnQuXG4gKiBAcHJvcGVydHkge1N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZS5cbiAqL1xuIiwiLyoqXG4gKiBAbGljZW5zZSBCaXRtYXBUZXh0XG4gKiBWaXNpdCBodHRwOi8vY3JlYXRlanMuY29tLyBmb3IgZG9jdW1lbnRhdGlvbiwgdXBkYXRlcyBhbmQgZXhhbXBsZXMuXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IGdza2lubmVyLmNvbSwgaW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gKiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxuICogZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0XG4gKiByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSxcbiAqIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiAqIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXG4gKiBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gKiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICogRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTXG4gKiBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICogTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcbiAqIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLFxuICogV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4gKiBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SXG4gKiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gKi9cblxuaW1wb3J0IENvbnRhaW5lciBmcm9tIFwiLi9Db250YWluZXJcIjtcbmltcG9ydCBTcHJpdGUgZnJvbSBcIi4vU3ByaXRlXCI7XG5cbi8qKlxuICogRGlzcGxheXMgdGV4dCB1c2luZyBiaXRtYXAgZ2x5cGhzIGRlZmluZWQgaW4gYSBzcHJpdGUgc2hlZXQuIE11bHRpLWxpbmUgdGV4dCBpcyBzdXBwb3J0ZWQgdXNpbmcgbmV3IGxpbmUgY2hhcmFjdGVycyxcbiAqIGJ1dCBhdXRvbWF0aWMgd3JhcHBpbmcgaXMgbm90IHN1cHBvcnRlZC4gU2VlIHRoZSB7QGxpbmsgZWFzZWxqcy5CaXRtYXBUZXh0I3Nwcml0ZVNoZWV0fSBwcm9wZXJ0eSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBkZWZpbmluZyBnbHlwaHMuXG4gKlxuICogPHN0cm9uZz5JbXBvcnRhbnQ6PC9zdHJvbmc+IFdoaWxlIEJpdG1hcFRleHQgZXh0ZW5kcyBDb250YWluZXIsIGl0IGlzIG5vdCBkZXNpZ25lZCB0byBiZSB1c2VkIGFzIG9uZS5cbiAqIEFzIHN1Y2gsIG1ldGhvZHMgbGlrZSBhZGRDaGlsZCBhbmQgcmVtb3ZlQ2hpbGQgYXJlIGRpc2FibGVkLlxuICpcbiAqIEBtZW1iZXJvZiBlYXNlbGpzXG4gKiBAZXh0ZW5kcyBlYXNlbGpzLkNvbnRhaW5lclxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbdGV4dD1cIlwiXSBUaGUgdGV4dCB0byBkaXNwbGF5LlxuICogQHBhcmFtIHtTcHJpdGVTaGVldH0gW3Nwcml0ZVNoZWV0PW51bGxdIFRoZSBzcHJpdGVzaGVldCB0aGF0IGRlZmluZXMgdGhlIGNoYXJhY3RlciBnbHlwaHMuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJpdG1hcFRleHQgZXh0ZW5kcyBDb250YWluZXIge1xuXG5cdGNvbnN0cnVjdG9yICh0ZXh0ID0gXCJcIiwgc3ByaXRlU2hlZXQgPSBudWxsKSB7XG5cdFx0c3VwZXIoKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSB0ZXh0IHRvIGRpc3BsYXkuXG5cdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHQgKiBAZGVmYXVsdCBcIlwiXG5cdFx0ICovXG5cdFx0dGhpcy50ZXh0ID0gdGV4dDtcblxuXHRcdC8qKlxuXHRcdCAqIEEgU3ByaXRlU2hlZXQgaW5zdGFuY2UgdGhhdCBkZWZpbmVzIHRoZSBnbHlwaHMgZm9yIHRoaXMgYml0bWFwIHRleHQuIEVhY2ggZ2x5cGgvY2hhcmFjdGVyXG5cdFx0ICogc2hvdWxkIGhhdmUgYSBzaW5nbGUgZnJhbWUgYW5pbWF0aW9uIGRlZmluZWQgaW4gdGhlIHNwcml0ZSBzaGVldCBuYW1lZCB0aGUgc2FtZSBhc1xuXHRcdCAqIGNvcnJlc3BvbmRpbmcgY2hhcmFjdGVyLlxuXHRcdCAqXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiAvLyB0aGUgZm9sbG93aW5nIGFuaW1hdGlvbiBkZWZpbml0aW9uIHdvdWxkIGluZGljYXRlIHRoYXQgdGhlIGZyYW1lIGF0IGluZGV4IDAgb2YgdGhlIHNwcml0ZXNoZWV0IHNob3VsZCBiZSBkcmF3biBmb3IgdGhlIFwiQVwiIGNoYXJhY3Rlci5cblx0XHQgKiBcIkFcIjoge2ZyYW1lczogWzBdfVxuXHRcdCAqIC8vIFRoZSBzaG9ydCBmb3JtIGlzIGFsc28gYWNjZXB0YWJsZTpcblx0XHQgKiBcIkFcIjogMFxuXHRcdCAqXG5cdFx0ICogTm90ZSB0aGF0IGlmIGEgY2hhcmFjdGVyIGluIHRoZSB0ZXh0IGlzIG5vdCBmb3VuZCBpbiB0aGUgc3ByaXRlIHNoZWV0LCBpdCB3aWxsIGFsc29cblx0XHQgKiB0cnkgdG8gdXNlIHRoZSBhbHRlcm5hdGUgY2FzZSAodXBwZXIgb3IgbG93ZXIpLlxuXHRcdCAqXG5cdFx0ICogQHNlZSB7QGxpbmsgZWFzZWxqcy5TcHJpdGVTaGVldH1cblx0XHQgKiBAdHlwZSB7ZWFzZWxqcy5TcHJpdGVTaGVldH1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5zcHJpdGVTaGVldCA9IHNwcml0ZVNoZWV0O1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGhlaWdodCBvZiBlYWNoIGxpbmUgb2YgdGV4dC4gSWYgMCwgdGhlbiBpdCB3aWxsIHVzZSBhIGxpbmUgaGVpZ2h0IGNhbGN1bGF0ZWRcblx0XHQgKiBieSBjaGVja2luZyBmb3IgdGhlIGhlaWdodCBvZiB0aGUgXCIxXCIsIFwiVFwiLCBvciBcIkxcIiBjaGFyYWN0ZXIgKGluIHRoYXQgb3JkZXIpLiBJZlxuXHRcdCAqIHRob3NlIGNoYXJhY3RlcnMgYXJlIG5vdCBkZWZpbmVkLCBpdCB3aWxsIHVzZSB0aGUgaGVpZ2h0IG9mIHRoZSBmaXJzdCBmcmFtZSBvZiB0aGVcblx0XHQgKiBzcHJpdGUgc2hlZXQuXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0dGhpcy5saW5lSGVpZ2h0ID0gMDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgc3BhY2luZyAoaW4gcGl4ZWxzKSB3aWxsIGJlIGFkZGVkIGFmdGVyIGVhY2ggY2hhcmFjdGVyIGluIHRoZSBvdXRwdXQuXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0dGhpcy5sZXR0ZXJTcGFjaW5nID0gMDtcblxuXHRcdC8qKlxuXHRcdCAqIElmIGEgc3BhY2UgY2hhcmFjdGVyIGlzIG5vdCBkZWZpbmVkIGluIHRoZSBzcHJpdGUgc2hlZXQsIHRoZW4gZW1wdHkgcGl4ZWxzIGVxdWFsIHRvXG5cdFx0ICogc3BhY2VXaWR0aCB3aWxsIGJlIGluc2VydGVkIGluc3RlYWQuIElmIDAsIHRoZW4gaXQgd2lsbCB1c2UgYSB2YWx1ZSBjYWxjdWxhdGVkXG5cdFx0ICogYnkgY2hlY2tpbmcgZm9yIHRoZSB3aWR0aCBvZiB0aGUgXCIxXCIsIFwibFwiLCBcIkVcIiwgb3IgXCJBXCIgY2hhcmFjdGVyIChpbiB0aGF0IG9yZGVyKS4gSWZcblx0XHQgKiB0aG9zZSBjaGFyYWN0ZXJzIGFyZSBub3QgZGVmaW5lZCwgaXQgd2lsbCB1c2UgdGhlIHdpZHRoIG9mIHRoZSBmaXJzdCBmcmFtZSBvZiB0aGVcblx0XHQgKiBzcHJpdGUgc2hlZXQuXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0dGhpcy5zcGFjZVdpZHRoID0gMDtcblxuXHQgXHQvKipcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLl9vbGRQcm9wcyA9IHt0ZXh0OjAsc3ByaXRlU2hlZXQ6MCxsaW5lSGVpZ2h0OjAsbGV0dGVyU3BhY2luZzowLHNwYWNlV2lkdGg6MH07XG5cblx0XHQvKipcblx0XHQgKiBVc2VkIHRvIHRyYWNrIHRoZSBvYmplY3Qgd2hpY2ggdGhpcyBjbGFzcyBhdHRhY2hlZCBsaXN0ZW5lcnMgdG8sIGhlbHBzIG9wdGltaXplIGxpc3RlbmVyIGF0dGFjaG1lbnQuXG5cdFx0ICogQHR5cGUge2Vhc2VsanMuU3RhZ2V9XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuX29sZFN0YWdlID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBldmVudCBsaXN0ZW5lciBwcm94eSB0cmlnZ2VyZWQgZHJhd2luZyBkcmF3IGZvciBzcGVjaWFsIGNpcmN1bXN0YW5jZXMuXG5cdFx0ICogQHR5cGUge0Z1bmN0aW9ufVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLl9kcmF3QWN0aW9uID0gbnVsbDtcblxuXHR9XG5cblx0ZHJhdyAoY3R4LCBpZ25vcmVDYWNoZSkge1xuXHRcdGlmICh0aGlzLmRyYXdDYWNoZShjdHgsIGlnbm9yZUNhY2hlKSkgeyByZXR1cm47IH1cblx0XHR0aGlzLl91cGRhdGVTdGF0ZSgpO1xuXHRcdHN1cGVyLmRyYXcoY3R4LCBpZ25vcmVDYWNoZSk7XG5cdH1cblxuXHRnZXRCb3VuZHMgKCkge1xuXHRcdHRoaXMuX3VwZGF0ZVRleHQoKTtcblx0XHRyZXR1cm4gc3VwZXIuZ2V0Qm91bmRzKCk7XG5cdH1cblxuXHRpc1Zpc2libGUgKCkge1xuXHRcdGxldCBoYXNDb250ZW50ID0gdGhpcy5jYWNoZUNhbnZhcyB8fCAodGhpcy5zcHJpdGVTaGVldCAmJiB0aGlzLnNwcml0ZVNoZWV0LmNvbXBsZXRlICYmIHRoaXMudGV4dCk7XG5cdFx0cmV0dXJuICEhKHRoaXMudmlzaWJsZSAmJiB0aGlzLmFscGhhID4gMCAmJiB0aGlzLnNjYWxlWCAhPT0gMCAmJiB0aGlzLnNjYWxlWSAhPT0gMCAmJiBoYXNDb250ZW50KTtcblx0fVxuXG5cdGNsb25lICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2xvbmVQcm9wcyhuZXcgQml0bWFwVGV4dCh0aGlzLnRleHQsIHRoaXMuc3ByaXRlU2hlZXQpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiA8c3Ryb25nPkRpc2FibGVkIGluIEJpdG1hcFRleHQuPC9zdHJvbmc+XG5cdCAqL1xuXHRhZGRDaGlsZCAoKSB7fVxuXG5cdC8qKlxuXHQgKiA8c3Ryb25nPkRpc2FibGVkIGluIEJpdG1hcFRleHQuPC9zdHJvbmc+XG5cdCAqL1xuXHRhZGRDaGlsZEF0ICgpIHt9XG5cblx0LyoqXG5cdCAqIDxzdHJvbmc+RGlzYWJsZWQgaW4gQml0bWFwVGV4dC48L3N0cm9uZz5cblx0ICovXG5cdHJlbW92ZUNoaWxkICgpIHt9XG5cblx0LyoqXG5cdCAqIDxzdHJvbmc+RGlzYWJsZWQgaW4gQml0bWFwVGV4dC48L3N0cm9uZz5cblx0ICovXG5cdHJlbW92ZUNoaWxkQXQgKCkge31cblxuXHQvKipcblx0ICogPHN0cm9uZz5EaXNhYmxlZCBpbiBCaXRtYXBUZXh0Ljwvc3Ryb25nPlxuXHQgKi9cblx0cmVtb3ZlQWxsQ2hpbGRyZW4gKCkge31cblxuXHRfdXBkYXRlU3RhdGUgKCkge1xuXHRcdHRoaXMuX3VwZGF0ZVRleHQoKTtcblx0fVxuXG4gXHQvKipcblx0ICogQHBhcmFtIHtlYXNlbGpzLkJpdG1hcFRleHR9IG9cblx0ICogQHJldHVybiB7ZWFzZWxqcy5CaXRtYXBUZXh0fVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRfY2xvbmVQcm9wcyAobykge1xuXHRcdHN1cGVyLl9jbG9uZVByb3BzKG8pO1xuXHRcdG8ubGluZUhlaWdodCA9IHRoaXMubGluZUhlaWdodDtcblx0XHRvLmxldHRlclNwYWNpbmcgPSB0aGlzLmxldHRlclNwYWNpbmc7XG5cdFx0by5zcGFjZVdpZHRoID0gdGhpcy5zcGFjZVdpZHRoO1xuXHRcdHJldHVybiBvO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBjaGFyYWN0ZXJcblx0ICogQHBhcmFtIHtlYXNlbGpzLlNwcml0ZVNoZWV0fSBzcHJpdGVTaGVldFxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdF9nZXRGcmFtZUluZGV4IChjaGFyYWN0ZXIsIHNwcml0ZVNoZWV0KSB7XG5cdFx0bGV0IGMsIG8gPSBzcHJpdGVTaGVldC5nZXRBbmltYXRpb24oY2hhcmFjdGVyKTtcblx0XHRpZiAoIW8pIHtcblx0XHRcdChjaGFyYWN0ZXIgIT0gKGMgPSBjaGFyYWN0ZXIudG9VcHBlckNhc2UoKSkpIHx8IChjaGFyYWN0ZXIgIT0gKGMgPSBjaGFyYWN0ZXIudG9Mb3dlckNhc2UoKSkpIHx8IChjID0gbnVsbCk7XG5cdFx0XHRpZiAoYykgeyBvID0gc3ByaXRlU2hlZXQuZ2V0QW5pbWF0aW9uKGMpOyB9XG5cdFx0fVxuXHRcdHJldHVybiBvICYmIG8uZnJhbWVzWzBdO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBjaGFyYWN0ZXJcblx0ICogQHBhcmFtIHtlYXNlbGpzLlNwcml0ZVNoZWV0fSBzcHJpdGVTaGVldFxuXHQgKiBAcmV0dXJuIHtPYmplY3R9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdF9nZXRGcmFtZSAoY2hhcmFjdGVyLCBzcHJpdGVTaGVldCkge1xuXHRcdGxldCBpbmRleCA9IHRoaXMuX2dldEZyYW1lSW5kZXgoY2hhcmFjdGVyLCBzcHJpdGVTaGVldCk7XG5cdFx0cmV0dXJuIGluZGV4ID09IG51bGwgPyBpbmRleCA6IHNwcml0ZVNoZWV0LmdldEZyYW1lKGluZGV4KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge2Vhc2VsanMuU3ByaXRlU2hlZXR9IHNzXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0X2dldExpbmVIZWlnaHQgKHNzKSB7XG5cdFx0bGV0IGZyYW1lID0gdGhpcy5fZ2V0RnJhbWUoXCIxXCIsIHNzKSB8fCB0aGlzLl9nZXRGcmFtZShcIlRcIiwgc3MpIHx8IHRoaXMuX2dldEZyYW1lKFwiTFwiLCBzcykgfHwgc3MuZ2V0RnJhbWUoMCk7XG5cdFx0cmV0dXJuIGZyYW1lID8gZnJhbWUucmVjdC5oZWlnaHQgOiAxO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7ZWFzZWxqcy5TcHJpdGVTaGVldH0gc3Ncblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRfZ2V0U3BhY2VXaWR0aCAoc3MpIHtcblx0XHRsZXQgZnJhbWUgPSB0aGlzLl9nZXRGcmFtZShcIjFcIiwgc3MpIHx8IHRoaXMuX2dldEZyYW1lKFwibFwiLCBzcykgfHwgdGhpcy5fZ2V0RnJhbWUoXCJlXCIsIHNzKSB8fCB0aGlzLl9nZXRGcmFtZShcImFcIiwgc3MpIHx8IHNzLmdldEZyYW1lKDApO1xuXHRcdHJldHVybiBmcmFtZSA/IGZyYW1lLnJlY3Qud2lkdGggOiAxO1xuXHR9XG5cblx0X3RpY2sgKGV2dE9iaikge1xuXHRcdGxldCBzdGFnZSA9IHRoaXMuc3RhZ2U7XG5cdFx0c3RhZ2UgJiYgc3RhZ2Uub24oXCJkcmF3c3RhcnRcIiwgdGhpcy5fdXBkYXRlVGV4dCwgdGhpcywgdHJ1ZSk7XG5cdFx0c3VwZXIuX3RpY2soZXZ0T2JqKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRfdXBkYXRlVGV4dCAoKSB7XG5cdFx0bGV0IHggPSAwLCB5ID0gMCwgbyA9IHRoaXMuX29sZFByb3BzLCBjaGFuZ2UgPSBmYWxzZSwgc3BhY2VXID0gdGhpcy5zcGFjZVdpZHRoLCBsaW5lSCA9IHRoaXMubGluZUhlaWdodCwgc3MgPSB0aGlzLnNwcml0ZVNoZWV0O1xuXHRcdGxldCBwb29sID0gQml0bWFwVGV4dC5fc3ByaXRlUG9vbCwga2lkcyA9IHRoaXMuY2hpbGRyZW4sIGNoaWxkSW5kZXggPSAwLCBudW1LaWRzID0ga2lkcy5sZW5ndGgsIHNwcml0ZTtcblxuXHRcdGZvciAobGV0IG4gaW4gbykge1xuXHRcdFx0aWYgKG9bbl0gIT0gdGhpc1tuXSkge1xuXHRcdFx0XHRvW25dID0gdGhpc1tuXTtcblx0XHRcdFx0Y2hhbmdlID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKCFjaGFuZ2UpIHsgcmV0dXJuOyB9XG5cblx0XHRsZXQgaGFzU3BhY2UgPSAhIXRoaXMuX2dldEZyYW1lKFwiIFwiLCBzcyk7XG5cdFx0aWYgKCFoYXNTcGFjZSAmJiAhc3BhY2VXKSB7IHNwYWNlVyA9IHRoaXMuX2dldFNwYWNlV2lkdGgoc3MpOyB9XG5cdFx0aWYgKCFsaW5lSCkgeyBsaW5lSCA9IHRoaXMuX2dldExpbmVIZWlnaHQoc3MpOyB9XG5cblx0XHRmb3IgKGxldCBpID0gMCwgbCA9IHRoaXMudGV4dC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdGxldCBjaGFyYWN0ZXIgPSB0aGlzLnRleHQuY2hhckF0KGkpO1xuXHRcdFx0aWYgKGNoYXJhY3RlciA9PT0gXCIgXCIgJiYgIWhhc1NwYWNlKSB7XG5cdFx0XHRcdHggKz0gc3BhY2VXO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH0gZWxzZSBpZiAoY2hhcmFjdGVyID09PSBcIlxcblwiIHx8IGNoYXJhY3RlciA9PT0gXCJcXHJcIikge1xuXHRcdFx0XHRpZiAoY2hhcmFjdGVyID09PSBcIlxcclwiICYmIHRoaXMudGV4dC5jaGFyQXQoaSsxKSA9PT0gXCJcXG5cIikgeyBpKys7IH0gLy8gY3JsZlxuXHRcdFx0XHR4ID0gMDtcblx0XHRcdFx0eSArPSBsaW5lSDtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdGxldCBpbmRleCA9IHRoaXMuX2dldEZyYW1lSW5kZXgoY2hhcmFjdGVyLCBzcyk7XG5cdFx0XHRpZiAoaW5kZXggPT0gbnVsbCkgeyBjb250aW51ZTsgfVxuXG5cdFx0XHRpZiAoY2hpbGRJbmRleCA8IG51bUtpZHMpIHtcblx0XHRcdFx0c3ByaXRlID0ga2lkc1tjaGlsZEluZGV4XTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGtpZHMucHVzaChzcHJpdGUgPSBwb29sLmxlbmd0aCA/IHBvb2wucG9wKCkgOiBuZXcgU3ByaXRlKCkpO1xuXHRcdFx0XHRzcHJpdGUucGFyZW50ID0gdGhpcztcblx0XHRcdFx0bnVtS2lkcysrO1xuXHRcdFx0fVxuXHRcdFx0c3ByaXRlLnNwcml0ZVNoZWV0ID0gc3M7XG5cdFx0XHRzcHJpdGUuZ290b0FuZFN0b3AoaW5kZXgpO1xuXHRcdFx0c3ByaXRlLnggPSB4O1xuXHRcdFx0c3ByaXRlLnkgPSB5O1xuXHRcdFx0Y2hpbGRJbmRleCsrO1xuXG5cdFx0XHR4ICs9IHNwcml0ZS5nZXRCb3VuZHMoKS53aWR0aCArIHRoaXMubGV0dGVyU3BhY2luZztcblx0XHR9XG5cblx0XHR3aGlsZSAobnVtS2lkcyA+IGNoaWxkSW5kZXgpIHtcblx0XHRcdCAvLyBmYXN0ZXIgdGhhbiByZW1vdmVDaGlsZC5cblx0XHRcdHBvb2wucHVzaChzcHJpdGUgPSBraWRzLnBvcCgpKTtcblx0XHRcdHNwcml0ZS5wYXJlbnQgPSBudWxsO1xuXHRcdFx0bnVtS2lkcy0tO1xuXHRcdH1cblx0XHRpZiAocG9vbC5sZW5ndGggPiBCaXRtYXBUZXh0Lm1heFBvb2xTaXplKSB7IHBvb2wubGVuZ3RoID0gQml0bWFwVGV4dC5tYXhQb29sU2l6ZTsgfVxuXHR9XG5cbn1cblxuLyoqXG4gKiBCaXRtYXBUZXh0IHVzZXMgU3ByaXRlIGluc3RhbmNlcyB0byBkcmF3IHRleHQuIFRvIHJlZHVjZSB0aGUgY3JlYXRpb24gYW5kIGRlc3RydWN0aW9uIG9mIGluc3RhbmNlcyAoYW5kIHRodXMgZ2FyYmFnZSBjb2xsZWN0aW9uKSwgaXQgbWFpbnRhaW5zXG4gKiBhbiBpbnRlcm5hbCBvYmplY3QgcG9vbCBvZiBzcHJpdGUgaW5zdGFuY2VzIHRvIHJldXNlLiBJbmNyZWFzaW5nIHRoaXMgdmFsdWUgY2FuIGNhdXNlIG1vcmUgc3ByaXRlcyB0byBiZVxuICogcmV0YWluZWQsIHNsaWdodGx5IGluY3JlYXNpbmcgbWVtb3J5IHVzZSwgYnV0IHJlZHVjaW5nIGluc3RhbnRpYXRpb24uXG4gKiBAdHlwZSB7TnVtYmVyfVxuICogQHN0YXRpY1xuICogQGRlZmF1bHQgMTAwXG4gKi9cbkJpdG1hcFRleHQubWF4UG9vbFNpemUgPSAxMDA7XG4vKipcbiAqIFNwcml0ZSBvYmplY3QgcG9vbC5cbiAqIEB0eXBlIHtBcnJheX1cbiAqIEBzdGF0aWNcbiAqIEBwcml2YXRlXG4gKiBAcmVhZG9ubHlcbiAqL1xuQml0bWFwVGV4dC5fc3ByaXRlUG9vbCA9IFtdO1xuIiwiLyoqXG4gKiBAbGljZW5zZSBET01FbGVtZW50XG4gKiBWaXNpdCBodHRwOi8vY3JlYXRlanMuY29tLyBmb3IgZG9jdW1lbnRhdGlvbiwgdXBkYXRlcyBhbmQgZXhhbXBsZXMuXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IGdza2lubmVyLmNvbSwgaW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gKiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxuICogZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0XG4gKiByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSxcbiAqIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiAqIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXG4gKiBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gKiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICogRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTXG4gKiBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICogTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcbiAqIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLFxuICogV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4gKiBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SXG4gKiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gKi9cblxuaW1wb3J0IERpc3BsYXlPYmplY3QgZnJvbSBcIi4vRGlzcGxheU9iamVjdFwiO1xuaW1wb3J0IERpc3BsYXlQcm9wcyBmcm9tIFwiLi4vZ2VvbS9EaXNwbGF5UHJvcHNcIjtcblxuLyoqXG4gKiA8Yj5UaGlzIGNsYXNzIGlzIHN0aWxsIGV4cGVyaW1lbnRhbCwgYW5kIG1vcmUgYWR2YW5jZWQgdXNlIGlzIGxpa2VseSB0byBiZSBidWdneS4gUGxlYXNlIHJlcG9ydCBidWdzLjwvYj5cbiAqXG4gKiBBIERPTUVsZW1lbnQgYWxsb3dzIHlvdSB0byBhc3NvY2lhdGUgYSBIVE1MRWxlbWVudCB3aXRoIHRoZSBkaXNwbGF5IGxpc3QuIEl0IHdpbGwgYmUgdHJhbnNmb3JtZWRcbiAqIHdpdGhpbiB0aGUgRE9NIGFzIHRob3VnaCBpdCBpcyBjaGlsZCBvZiB0aGUge3sjY3Jvc3NMaW5rIFwiQ29udGFpbmVyXCJ9fXt7L2Nyb3NzTGlua319IGl0IGlzIGFkZGVkIHRvLiBIb3dldmVyLCBpdCBpc1xuICogbm90IHJlbmRlcmVkIHRvIGNhbnZhcywgYW5kIGFzIHN1Y2ggd2lsbCByZXRhaW4gd2hhdGV2ZXIgei1pbmRleCBpdCBoYXMgcmVsYXRpdmUgdG8gdGhlIGNhbnZhcyAoaWUuIGl0IHdpbGwgYmVcbiAqIGRyYXduIGluIGZyb250IG9mIG9yIGJlaGluZCB0aGUgY2FudmFzKS5cbiAqXG4gKiBUaGUgcG9zaXRpb24gb2YgYSBET01FbGVtZW50IGlzIHJlbGF0aXZlIHRvIHRoZWlyIHBhcmVudCBub2RlIGluIHRoZSBET00uIEl0IGlzIHJlY29tbWVuZGVkIHRoYXRcbiAqIHRoZSBET00gT2JqZWN0IGJlIGFkZGVkIHRvIGEgZGl2IHRoYXQgYWxzbyBjb250YWlucyB0aGUgY2FudmFzIHNvIHRoYXQgdGhleSBzaGFyZSB0aGUgc2FtZSBwb3NpdGlvblxuICogb24gdGhlIHBhZ2UuXG4gKlxuICogRE9NRWxlbWVudCBpcyB1c2VmdWwgZm9yIHBvc2l0aW9uaW5nIEhUTUwgZWxlbWVudHMgb3ZlciB0b3Agb2YgY2FudmFzIGNvbnRlbnQsIGFuZCBmb3IgZWxlbWVudHNcbiAqIHRoYXQgeW91IHdhbnQgdG8gZGlzcGxheSBvdXRzaWRlIHRoZSBib3VuZHMgb2YgdGhlIGNhbnZhcy4gRm9yIGV4YW1wbGUsIGEgdG9vbHRpcCB3aXRoIHJpY2ggSFRNTFxuICogY29udGVudC5cbiAqXG4gKiA8aDQ+TW91c2UgSW50ZXJhY3Rpb248L2g0PlxuICpcbiAqIERPTUVsZW1lbnQgaW5zdGFuY2VzIGFyZSBub3QgZnVsbCBFYXNlbEpTIGRpc3BsYXkgb2JqZWN0cywgYW5kIGRvIG5vdCBwYXJ0aWNpcGF0ZSBpbiBFYXNlbEpTIG1vdXNlXG4gKiBldmVudHMgb3Igc3VwcG9ydCBtZXRob2RzIGxpa2UgaGl0VGVzdC4gVG8gZ2V0IG1vdXNlIGV2ZW50cyBmcm9tIGEgRE9NRWxlbWVudCwgeW91IG11c3QgaW5zdGVhZCBhZGQgaGFuZGxlcnMgdG9cbiAqIHRoZSBodG1sRWxlbWVudCAobm90ZSwgdGhpcyBkb2VzIG5vdCBzdXBwb3J0IEV2ZW50RGlzcGF0Y2hlcilcbiAqXG4gKiAgICAgIHZhciBkb21FbGVtZW50ID0gbmV3IGNyZWF0ZWpzLkRPTUVsZW1lbnQoaHRtbEVsZW1lbnQpO1xuICogICAgICBkb21FbGVtZW50Lmh0bWxFbGVtZW50Lm9uY2xpY2sgPSBmdW5jdGlvbigpIHtcbiAqICAgICAgICAgIGNvbnNvbGUubG9nKFwiY2xpY2tlZFwiKTtcbiAqICAgICAgfVxuICpcbiAqIDxzdHJvbmc+SW1wb3J0YW50Ojwvc3Ryb25nPiBUaGlzIGNsYXNzIG5lZWRzIHRvIGJlIG5vdGlmaWVkIGl0IGlzIGFib3V0IHRvIGJlIGRyYXduLCB0aGlzIHdpbGwgaGFwcGVuIGF1dG9tYXRpY2FsbHlcbiAqIGlmIHlvdSBjYWxsIHN0YWdlLnVwZGF0ZSwgY2FsbGluZyBzdGFnZS5kcmF3IG9yIGRpc2FibGluZyB0aWNrRW5hYmxlZCB3aWxsIG1pc3MgaW1wb3J0YW50IHN0ZXBzIGFuZCBpdCB3aWxsIHJlbmRlclxuICogc3RhbGUgaW5mb3JtYXRpb24uXG4gKlxuICogQG1lbWJlcm9mIGVhc2VsanNcbiAqIEBleHRlbmRzIERpc3BsYXlPYmplY3RcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnQgfCBTdHJpbmd9IGh0bWxFbGVtZW50IEEgcmVmZXJlbmNlIG9yIGlkIGZvciB0aGUgRE9NIGVsZW1lbnQgdG8gbWFuYWdlLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBET01FbGVtZW50IGV4dGVuZHMgRGlzcGxheU9iamVjdCB7XG5cblx0Y29uc3RydWN0b3IgKGh0bWxFbGVtZW50KSB7XG5cdFx0c3VwZXIoKTtcblxuXHRcdGlmICh0eXBlb2YgaHRtbEVsZW1lbnQgPT09IFwic3RyaW5nXCIpIHsgaHRtbEVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChodG1sRWxlbWVudCk7IH1cblx0XHR0aGlzLm1vdXNlRW5hYmxlZCA9IGZhbHNlO1xuXG5cdFx0bGV0IHN0eWxlID0gaHRtbEVsZW1lbnQuc3R5bGU7XG5cdFx0c3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG5cdFx0c3R5bGUudHJhbnNmb3JtT3JpZ2luID0gc3R5bGUuV2Via2l0VHJhbnNmb3JtT3JpZ2luID0gc3R5bGUubXNUcmFuc2Zvcm1PcmlnaW4gPSBzdHlsZS5Nb3pUcmFuc2Zvcm1PcmlnaW4gPSBzdHlsZS5PVHJhbnNmb3JtT3JpZ2luID0gXCIwJSAwJVwiO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIERPTSBvYmplY3QgdG8gbWFuYWdlLlxuXHRcdCAqIEB0eXBlIHtIVE1MRWxlbWVudH1cblx0XHQgKi9cblx0XHR0aGlzLmh0bWxFbGVtZW50ID0gaHRtbEVsZW1lbnQ7XG5cblx0XHQvKipcblx0XHQgKiBAdHlwZSB7ZWFzZWxqcy5NYXRyaXgyRH1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuX29sZFByb3BzID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIFVzZWQgdG8gdHJhY2sgdGhlIG9iamVjdCB3aGljaCB0aGlzIGNsYXNzIGF0dGFjaGVkIGxpc3RlbmVycyB0bywgaGVscHMgb3B0aW1pemUgbGlzdGVuZXIgYXR0YWNobWVudC5cblx0XHQgKiBAdHlwZSB7ZWFzZWxqcy5TdGFnZX1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuX29sZFN0YWdlID0gbnVsbDtcblx0XHQvKipcblx0XHQgKiBUaGUgZXZlbnQgbGlzdGVuZXIgcHJveHkgdHJpZ2dlcmVkIGRyYXdpbmcgZHJhdyBmb3Igc3BlY2lhbCBjaXJjdW1zdGFuY2VzLlxuXHRcdCAqIEB0eXBlIHtGdW5jdGlvbn1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuX2RyYXdBY3Rpb24gPSBudWxsO1xuXHR9XG5cblx0aXNWaXNpYmxlICgpIHtcblx0XHRyZXR1cm4gdGhpcy5odG1sRWxlbWVudCAhPSBudWxsO1xuXHR9XG5cblx0ZHJhdyAoY3R4LCBpZ25vcmVDYWNoZSkge1xuXHRcdC8vIHRoaXMgcmVsaWVzIG9uIHRoZSBfdGljayBtZXRob2QgYmVjYXVzZSBkcmF3IGlzbid0IGNhbGxlZCBpZiB0aGUgcGFyZW50IGlzIG5vdCB2aXNpYmxlLlxuXHRcdC8vIHRoZSBhY3R1YWwgdXBkYXRlIGhhcHBlbnMgaW4gX2hhbmRsZURyYXdFbmRcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEaXNhYmxlZCBpbiBET01FbGVtZW50LlxuXHQgKi9cblx0Y2FjaGUgKCkge31cblxuXHQvKipcblx0ICogRGlzYWJsZWQgaW4gRE9NRWxlbWVudC5cblx0ICovXG5cdHVuY2FjaGUgKCkge31cblxuXHQvKipcblx0ICogRGlzYWJsZWQgaW4gRE9NRWxlbWVudC5cblx0ICovXG5cdHVwZGF0ZUNhY2hlICgpIHt9XG5cblx0LyoqXG5cdCAqIERpc2FibGVkIGluIERPTUVsZW1lbnQuXG5cdCAqL1xuXHRoaXRUZXN0ICgpIHt9XG5cblx0LyoqXG5cdCAqIERpc2FibGVkIGluIERPTUVsZW1lbnQuXG5cdCAqL1xuXHRsb2NhbFRvR2xvYmFsICgpIHt9XG5cblx0LyoqXG5cdCAqIERpc2FibGVkIGluIERPTUVsZW1lbnQuXG5cdCAqL1xuXHRnbG9iYWxUb0xvY2FsICgpIHt9XG5cblx0LyoqXG5cdCAqIERpc2FibGVkIGluIERPTUVsZW1lbnQuXG5cdCAqL1xuXHRsb2NhbFRvTG9jYWwgKCkge31cblxuXHQvKipcblx0ICogRE9NRWxlbWVudCBjYW5ub3QgYmUgY2xvbmVkLlxuXHQgKiBAdGhyb3dzIERPTUVsZW1lbnQgY2Fubm90IGJlIGNsb25lZFxuXHQgKi9cblx0Y2xvbmUgKCkge1xuXHRcdHRocm93IFwiRE9NRWxlbWVudCBjYW5ub3QgYmUgY2xvbmVkLlwiO1xuXHR9XG5cblx0X3RpY2sgKGV2dE9iaikge1xuXHRcdGxldCBzdGFnZSA9IHRoaXMuc3RhZ2U7XG5cdFx0aWYgKHN0YWdlICE9IG51bGwgJiYgc3RhZ2UgIT09IHRoaXMuX29sZFN0YWdlKSB7XG5cdFx0XHR0aGlzLl9kcmF3QWN0aW9uICYmIHN0YWdlLm9mZihcImRyYXdlbmRcIiwgdGhpcy5fZHJhd0FjdGlvbik7XG5cdFx0XHR0aGlzLl9kcmF3QWN0aW9uID0gc3RhZ2Uub24oXCJkcmF3ZW5kXCIsIHRoaXMuX2hhbmRsZURyYXdFbmQsIHRoaXMpO1xuXHRcdFx0dGhpcy5fb2xkU3RhZ2UgPSBzdGFnZTtcblx0XHR9XG5cdFx0c3VwZXIuX3RpY2soZXZ0T2JqKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge2NvcmUuRXZlbnR9IGV2dFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRfaGFuZGxlRHJhd0VuZCAoZXZ0KSB7XG5cdFx0bGV0IG8gPSB0aGlzLmh0bWxFbGVtZW50O1xuXHRcdGlmICghbykgeyByZXR1cm47IH1cblx0XHRsZXQgc3R5bGUgPSBvLnN0eWxlO1xuXG5cdFx0bGV0IHByb3BzID0gdGhpcy5nZXRDb25jYXRlbmF0ZWREaXNwbGF5UHJvcHModGhpcy5fcHJvcHMpLCBtdHggPSBwcm9wcy5tYXRyaXg7XG5cblx0XHRsZXQgdmlzaWJpbGl0eSA9IHByb3BzLnZpc2libGUgPyBcInZpc2libGVcIiA6IFwiaGlkZGVuXCI7XG5cdFx0aWYgKHZpc2liaWxpdHkgIT0gc3R5bGUudmlzaWJpbGl0eSkgeyBzdHlsZS52aXNpYmlsaXR5ID0gdmlzaWJpbGl0eTsgfVxuXHRcdGlmICghcHJvcHMudmlzaWJsZSkgeyByZXR1cm47IH1cblxuXHRcdGxldCBvbGRQcm9wcyA9IHRoaXMuX29sZFByb3BzLCBvbGRNdHggPSBvbGRQcm9wcyYmb2xkUHJvcHMubWF0cml4O1xuXHRcdGxldCBuID0gMTAwMDA7IC8vIHByZWNpc2lvblxuXG5cdFx0aWYgKCFvbGRNdHggfHwgIW9sZE10eC5lcXVhbHMobXR4KSkge1xuXHRcdFx0bGV0IHN0ciA9IFwibWF0cml4KFwiICsgKG10eC5hKm58MCkvbiArXCIsXCIrIChtdHguYipufDApL24gK1wiLFwiKyAobXR4LmMqbnwwKS9uICtcIixcIisgKG10eC5kKm58MCkvbiArXCIsXCIrIChtdHgudHgrMC41fDApO1xuXHRcdFx0c3R5bGUudHJhbnNmb3JtID0gc3R5bGUuV2Via2l0VHJhbnNmb3JtID0gc3R5bGUuT1RyYW5zZm9ybSA9IHN0eWxlLm1zVHJhbnNmb3JtID0gc3RyICtcIixcIisgKG10eC50eSswLjV8MCkgK1wiKVwiO1xuXHRcdFx0c3R5bGUuTW96VHJhbnNmb3JtID0gc3RyICtcInB4LFwiKyAobXR4LnR5KzAuNXwwKSArXCJweClcIjtcblx0XHRcdGlmICghb2xkUHJvcHMpIHsgb2xkUHJvcHMgPSB0aGlzLl9vbGRQcm9wcyA9IG5ldyBEaXNwbGF5UHJvcHModHJ1ZSwgbnVsbCk7IH1cblx0XHRcdG9sZFByb3BzLm1hdHJpeC5jb3B5KG10eCk7XG5cdFx0fVxuXG5cdFx0aWYgKG9sZFByb3BzLmFscGhhICE9IHByb3BzLmFscGhhKSB7XG5cdFx0XHRzdHlsZS5vcGFjaXR5ID0gXCJcIisocHJvcHMuYWxwaGEqbnwwKS9uO1xuXHRcdFx0b2xkUHJvcHMuYWxwaGEgPSBwcm9wcy5hbHBoYTtcblx0XHR9XG5cdH1cblxufVxuXG4vKipcbiAqIEludGVyYWN0aW9uIGV2ZW50cyBzaG91bGQgYmUgYWRkZWQgdG8gYGh0bWxFbGVtZW50YCwgYW5kIG5vdCB0aGUgRE9NRWxlbWVudCBpbnN0YW5jZSwgc2luY2UgRE9NRWxlbWVudCBpbnN0YW5jZXNcbiAqIGFyZSBub3QgZnVsbCBFYXNlbEpTIGRpc3BsYXkgb2JqZWN0cyBhbmQgZG8gbm90IHBhcnRpY2lwYXRlIGluIEVhc2VsSlMgbW91c2UgZXZlbnRzLlxuICogQGV2ZW50IGVhc2VsanMuRE9NRWxlbWVudCNjbGlja1xuICovXG5cbi8qKlxuICogSW50ZXJhY3Rpb24gZXZlbnRzIHNob3VsZCBiZSBhZGRlZCB0byBgaHRtbEVsZW1lbnRgLCBhbmQgbm90IHRoZSBET01FbGVtZW50IGluc3RhbmNlLCBzaW5jZSBET01FbGVtZW50IGluc3RhbmNlc1xuICogYXJlIG5vdCBmdWxsIEVhc2VsSlMgZGlzcGxheSBvYmplY3RzIGFuZCBkbyBub3QgcGFydGljaXBhdGUgaW4gRWFzZWxKUyBtb3VzZSBldmVudHMuXG4gKiBAZXZlbnQgZWFzZWxqcy5ET01FbGVtZW50I2RibENsaWNrXG4gKi9cblxuLyoqXG4gKiBJbnRlcmFjdGlvbiBldmVudHMgc2hvdWxkIGJlIGFkZGVkIHRvIGBodG1sRWxlbWVudGAsIGFuZCBub3QgdGhlIERPTUVsZW1lbnQgaW5zdGFuY2UsIHNpbmNlIERPTUVsZW1lbnQgaW5zdGFuY2VzXG4gKiBhcmUgbm90IGZ1bGwgRWFzZWxKUyBkaXNwbGF5IG9iamVjdHMgYW5kIGRvIG5vdCBwYXJ0aWNpcGF0ZSBpbiBFYXNlbEpTIG1vdXNlIGV2ZW50cy5cbiAqIEBldmVudCBlYXNlbGpzLkRPTUVsZW1lbnQjbW91c2Vkb3duXG4gKi9cblxuLyoqXG4gKiBJbnRlcmFjdGlvbiBldmVudHMgc2hvdWxkIGJlIGFkZGVkIHRvIGBodG1sRWxlbWVudGAsIGFuZCBub3QgdGhlIERPTUVsZW1lbnQgaW5zdGFuY2UsIHNpbmNlIERPTUVsZW1lbnQgaW5zdGFuY2VzXG4gKiBhcmUgbm90IGZ1bGwgRWFzZWxKUyBkaXNwbGF5IG9iamVjdHMgYW5kIGRvIG5vdCBwYXJ0aWNpcGF0ZSBpbiBFYXNlbEpTIG1vdXNlIGV2ZW50cy5cbiAqIEBldmVudCBlYXNlbGpzLkRPTUVsZW1lbnQjbW91c2VvdmVyXG4gKi9cblxuLyoqXG4gKiBEaXNhYmxlZCBpbiBET01FbGVtZW50LlxuICogQGV2ZW50IGVhc2VsanMuRE9NRWxlbWVudCN0aWNrXG4gKi9cbiIsIi8qKlxuICogQGxpY2Vuc2UgR3JhcGhpY3NcbiAqIFZpc2l0IGh0dHA6Ly9jcmVhdGVqcy5jb20vIGZvciBkb2N1bWVudGF0aW9uLCB1cGRhdGVzIGFuZCBleGFtcGxlcy5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgZ3NraW5uZXIuY29tLCBpbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAqIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXG4gKiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXRcbiAqIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxuICogY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuICogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbiAqIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAqIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gKiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcbiAqIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gKiBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuICogSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXG4gKiBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcbiAqIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5pbXBvcnQgY3JlYXRlQ2FudmFzIGZyb20gXCIuLi91dGlscy9DYW52YXNcIjtcblxuLyoqXG4gKiBUaGUgR3JhcGhpY3MgY2xhc3MgZXhwb3NlcyBhbiBlYXN5IHRvIHVzZSBBUEkgZm9yIGdlbmVyYXRpbmcgdmVjdG9yIGRyYXdpbmcgaW5zdHJ1Y3Rpb25zIGFuZCBkcmF3aW5nIHRoZW0gdG8gYVxuICogc3BlY2lmaWVkIGNvbnRleHQuIE5vdGUgdGhhdCB5b3UgY2FuIHVzZSBHcmFwaGljcyB3aXRob3V0IGFueSBkZXBlbmRlbmN5IG9uIHRoZSBFYXNlbEpTIGZyYW1ld29yayBieSBjYWxsaW5nIHtAbGluayBlYXNlbGpzLkdyYXBoaWNzI2RyYXd9XG4gKiBkaXJlY3RseSwgb3IgaXQgY2FuIGJlIHVzZWQgd2l0aCB0aGUge0BsaW5rIGVhc2VsanMuU2hhcGV9IG9iamVjdCB0byBkcmF3IHZlY3RvciBncmFwaGljcyB3aXRoaW4gdGhlXG4gKiBjb250ZXh0IG9mIGFuIEVhc2VsSlMgZGlzcGxheSBsaXN0LlxuICpcbiAqIFRoZXJlIGFyZSB0d28gYXBwcm9hY2hlcyB0byB3b3JraW5nIHdpdGggR3JhcGhpY3Mgb2JqZWN0OiBjYWxsaW5nIG1ldGhvZHMgb24gYSBHcmFwaGljcyBpbnN0YW5jZSAodGhlIFwiR3JhcGhpY3MgQVBJXCIpLCBvclxuICogaW5zdGFudGlhdGluZyBHcmFwaGljcyBjb21tYW5kIG9iamVjdHMgYW5kIGFkZGluZyB0aGVtIHRvIHRoZSBncmFwaGljcyBxdWV1ZSB2aWEge0BsaW5rIGVhc2VsanMuR3JhcGhpY3MjYXBwZW5kfS5cbiAqIFRoZSBmb3JtZXIgYWJzdHJhY3RzIHRoZSBsYXR0ZXIsIHNpbXBsaWZ5aW5nIGJlZ2lubmluZyBhbmQgZW5kaW5nIHBhdGhzLCBmaWxscywgYW5kIHN0cm9rZXMuXG4gKlxuICogPGg0PlRpbnkgQVBJPC9oND5cbiAqIFRoZSBHcmFwaGljcyBjbGFzcyBhbHNvIGluY2x1ZGVzIGEgXCJ0aW55IEFQSVwiLCB3aGljaCBpcyBvbmUgb3IgdHdvLWxldHRlciBtZXRob2RzIHRoYXQgYXJlIHNob3J0Y3V0cyBmb3IgYWxsIG9mIHRoZVxuICogR3JhcGhpY3MgbWV0aG9kcy4gVGhlc2UgbWV0aG9kcyBhcmUgZ3JlYXQgZm9yIGNyZWF0aW5nIGNvbXBhY3QgaW5zdHJ1Y3Rpb25zLCBhbmQgaXMgdXNlZCBieSB0aGUgVG9vbGtpdCBmb3IgQ3JlYXRlSlNcbiAqIHRvIGdlbmVyYXRlIHJlYWRhYmxlIGNvZGUuIEFsbCB0aW55IG1ldGhvZHMgYXJlIG1hcmtlZCBhcyBwcm90ZWN0ZWQsIHNvIHlvdSBjYW4gdmlldyB0aGVtIGJ5IGVuYWJsaW5nIHByb3RlY3RlZFxuICogZGVzY3JpcHRpb25zIGluIHRoZSBkb2NzLlxuICpcbiAqIDx0YWJsZT5cbiAqICAgICA8dHI+PHRkPjxiPlRpbnk8L2I+PC90ZD48dGQ+PGI+TWV0aG9kPC9iPjwvdGQ+PHRkPjxiPlRpbnk8L2I+PC90ZD48dGQ+PGI+TWV0aG9kPC9iPjwvdGQ+PC90cj5cbiAqICAgICA8dHI+PHRkPm10PC90ZD48dGQ+e0BsaW5rIGVhc2VsanMuR3JhcGhpY3MjbW92ZVRvfTwvdGQ+XG4gKiAgICAgPHRkPmx0PC90ZD4gPHRkPntAbGluayBlYXNlbGpzLkdyYXBoaWNzI2xpbmVUb308L3RkPjwvdHI+XG4gKiAgICAgPHRyPjx0ZD5hL2F0PC90ZD48dGQ+e0BsaW5rIGVhc2VsanMuR3JhcGhpY3MjYXJjfSAvIHtAbGluayBlYXNlbGpzLkdyYXBoaWNzI2FyY1RvfTwvdGQ+XG4gKiAgICAgPHRkPmJ0PC90ZD48dGQ+e0BsaW5rIGVhc2VsanMuR3JhcGhpY3MjYmV6aWVyQ3VydmVUb308L3RkPjwvdHI+XG4gKiAgICAgPHRyPjx0ZD5xdDwvdGQ+PHRkPntAbGluayBlYXNlbGpzLkdyYXBoaWNzI3F1YWRyYXRpY0N1cnZlVG99IChhbHNvIGN1cnZlVG8pPC90ZD5cbiAqICAgICA8dGQ+cjwvdGQ+PHRkPntAbGluayBlYXNlbGpzLkdyYXBoaWNzI3JlY3R9PC90ZD48L3RyPlxuICogICAgIDx0cj48dGQ+Y3A8L3RkPjx0ZD57QGxpbmsgZWFzZWxqcy5HcmFwaGljcyNjbG9zZVBhdGh9PC90ZD5cbiAqICAgICA8dGQ+YzwvdGQ+PHRkPntAbGluayBlYXNlbGpzLkdyYXBoaWNzI2NsZWFyfTwvdGQ+PC90cj5cbiAqICAgICA8dHI+PHRkPmY8L3RkPjx0ZD57QGxpbmsgZWFzZWxqcy5HcmFwaGljcyNiZWdpbkZpbGx9PC90ZD5cbiAqICAgICA8dGQ+bGY8L3RkPjx0ZD57QGxpbmsgZWFzZWxqcy5HcmFwaGljcyNiZWdpbkxpbmVhckdyYWRpZW50RmlsbH08L3RkPjwvdHI+XG4gKiAgICAgPHRyPjx0ZD5yZjwvdGQ+PHRkPntAbGluayBlYXNlbGpzLkdyYXBoaWNzI2JlZ2luUmFkaWFsR3JhZGllbnRGaWxsfTwvdGQ+XG4gKiAgICAgPHRkPmJmPC90ZD48dGQ+e0BsaW5rIGVhc2VsanMuR3JhcGhpY3MjYmVnaW5CaXRtYXBGaWxsfTwvdGQ+PC90cj5cbiAqICAgICA8dHI+PHRkPmVmPC90ZD48dGQ+e0BsaW5rIGVhc2VsanMuR3JhcGhpY3MjZW5kRmlsbH08L3RkPlxuICogICAgIDx0ZD5zcyAvIHNkPC90ZD48dGQ+e0BsaW5rIGVhc2VsanMuR3JhcGhpY3Mjc2V0U3Ryb2tlU3R5bGV9IC8ge0BsaW5rIGVhc2VsanMuR3JhcGhpY3Mjc2V0U3Ryb2tlRGFzaH08L3RkPjwvdHI+XG4gKiAgICAgPHRyPjx0ZD5zPC90ZD48dGQ+e0BsaW5rIGVhc2VsanMuR3JhcGhpY3MjYmVnaW5TdHJva2V9PC90ZD5cbiAqICAgICA8dGQ+bHM8L3RkPjx0ZD57QGxpbmsgZWFzZWxqcy5HcmFwaGljcyNiZWdpbkxpbmVhckdyYWRpZW50U3Ryb2tlfTwvdGQ+PC90cj5cbiAqICAgICA8dHI+PHRkPnJzPC90ZD48dGQ+e0BsaW5rIGVhc2VsanMuR3JhcGhpY3MjYmVnaW5SYWRpYWxHcmFkaWVudFN0cm9rZX08L3RkPlxuICogICAgIDx0ZD5iczwvdGQ+PHRkPntAbGluayBlYXNlbGpzLkdyYXBoaWNzI2JlZ2luQml0bWFwU3Ryb2tlfTwvdGQ+PC90cj5cbiAqICAgICA8dHI+PHRkPmVzPC90ZD48dGQ+e0BsaW5rIGVhc2VsanMuR3JhcGhpY3MjZW5kU3Ryb2tlfTwvdGQ+XG4gKiAgICAgPHRkPmRyPC90ZD48dGQ+e0BsaW5rIGVhc2VsanMuR3JhcGhpY3MjZHJhd1JlY3R9PC90ZD48L3RyPlxuICogICAgIDx0cj48dGQ+cnI8L3RkPjx0ZD57QGxpbmsgZWFzZWxqcy5HcmFwaGljcyNkcmF3Um91bmRSZWN0fTwvdGQ+XG4gKiAgICAgPHRkPnJjPC90ZD48dGQ+e0BsaW5rIGVhc2VsanMuR3JhcGhpY3MjZHJhd1JvdW5kUmVjdENvbXBsZXh9PC90ZD48L3RyPlxuICogICAgIDx0cj48dGQ+ZGM8L3RkPjx0ZD57QGxpbmsgZWFzZWxqcy5HcmFwaGljcyNkcmF3Q2lyY2xlfTwvdGQ+XG4gKiAgICAgPHRkPmRlPC90ZD48dGQ+e0BsaW5rIGVhc2VsanMuR3JhcGhpY3MjZHJhd0VsbGlwc2V9PC90ZD48L3RyPlxuICogICAgIDx0cj48dGQ+ZHA8L3RkPjx0ZD57QGxpbmsgZWFzZWxqcy5HcmFwaGljcyNkcmF3UG9seVN0YXJ9PC90ZD5cbiAqICAgICA8dGQ+cDwvdGQ+PHRkPntAbGluayBlYXNlbGpzLkdyYXBoaWNzI2RlY29kZVBhdGh9PC90ZD48L3RyPlxuICogPC90YWJsZT5cbiAqXG4gKiBAZXhhbXBsZVxuICogdmFyIGcgPSBuZXcgY3JlYXRlanMuR3JhcGhpY3MoKTtcbiAqIGcuc2V0U3Ryb2tlU3R5bGUoMSk7XG4gKiBnLmJlZ2luU3Ryb2tlKFwiIzAwMDAwMFwiKTtcbiAqIGcuYmVnaW5GaWxsKFwicmVkXCIpO1xuICogZy5kcmF3Q2lyY2xlKDAsMCwzMCk7XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEFsbCBkcmF3aW5nIG1ldGhvZHMgaW4gR3JhcGhpY3MgcmV0dXJuIHRoZSBHcmFwaGljcyBpbnN0YW5jZSwgc28gdGhleSBjYW4gYmUgY2hhaW5lZCB0b2dldGhlci5cbiAqIGdyYXBoaWNzLmJlZ2luU3Ryb2tlKFwicmVkXCIpLmJlZ2luRmlsbChcImJsdWVcIikuZHJhd1JlY3QoMjAsIDIwLCAxMDAsIDUwKTtcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gRWFjaCBncmFwaGljcyBBUEkgY2FsbCBnZW5lcmF0ZXMgYSBjb21tYW5kIG9iamVjdCAoc2VlIGJlbG93KS4gVGhlIGxhc3QgY29tbWFuZCB0byBiZSBjcmVhdGVkIGNhbiBiZSBhY2Nlc3NlZCB2aWEgLmNvbW1hbmRcbiAqIGxldCBmaWxsQ29tbWFuZCA9IGdyYXBoaWNzLmJlZ2luRmlsbChcInJlZFwiKS5jb21tYW5kO1xuICogZmlsbENvbW1hbmQuc3R5bGUgPSBcImJsdWVcIjtcbiAqIC8vIG9yIGNoYW5nZSBpdCB0byBhIGJpdG1hcCBmaWxsOlxuICogZmlsbENvbW1hbmQuYml0bWFwKGltZyk7XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEZvciBtb3JlIGRpcmVjdCBjb250cm9sIG9mIHJlbmRlcmluZywgeW91IGNhbiBpbnN0YW50aWF0ZSBhbmQgYXBwZW5kIGNvbW1hbmQgb2JqZWN0cyB0byB0aGUgZ3JhcGhpY3MgcXVldWUgZGlyZWN0bHkuXG4gKiAvLyBJbiB0aGlzIGNhc2UsIHlvdSBuZWVkIHRvIG1hbmFnZSBwYXRoIGNyZWF0aW9uIG1hbnVhbGx5LCBhbmQgZW5zdXJlIHRoYXQgZmlsbC9zdHJva2UgaXMgYXBwbGllZCB0byBhIGRlZmluZWQgcGF0aDpcbiAqXG4gKiAvLyBzdGFydCBhIG5ldyBwYXRoLiBHcmFwaGljcy5iZWdpbkNtZCBpcyBhIHJldXNhYmxlIEJlZ2luUGF0aCBpbnN0YW5jZTpcbiAqIGdyYXBoaWNzLmFwcGVuZChHcmFwaGljcy5iZWdpbkNtZCk7XG4gKiAvLyB3ZSBuZWVkIHRvIGRlZmluZSB0aGUgcGF0aCBiZWZvcmUgYXBwbHlpbmcgdGhlIGZpbGw6XG4gKiBsZXQgY2lyY2xlID0gbmV3IEdyYXBoaWNzLkNpcmNsZSgwLDAsMzApO1xuICogZ3JhcGhpY3MuYXBwZW5kKGNpcmNsZSk7XG4gKiAvLyBmaWxsIHRoZSBwYXRoIHdlIGp1c3QgZGVmaW5lZDpcbiAqIGxldCBmaWxsID0gbmV3IEdyYXBoaWNzLkZpbGwoXCJyZWRcIik7XG4gKiBncmFwaGljcy5hcHBlbmQoZmlsbCk7XG4gKlxuICogLy8gVGhlc2UgYXBwcm9hY2hlcyBjYW4gYmUgdXNlZCB0b2dldGhlciwgZm9yIGV4YW1wbGUgdG8gaW5zZXJ0IGEgY3VzdG9tIGNvbW1hbmQ6XG4gKiBncmFwaGljcy5iZWdpbkZpbGwoXCJyZWRcIik7XG4gKiBsZXQgY3VzdG9tQ29tbWFuZCA9IG5ldyBDdXN0b21TcGlyYWxDb21tYW5kKGV0Yyk7XG4gKiBncmFwaGljcy5hcHBlbmQoY3VzdG9tQ29tbWFuZCk7XG4gKiBncmFwaGljcy5iZWdpbkZpbGwoXCJibHVlXCIpO1xuICogZ3JhcGhpY3MuZHJhd0NpcmNsZSgwLCAwLCAzMCk7XG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+VXNpbmcgdGhlIFRpbnkgQVBJPC9jYXB0aW9uPlxuICogZ3JhcGhpY3MucyhcInJlZFwiKS5mKFwiYmx1ZVwiKS5yKDIwLCAyMCwgMTAwLCA1MCk7XG4gKlxuICogQHNlZSB7QGxpbmsgZWFzZWxqcy5HcmFwaGljcyNhcHBlbmR9XG4gKiBAbWVtYmVyb2YgZWFzZWxqc1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHcmFwaGljcyB7XG5cblx0Y29uc3RydWN0b3IgKCkge1xuXHRcdC8qKlxuXHRcdCAqIEhvbGRzIGEgcmVmZXJlbmNlIHRvIHRoZSBsYXN0IGNvbW1hbmQgdGhhdCB3YXMgY3JlYXRlZCBvciBhcHBlbmRlZC4gRm9yIGV4YW1wbGUsIHlvdSBjb3VsZCByZXRhaW4gYSByZWZlcmVuY2Vcblx0XHQgKiB0byBhIEZpbGwgY29tbWFuZCBpbiBvcmRlciB0byBkeW5hbWljYWxseSB1cGRhdGUgdGhlIGNvbG9yIGxhdGVyIGJ5IHVzaW5nOlxuXHRcdCAqXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiBsZXQgZmlsbCA9IGdyYXBoaWNzLmJlZ2luRmlsbChcInJlZFwiKS5jb21tYW5kO1xuXHRcdCAqIC8vIHVwZGF0ZSBjb2xvciBsYXRlcjpcblx0XHQgKiBmaWxsLnN0eWxlID0gXCJ5ZWxsb3dcIjtcblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuY29tbWFuZCA9IG51bGw7XG5cblxuXHQvLyBwcml2YXRlIHByb3BlcnRpZXNcblx0XHQvKipcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge2Vhc2VsanMuR3JhcGhpY3MuU3Ryb2tlfVxuXHRcdCAqL1xuXHRcdHRoaXMuX3N0cm9rZSA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge2Vhc2VsanMuR3JhcGhpY3MuU3Ryb2tlU3R5bGV9XG5cdFx0ICovXG5cdFx0dGhpcy5fc3Ryb2tlU3R5bGUgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtlYXNlbGpzLkdyYXBoaWNzLlN0cm9rZVN0eWxlfVxuXHRcdCAqL1xuXHRcdHRoaXMuX29sZFN0cm9rZVN0eWxlID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7ZWFzZWxqcy5HcmFwaGljcy5TdHJva2VEYXNofVxuXHRcdCAqL1xuXHRcdHRoaXMuX3N0cm9rZURhc2ggPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtlYXNlbGpzLkdyYXBoaWNzLlN0cm9rZURhc2h9XG5cdFx0ICovXG5cdFx0dGhpcy5fb2xkU3Ryb2tlRGFzaCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge2Vhc2VsanMuR3JhcGhpY3MuRmlsbH1cblx0XHQgKi9cblx0XHR0aGlzLl9maWxsID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKi9cblx0XHR0aGlzLl9zdHJva2VJZ25vcmVTY2FsZSA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHRoZSBsYXN0IGluc3RydWN0aW9uIGluZGV4IHRoYXQgd2FzIGNvbW1pdHRlZC5cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0dGhpcy5fY29tbWl0SW5kZXggPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHQgKi9cblx0XHR0aGlzLl9pbnN0cnVjdGlvbnMgPSBbXTtcblxuXHRcdC8qKlxuXHRcdCAqIFVuY29tbWl0dGVkIGluc3RydWN0aW9ucy5cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge0FycmF5fVxuXHRcdCAqL1xuXHRcdHRoaXMuX2FjdGl2ZUluc3RydWN0aW9ucyA9IFtdO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhpcyBpbmRpY2F0ZXMgdGhhdCB0aGVyZSBoYXZlIGJlZW4gY2hhbmdlcyB0byB0aGUgYWN0aXZlSW5zdHJ1Y3Rpb24gbGlzdCBzaW5jZSB0aGUgbGFzdCB1cGRhdGVJbnN0cnVjdGlvbnMgY2FsbC5cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKi9cblx0XHR0aGlzLl9kaXJ0eSA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogSW5kZXggdG8gZHJhdyBmcm9tIGlmIGEgc3RvcmUgb3BlcmF0aW9uIGhhcyBoYXBwZW5lZC5cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0dGhpcy5fc3RvcmVJbmRleCA9IDA7XG5cblx0XHQvKipcblx0XHQgKiBNYXBzIHRoZSBmYW1pbGlhciBBY3Rpb25TY3JpcHQgYGN1cnZlVG8oKWAgbWV0aG9kIHRvIHRoZSBmdW5jdGlvbmFsbHkgc2ltaWxhciB7QGxpbmsgZWFzZWxqcy5HcmFwaGljcyNxdWFkcmF0aWNDdXJ2ZVRvfSBtZXRob2QuXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IGNweFxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBjcHlcblx0XHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdFx0ICogQHJldHVybiB7ZWFzZWxqcy5HcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0XHQgKiBAY2hhaW5hYmxlXG5cdFx0ICovXG5cdFx0dGhpcy5jdXJ2ZVRvID0gdGhpcy5xdWFkcmF0aWNDdXJ2ZVRvO1xuXG5cdFx0LyoqXG5cdFx0ICogTWFwcyB0aGUgZmFtaWxpYXIgQWN0aW9uU2NyaXB0IGBkcmF3UmVjdCgpYCBtZXRob2QgdG8gdGhlIGZ1bmN0aW9uYWxseSBzaW1pbGFyIHtAbGluayBlYXNlbGpzLkdyYXBoaWNzI3JlY3R9IG1ldGhvZC5cblx0XHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHcgV2lkdGggb2YgdGhlIHJlY3RhbmdsZVxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBoIEhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlXG5cdFx0ICogQHJldHVybiB7ZWFzZWxqcy5HcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0XHQgKiBAY2hhaW5hYmxlXG5cdFx0ICovXG5cdFx0dGhpcy5kcmF3UmVjdCA9IHRoaXMucmVjdDtcblxuXHRcdC8vIHRpbnkgYXBpXG5cdFx0dGhpcy5tdCA9IHRoaXMubW92ZVRvO1xuXHRcdHRoaXMubHQgPSB0aGlzLmxpbmVUbztcblx0XHR0aGlzLmF0ID0gdGhpcy5hcmNUbztcblx0XHR0aGlzLmJ0ID0gdGhpcy5iZXppZXJDdXJ2ZVRvO1xuXHRcdHRoaXMucXQgPSB0aGlzLnF1YWRyYXRpY0N1cnZlVG87XG5cdFx0dGhpcy5hID0gdGhpcy5hcmM7XG5cdFx0dGhpcy5yID0gdGhpcy5yZWN0O1xuXHRcdHRoaXMuY3AgPSB0aGlzLmNsb3NlUGF0aDtcblx0XHR0aGlzLmMgPSB0aGlzLmNsZWFyO1xuXHRcdHRoaXMuZiA9IHRoaXMuYmVnaW5GaWxsO1xuXHRcdHRoaXMubGYgPSB0aGlzLmJlZ2luTGluZWFyR3JhZGllbnRGaWxsO1xuXHRcdHRoaXMucmYgPSB0aGlzLmJlZ2luUmFkaWFsR3JhZGllbnRGaWxsO1xuXHRcdHRoaXMuYmYgPSB0aGlzLmJlZ2luQml0bWFwRmlsbDtcblx0XHR0aGlzLmVmID0gdGhpcy5lbmRGaWxsO1xuXHRcdHRoaXMuc3MgPSB0aGlzLnNldFN0cm9rZVN0eWxlO1xuXHRcdHRoaXMuc2QgPSB0aGlzLnNldFN0cm9rZURhc2g7XG5cdFx0dGhpcy5zID0gdGhpcy5iZWdpblN0cm9rZTtcblx0XHR0aGlzLmxzID0gdGhpcy5iZWdpbkxpbmVhckdyYWRpZW50U3Ryb2tlO1xuXHRcdHRoaXMucnMgPSB0aGlzLmJlZ2luUmFkaWFsR3JhZGllbnRTdHJva2U7XG5cdFx0dGhpcy5icyA9IHRoaXMuYmVnaW5CaXRtYXBTdHJva2U7XG5cdFx0dGhpcy5lcyA9IHRoaXMuZW5kU3Ryb2tlO1xuXHRcdHRoaXMuZHIgPSB0aGlzLmRyYXdSZWN0O1xuXHRcdHRoaXMucnIgPSB0aGlzLmRyYXdSb3VuZFJlY3Q7XG5cdFx0dGhpcy5yYyA9IHRoaXMuZHJhd1JvdW5kUmVjdENvbXBsZXg7XG5cdFx0dGhpcy5kYyA9IHRoaXMuZHJhd0NpcmNsZTtcblx0XHR0aGlzLmRlID0gdGhpcy5kcmF3RWxsaXBzZTtcblx0XHR0aGlzLmRwID0gdGhpcy5kcmF3UG9seVN0YXI7XG5cdFx0dGhpcy5wID0gdGhpcy5kZWNvZGVQYXRoO1xuXG5cdFx0dGhpcy5jbGVhcigpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBDU1MgY29tcGF0aWJsZSBjb2xvciBzdHJpbmcgYmFzZWQgb24gdGhlIHNwZWNpZmllZCBSR0IgbnVtZXJpYyBjb2xvciB2YWx1ZXMgaW4gdGhlIGZvcm1hdFxuXHQgKiBcInJnYmEoMjU1LDI1NSwyNTUsMS4wKVwiLCBvciBpZiBhbHBoYSBpcyBudWxsIHRoZW4gaW4gdGhlIGZvcm1hdCBcInJnYigyNTUsMjU1LDI1NSlcIi5cblx0ICogSXQgYWxzbyBzdXBwb3J0cyBwYXNzaW5nIGEgc2luZ2xlIGhleCBjb2xvciB2YWx1ZSBhcyB0aGUgZmlyc3QgcGFyYW0sIGFuZCBhbiBvcHRpb25hbCBhbHBoYSB2YWx1ZSBhcyB0aGUgc2Vjb25kXG5cdCAqIHBhcmFtLlxuXHQgKlxuXHQgKiBAZXhhbXBsZVxuXHQgKiBHcmFwaGljcy5nZXRSR0IoNTAsIDEwMCwgMTUwLCAwLjUpOyAvLyByZ2JhKDUwLDEwMCwxNTAsMC41KVxuXHQgKiBHcmFwaGljcy5nZXRSR0IoMHhGRjAwRkYsIDAuMik7IC8vIHJnYmEoMjU1LDAsMjU1LDAuMilcblx0ICpcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge051bWJlcn0gciBUaGUgcmVkIGNvbXBvbmVudCBmb3IgdGhlIGNvbG9yLCBiZXR3ZWVuIDAgYW5kIDB4RkYgKDI1NSkuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBnIFRoZSBncmVlbiBjb21wb25lbnQgZm9yIHRoZSBjb2xvciwgYmV0d2VlbiAwIGFuZCAweEZGICgyNTUpLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gYiBUaGUgYmx1ZSBjb21wb25lbnQgZm9yIHRoZSBjb2xvciwgYmV0d2VlbiAwIGFuZCAweEZGICgyNTUpLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2FscGhhXSBUaGUgYWxwaGEgY29tcG9uZW50IGZvciB0aGUgY29sb3Igd2hlcmUgMCBpcyBmdWxseSB0cmFuc3BhcmVudCBhbmQgMSBpcyBmdWxseSBvcGFxdWUuXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gQSBDU1MgY29tcGF0aWJsZSBjb2xvciBzdHJpbmcgYmFzZWQgb24gdGhlIHNwZWNpZmllZCBSR0IgbnVtZXJpYyBjb2xvciB2YWx1ZXMgaW4gdGhlIGZvcm1hdFxuXHQgKiBcInJnYmEoMjU1LDI1NSwyNTUsMS4wKVwiLCBvciBpZiBhbHBoYSBpcyBudWxsIHRoZW4gaW4gdGhlIGZvcm1hdCBcInJnYigyNTUsMjU1LDI1NSlcIi5cblx0ICovXG5cdHN0YXRpYyBnZXRSR0IgKHIsIGcsIGIsIGFscGhhKSB7XG5cdFx0aWYgKHIgIT0gbnVsbCAmJiBiID09IG51bGwpIHtcblx0XHRcdGFscGhhID0gZztcblx0XHRcdGIgPSByJjB4RkY7XG5cdFx0XHRnID0gcj4+OCYweEZGO1xuXHRcdFx0ciA9IHI+PjE2JjB4RkY7XG5cdFx0fVxuXHRcdGlmIChhbHBoYSA9PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gYHJnYigke3J9LCR7Z30sJHtifSlgO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gYHJnYmEoJHtyfSwke2d9LCR7Yn0sJHthbHBoYX0pYDtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIENTUyBjb21wYXRpYmxlIGNvbG9yIHN0cmluZyBiYXNlZCBvbiB0aGUgc3BlY2lmaWVkIEhTTCBudW1lcmljIGNvbG9yIHZhbHVlcyBpbiB0aGUgZm9ybWF0IFwiaHNsYSgzNjAsMTAwLDEwMCwxLjApXCIsXG5cdCAqIG9yIGlmIGFscGhhIGlzIG51bGwgdGhlbiBpbiB0aGUgZm9ybWF0IFwiaHNsKDM2MCwxMDAsMTAwKVwiLlxuXHQgKlxuXHQgKiBAZXhhbXBsZVxuXHQgKiBHcmFwaGljcy5nZXRIU0woMTUwLCAxMDAsIDcwKTsgLy8gaHNsKDE1MCwxMDAsNzApXG5cdCAqXG5cdCAqIEBzdGF0aWNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGh1ZSBUaGUgaHVlIGNvbXBvbmVudCBmb3IgdGhlIGNvbG9yLCBiZXR3ZWVuIDAgYW5kIDM2MC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHNhdHVyYXRpb24gVGhlIHNhdHVyYXRpb24gY29tcG9uZW50IGZvciB0aGUgY29sb3IsIGJldHdlZW4gMCBhbmQgMTAwLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gbGlnaHRuZXNzIFRoZSBsaWdodG5lc3MgY29tcG9uZW50IGZvciB0aGUgY29sb3IsIGJldHdlZW4gMCBhbmQgMTAwLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2FscGhhXSBUaGUgYWxwaGEgY29tcG9uZW50IGZvciB0aGUgY29sb3Igd2hlcmUgMCBpcyBmdWxseSB0cmFuc3BhcmVudCBhbmQgMSBpcyBmdWxseSBvcGFxdWUuXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gQSBDU1MgY29tcGF0aWJsZSBjb2xvciBzdHJpbmcgYmFzZWQgb24gdGhlIHNwZWNpZmllZCBIU0wgbnVtZXJpYyBjb2xvciB2YWx1ZXMgaW4gdGhlIGZvcm1hdFxuXHQgKiBcImhzbGEoMzYwLDEwMCwxMDAsMS4wKVwiLCBvciBpZiBhbHBoYSBpcyBudWxsIHRoZW4gaW4gdGhlIGZvcm1hdCBcImhzbCgzNjAsMTAwLDEwMClcIi5cblx0ICovXG5cdHN0YXRpYyBnZXRIU0wgKGh1ZSwgc2F0dXJhdGlvbiwgbGlnaHRuZXNzLCBhbHBoYSkge1xuXHRcdGlmIChhbHBoYSA9PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gYGhzbCgke2h1ZSAlIDM2MH0sJHtzYXR1cmF0aW9ufSUsJHtsaWdodG5lc3N9JSlgO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gYGhzbCgke2h1ZSAlIDM2MH0sJHtzYXR1cmF0aW9ufSUsJHtsaWdodG5lc3N9JSwke2FscGhhfSlgO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBncmFwaGljcyBpbnN0cnVjdGlvbnMgYXJyYXkuIEVhY2ggZW50cnkgaXMgYSBncmFwaGljcyBjb21tYW5kIG9iamVjdCAoZXguIEdyYXBoaWNzLkZpbGwsIEdyYXBoaWNzLlJlY3QpXG5cdCAqIE1vZGlmeWluZyB0aGUgcmV0dXJuZWQgYXJyYXkgZGlyZWN0bHkgaXMgbm90IHJlY29tbWVuZGVkLCBhbmQgaXMgbGlrZWx5IHRvIHJlc3VsdCBpbiB1bmV4cGVjdGVkIGJlaGF2aW91ci5cblx0ICpcblx0ICogVGhpcyBwcm9wZXJ0eSBpcyBtYWlubHkgaW50ZW5kZWQgZm9yIGludHJvc3BlY3Rpb24gb2YgdGhlIGluc3RydWN0aW9ucyAoZXguIGZvciBncmFwaGljcyBleHBvcnQpLlxuXHQgKiBAdHlwZSB7QXJyYXl9XG5cdCAqIEByZWFkb25seVxuXHQgKi9cblx0Z2V0IGluc3RydWN0aW9ucyAoKSB7XG5cdFx0dGhpcy5fdXBkYXRlSW5zdHJ1Y3Rpb25zKCk7XG5cdFx0cmV0dXJuIHRoaXMuX2luc3RydWN0aW9ucztcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBHcmFwaGljcyBpbnN0YW5jZSBoYXMgbm8gZHJhd2luZyBjb21tYW5kcy5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoaXMgR3JhcGhpY3MgaW5zdGFuY2UgaGFzIG5vIGRyYXdpbmcgY29tbWFuZHMuXG5cdCAqL1xuXHRpc0VtcHR5ICgpIHtcblx0XHRyZXR1cm4gISh0aGlzLl9pbnN0cnVjdGlvbnMubGVuZ3RoIHx8IHRoaXMuX2FjdGl2ZUluc3RydWN0aW9ucy5sZW5ndGgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIERyYXdzIHRoZSBkaXNwbGF5IG9iamVjdCBpbnRvIHRoZSBzcGVjaWZpZWQgY29udGV4dCBpZ25vcmluZyBpdHMgdmlzaWJsZSwgYWxwaGEsIHNoYWRvdywgYW5kIHRyYW5zZm9ybS5cblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSBkcmF3IHdhcyBoYW5kbGVkICh1c2VmdWwgZm9yIG92ZXJyaWRpbmcgZnVuY3Rpb25hbGl0eSkuXG5cdCAqXG5cdCAqIE5PVEU6IFRoaXMgbWV0aG9kIGlzIG1haW5seSBmb3IgaW50ZXJuYWwgdXNlLCB0aG91Z2ggaXQgbWF5IGJlIHVzZWZ1bCBmb3IgYWR2YW5jZWQgdXNlcy5cblx0ICpcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBUaGUgY2FudmFzIDJEIGNvbnRleHQgb2JqZWN0IHRvIGRyYXcgaW50by5cblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGEgT3B0aW9uYWwgZGF0YSB0aGF0IGlzIHBhc3NlZCB0byBncmFwaGljcyBjb21tYW5kIGV4ZWMgbWV0aG9kcy4gV2hlbiBjYWxsZWQgZnJvbSBhIFNoYXBlIGluc3RhbmNlLCB0aGUgc2hhcGUgcGFzc2VzIGl0c2VsZiBhcyB0aGUgZGF0YSBwYXJhbWV0ZXIuIFRoaXMgY2FuIGJlIHVzZWQgYnkgY3VzdG9tIGdyYXBoaWMgY29tbWFuZHMgdG8gaW5zZXJ0IGNvbnRleHR1YWwgZGF0YS5cblx0ICovXG5cdGRyYXcgKGN0eCwgZGF0YSkge1xuXHRcdHRoaXMuX3VwZGF0ZUluc3RydWN0aW9ucygpO1xuXHRcdGxldCBpbnN0ciA9IHRoaXMuX2luc3RydWN0aW9ucztcblx0XHRjb25zdCBsID0gaW5zdHIubGVuZ3RoO1xuXHRcdGZvciAobGV0IGkgPSB0aGlzLl9zdG9yZUluZGV4OyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRpbnN0cltpXS5leGVjKGN0eCwgZGF0YSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIERyYXdzIG9ubHkgdGhlIHBhdGggZGVzY3JpYmVkIGZvciB0aGlzIEdyYXBoaWNzIGluc3RhbmNlLCBza2lwcGluZyBhbnkgbm9uLXBhdGggaW5zdHJ1Y3Rpb25zLCBpbmNsdWRpbmcgZmlsbCBhbmRcblx0ICogc3Ryb2tlIGRlc2NyaXB0aW9ucy4gVXNlZCBmb3IgYERpc3BsYXlPYmplY3QubWFza2AgdG8gZHJhdyB0aGUgY2xpcHBpbmcgcGF0aCwgZm9yIGV4YW1wbGUuXG5cdCAqXG5cdCAqIE5PVEU6IFRoaXMgbWV0aG9kIGlzIG1haW5seSBmb3IgaW50ZXJuYWwgdXNlLCB0aG91Z2ggaXQgbWF5IGJlIHVzZWZ1bCBmb3IgYWR2YW5jZWQgdXNlcy5cblx0ICpcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBUaGUgY2FudmFzIDJEIGNvbnRleHQgb2JqZWN0IHRvIGRyYXcgaW50by5cblx0ICovXG5cdGRyYXdBc1BhdGggKGN0eCkge1xuXHRcdHRoaXMuX3VwZGF0ZUluc3RydWN0aW9ucygpO1xuXHRcdGxldCBpbnN0ciwgaW5zdHJzID0gdGhpcy5faW5zdHJ1Y3Rpb25zO1xuXHRcdGNvbnN0IGwgPSBpbnN0cnMubGVuZ3RoO1xuXHRcdGZvciAobGV0IGkgPSB0aGlzLl9zdG9yZUluZGV4OyBpIDwgbDsgaSsrKSB7XG5cdFx0XHQvLyB0aGUgZmlyc3QgY29tbWFuZCBpcyBhbHdheXMgYSBiZWdpblBhdGggY29tbWFuZC5cblx0XHRcdGlmICgoaW5zdHIgPSBpbnN0cnNbaV0pLnBhdGggIT09IGZhbHNlKSB7IGluc3RyLmV4ZWMoY3R4KTsgfVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBNb3ZlcyB0aGUgZHJhd2luZyBwb2ludCB0byB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uLlxuXHQgKiBBIHRpbnkgQVBJIG1ldGhvZCBcIm10XCIgYWxzbyBleGlzdHMuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IGNvb3JkaW5hdGUgdGhlIGRyYXdpbmcgcG9pbnQgc2hvdWxkIG1vdmUgdG8uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IGNvb3JkaW5hdGUgdGhlIGRyYXdpbmcgcG9pbnQgc2hvdWxkIG1vdmUgdG8uXG5cdCAqIEByZXR1cm4ge2Vhc2VsanMuR3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscykuXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdG1vdmVUbyAoeCwgeSkge1xuXHRcdHJldHVybiB0aGlzLmFwcGVuZChuZXcgTW92ZVRvKHgseSksIHRydWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIERyYXdzIGEgbGluZSBmcm9tIHRoZSBjdXJyZW50IGRyYXdpbmcgcG9pbnQgdG8gdGhlIHNwZWNpZmllZCBwb3NpdGlvbiwgd2hpY2ggYmVjb21lIHRoZSBuZXcgY3VycmVudCBkcmF3aW5nXG5cdCAqIHBvaW50LiBOb3RlIHRoYXQgeW91ICptdXN0KiBjYWxsIHtAbGluayBlYXNlbGpzLkdyYXBoaWNzI21vdmVUb30gYmVmb3JlIHRoZSBmaXJzdCBgbGluZVRvKClgLlxuXHQgKiBBIHRpbnkgQVBJIG1ldGhvZCBcImx0XCIgYWxzbyBleGlzdHMuXG5cdCAqIEBzZWUge0BsaW5rIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3RoZS1jYW52YXMtZWxlbWVudC5odG1sI2NvbXBsZXgtc2hhcGVzLShwYXRocykgXCJXSEFUV0cgc3BlY1wifVxuXHQgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgeCBjb29yZGluYXRlIHRoZSBkcmF3aW5nIHBvaW50IHNob3VsZCBkcmF3IHRvLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgeSBjb29yZGluYXRlIHRoZSBkcmF3aW5nIHBvaW50IHNob3VsZCBkcmF3IHRvLlxuXHQgKiBAcmV0dXJuIHtlYXNlbGpzLkdyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRsaW5lVG8gKHgsIHkpIHtcblx0XHRyZXR1cm4gdGhpcy5hcHBlbmQobmV3IExpbmVUbyh4LHkpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEcmF3cyBhbiBhcmMgd2l0aCB0aGUgc3BlY2lmaWVkIGNvbnRyb2wgcG9pbnRzIGFuZCByYWRpdXMuXG5cdCAqIEEgdGlueSBBUEkgbWV0aG9kIFwiYXRcIiBhbHNvIGV4aXN0cy5cblx0ICogQHNlZSB7QGxpbmsgaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLWNhbnZhcy1lbGVtZW50Lmh0bWwjZG9tLWNvbnRleHQtMmQtYXJjdG8gXCJXSEFUV0cgc3BlY1wifVxuXHQgKiBAcGFyYW0ge051bWJlcn0geDFcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkxXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MlxuXHQgKiBAcGFyYW0ge051bWJlcn0geTJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c1xuXHQgKiBAcmV0dXJuIHtlYXNlbGpzLkdyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRhcmNUbyAoeDEsIHkxLCB4MiwgeTIsIHJhZGl1cykge1xuXHRcdHJldHVybiB0aGlzLmFwcGVuZChuZXcgQXJjVG8oeDEsIHkxLCB4MiwgeTIsIHJhZGl1cykpO1xuXHR9XG5cblx0LyoqXG5cdCAqIERyYXdzIGFuIGFyYyBkZWZpbmVkIGJ5IHRoZSByYWRpdXMsIHN0YXJ0QW5nbGUgYW5kIGVuZEFuZ2xlIGFyZ3VtZW50cywgY2VudGVyZWQgYXQgdGhlIHBvc2l0aW9uICh4LCB5KS5cblx0ICogQSB0aW55IEFQSSBtZXRob2QgXCJhXCIgYWxzbyBleGlzdHMuXG5cdCAqXG5cdCAqIEBleGFtcGxlXG5cdCAqIC8vIGRyYXcgYSBmdWxsIGNpcmNsZSB3aXRoIGEgcmFkaXVzIG9mIDIwIGNlbnRlcmVkIGF0ICgxMDAsIDEwMClcblx0ICogYXJjKDEwMCwgMTAwLCAyMCwgMCwgTWF0aC5QSSoyKTtcblx0ICpcblx0ICogQHNlZSB7QGxpbmsgaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLWNhbnZhcy1lbGVtZW50Lmh0bWwjZG9tLWNvbnRleHQtMmQtYXJjIFwiV0hBVFdHIHNwZWNcIn1cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c1xuXHQgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRBbmdsZSBNZWFzdXJlZCBpbiByYWRpYW5zLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gZW5kQW5nbGUgTWVhc3VyZWQgaW4gcmFkaWFucy5cblx0ICogQHBhcmFtIHtCb29sZWFufSBhbnRpY2xvY2t3aXNlXG5cdCAqIEByZXR1cm4ge2Vhc2VsanMuR3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdGFyYyAoeCwgeSwgcmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSkge1xuXHRcdHJldHVybiB0aGlzLmFwcGVuZChuZXcgQXJjKHgsIHksIHJhZGl1cywgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEcmF3cyBhIHF1YWRyYXRpYyBjdXJ2ZSBmcm9tIHRoZSBjdXJyZW50IGRyYXdpbmcgcG9pbnQgdG8gKHgsIHkpIHVzaW5nIHRoZSBjb250cm9sIHBvaW50IChjcHgsIGNweSkuXG5cdCAqIEEgdGlueSBBUEkgbWV0aG9kIFwicXRcIiBhbHNvIGV4aXN0cy5cblx0ICogQHNlZSB7QGxpbmsgaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLWNhbnZhcy1lbGVtZW50Lmh0bWwjZG9tLWNvbnRleHQtMmQtcXVhZHJhdGljY3VydmV0byBcIldIQVRXRyBzcGVjXCJ9XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjcHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNweVxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcmV0dXJuIHtlYXNlbGpzLkdyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRxdWFkcmF0aWNDdXJ2ZVRvIChjcHgsIGNweSwgeCwgeSkge1xuXHRcdHJldHVybiB0aGlzLmFwcGVuZChuZXcgUXVhZHJhdGljQ3VydmVUbyhjcHgsIGNweSwgeCwgeSkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIERyYXdzIGEgYmV6aWVyIGN1cnZlIGZyb20gdGhlIGN1cnJlbnQgZHJhd2luZyBwb2ludCB0byAoeCwgeSkgdXNpbmcgdGhlIGNvbnRyb2wgcG9pbnRzIChjcDF4LCBjcDF5KSBhbmQgKGNwMngsIGNwMnkpLlxuXHQgKiBBIHRpbnkgQVBJIG1ldGhvZCBcImJ0XCIgYWxzbyBleGlzdHMuXG5cdCAqIEBzZWUge0BsaW5rIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3RoZS1jYW52YXMtZWxlbWVudC5odG1sI2RvbS1jb250ZXh0LTJkLWJlemllcmN1cnZldG8gXCJXSEFUV0cgc3BlY1wifVxuXHQgKiBAcGFyYW0ge051bWJlcn0gY3AxeFxuXHQgKiBAcGFyYW0ge051bWJlcn0gY3AxeVxuXHQgKiBAcGFyYW0ge051bWJlcn0gY3AyeFxuXHQgKiBAcGFyYW0ge051bWJlcn0gY3AyeVxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcmV0dXJuIHtlYXNlbGpzLkdyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRiZXppZXJDdXJ2ZVRvIChjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCB4LCB5KSB7XG5cdFx0cmV0dXJuIHRoaXMuYXBwZW5kKG5ldyBCZXppZXJDdXJ2ZVRvKGNwMXgsIGNwMXksIGNwMngsIGNwMnksIHgsIHkpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEcmF3cyBhIHJlY3RhbmdsZSBhdCAoeCwgeSkgd2l0aCB0aGUgc3BlY2lmaWVkIHdpZHRoIGFuZCBoZWlnaHQgdXNpbmcgdGhlIGN1cnJlbnQgZmlsbCBhbmQvb3Igc3Ryb2tlLlxuXHQgKiBBIHRpbnkgQVBJIG1ldGhvZCBcInJcIiBhbHNvIGV4aXN0cy5cblx0ICogQHNlZSB7QGxpbmsgaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLWNhbnZhcy1lbGVtZW50Lmh0bWwjZG9tLWNvbnRleHQtMmQtcmVjdCBcIldIQVRXRyBzcGVjXCJ9XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB3IFdpZHRoIG9mIHRoZSByZWN0YW5nbGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGggSGVpZ2h0IG9mIHRoZSByZWN0YW5nbGVcblx0ICogQHJldHVybiB7ZWFzZWxqcy5HcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0cmVjdCAoeCwgeSwgdywgaCkge1xuXHRcdHJldHVybiB0aGlzLmFwcGVuZChuZXcgUmVjdCh4LCB5LCB3LCBoKSk7XG5cdH1cblxuXHQvKipcblx0ICogQ2xvc2VzIHRoZSBjdXJyZW50IHBhdGgsIGVmZmVjdGl2ZWx5IGRyYXdpbmcgYSBsaW5lIGZyb20gdGhlIGN1cnJlbnQgZHJhd2luZyBwb2ludCB0byB0aGUgZmlyc3QgZHJhd2luZyBwb2ludCBzcGVjaWZpZWRcblx0ICogc2luY2UgdGhlIGZpbGwgb3Igc3Ryb2tlIHdhcyBsYXN0IHNldC5cblx0ICogQSB0aW55IEFQSSBtZXRob2QgXCJjcFwiIGFsc28gZXhpc3RzLlxuXHQgKiBAcmV0dXJuIHtlYXNlbGpzLkdyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRjbG9zZVBhdGggKCkge1xuXHRcdHJldHVybiB0aGlzLl9hY3RpdmVJbnN0cnVjdGlvbnMubGVuZ3RoID8gdGhpcy5hcHBlbmQobmV3IENsb3NlUGF0aCgpKSA6IHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQ2xlYXJzIGFsbCBkcmF3aW5nIGluc3RydWN0aW9ucywgZWZmZWN0aXZlbHkgcmVzZXR0aW5nIHRoaXMgR3JhcGhpY3MgaW5zdGFuY2UuIEFueSBsaW5lIGFuZCBmaWxsIHN0eWxlcyB3aWxsIG5lZWRcblx0ICogdG8gYmUgcmVkZWZpbmVkIHRvIGRyYXcgc2hhcGVzIGZvbGxvd2luZyBhIGNsZWFyIGNhbGwuXG5cdCAqIEEgdGlueSBBUEkgbWV0aG9kIFwiY1wiIGFsc28gZXhpc3RzLlxuXHQgKiBAcmV0dXJuIHtlYXNlbGpzLkdyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRjbGVhciAoKSB7XG5cdFx0dGhpcy5faW5zdHJ1Y3Rpb25zLmxlbmd0aCA9IHRoaXMuX2FjdGl2ZUluc3RydWN0aW9ucy5sZW5ndGggPSB0aGlzLl9jb21taXRJbmRleCA9IDA7XG5cdFx0dGhpcy5fc3Ryb2tlU3R5bGUgPSB0aGlzLl9vbGRTdHJva2VTdHlsZSA9IHRoaXMuX3N0cm9rZSA9IHRoaXMuX2ZpbGwgPSB0aGlzLl9zdHJva2VEYXNoID0gdGhpcy5fb2xkU3Ryb2tlRGFzaCA9IG51bGw7XG5cdFx0dGhpcy5fZGlydHkgPSB0aGlzLl9zdHJva2VJZ25vcmVTY2FsZSA9IGZhbHNlO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEJlZ2lucyBhIGZpbGwgd2l0aCB0aGUgc3BlY2lmaWVkIGNvbG9yLiBUaGlzIGVuZHMgdGhlIGN1cnJlbnQgc3ViLXBhdGguXG5cdCAqIEEgdGlueSBBUEkgbWV0aG9kIFwiZlwiIGFsc28gZXhpc3RzLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gY29sb3IgQSBDU1MgY29tcGF0aWJsZSBjb2xvciB2YWx1ZSAoZXguIFwicmVkXCIsIFwiI0ZGMDAwMFwiLCBvciBcInJnYmEoMjU1LDAsMCwwLjUpXCIpLiBTZXR0aW5nIHRvXG5cdCAqIG51bGwgd2lsbCByZXN1bHQgaW4gbm8gZmlsbC5cblx0ICogQHJldHVybiB7ZWFzZWxqcy5HcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0YmVnaW5GaWxsIChjb2xvcikge1xuXHRcdHJldHVybiB0aGlzLl9zZXRGaWxsKGNvbG9yID8gbmV3IEZpbGwoY29sb3IpIDogbnVsbCk7XG5cdH1cblxuXHQvKipcblx0ICogQmVnaW5zIGEgbGluZWFyIGdyYWRpZW50IGZpbGwgZGVmaW5lZCBieSB0aGUgbGluZSAoeDAsIHkwKSB0byAoeDEsIHkxKS5cblx0ICogQSB0aW55IEFQSSBtZXRob2QgXCJsZlwiIGFsc28gZXhpc3RzLlxuXHQgKlxuXHQgKiBAZXhhbXBsZSA8Y2FwdGlvbj5EZWZpbmUgYSBibGFjayB0byB3aGl0ZSB2ZXJ0aWNhbCBncmFkaWVudCByYW5naW5nIGZyb20gMjBweCB0byAxMjBweCwgYW5kIGRyYXcgYSBzcXVhcmUgdG8gZGlzcGxheSBpdDwvY2FwdGlvbj5cblx0ICogZ3JhcGhpY3MuYmVnaW5MaW5lYXJHcmFkaWVudEZpbGwoW1wiIzAwMFwiLFwiI0ZGRlwiXSwgWzAsIDFdLCAwLCAyMCwgMCwgMTIwKS5kcmF3UmVjdCgyMCwgMjAsIDEyMCwgMTIwKTtcblx0ICpcblx0ICogQHBhcmFtIHtBcnJheX0gY29sb3JzIEFuIGFycmF5IG9mIENTUyBjb21wYXRpYmxlIGNvbG9yIHZhbHVlcy4gRm9yIGV4YW1wbGUsIFtcIiNGMDBcIixcIiMwMEZcIl0gd291bGQgZGVmaW5lIGEgZ3JhZGllbnRcblx0ICogZHJhd2luZyBmcm9tIHJlZCB0byBibHVlLlxuXHQgKiBAcGFyYW0ge0FycmF5fSByYXRpb3MgQW4gYXJyYXkgb2YgZ3JhZGllbnQgcG9zaXRpb25zIHdoaWNoIGNvcnJlc3BvbmQgdG8gdGhlIGNvbG9ycy4gRm9yIGV4YW1wbGUsIFswLjEsIDAuOV0gd291bGQgZHJhd1xuXHQgKiB0aGUgZmlyc3QgY29sb3IgdG8gMTAlIHRoZW4gaW50ZXJwb2xhdGluZyB0byB0aGUgc2Vjb25kIGNvbG9yIGF0IDkwJS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgwIFRoZSBwb3NpdGlvbiBvZiB0aGUgZmlyc3QgcG9pbnQgZGVmaW5pbmcgdGhlIGxpbmUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudCBkaXJlY3Rpb24gYW5kIHNpemUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MCBUaGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IHBvaW50IGRlZmluaW5nIHRoZSBsaW5lIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQgZGlyZWN0aW9uIGFuZCBzaXplLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geDEgVGhlIHBvc2l0aW9uIG9mIHRoZSBzZWNvbmQgcG9pbnQgZGVmaW5pbmcgdGhlIGxpbmUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudCBkaXJlY3Rpb24gYW5kIHNpemUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MSBUaGUgcG9zaXRpb24gb2YgdGhlIHNlY29uZCBwb2ludCBkZWZpbmluZyB0aGUgbGluZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50IGRpcmVjdGlvbiBhbmQgc2l6ZS5cblx0ICogQHJldHVybiB7ZWFzZWxqcy5HcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0YmVnaW5MaW5lYXJHcmFkaWVudEZpbGwgKGNvbG9ycywgcmF0aW9zLCB4MCwgeTAsIHgxLCB5MSkge1xuXHRcdHJldHVybiB0aGlzLl9zZXRGaWxsKG5ldyBGaWxsKCkubGluZWFyR3JhZGllbnQoY29sb3JzLCByYXRpb3MsIHgwLCB5MCwgeDEsIHkxKSk7XG5cdH1cblxuXHQvKipcblx0ICogQmVnaW5zIGEgcmFkaWFsIGdyYWRpZW50IGZpbGwuIFRoaXMgZW5kcyB0aGUgY3VycmVudCBzdWItcGF0aC5cblx0ICogQSB0aW55IEFQSSBtZXRob2QgXCJyZlwiIGFsc28gZXhpc3RzLlxuXHQgKlxuXHQgKiBAZXhhbXBsZSA8Y2FwdGlvbj5EZWZpbmUgYSByZWQgdG8gYmx1ZSByYWRpYWwgZ3JhZGllbnQgY2VudGVyZWQgYXQgKDEwMCwgMTAwKSwgd2l0aCBhIHJhZGl1cyBvZiA1MCwgYW5kIGRyYXcgYSBjaXJjbGUgdG8gZGlzcGxheSBpdDwvY2FwdGlvbj5cblx0ICogZ3JhcGhpY3MuYmVnaW5SYWRpYWxHcmFkaWVudEZpbGwoW1wiI0YwMFwiLFwiIzAwRlwiXSwgWzAsIDFdLCAxMDAsIDEwMCwgMCwgMTAwLCAxMDAsIDUwKS5kcmF3Q2lyY2xlKDEwMCwgMTAwLCA1MCk7XG5cdCAqXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvbG9ycyBBbiBhcnJheSBvZiBDU1MgY29tcGF0aWJsZSBjb2xvciB2YWx1ZXMuIEZvciBleGFtcGxlLCBbXCIjRjAwXCIsXCIjMDBGXCJdIHdvdWxkIGRlZmluZVxuXHQgKiBhIGdyYWRpZW50IGRyYXdpbmcgZnJvbSByZWQgdG8gYmx1ZS5cblx0ICogQHBhcmFtIHtBcnJheX0gcmF0aW9zIEFuIGFycmF5IG9mIGdyYWRpZW50IHBvc2l0aW9ucyB3aGljaCBjb3JyZXNwb25kIHRvIHRoZSBjb2xvcnMuIEZvciBleGFtcGxlLCBbMC4xLFxuXHQgKiAwLjldIHdvdWxkIGRyYXcgdGhlIGZpcnN0IGNvbG9yIHRvIDEwJSB0aGVuIGludGVycG9sYXRpbmcgdG8gdGhlIHNlY29uZCBjb2xvciBhdCA5MCUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MCBDZW50ZXIgcG9zaXRpb24gb2YgdGhlIGlubmVyIGNpcmNsZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50LlxuXHQgKiBAcGFyYW0ge051bWJlcn0geTAgQ2VudGVyIHBvc2l0aW9uIG9mIHRoZSBpbm5lciBjaXJjbGUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHIwIFJhZGl1cyBvZiB0aGUgaW5uZXIgY2lyY2xlIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MSBDZW50ZXIgcG9zaXRpb24gb2YgdGhlIG91dGVyIGNpcmNsZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50LlxuXHQgKiBAcGFyYW0ge051bWJlcn0geTEgQ2VudGVyIHBvc2l0aW9uIG9mIHRoZSBvdXRlciBjaXJjbGUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHIxIFJhZGl1cyBvZiB0aGUgb3V0ZXIgY2lyY2xlIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQuXG5cdCAqIEByZXR1cm4ge2Vhc2VsanMuR3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdGJlZ2luUmFkaWFsR3JhZGllbnRGaWxsIChjb2xvcnMsIHJhdGlvcywgeDAsIHkwLCByMCwgeDEsIHkxLCByMSkge1xuXHRcdHJldHVybiB0aGlzLl9zZXRGaWxsKG5ldyBGaWxsKCkucmFkaWFsR3JhZGllbnQoY29sb3JzLCByYXRpb3MsIHgwLCB5MCwgcjAsIHgxLCB5MSwgcjEpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCZWdpbnMgYSBwYXR0ZXJuIGZpbGwgdXNpbmcgdGhlIHNwZWNpZmllZCBpbWFnZS4gVGhpcyBlbmRzIHRoZSBjdXJyZW50IHN1Yi1wYXRoLlxuXHQgKiBBIHRpbnkgQVBJIG1ldGhvZCBcImJmXCIgYWxzbyBleGlzdHMuXG5cdCAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudCB8IEhUTUxDYW52YXNFbGVtZW50IHwgSFRNTFZpZGVvRWxlbWVudH0gaW1hZ2UgVGhlIEltYWdlLCBDYW52YXMsIG9yIFZpZGVvIG9iamVjdCB0byB1c2Vcblx0ICogYXMgdGhlIHBhdHRlcm4uIE11c3QgYmUgbG9hZGVkIHByaW9yIHRvIGNyZWF0aW5nIGEgYml0bWFwIGZpbGwsIG9yIHRoZSBmaWxsIHdpbGwgYmUgZW1wdHkuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSByZXBldGl0aW9uIE9wdGlvbmFsLiBJbmRpY2F0ZXMgd2hldGhlciB0byByZXBlYXQgdGhlIGltYWdlIGluIHRoZSBmaWxsIGFyZWEuIE9uZSBvZiBcInJlcGVhdFwiLFxuXHQgKiBcInJlcGVhdC14XCIsIFwicmVwZWF0LXlcIiwgb3IgXCJuby1yZXBlYXRcIi4gRGVmYXVsdHMgdG8gXCJyZXBlYXRcIi4gTm90ZSB0aGF0IEZpcmVmb3ggZG9lcyBub3Qgc3VwcG9ydCBcInJlcGVhdC14XCIgb3Jcblx0ICogXCJyZXBlYXQteVwiIChsYXRlc3QgdGVzdHMgd2VyZSBpbiBGRiAyMC4wKSwgYW5kIHdpbGwgZGVmYXVsdCB0byBcInJlcGVhdFwiLlxuXHQgKiBAcGFyYW0ge2Vhc2VsanMuTWF0cml4MkR9IG1hdHJpeCBPcHRpb25hbC4gU3BlY2lmaWVzIGEgdHJhbnNmb3JtYXRpb24gbWF0cml4IGZvciB0aGUgYml0bWFwIGZpbGwuIFRoaXMgdHJhbnNmb3JtYXRpb25cblx0ICogd2lsbCBiZSBhcHBsaWVkIHJlbGF0aXZlIHRvIHRoZSBwYXJlbnQgdHJhbnNmb3JtLlxuXHQgKiBAcmV0dXJuIHtlYXNlbGpzLkdyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRiZWdpbkJpdG1hcEZpbGwgKGltYWdlLCByZXBldGl0aW9uLCBtYXRyaXgpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2V0RmlsbChuZXcgRmlsbChudWxsLCBtYXRyaXgpLmJpdG1hcChpbWFnZSwgcmVwZXRpdGlvbikpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEVuZHMgdGhlIGN1cnJlbnQgc3ViLXBhdGgsIGFuZCBiZWdpbnMgYSBuZXcgb25lIHdpdGggbm8gZmlsbC4gRnVuY3Rpb25hbGx5IGlkZW50aWNhbCB0byBgYmVnaW5GaWxsKG51bGwpYC5cblx0ICogQSB0aW55IEFQSSBtZXRob2QgXCJlZlwiIGFsc28gZXhpc3RzLlxuXHQgKiBAcmV0dXJuIHtlYXNlbGpzLkdyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRlbmRGaWxsICgpIHtcblx0XHRyZXR1cm4gdGhpcy5iZWdpbkZpbGwoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBzdHJva2Ugc3R5bGUuXG5cdCAqIEEgdGlueSBBUEkgbWV0aG9kIFwic3NcIiBhbHNvIGV4aXN0cy5cblx0ICpcblx0ICogQGV4YW1wbGVcblx0ICogZ3JhcGhpY3Muc2V0U3Ryb2tlU3R5bGUoOCxcInJvdW5kXCIpLmJlZ2luU3Ryb2tlKFwiI0YwMFwiKTtcblx0ICpcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRoaWNrbmVzcyBUaGUgd2lkdGggb2YgdGhlIHN0cm9rZS5cblx0ICogQHBhcmFtIHtTdHJpbmcgfCBOdW1iZXJ9IFtjYXBzPTBdIEluZGljYXRlcyB0aGUgdHlwZSBvZiBjYXBzIHRvIHVzZSBhdCB0aGUgZW5kIG9mIGxpbmVzLiBPbmUgb2YgYnV0dCxcblx0ICogcm91bmQsIG9yIHNxdWFyZS4gRGVmYXVsdHMgdG8gXCJidXR0XCIuIEFsc28gYWNjZXB0cyB0aGUgdmFsdWVzIDAgKGJ1dHQpLCAxIChyb3VuZCksIGFuZCAyIChzcXVhcmUpIGZvciB1c2Ugd2l0aFxuXHQgKiB0aGUgdGlueSBBUEkuXG5cdCAqIEBwYXJhbSB7U3RyaW5nIHwgTnVtYmVyfSBbam9pbnRzPTBdIFNwZWNpZmllcyB0aGUgdHlwZSBvZiBqb2ludHMgdGhhdCBzaG91bGQgYmUgdXNlZCB3aGVyZSB0d28gbGluZXMgbWVldC5cblx0ICogT25lIG9mIGJldmVsLCByb3VuZCwgb3IgbWl0ZXIuIERlZmF1bHRzIHRvIFwibWl0ZXJcIi4gQWxzbyBhY2NlcHRzIHRoZSB2YWx1ZXMgMCAobWl0ZXIpLCAxIChyb3VuZCksIGFuZCAyIChiZXZlbClcblx0ICogZm9yIHVzZSB3aXRoIHRoZSB0aW55IEFQSS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFttaXRlckxpbWl0PTEwXSBJZiBqb2ludHMgaXMgc2V0IHRvIFwibWl0ZXJcIiwgdGhlbiB5b3UgY2FuIHNwZWNpZnkgYSBtaXRlciBsaW1pdCByYXRpbyB3aGljaFxuXHQgKiBjb250cm9scyBhdCB3aGF0IHBvaW50IGEgbWl0ZXJlZCBqb2ludCB3aWxsIGJlIGNsaXBwZWQuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lnbm9yZVNjYWxlPWZhbHNlXSBJZiB0cnVlLCB0aGUgc3Ryb2tlIHdpbGwgYmUgZHJhd24gYXQgdGhlIHNwZWNpZmllZCB0aGlja25lc3MgcmVnYXJkbGVzc1xuXHQgKiBvZiBhY3RpdmUgdHJhbnNmb3JtYXRpb25zLlxuXHQgKiBAcmV0dXJuIHtlYXNlbGpzLkdyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRzZXRTdHJva2VTdHlsZSAodGhpY2tuZXNzLCBjYXBzID0gMCwgam9pbnRzID0gMCwgbWl0ZXJMaW1pdCA9IDEwLCBpZ25vcmVTY2FsZSA9IGZhbHNlKSB7XG5cdFx0dGhpcy5fdXBkYXRlSW5zdHJ1Y3Rpb25zKHRydWUpO1xuXHRcdHRoaXMuX3N0cm9rZVN0eWxlID0gdGhpcy5jb21tYW5kID0gbmV3IFN0cm9rZVN0eWxlKHRoaWNrbmVzcywgY2Fwcywgam9pbnRzLCBtaXRlckxpbWl0LCBpZ25vcmVTY2FsZSk7XG5cblx0XHQvLyBpZ25vcmVTY2FsZSBsaXZlcyBvbiBTdHJva2UsIG5vdCBTdHJva2VTdHlsZSwgc28gd2UgZG8gYSBsaXR0bGUgdHJpY2tlcnk6XG5cdFx0aWYgKHRoaXMuX3N0cm9rZSkgeyB0aGlzLl9zdHJva2UuaWdub3JlU2NhbGUgPSBpZ25vcmVTY2FsZTsgfVxuXHRcdHRoaXMuX3N0cm9rZUlnbm9yZVNjYWxlID0gaWdub3JlU2NhbGU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyBvciBjbGVhcnMgdGhlIHN0cm9rZSBkYXNoIHBhdHRlcm4uXG5cdCAqIEEgdGlueSBBUEkgbWV0aG9kIGBzZGAgYWxzbyBleGlzdHMuXG5cdCAqXG5cdCAqIEBleGFtcGxlXG5cdCAqIGdyYXBoaWNzLnNldFN0cm9rZURhc2goWzIwLCAxMF0sIDApO1xuXHQgKlxuXHQgKiBAcGFyYW0ge0FycmF5fSBbc2VnbWVudHNdIEFuIGFycmF5IHNwZWNpZnlpbmcgdGhlIGRhc2ggcGF0dGVybiwgYWx0ZXJuYXRpbmcgYmV0d2VlbiBsaW5lIGFuZCBnYXAuXG5cdCAqIEZvciBleGFtcGxlLCBgWzIwLDEwXWAgd291bGQgY3JlYXRlIGEgcGF0dGVybiBvZiAyMCBwaXhlbCBsaW5lcyB3aXRoIDEwIHBpeGVsIGdhcHMgYmV0d2VlbiB0aGVtLlxuXHQgKiBQYXNzaW5nIG51bGwgb3IgYW4gZW1wdHkgYXJyYXkgd2lsbCBjbGVhciB0aGUgZXhpc3Rpbmcgc3Ryb2tlIGRhc2guXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbb2Zmc2V0PTBdIFRoZSBvZmZzZXQgb2YgdGhlIGRhc2ggcGF0dGVybi4gRm9yIGV4YW1wbGUsIHlvdSBjb3VsZCBpbmNyZW1lbnQgdGhpcyB2YWx1ZSB0byBjcmVhdGUgYSBcIm1hcmNoaW5nIGFudHNcIiBlZmZlY3QuXG5cdCAqIEByZXR1cm4ge2Vhc2VsanMuR3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdHNldFN0cm9rZURhc2ggKHNlZ21lbnRzLCBvZmZzZXQgPSAwKSB7XG5cdFx0dGhpcy5fdXBkYXRlSW5zdHJ1Y3Rpb25zKHRydWUpO1xuXHRcdHRoaXMuX3N0cm9rZURhc2ggPSB0aGlzLmNvbW1hbmQgPSBuZXcgU3Ryb2tlRGFzaChzZWdtZW50cywgb2Zmc2V0KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBCZWdpbnMgYSBzdHJva2Ugd2l0aCB0aGUgc3BlY2lmaWVkIGNvbG9yLiBUaGlzIGVuZHMgdGhlIGN1cnJlbnQgc3ViLXBhdGguXG5cdCAqIEEgdGlueSBBUEkgbWV0aG9kIFwic1wiIGFsc28gZXhpc3RzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gY29sb3IgQSBDU1MgY29tcGF0aWJsZSBjb2xvciB2YWx1ZSAoZXguIFwiI0ZGMDAwMFwiLCBcInJlZFwiLCBvciBcInJnYmEoMjU1LDAsMCwwLjUpXCIpLiBTZXR0aW5nIHRvXG5cdCAqIG51bGwgd2lsbCByZXN1bHQgaW4gbm8gc3Ryb2tlLlxuXHQgKiBAcmV0dXJuIHtlYXNlbGpzLkdyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRiZWdpblN0cm9rZSAoY29sb3IpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2V0U3Ryb2tlKGNvbG9yID8gbmV3IFN0cm9rZShjb2xvcikgOiBudWxsKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCZWdpbnMgYSBsaW5lYXIgZ3JhZGllbnQgc3Ryb2tlIGRlZmluZWQgYnkgdGhlIGxpbmUgKHgwLCB5MCkgdG8gKHgxLCB5MSkuIFRoaXMgZW5kcyB0aGUgY3VycmVudCBzdWItcGF0aC5cblx0ICogQSB0aW55IEFQSSBtZXRob2QgXCJsc1wiIGFsc28gZXhpc3RzLlxuXHQgKlxuXHQgKiBAZXhhbXBsZSA8Y2FwdGlvbj5EZWZpbmUgYSBibGFjayB0byB3aGl0ZSB2ZXJ0aWNhbCBncmFkaWVudCByYW5naW5nIGZyb20gMjBweCB0byAxMjBweCwgYW5kIGRyYXcgYSBzcXVhcmUgdG8gZGlzcGxheSBpdDwvY2FwdGlvbj5cblx0ICogZ3JhcGhpY3Muc2V0U3Ryb2tlU3R5bGUoMTApXG5cdCAqICAgLmJlZ2luTGluZWFyR3JhZGllbnRTdHJva2UoW1wiIzAwMFwiLFwiI0ZGRlwiXSwgWzAsIDFdLCAwLCAyMCwgMCwgMTIwKVxuXHQgKiAgIC5kcmF3UmVjdCgyMCwgMjAsIDEyMCwgMTIwKTtcblx0ICpcblx0ICogQHBhcmFtIHtBcnJheTxTdHJpbmc+fSBjb2xvcnMgQW4gYXJyYXkgb2YgQ1NTIGNvbXBhdGlibGUgY29sb3IgdmFsdWVzLiBGb3IgZXhhbXBsZSwgW1wiI0YwMFwiLFwiIzAwRlwiXSB3b3VsZCBkZWZpbmVcblx0ICogYSBncmFkaWVudCBkcmF3aW5nIGZyb20gcmVkIHRvIGJsdWUuXG5cdCAqIEBwYXJhbSB7QXJyYXk8TnVtYmVyPn0gcmF0aW9zIEFuIGFycmF5IG9mIGdyYWRpZW50IHBvc2l0aW9ucyB3aGljaCBjb3JyZXNwb25kIHRvIHRoZSBjb2xvcnMuIEZvciBleGFtcGxlLCBbMC4xLFxuXHQgKiAwLjldIHdvdWxkIGRyYXcgdGhlIGZpcnN0IGNvbG9yIHRvIDEwJSB0aGVuIGludGVycG9sYXRpbmcgdG8gdGhlIHNlY29uZCBjb2xvciBhdCA5MCUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MCBUaGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IHBvaW50IGRlZmluaW5nIHRoZSBsaW5lIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQgZGlyZWN0aW9uIGFuZCBzaXplLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geTAgVGhlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBwb2ludCBkZWZpbmluZyB0aGUgbGluZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50IGRpcmVjdGlvbiBhbmQgc2l6ZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgxIFRoZSBwb3NpdGlvbiBvZiB0aGUgc2Vjb25kIHBvaW50IGRlZmluaW5nIHRoZSBsaW5lIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQgZGlyZWN0aW9uIGFuZCBzaXplLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geTEgVGhlIHBvc2l0aW9uIG9mIHRoZSBzZWNvbmQgcG9pbnQgZGVmaW5pbmcgdGhlIGxpbmUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudCBkaXJlY3Rpb24gYW5kIHNpemUuXG5cdCAqIEByZXR1cm4ge2Vhc2VsanMuR3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdGJlZ2luTGluZWFyR3JhZGllbnRTdHJva2UgKGNvbG9ycywgcmF0aW9zLCB4MCwgeTAsIHgxLCB5MSkge1xuXHRcdHJldHVybiB0aGlzLl9zZXRTdHJva2UobmV3IFN0cm9rZSgpLmxpbmVhckdyYWRpZW50KGNvbG9ycywgcmF0aW9zLCB4MCwgeTAsIHgxLCB5MSkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEJlZ2lucyBhIHJhZGlhbCBncmFkaWVudCBzdHJva2UuIFRoaXMgZW5kcyB0aGUgY3VycmVudCBzdWItcGF0aC5cblx0ICogQSB0aW55IEFQSSBtZXRob2QgXCJyc1wiIGFsc28gZXhpc3RzLlxuXHQgKlxuXHQgKiBAZXhhbXBsZSA8Y2FwdGlvbj5EZWZpbmUgYSByZWQgdG8gYmx1ZSByYWRpYWwgZ3JhZGllbnQgY2VudGVyZWQgYXQgKDEwMCwgMTAwKSwgd2l0aCBhIHJhZGl1cyBvZiA1MCwgYW5kIGRyYXcgYSByZWN0YW5nbGUgdG8gZGlzcGxheSBpdDwvY2FwdGlvbj5cblx0ICogZ3JhcGhpY3Muc2V0U3Ryb2tlU3R5bGUoMTApXG5cdCAqICAgLmJlZ2luUmFkaWFsR3JhZGllbnRTdHJva2UoW1wiI0YwMFwiLFwiIzAwRlwiXSwgWzAsIDFdLCAxMDAsIDEwMCwgMCwgMTAwLCAxMDAsIDUwKVxuXHQgKiAgIC5kcmF3UmVjdCg1MCwgOTAsIDE1MCwgMTEwKTtcblx0ICpcblx0ICogQHBhcmFtIHtBcnJheTxTdHJpbmc+fSBjb2xvcnMgQW4gYXJyYXkgb2YgQ1NTIGNvbXBhdGlibGUgY29sb3IgdmFsdWVzLiBGb3IgZXhhbXBsZSwgW1wiI0YwMFwiLFwiIzAwRlwiXSB3b3VsZCBkZWZpbmVcblx0ICogYSBncmFkaWVudCBkcmF3aW5nIGZyb20gcmVkIHRvIGJsdWUuXG5cdCAqIEBwYXJhbSB7QXJyYXk8TnVtYmVyPn0gcmF0aW9zIEFuIGFycmF5IG9mIGdyYWRpZW50IHBvc2l0aW9ucyB3aGljaCBjb3JyZXNwb25kIHRvIHRoZSBjb2xvcnMuIEZvciBleGFtcGxlLCBbMC4xLFxuXHQgKiAwLjldIHdvdWxkIGRyYXcgdGhlIGZpcnN0IGNvbG9yIHRvIDEwJSB0aGVuIGludGVycG9sYXRpbmcgdG8gdGhlIHNlY29uZCBjb2xvciBhdCA5MCUsIHRoZW4gZHJhdyB0aGUgc2Vjb25kIGNvbG9yXG5cdCAqIHRvIDEwMCUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MCBDZW50ZXIgcG9zaXRpb24gb2YgdGhlIGlubmVyIGNpcmNsZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50LlxuXHQgKiBAcGFyYW0ge051bWJlcn0geTAgQ2VudGVyIHBvc2l0aW9uIG9mIHRoZSBpbm5lciBjaXJjbGUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHIwIFJhZGl1cyBvZiB0aGUgaW5uZXIgY2lyY2xlIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MSBDZW50ZXIgcG9zaXRpb24gb2YgdGhlIG91dGVyIGNpcmNsZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50LlxuXHQgKiBAcGFyYW0ge051bWJlcn0geTEgQ2VudGVyIHBvc2l0aW9uIG9mIHRoZSBvdXRlciBjaXJjbGUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHIxIFJhZGl1cyBvZiB0aGUgb3V0ZXIgY2lyY2xlIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQuXG5cdCAqIEByZXR1cm4ge2Vhc2VsanMuR3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdGJlZ2luUmFkaWFsR3JhZGllbnRTdHJva2UgKGNvbG9ycywgcmF0aW9zLCB4MCwgeTAsIHIwLCB4MSwgeTEsIHIxKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NldFN0cm9rZShuZXcgU3Ryb2tlKCkucmFkaWFsR3JhZGllbnQoY29sb3JzLCByYXRpb3MsIHgwLCB5MCwgcjAsIHgxLCB5MSwgcjEpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCZWdpbnMgYSBwYXR0ZXJuIGZpbGwgdXNpbmcgdGhlIHNwZWNpZmllZCBpbWFnZS4gVGhpcyBlbmRzIHRoZSBjdXJyZW50IHN1Yi1wYXRoLiBOb3RlIHRoYXQgdW5saWtlIGJpdG1hcCBmaWxscyxcblx0ICogc3Ryb2tlcyBkbyBub3QgY3VycmVudGx5IHN1cHBvcnQgYSBtYXRyaXggcGFyYW1ldGVyIGR1ZSB0byBsaW1pdGF0aW9ucyBpbiB0aGUgY2FudmFzIEFQSS5cblx0ICogQSB0aW55IEFQSSBtZXRob2QgXCJic1wiIGFsc28gZXhpc3RzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnQgfCBIVE1MQ2FudmFzRWxlbWVudCB8IEhUTUxWaWRlb0VsZW1lbnR9IGltYWdlIFRoZSBJbWFnZSwgQ2FudmFzLCBvciBWaWRlbyBvYmplY3QgdG8gdXNlXG5cdCAqIGFzIHRoZSBwYXR0ZXJuLiBNdXN0IGJlIGxvYWRlZCBwcmlvciB0byBjcmVhdGluZyBhIGJpdG1hcCBmaWxsLCBvciB0aGUgZmlsbCB3aWxsIGJlIGVtcHR5LlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW3JlcGV0aXRpb249XCJyZXBlYXRcIl0gSW5kaWNhdGVzIHdoZXRoZXIgdG8gcmVwZWF0IHRoZSBpbWFnZSBpbiB0aGUgZmlsbCBhcmVhLiBPbmUgb2Zcblx0ICogXCJyZXBlYXRcIiwgXCJyZXBlYXQteFwiLCBcInJlcGVhdC15XCIsIG9yIFwibm8tcmVwZWF0XCIuIERlZmF1bHRzIHRvIFwicmVwZWF0XCIuXG5cdCAqIEByZXR1cm4ge2Vhc2VsanMuR3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdGJlZ2luQml0bWFwU3Ryb2tlIChpbWFnZSwgcmVwZXRpdGlvbiA9IFwicmVwZWF0XCIpIHtcblx0XHQvLyBOT1RFOiBtYXRyaXggaXMgbm90IHN1cHBvcnRlZCBmb3Igc3Ryb2tlIGJlY2F1c2UgdHJhbnNmb3JtcyBvbiBzdHJva2VzIGFsc28gYWZmZWN0IHRoZSBkcmF3biBzdHJva2Ugd2lkdGguXG5cdFx0cmV0dXJuIHRoaXMuX3NldFN0cm9rZShuZXcgU3Ryb2tlKCkuYml0bWFwKGltYWdlLCByZXBldGl0aW9uKSk7XG5cdH1cblxuXHQvKipcblx0ICogRW5kcyB0aGUgY3VycmVudCBzdWItcGF0aCwgYW5kIGJlZ2lucyBhIG5ldyBvbmUgd2l0aCBubyBzdHJva2UuIEZ1bmN0aW9uYWxseSBpZGVudGljYWwgdG8gYGJlZ2luU3Ryb2tlKG51bGwpYC5cblx0ICogQSB0aW55IEFQSSBtZXRob2QgXCJlc1wiIGFsc28gZXhpc3RzLlxuXHQgKiBAcmV0dXJuIHtlYXNlbGpzLkdyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRlbmRTdHJva2UgKCkge1xuXHRcdHJldHVybiB0aGlzLmJlZ2luU3Ryb2tlKCk7XG5cdH1cblxuXHQvKipcblx0ICogRHJhd3MgYSByb3VuZGVkIHJlY3RhbmdsZSB3aXRoIGFsbCBjb3JuZXJzIHdpdGggdGhlIHNwZWNpZmllZCByYWRpdXMuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB3XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXMgQ29ybmVyIHJhZGl1cy5cblx0ICogQHJldHVybiB7ZWFzZWxqcy5HcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0ZHJhd1JvdW5kUmVjdCAoeCwgeSwgdywgaCwgcmFkaXVzKSB7XG5cdFx0cmV0dXJuIHRoaXMuZHJhd1JvdW5kUmVjdENvbXBsZXgoeCwgeSwgdywgaCwgcmFkaXVzLCByYWRpdXMsIHJhZGl1cywgcmFkaXVzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEcmF3cyBhIHJvdW5kZWQgcmVjdGFuZ2xlIHdpdGggZGlmZmVyZW50IGNvcm5lciByYWRpaS4gU3VwcG9ydHMgcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIGNvcm5lciByYWRpaS5cblx0ICogQSB0aW55IEFQSSBtZXRob2QgXCJyY1wiIGFsc28gZXhpc3RzLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgaG9yaXpvbnRhbCBjb29yZGluYXRlIHRvIGRyYXcgdGhlIHJvdW5kIHJlY3QuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB2ZXJ0aWNhbCBjb29yZGluYXRlIHRvIGRyYXcgdGhlIHJvdW5kIHJlY3QuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB3IFRoZSB3aWR0aCBvZiB0aGUgcm91bmQgcmVjdC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGggVGhlIGhlaWdodCBvZiB0aGUgcm91bmQgcmVjdC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c1RMIFRvcCBsZWZ0IGNvcm5lciByYWRpdXMuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNUUiBUb3AgcmlnaHQgY29ybmVyIHJhZGl1cy5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c0JSIEJvdHRvbSByaWdodCBjb3JuZXIgcmFkaXVzLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzQkwgQm90dG9tIGxlZnQgY29ybmVyIHJhZGl1cy5cblx0ICogQHJldHVybiB7ZWFzZWxqcy5HcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0ZHJhd1JvdW5kUmVjdENvbXBsZXggKHgsIHksIHcsIGgsIHJhZGl1c1RMLCByYWRpdXNUUiwgcmFkaXVzQlIsIHJhZGl1c0JMKSB7XG5cdFx0cmV0dXJuIHRoaXMuYXBwZW5kKG5ldyBSb3VuZFJlY3QoeCwgeSwgdywgaCwgcmFkaXVzVEwsIHJhZGl1c1RSLCByYWRpdXNCUiwgcmFkaXVzQkwpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEcmF3cyBhIGNpcmNsZSB3aXRoIHRoZSBzcGVjaWZpZWQgcmFkaXVzIGF0ICh4LCB5KS5cblx0ICogQSB0aW55IEFQSSBtZXRob2QgXCJkY1wiIGFsc28gZXhpc3RzLlxuXHQgKlxuXHQgKiBAZXhhbXBsZVxuXHQgKiBsZXQgZyA9IG5ldyBHcmFwaGljcygpO1xuXHQgKiBnLnNldFN0cm9rZVN0eWxlKDEpO1xuXHQgKiBnLmJlZ2luU3Ryb2tlKEdyYXBoaWNzLmdldFJHQigwLDAsMCkpO1xuXHQgKiBnLmJlZ2luRmlsbChHcmFwaGljcy5nZXRSR0IoMjU1LDAsMCkpO1xuXHQgKiBnLmRyYXdDaXJjbGUoMCwwLDMpO1xuXHQgKiBsZXQgcyA9IG5ldyBTaGFwZShnKTtcblx0ICogcy54ID0gMTAwO1xuXHQgKiBzLnkgPSAxMDA7XG5cdCAqIHN0YWdlLmFkZENoaWxkKHMpO1xuXHQgKiBzdGFnZS51cGRhdGUoKTtcblx0ICpcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggeCBjb29yZGluYXRlIGNlbnRlciBwb2ludCBvZiBjaXJjbGUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IHkgY29vcmRpbmF0ZSBjZW50ZXIgcG9pbnQgb2YgY2lyY2xlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzIFJhZGl1cyBvZiBjaXJjbGUuXG5cdCAqIEByZXR1cm4ge2Vhc2VsanMuR3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdGRyYXdDaXJjbGUgKHgsIHksIHJhZGl1cykge1xuXHRcdHJldHVybiB0aGlzLmFwcGVuZChuZXcgQ2lyY2xlKHgsIHksIHJhZGl1cykpO1xuXHR9XG5cblx0LyoqXG5cdCAqIERyYXdzIGFuIGVsbGlwc2UgKG92YWwpIHdpdGggYSBzcGVjaWZpZWQgd2lkdGggKHcpIGFuZCBoZWlnaHQgKGgpLiBTaW1pbGFyIHRvIHtAbGluayBlYXNlbHMuR3JhcGhpY3MjZHJhd0NpcmNsZX0sXG5cdCAqIGV4Y2VwdCB0aGUgd2lkdGggYW5kIGhlaWdodCBjYW4gYmUgZGlmZmVyZW50LlxuXHQgKiBBIHRpbnkgQVBJIG1ldGhvZCBcImRlXCIgYWxzbyBleGlzdHMuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSBsZWZ0IGNvb3JkaW5hdGUgcG9pbnQgb2YgdGhlIGVsbGlwc2UuIE5vdGUgdGhhdCB0aGlzIGlzIGRpZmZlcmVudCBmcm9tIHtAbGluayBlYXNlbHMuR3JhcGhpY3MjZHJhd0NpcmNsZX1cblx0ICogd2hpY2ggZHJhd3MgZnJvbSBjZW50ZXIuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB0b3AgY29vcmRpbmF0ZSBwb2ludCBvZiB0aGUgZWxsaXBzZS4gTm90ZSB0aGF0IHRoaXMgaXMgZGlmZmVyZW50IGZyb20ge0BsaW5rIGVhc2Vscy5HcmFwaGljcyNkcmF3Q2lyY2xlfVxuXHQgKiB3aGljaCBkcmF3cyBmcm9tIHRoZSBjZW50ZXIuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB3IFRoZSBoZWlnaHQgKGhvcml6b250YWwgZGlhbWV0ZXIpIG9mIHRoZSBlbGxpcHNlLiBUaGUgaG9yaXpvbnRhbCByYWRpdXMgd2lsbCBiZSBoYWxmIG9mIHRoaXNcblx0ICogbnVtYmVyLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gaCBUaGUgd2lkdGggKHZlcnRpY2FsIGRpYW1ldGVyKSBvZiB0aGUgZWxsaXBzZS4gVGhlIHZlcnRpY2FsIHJhZGl1cyB3aWxsIGJlIGhhbGYgb2YgdGhpcyBudW1iZXIuXG5cdCAqIEByZXR1cm4ge2Vhc2VsanMuR3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdGRyYXdFbGxpcHNlICh4LCB5LCB3LCBoKSB7XG5cdFx0cmV0dXJuIHRoaXMuYXBwZW5kKG5ldyBFbGxpcHNlKHgsIHksIHcsIGgpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEcmF3cyBhIHN0YXIgaWYgcG9pbnRTaXplIGlzIGdyZWF0ZXIgdGhhbiAwLCBvciBhIHJlZ3VsYXIgcG9seWdvbiBpZiBwb2ludFNpemUgaXMgMCB3aXRoIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIHBvaW50cy5cblx0ICogQSB0aW55IEFQSSBtZXRob2QgXCJkcFwiIGFsc28gZXhpc3RzLlxuXHQgKlxuXHQgKiBAZXhhbXBsZSA8Y2FwdGlvbj5EcmF3IGEgNSBwb2ludGVkIHN0YXIgc2hhcGUgY2VudGVyZWQgYXQgMTAwLCAxMDAgYW5kIHdpdGggYSByYWRpdXMgb2YgNTA8L2NhcHRpb24+XG5cdCAqIGdyYXBoaWNzLmJlZ2luRmlsbChcIiNGRjBcIikuZHJhd1BvbHlTdGFyKDEwMCwgMTAwLCA1MCwgNSwgMC42LCAtOTApO1xuXHQgKiAvLyBOb3RlOiAtOTAgbWFrZXMgdGhlIGZpcnN0IHBvaW50IHZlcnRpY2FsXG5cdCAqXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb2YgdGhlIHNoYXBlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBQb3NpdGlvbiBvZiB0aGUgY2VudGVyIG9mIHRoZSBzaGFwZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1cyBUaGUgb3V0ZXIgcmFkaXVzIG9mIHRoZSBzaGFwZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHNpZGVzIFRoZSBudW1iZXIgb2YgcG9pbnRzIG9uIHRoZSBzdGFyIG9yIHNpZGVzIG9uIHRoZSBwb2x5Z29uLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcG9pbnRTaXplIFRoZSBkZXB0aCBvciBcInBvaW50eS1uZXNzXCIgb2YgdGhlIHN0YXIgcG9pbnRzLiBBIHBvaW50U2l6ZSBvZiAwIHdpbGwgZHJhdyBhIHJlZ3VsYXJcblx0ICogcG9seWdvbiAobm8gcG9pbnRzKSwgYSBwb2ludFNpemUgb2YgMSB3aWxsIGRyYXcgbm90aGluZyBiZWNhdXNlIHRoZSBwb2ludHMgYXJlIGluZmluaXRlbHkgcG9pbnR5LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gYW5nbGUgVGhlIGFuZ2xlIG9mIHRoZSBmaXJzdCBwb2ludCAvIGNvcm5lci4gRm9yIGV4YW1wbGUgYSB2YWx1ZSBvZiAwIHdpbGwgZHJhdyB0aGUgZmlyc3QgcG9pbnRcblx0ICogZGlyZWN0bHkgdG8gdGhlIHJpZ2h0IG9mIHRoZSBjZW50ZXIuXG5cdCAqIEByZXR1cm4ge2Vhc2VsanMuR3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdGRyYXdQb2x5U3RhciAoeCwgeSwgcmFkaXVzLCBzaWRlcywgcG9pbnRTaXplLCBhbmdsZSkge1xuXHRcdHJldHVybiB0aGlzLmFwcGVuZChuZXcgUG9seVN0YXIoeCwgeSwgcmFkaXVzLCBzaWRlcywgcG9pbnRTaXplLCBhbmdsZSkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFwcGVuZHMgYSBncmFwaGljcyBjb21tYW5kIG9iamVjdCB0byB0aGUgZ3JhcGhpY3MgcXVldWUuIENvbW1hbmQgb2JqZWN0cyBleHBvc2UgYW4gXCJleGVjXCIgbWV0aG9kXG5cdCAqIHRoYXQgYWNjZXB0cyB0d28gcGFyYW1ldGVyczogdGhlIENvbnRleHQyRCB0byBvcGVyYXRlIG9uLCBhbmQgYW4gYXJiaXRyYXJ5IGRhdGEgb2JqZWN0IHBhc3NlZCBpbnRvXG5cdCAqIHtAbGluayBlYXNlbGpzLkdyYXBoaWNzI2RyYXd9LiBUaGUgbGF0dGVyIHdpbGwgdXN1YWxseSBiZSB0aGUgU2hhcGUgaW5zdGFuY2UgdGhhdCBjYWxsZWQgZHJhdy5cblx0ICpcblx0ICogVGhpcyBtZXRob2QgaXMgdXNlZCBpbnRlcm5hbGx5IGJ5IEdyYXBoaWNzIG1ldGhvZHMsIHN1Y2ggYXMgZHJhd0NpcmNsZSwgYnV0IGNhbiBhbHNvIGJlIHVzZWQgZGlyZWN0bHkgdG8gaW5zZXJ0XG5cdCAqIGJ1aWx0LWluIG9yIGN1c3RvbSBncmFwaGljcyBjb21tYW5kcy5cblx0ICpcblx0ICogQGV4YW1wbGVcblx0ICogLy8gYXR0YWNoIGRhdGEgdG8gb3VyIHNoYXBlLCBzbyB3ZSBjYW4gYWNjZXNzIGl0IGR1cmluZyB0aGUgZHJhdzpcblx0ICogc2hhcGUuY29sb3IgPSBcInJlZFwiO1xuXHQgKlxuXHQgKiAvLyBhcHBlbmQgYSBDaXJjbGUgY29tbWFuZCBvYmplY3Q6XG5cdCAqIHNoYXBlLmdyYXBoaWNzLmFwcGVuZChuZXcgR3JhcGhpY3MuQ2lyY2xlKDUwLCA1MCwgMzApKTtcblx0ICpcblx0ICogLy8gYXBwZW5kIGEgY3VzdG9tIGNvbW1hbmQgb2JqZWN0IHdpdGggYW4gZXhlYyBtZXRob2QgdGhhdCBzZXRzIHRoZSBmaWxsIHN0eWxlXG5cdCAqIC8vIGJhc2VkIG9uIHRoZSBzaGFwZSdzIGRhdGEsIGFuZCB0aGVuIGZpbGxzIHRoZSBjaXJjbGUuXG5cdCAqIHNoYXBlLmdyYXBoaWNzLmFwcGVuZCh7XG5cdCAqICAgZXhlYzogKGN0eCwgc2hhcGUpID0+IHtcblx0ICogICAgIGN0eC5maWxsU3R5bGUgPSBzaGFwZS5jb2xvcjtcblx0ICogICAgIGN0eC5maWxsKCk7XG5cdCAqICAgfVxuXHQgKiB9KTtcblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IGNvbW1hbmQgQSBncmFwaGljcyBjb21tYW5kIG9iamVjdCBleHBvc2luZyBhbiBcImV4ZWNcIiBtZXRob2QuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gY2xlYW4gVGhlIGNsZWFuIHBhcmFtIGlzIHByaW1hcmlseSBmb3IgaW50ZXJuYWwgdXNlLiBBIHZhbHVlIG9mIHRydWUgaW5kaWNhdGVzIHRoYXQgYSBjb21tYW5kIGRvZXMgbm90IGdlbmVyYXRlIGEgcGF0aCB0aGF0IHNob3VsZCBiZSBzdHJva2VkIG9yIGZpbGxlZC5cblx0ICogQHJldHVybiB7ZWFzZWxqcy5HcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0YXBwZW5kIChjb21tYW5kLCBjbGVhbikge1xuXHRcdHRoaXMuX2FjdGl2ZUluc3RydWN0aW9ucy5wdXNoKGNvbW1hbmQpO1xuXHRcdHRoaXMuY29tbWFuZCA9IGNvbW1hbmQ7XG5cdFx0aWYgKCFjbGVhbikgeyB0aGlzLl9kaXJ0eSA9IHRydWU7IH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBEZWNvZGVzIGEgY29tcGFjdCBlbmNvZGVkIHBhdGggc3RyaW5nIGludG8gYSBzZXJpZXMgb2YgZHJhdyBpbnN0cnVjdGlvbnMuXG5cdCAqIFRoaXMgZm9ybWF0IGlzIG5vdCBpbnRlbmRlZCB0byBiZSBodW1hbiByZWFkYWJsZSwgYW5kIGlzIG1lYW50IGZvciB1c2UgYnkgYXV0aG9yaW5nIHRvb2xzLlxuXHQgKiBUaGUgZm9ybWF0IHVzZXMgYSBiYXNlNjQgY2hhcmFjdGVyIHNldCwgd2l0aCBlYWNoIGNoYXJhY3RlciByZXByZXNlbnRpbmcgNiBiaXRzLCB0byBkZWZpbmUgYSBzZXJpZXMgb2YgZHJhd1xuXHQgKiBjb21tYW5kcy5cblx0ICpcblx0ICogRWFjaCBjb21tYW5kIGlzIGNvbXByaXNlZCBvZiBhIHNpbmdsZSBcImhlYWRlclwiIGNoYXJhY3RlciBmb2xsb3dlZCBieSBhIHZhcmlhYmxlIG51bWJlciBvZiBhbHRlcm5hdGluZyB4IGFuZCB5XG5cdCAqIHBvc2l0aW9uIHZhbHVlcy4gUmVhZGluZyB0aGUgaGVhZGVyIGJpdHMgZnJvbSBsZWZ0IHRvIHJpZ2h0IChtb3N0IHRvIGxlYXN0IHNpZ25pZmljYW50KTogYml0cyAxIHRvIDMgc3BlY2lmeSB0aGVcblx0ICogdHlwZSBvZiBvcGVyYXRpb24gKDAtbW92ZVRvLCAxLWxpbmVUbywgMi1xdWFkcmF0aWNDdXJ2ZVRvLCAzLWJlemllckN1cnZlVG8sIDQtY2xvc2VQYXRoLCA1LTcgdW51c2VkKS4gQml0IDRcblx0ICogaW5kaWNhdGVzIHdoZXRoZXIgcG9zaXRpb24gdmFsdWVzIHVzZSAxMiBiaXRzICgyIGNoYXJhY3RlcnMpIG9yIDE4IGJpdHMgKDMgY2hhcmFjdGVycyksIHdpdGggYSBvbmUgaW5kaWNhdGluZyB0aGVcblx0ICogbGF0dGVyLiBCaXRzIDUgYW5kIDYgYXJlIGN1cnJlbnRseSB1bnVzZWQuXG5cdCAqXG5cdCAqIEZvbGxvd2luZyB0aGUgaGVhZGVyIGlzIGEgc2VyaWVzIG9mIDAgKGNsb3NlUGF0aCksIDIgKG1vdmVUbywgbGluZVRvKSwgNCAocXVhZHJhdGljQ3VydmVUbyksIG9yIDYgKGJlemllckN1cnZlVG8pXG5cdCAqIHBhcmFtZXRlcnMuIFRoZXNlIHBhcmFtZXRlcnMgYXJlIGFsdGVybmF0aW5nIHgveSBwb3NpdGlvbnMgcmVwcmVzZW50ZWQgYnkgMiBvciAzIGNoYXJhY3RlcnMgKGFzIGluZGljYXRlZCBieSB0aGVcblx0ICogNHRoIGJpdCBpbiB0aGUgY29tbWFuZCBjaGFyKS4gVGhlc2UgY2hhcmFjdGVycyBjb25zaXN0IG9mIGEgMSBiaXQgc2lnbiAoMSBpcyBuZWdhdGl2ZSwgMCBpcyBwb3NpdGl2ZSksIGZvbGxvd2VkXG5cdCAqIGJ5IGFuIDExICgyIGNoYXIpIG9yIDE3ICgzIGNoYXIpIGJpdCBpbnRlZ2VyIHZhbHVlLiBBbGwgcG9zaXRpb24gdmFsdWVzIGFyZSBpbiB0ZW50aHMgb2YgYSBwaXhlbC4gRXhjZXB0IGluIHRoZVxuXHQgKiBjYXNlIG9mIG1vdmUgb3BlcmF0aW9ucyB3aGljaCBhcmUgYWJzb2x1dGUsIHRoaXMgdmFsdWUgaXMgYSBkZWx0YSBmcm9tIHRoZSBwcmV2aW91cyB4IG9yIHkgcG9zaXRpb24gKGFzXG5cdCAqIGFwcHJvcHJpYXRlKS5cblx0ICpcblx0ICogRm9yIGV4YW1wbGUsIHRoZSBzdHJpbmcgXCJBM2NBQU1BdTRBQUFcIiByZXByZXNlbnRzIGEgbGluZSBzdGFydGluZyBhdCAtMTUwLDAgYW5kIGVuZGluZyBhdCAxNTAsMC5cblx0ICogPGJyIC8+QSAtIGJpdHMgMDAwMDAwLiBGaXJzdCAzIGJpdHMgKDAwMCkgaW5kaWNhdGUgYSBtb3ZlVG8gb3BlcmF0aW9uLiA0dGggYml0ICgwKSBpbmRpY2F0ZXMgMiBjaGFycyBwZXJcblx0ICogcGFyYW1ldGVyLlxuXHQgKiA8YnIgLz5uMCAtIDExMDExMTAxMTEwMC4gQWJzb2x1dGUgeCBwb3NpdGlvbiBvZiAtMTUwLjBweC4gRmlyc3QgYml0IGluZGljYXRlcyBhIG5lZ2F0aXZlIHZhbHVlLCByZW1haW5pbmcgYml0c1xuXHQgKiBpbmRpY2F0ZSAxNTAwIHRlbnRocyBvZiBhIHBpeGVsLlxuXHQgKiA8YnIgLz5BQSAtIDAwMDAwMDAwMDAwMC4gQWJzb2x1dGUgeSBwb3NpdGlvbiBvZiAwLlxuXHQgKiA8YnIgLz5JIC0gMDAxMTAwLiBGaXJzdCAzIGJpdHMgKDAwMSkgaW5kaWNhdGUgYSBsaW5lVG8gb3BlcmF0aW9uLiA0dGggYml0ICgxKSBpbmRpY2F0ZXMgMyBjaGFycyBwZXIgcGFyYW1ldGVyLlxuXHQgKiA8YnIgLz5BdTQgLSAwMDAwMDAxMDExMTAxMTEwMDAuIEFuIHggZGVsdGEgb2YgMzAwLjBweCwgd2hpY2ggaXMgYWRkZWQgdG8gdGhlIHByZXZpb3VzIHggdmFsdWUgb2YgLTE1MC4wcHggdG9cblx0ICogcHJvdmlkZSBhbiBhYnNvbHV0ZSBwb3NpdGlvbiBvZiArMTUwLjBweC5cblx0ICogPGJyIC8+QUFBIC0gMDAwMDAwMDAwMDAwMDAwMDAwLiBBIHkgZGVsdGEgdmFsdWUgb2YgMC5cblx0ICpcblx0ICogQSB0aW55IEFQSSBtZXRob2QgXCJwXCIgYWxzbyBleGlzdHMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHBhdGggc3RyaW5nIHRvIGRlY29kZS5cblx0ICogQHJldHVybiB7ZWFzZWxqcy5HcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0ZGVjb2RlUGF0aCAoc3RyKSB7XG5cdFx0bGV0IGluc3RydWN0aW9ucyA9IFt0aGlzLm1vdmVUbywgdGhpcy5saW5lVG8sIHRoaXMucXVhZHJhdGljQ3VydmVUbywgdGhpcy5iZXppZXJDdXJ2ZVRvLCB0aGlzLmNsb3NlUGF0aF07XG5cdFx0bGV0IHBhcmFtQ291bnQgPSBbMiwgMiwgNCwgNiwgMF07XG5cdFx0bGV0IGkgPSAwO1xuXHRcdGNvbnN0IGwgPSBzdHIubGVuZ3RoO1xuXHRcdGxldCBwYXJhbXMgPSBbXTtcblx0XHRsZXQgeCA9IDAsIHkgPSAwO1xuXHRcdGxldCBiYXNlNjQgPSBHcmFwaGljcy5fQkFTRV82NDtcblxuXHRcdHdoaWxlIChpIDwgbCkge1xuXHRcdFx0bGV0IGMgPSBzdHIuY2hhckF0KGkpO1xuXHRcdFx0bGV0IG4gPSBiYXNlNjRbY107XG5cdFx0XHRsZXQgZmkgPSBuPj4zOyAvLyBoaWdoZXN0IG9yZGVyIGJpdHMgMS0zIGNvZGUgZm9yIG9wZXJhdGlvbi5cblx0XHRcdGxldCBmID0gaW5zdHJ1Y3Rpb25zW2ZpXTtcblx0XHRcdC8vIGNoZWNrIHRoYXQgd2UgaGF2ZSBhIHZhbGlkIGluc3RydWN0aW9uICYgdGhhdCB0aGUgdW51c2VkIGJpdHMgYXJlIGVtcHR5OlxuXHRcdFx0aWYgKCFmIHx8IChuJjMpKSB7IHRocm93IGBCYWQgcGF0aCBkYXRhIChAJHtpfSk6Y2A7IH1cblx0XHRcdGNvbnN0IHBsID0gcGFyYW1Db3VudFtmaV07XG5cdFx0XHRpZiAoIWZpKSB7IHg9eT0wOyB9IC8vIG1vdmUgb3BlcmF0aW9ucyByZXNldCB0aGUgcG9zaXRpb24uXG5cdFx0XHRwYXJhbXMubGVuZ3RoID0gMDtcblx0XHRcdGkrKztcblx0XHRcdGxldCBjaGFyQ291bnQgPSAobj4+MiYxKSsyOyAgLy8gNHRoIGhlYWRlciBiaXQgaW5kaWNhdGVzIG51bWJlciBzaXplIGZvciB0aGlzIG9wZXJhdGlvbi5cblx0XHRcdGZvciAobGV0IHAgPSAwOyBwIDwgcGw7IHArKykge1xuXHRcdFx0XHRsZXQgbnVtID0gYmFzZTY0W3N0ci5jaGFyQXQoaSldO1xuXHRcdFx0XHRsZXQgc2lnbiA9IChudW0+PjUpID8gLTEgOiAxO1xuXHRcdFx0XHRudW0gPSAoKG51bSYzMSk8PDYpfChiYXNlNjRbc3RyLmNoYXJBdChpKzEpXSk7XG5cdFx0XHRcdGlmIChjaGFyQ291bnQgPT09IDMpIHsgbnVtID0gKG51bTw8Nil8KGJhc2U2NFtzdHIuY2hhckF0KGkrMildKTsgfVxuXHRcdFx0XHRudW0gPSBzaWduKm51bS8xMDtcblx0XHRcdFx0aWYgKHAlMikgeyB4ID0gKG51bSArPSB4KTsgfVxuXHRcdFx0XHRlbHNlIHsgeSA9IChudW0gKz0geSk7IH1cblx0XHRcdFx0cGFyYW1zW3BdID0gbnVtO1xuXHRcdFx0XHRpICs9IGNoYXJDb3VudDtcblx0XHRcdH1cblx0XHRcdGYuYXBwbHkodGhpcywgcGFyYW1zKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogU3RvcmVzIGFsbCBncmFwaGljcyBjb21tYW5kcyBzbyB0aGV5IHdvbid0IGJlIGV4ZWN1dGVkIGluIGZ1dHVyZSBkcmF3cy4gQ2FsbGluZyBzdG9yZSgpIGEgc2Vjb25kIHRpbWUgYWRkcyB0b1xuXHQgKiB0aGUgZXhpc3Rpbmcgc3RvcmUuIFRoaXMgYWxzbyBhZmZlY3RzIGBkcmF3QXNQYXRoKClgLlxuXHQgKlxuXHQgKiBUaGlzIGlzIHVzZWZ1bCBpbiBjYXNlcyB3aGVyZSB5b3UgYXJlIGNyZWF0aW5nIHZlY3RvciBncmFwaGljcyBpbiBhbiBpdGVyYXRpdmUgbWFubmVyIChleC4gZ2VuZXJhdGl2ZSBhcnQpLCBzb1xuXHQgKiB0aGF0IG9ubHkgbmV3IGdyYXBoaWNzIG5lZWQgdG8gYmUgZHJhd24gKHdoaWNoIGNhbiBwcm92aWRlIGh1Z2UgcGVyZm9ybWFuY2UgYmVuZWZpdHMpLCBidXQgeW91IHdpc2ggdG8gcmV0YWluIGFsbFxuXHQgKiBvZiB0aGUgdmVjdG9yIGluc3RydWN0aW9ucyBmb3IgbGF0ZXIgdXNlIChleC4gc2NhbGluZywgbW9kaWZ5aW5nLCBvciBleHBvcnRpbmcpLlxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgY2FsbGluZyBzdG9yZSgpIHdpbGwgZm9yY2UgdGhlIGFjdGl2ZSBwYXRoIChpZiBhbnkpIHRvIGJlIGVuZGVkIGluIGEgbWFubmVyIHNpbWlsYXIgdG8gY2hhbmdpbmdcblx0ICogdGhlIGZpbGwgb3Igc3Ryb2tlLlxuXHQgKlxuXHQgKiBGb3IgZXhhbXBsZSwgY29uc2lkZXIgYSBhcHBsaWNhdGlvbiB3aGVyZSB0aGUgdXNlciBkcmF3cyBsaW5lcyB3aXRoIHRoZSBtb3VzZS4gQXMgZWFjaCBsaW5lIHNlZ21lbnQgKG9yIGNvbGxlY3Rpb24gb2Zcblx0ICogc2VnbWVudHMpIGFyZSBhZGRlZCB0byBhIFNoYXBlLCBpdCBjYW4gYmUgcmFzdGVyaXplZCB1c2luZyB7QGxpbmsgZWFzZWxqcy5EaXNwbGF5T2JqZWN0I3VwZGF0ZUNhY2hlfSxcblx0ICogYW5kIHRoZW4gc3RvcmVkLCBzbyB0aGF0IGl0IGNhbiBiZSByZWRyYXduIGF0IGEgZGlmZmVyZW50IHNjYWxlIHdoZW4gdGhlIGFwcGxpY2F0aW9uIGlzIHJlc2l6ZWQsIG9yIGV4cG9ydGVkIHRvIFNWR3JhcGhpY3MuXG5cdCAqXG5cdCAqIEBleGFtcGxlXG5cdCAqIC8vIHNldCB1cCBjYWNoZTpcblx0ICogc2hhcGUuY2FjaGUoMCwwLDUwMCw1MDAsc2NhbGUpO1xuXHQgKlxuXHQgKiAvLyB3aGVuIHRoZSB1c2VyIGRyYWdzLCBkcmF3IGEgbmV3IGxpbmU6XG5cdCAqIHNoYXBlLmdyYXBoaWNzLm1vdmVUbyhvbGRYLG9sZFkpLmxpbmVUbyhuZXdYLG5ld1kpO1xuXHQgKiAvLyB0aGVuIGRyYXcgaXQgaW50byB0aGUgZXhpc3RpbmcgY2FjaGU6XG5cdCAqIHNoYXBlLnVwZGF0ZUNhY2hlKFwic291cmNlLW92ZXJcIik7XG5cdCAqIC8vIHN0b3JlIHRoZSBuZXcgbGluZSwgc28gaXQgaXNuJ3QgcmVkcmF3biBuZXh0IHRpbWU6XG5cdCAqIHNoYXBlLnN0b3JlKCk7XG5cdCAqXG5cdCAqIC8vIHRoZW4sIHdoZW4gdGhlIHdpbmRvdyByZXNpemVzLCB3ZSBjYW4gcmUtcmVuZGVyIGF0IGEgZGlmZmVyZW50IHNjYWxlOlxuXHQgKiAvLyBmaXJzdCwgdW5zdG9yZSBhbGwgb3VyIGxpbmVzOlxuXHQgKiBzaGFwZS51bnN0b3JlKCk7XG5cdCAqIC8vIHRoZW4gY2FjaGUgdXNpbmcgdGhlIG5ldyBzY2FsZTpcblx0ICogc2hhcGUuY2FjaGUoMCwwLDUwMCw1MDAsbmV3U2NhbGUpO1xuXHQgKiAvLyBmaW5hbGx5LCBzdG9yZSB0aGUgZXhpc3RpbmcgY29tbWFuZHMgYWdhaW46XG5cdCAqIHNoYXBlLnN0b3JlKCk7XG5cdCAqXG5cdCAqIEByZXR1cm4ge2Vhc2VsanMuR3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdHN0b3JlICgpIHtcblx0XHR0aGlzLl91cGRhdGVJbnN0cnVjdGlvbnModHJ1ZSk7XG5cdFx0dGhpcy5fc3RvcmVJbmRleCA9IHRoaXMuX2luc3RydWN0aW9ucy5sZW5ndGg7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogVW5zdG9yZXMgYW55IGdyYXBoaWNzIGNvbW1hbmRzIHRoYXQgd2VyZSBwcmV2aW91c2x5IHN0b3JlZCB1c2luZyB7QGxpbmsgZWFzZWxqcy5HcmFwaGljcyNzdG9yZX1cblx0ICogc28gdGhhdCB0aGV5IHdpbGwgYmUgZXhlY3V0ZWQgaW4gc3Vic2VxdWVudCBkcmF3IGNhbGxzLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtlYXNlbGpzLkdyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHR1bnN0b3JlICgpIHtcblx0XHR0aGlzLl9zdG9yZUluZGV4ID0gMDtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhpcyBHcmFwaGljcyBpbnN0YW5jZS4gTm90ZSB0aGF0IHRoZSBpbmRpdmlkdWFsIGNvbW1hbmQgb2JqZWN0cyBhcmUgbm90IGNsb25lZC5cblx0ICogQHJldHVybiB7ZWFzZWxqcy5HcmFwaGljc30gQSBjbG9uZSBvZiB0aGUgY3VycmVudCBHcmFwaGljcyBpbnN0YW5jZS5cblx0ICovXG5cdGNsb25lICgpIHtcblx0XHRsZXQgbyA9IG5ldyBHcmFwaGljcygpO1xuXHRcdG8uY29tbWFuZCA9IHRoaXMuY29tbWFuZDtcblx0XHRvLl9zdHJva2UgPSB0aGlzLl9zdHJva2U7XG5cdFx0by5fc3Ryb2tlU3R5bGUgPSB0aGlzLl9zdHJva2VTdHlsZTtcblx0XHRvLl9zdHJva2VEYXNoID0gdGhpcy5fc3Ryb2tlRGFzaDtcblx0XHRvLl9zdHJva2VJZ25vcmVTY2FsZSA9IHRoaXMuX3N0cm9rZUlnbm9yZVNjYWxlO1xuXHRcdG8uX2ZpbGwgPSB0aGlzLl9maWxsO1xuXHRcdG8uX2luc3RydWN0aW9ucyA9IHRoaXMuX2luc3RydWN0aW9ucy5zbGljZSgpO1xuXHRcdG8uX2NvbW1pdEluZGV4ID0gdGhpcy5fY29tbWl0SW5kZXg7XG5cdFx0by5fYWN0aXZlSW5zdHJ1Y3Rpb25zID0gdGhpcy5fYWN0aXZlSW5zdHJ1Y3Rpb25zLnNsaWNlKCk7XG5cdFx0by5fZGlydHkgPSB0aGlzLl9kaXJ0eTtcblx0XHRvLl9zdG9yZUluZGV4ID0gdGhpcy5fc3RvcmVJbmRleDtcblx0XHRyZXR1cm4gbztcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZS5cblx0ICovXG5cdHRvU3RyaW5nICgpIHtcblx0XHRyZXR1cm4gYFske3RoaXMuY29uc3RydWN0b3IubmFtZX1dYDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGNvbW1pdFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRfdXBkYXRlSW5zdHJ1Y3Rpb25zIChjb21taXQpIHtcblx0XHRsZXQgaW5zdHIgPSB0aGlzLl9pbnN0cnVjdGlvbnMsIGFjdGl2ZSA9IHRoaXMuX2FjdGl2ZUluc3RydWN0aW9ucywgY29tbWl0SW5kZXggPSB0aGlzLl9jb21taXRJbmRleDtcblxuXHRcdGlmICh0aGlzLl9kaXJ0eSAmJiBhY3RpdmUubGVuZ3RoKSB7XG5cdFx0XHRpbnN0ci5sZW5ndGggPSBjb21taXRJbmRleDsgLy8gcmVtb3ZlIG9sZCwgdW5jb21taXR0ZWQgY29tbWFuZHNcblx0XHRcdGluc3RyLnB1c2goR3JhcGhpY3MuYmVnaW5DbWQpO1xuXG5cdFx0XHRjb25zdCBsID0gYWN0aXZlLmxlbmd0aCwgbGwgPSBpbnN0ci5sZW5ndGg7XG5cdFx0XHRpbnN0ci5sZW5ndGggPSBsbCtsO1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpKyspIHsgaW5zdHJbaStsbF0gPSBhY3RpdmVbaV07IH1cblxuXHRcdFx0aWYgKHRoaXMuX2ZpbGwpIHsgaW5zdHIucHVzaCh0aGlzLl9maWxsKTsgfVxuXHRcdFx0aWYgKHRoaXMuX3N0cm9rZSkge1xuXHRcdFx0XHQvLyBkb2Vzbid0IG5lZWQgdG8gYmUgcmUtYXBwbGllZCBpZiBpdCBoYXNuJ3QgY2hhbmdlZC5cblx0XHRcdFx0aWYgKHRoaXMuX3N0cm9rZURhc2ggIT09IHRoaXMuX29sZFN0cm9rZURhc2gpIHtcblx0XHRcdFx0XHRpbnN0ci5wdXNoKHRoaXMuX3N0cm9rZURhc2gpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aGlzLl9zdHJva2VTdHlsZSAhPT0gdGhpcy5fb2xkU3Ryb2tlU3R5bGUpIHtcblx0XHRcdFx0XHRpbnN0ci5wdXNoKHRoaXMuX3N0cm9rZVN0eWxlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoY29tbWl0KSB7XG5cdFx0XHRcdFx0dGhpcy5fb2xkU3Ryb2tlRGFzaCA9IHRoaXMuX3N0cm9rZURhc2g7XG5cdFx0XHRcdFx0dGhpcy5fb2xkU3Ryb2tlU3R5bGUgPSB0aGlzLl9zdHJva2VTdHlsZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpbnN0ci5wdXNoKHRoaXMuX3N0cm9rZSk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX2RpcnR5ID0gZmFsc2U7XG5cdFx0fVxuXG5cdFx0aWYgKGNvbW1pdCkge1xuXHRcdFx0YWN0aXZlLmxlbmd0aCA9IDA7XG5cdFx0XHR0aGlzLl9jb21taXRJbmRleCA9IGluc3RyLmxlbmd0aDtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7ZWFzZWxqcy5HcmFwaGljcy5GaWxsfSBmaWxsXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdF9zZXRGaWxsIChmaWxsKSB7XG5cdFx0dGhpcy5fdXBkYXRlSW5zdHJ1Y3Rpb25zKHRydWUpO1xuXHRcdHRoaXMuY29tbWFuZCA9IHRoaXMuX2ZpbGwgPSBmaWxsO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7ZWFzZWxqcy5HcmFwaGljcy5TdHJva2V9IHN0cm9rZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRfc2V0U3Ryb2tlIChzdHJva2UpIHtcblx0XHR0aGlzLl91cGRhdGVJbnN0cnVjdGlvbnModHJ1ZSk7XG5cdFx0aWYgKHRoaXMuY29tbWFuZCA9IHRoaXMuX3N0cm9rZSA9IHN0cm9rZSkge1xuXHRcdFx0c3Ryb2tlLmlnbm9yZVNjYWxlID0gdGhpcy5fc3Ryb2tlSWdub3JlU2NhbGU7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0c3RhdGljIGdldCBMaW5lVG8gKCkgeyByZXR1cm4gTGluZVRvOyB9XG5cdHN0YXRpYyBnZXQgTW92ZVRvICgpIHsgcmV0dXJuIE1vdmVUbzsgfVxuXHRzdGF0aWMgZ2V0IEFyY1RvICgpIHsgcmV0dXJuIEFyY1RvOyB9XG5cdHN0YXRpYyBnZXQgQXJjICgpIHsgcmV0dXJuIEFyYzsgfVxuXHRzdGF0aWMgZ2V0IFF1YWRyYXRpY0N1cnZlVG8gKCkgeyByZXR1cm4gUXVhZHJhdGljQ3VydmVUbzsgfVxuXHRzdGF0aWMgZ2V0IEJlemllckN1cnZlVG8gKCkgeyByZXR1cm4gQmV6aWVyQ3VydmVUbzsgfVxuXHRzdGF0aWMgZ2V0IFJlY3QgKCkgeyByZXR1cm4gUmVjdDsgfVxuXHRzdGF0aWMgZ2V0IENsb3NlUGF0aCAoKSB7IHJldHVybiBDbG9zZVBhdGg7IH1cblx0c3RhdGljIGdldCBCZWdpblBhdGggKCkgeyByZXR1cm4gQmVnaW5QYXRoOyB9XG5cdHN0YXRpYyBnZXQgRmlsbCAoKSB7IHJldHVybiBGaWxsOyB9XG5cdHN0YXRpYyBnZXQgU3Ryb2tlICgpIHsgcmV0dXJuIFN0cm9rZTsgfVxuXHRzdGF0aWMgZ2V0IFN0cm9rZVN0eWxlICgpIHsgcmV0dXJuIFN0cm9rZVN0eWxlOyB9XG5cdHN0YXRpYyBnZXQgU3Ryb2tlRGFzaCAoKSB7IHJldHVybiBTdHJva2VEYXNoOyB9XG5cdHN0YXRpYyBnZXQgUm91bmRSZWN0ICgpIHsgcmV0dXJuIFJvdW5kUmVjdDsgfVxuXHRzdGF0aWMgZ2V0IENpcmNsZSAoKSB7IHJldHVybiBDaXJjbGU7IH1cblx0c3RhdGljIGdldCBFbGxpcHNlICgpIHsgcmV0dXJuIEVsbGlwc2U7IH1cblx0c3RhdGljIGdldCBQb2x5U3RhciAoKSB7IHJldHVybiBQb2x5U3RhcjsgfVxuXG59XG5cbi8qKlxuICogQHNlZSB7QGxpbmsgZWFzZWxqcy5HcmFwaGljcyNsaW5lVG99XG4gKiBAYWxpYXMgZWFzZWxqcy5HcmFwaGljcy5MaW5lVG9cbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiBAcGFyYW0ge051bWJlcn0geVxuICovXG5jbGFzcyBMaW5lVG8ge1xuXHRjb25zdHJ1Y3RvciAoeCwgeSkge1xuXHRcdC8qKlxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICovXG5cdFx0dGhpcy54ID0geDtcblx0XHQvKipcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqL1xuXHRcdHRoaXMueSA9IHk7XG5cdH1cblx0LyoqXG5cdCAqIEV4ZWN1dGUgdGhlIEdyYXBoaWNzIGNvbW1hbmQgaW4gdGhlIHByb3ZpZGVkIENhbnZhcyBjb250ZXh0LlxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IFRoZSBjYW52YXMgcmVuZGVyaW5nIGNvbnRleHRcblx0ICovXG5cdGV4ZWMgKGN0eCkge1xuXHRcdGN0eC5saW5lVG8odGhpcy54LCB0aGlzLnkpO1xuXHR9XG59XG5cbi8qKlxuICogQHNlZSB7QGxpbmsgZWFzZWxqcy5HcmFwaGljcyNtb3ZlVG99XG4gKiBAYWxpYXMgZWFzZWxqcy5HcmFwaGljcy5Nb3ZlVG9cbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiBAcGFyYW0ge051bWJlcn0geVxuICovXG5jbGFzcyBNb3ZlVG8ge1xuIFx0Y29uc3RydWN0b3IgKHgsIHkpIHtcblx0XHQvKipcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqL1xuIFx0XHR0aGlzLnggPSB4O1xuXHRcdC8qKlxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICovXG5cdFx0dGhpcy55ID0geTtcbiBcdH1cblx0LyoqXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcblx0ICovXG4gXHRleGVjIChjdHgpIHtcbiBcdFx0Y3R4Lm1vdmVUbyh0aGlzLngsIHRoaXMueSk7XG4gXHR9XG59XG5cblxuLyoqXG4gKiBAc2VlIHtAbGluayBlYXNlbGpzLkdyYXBoaWNzI2FyY1RvfVxuICogQGFsaWFzIGVhc2VsanMuR3JhcGhpY3MuQXJjVG9cbiAqIEBwYXJhbSB7TnVtYmVyfSB4MVxuICogQHBhcmFtIHtOdW1iZXJ9IHkxXG4gKiBAcGFyYW0ge051bWJlcn0geDJcbiAqIEBwYXJhbSB7TnVtYmVyfSB5MlxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c1xuICovXG5jbGFzcyBBcmNUbyB7XG4gXHRjb25zdHJ1Y3RvciAoeDEsIHkxLCB4MiwgeTIsIHJhZGl1cykge1xuXHRcdC8qKlxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICovXG5cdCBcdHRoaXMueDEgPSB4MTtcblx0XHQvKipcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqL1xuXHRcdHRoaXMueTEgPSB5MTtcblx0XHQvKipcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqL1xuXHQgXHR0aGlzLngyID0geDI7XG5cdFx0LyoqXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKi9cblx0XHR0aGlzLnkyID0geTI7XG5cdFx0LyoqXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKi9cblx0IFx0dGhpcy5yYWRpdXMgPSByYWRpdXM7XG4gXHR9XG5cdC8qKlxuXHQgKiBFeGVjdXRlIHRoZSBHcmFwaGljcyBjb21tYW5kIGluIHRoZSBwcm92aWRlZCBDYW52YXMgY29udGV4dC5cblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBUaGUgY2FudmFzIHJlbmRlcmluZyBjb250ZXh0XG5cdCAqL1xuIFx0ZXhlYyAoY3R4KSB7XG4gXHRcdGN0eC5hcmNUbyh0aGlzLngxLCB0aGlzLnkxLCB0aGlzLngyLCB0aGlzLnkyLCB0aGlzLnJhZGl1cyk7XG4gXHR9XG59XG5cbi8qKlxuICogQHNlZSB7QGxpbmsgZWFzZWxqcy5HcmFwaGljcyNhcmN9XG4gKiBAYWxpYXMgZWFzZWxqcy5HcmFwaGljcy5BcmNcbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiBAcGFyYW0ge051bWJlcn0geVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c1xuICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0QW5nbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBlbmRBbmdsZVxuICogQHBhcmFtIHtCb29sZWFufSBbYW50aWNsb2Nrd2lzZT1mYWxzZV1cbiAqL1xuY2xhc3MgQXJjIHtcbiBcdGNvbnN0cnVjdG9yICh4LCB5LCByYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlID0gZmFsc2UpIHtcblx0XHQvKipcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqL1xuXHQgXHR0aGlzLnggPSB4O1xuXHRcdC8qKlxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICovXG5cdFx0dGhpcy55ID0geTtcblx0XHQvKipcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqL1xuXHQgXHR0aGlzLnJhZGl1cyA9IHJhZGl1cztcblx0XHQvKipcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqL1xuXHQgXHR0aGlzLnN0YXJ0QW5nbGUgPSBzdGFydEFuZ2xlO1xuXHRcdC8qKlxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICovXG5cdFx0dGhpcy5lbmRBbmdsZSA9IGVuZEFuZ2xlO1xuXHRcdC8qKlxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqL1xuXHQgXHR0aGlzLmFudGljbG9ja3dpc2UgPSBhbnRpY2xvY2t3aXNlO1xuIFx0fVxuXHQvKipcblx0ICogRXhlY3V0ZSB0aGUgR3JhcGhpY3MgY29tbWFuZCBpbiB0aGUgcHJvdmlkZWQgQ2FudmFzIGNvbnRleHQuXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggVGhlIGNhbnZhcyByZW5kZXJpbmcgY29udGV4dFxuXHQgKi9cbiBcdGV4ZWMgKGN0eCkge1xuIFx0XHRjdHguYXJjKHRoaXMueCwgdGhpcy55LCB0aGlzLnJhZGl1cywgdGhpcy5zdGFydEFuZ2xlLCB0aGlzLmVuZEFuZ2xlLCB0aGlzLmFudGljbG9ja3dpc2UpO1xuIFx0fVxufVxuXG4vKipcbiAqIEBzZWUge0BsaW5rIGVhc2VsanMuR3JhcGhpY3MjcXVhZHJhdGljQ3VydmVUb31cbiAqIEBhbGlhcyBlYXNlbGpzLkdyYXBoaWNzLlF1YWRyYXRpY0N1cnZlVG9cbiAqIEBwYXJhbSB7TnVtYmVyfSBjcHhcbiAqIEBwYXJhbSB7TnVtYmVyfSBjcHlcbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiBAcGFyYW0ge051bWJlcn0geVxuICovXG5jbGFzcyBRdWFkcmF0aWNDdXJ2ZVRvIHtcbiBcdGNvbnN0cnVjdG9yIChjcHgsIGNweSwgeCwgeSkge1xuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBjcHhcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKi9cblx0IFx0dGhpcy5jcHggPSBjcHg7XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IGNweVxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqL1xuXHRcdHRoaXMuY3B5ID0gY3B5O1xuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSB4XG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICovXG5cdCBcdHRoaXMueCA9IHg7XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IHlcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKi9cblx0XHR0aGlzLnkgPSB5O1xuIFx0fVxuXHQvKipcblx0ICogRXhlY3V0ZSB0aGUgR3JhcGhpY3MgY29tbWFuZCBpbiB0aGUgcHJvdmlkZWQgQ2FudmFzIGNvbnRleHQuXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggVGhlIGNhbnZhcyByZW5kZXJpbmcgY29udGV4dFxuXHQgKi9cbiBcdGV4ZWMgKGN0eCkge1xuIFx0XHRjdHgucXVhZHJhdGljQ3VydmVUbyh0aGlzLmNweCwgdGhpcy5jcHksIHRoaXMueCwgdGhpcy55KTtcbiBcdH1cbn1cblxuLyoqXG4gKiBAc2VlIHtAbGluayBlYXNlbGpzLkdyYXBoaWNzI2JlemllckN1cnZlVG99XG4gKiBAYWxpYXMgZWFzZWxqcy5HcmFwaGljcy5CZXppZXJDdXJ2ZVRvXG4gKiBAcGFyYW0ge051bWJlcn0gY3AxeFxuICogQHBhcmFtIHtOdW1iZXJ9IGNwMXlcbiAqIEBwYXJhbSB7TnVtYmVyfSBjcDJ4XG4gKiBAcGFyYW0ge051bWJlcn0gY3AyeVxuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gKi9cbmNsYXNzIEJlemllckN1cnZlVG8ge1xuIFx0Y29uc3RydWN0b3IgKGNwMXgsIGNwMXksIGNwMngsIGNwMnksIHgsIHkpIHtcblx0XHQvKipcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqL1xuXHQgXHR0aGlzLmNwMXggPSBjcDF4O1xuXHRcdC8qKlxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICovXG5cdFx0dGhpcy5jcDF5ID0gY3AxeTtcblx0XHQvKipcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqL1xuXHQgXHR0aGlzLmNwMnggPSBjcDJ4O1xuXHRcdC8qKlxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICovXG5cdFx0dGhpcy5jcDJ5ID0gY3AyeTtcblx0XHQvKipcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqL1xuXHQgXHR0aGlzLnggPSB4O1xuXHRcdC8qKlxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICovXG5cdFx0dGhpcy55ID0geTtcbiBcdH1cblx0LyoqXG5cdCAqIEV4ZWN1dGUgdGhlIEdyYXBoaWNzIGNvbW1hbmQgaW4gdGhlIHByb3ZpZGVkIENhbnZhcyBjb250ZXh0LlxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IFRoZSBjYW52YXMgcmVuZGVyaW5nIGNvbnRleHRcblx0ICovXG4gXHRleGVjIChjdHgpIHtcbiBcdFx0Y3R4LmJlemllckN1cnZlVG8odGhpcy5jcDF4LCB0aGlzLmNwMXksIHRoaXMuY3AyeCwgdGhpcy5jcDJ5LCB0aGlzLngsIHRoaXMueSk7XG4gXHR9XG59XG5cbi8qKlxuICogQHNlZSB7QGxpbmsgZWFzZWxqcy5HcmFwaGljcyNyZWN0fVxuICogQGFsaWFzIGVhc2VsanMuR3JhcGhpY3MuUmVjdFxuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gKiBAcGFyYW0ge051bWJlcn0gd1xuICogQHBhcmFtIHtOdW1iZXJ9IGhcbiAqL1xuY2xhc3MgUmVjdCB7XG4gXHRjb25zdHJ1Y3RvciAoeCwgeSwgdywgaCkge1xuXHRcdC8qKlxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICovXG5cdCBcdHRoaXMueCA9IHg7XG5cdFx0LyoqXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKi9cblx0XHR0aGlzLnkgPSB5O1xuXHRcdC8qKlxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICovXG5cdCBcdHRoaXMudyA9IHc7XG5cdFx0LyoqXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKi9cblx0XHR0aGlzLmggPSBoO1xuIFx0fVxuXHQvKipcblx0ICogRXhlY3V0ZSB0aGUgR3JhcGhpY3MgY29tbWFuZCBpbiB0aGUgcHJvdmlkZWQgQ2FudmFzIGNvbnRleHQuXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggVGhlIGNhbnZhcyByZW5kZXJpbmcgY29udGV4dFxuXHQgKi9cbiBcdGV4ZWMgKGN0eCkge1xuIFx0XHRjdHgucmVjdCh0aGlzLngsIHRoaXMueSwgdGhpcy53LCB0aGlzLmgpO1xuIFx0fVxufVxuXG4vKipcbiAqIEBzZWUge0BsaW5rIGVhc2VsanMuR3JhcGhpY3MjY2xvc2VQYXRofVxuICogQGFsaWFzIGVhc2VsanMuR3JhcGhpY3MuQ2xvc2VQYXRoXG4gKi9cbmNsYXNzIENsb3NlUGF0aCB7XG4gXHRjb25zdHJ1Y3RvciAoKSB7IH1cblx0LyoqXG5cdCAqIEV4ZWN1dGUgdGhlIEdyYXBoaWNzIGNvbW1hbmQgaW4gdGhlIHByb3ZpZGVkIENhbnZhcyBjb250ZXh0LlxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IFRoZSBjYW52YXMgcmVuZGVyaW5nIGNvbnRleHRcblx0ICovXG4gXHRleGVjIChjdHgpIHtcbiBcdFx0Y3R4LmNsb3NlUGF0aCgpO1xuIFx0fVxufVxuXG4vKipcbiAqIEBzZWUge0BsaW5rIGVhc2VsanMuR3JhcGhpY3MjYmVnaW5QYXRofVxuICogQGFsaWFzIGVhc2VsanMuR3JhcGhpY3MuQmVnaW5QYXRoXG4gKi9cbmNsYXNzIEJlZ2luUGF0aCB7XG4gXHRjb25zdHJ1Y3RvciAoKSB7IH1cblx0LyoqXG5cdCAqIEV4ZWN1dGUgdGhlIEdyYXBoaWNzIGNvbW1hbmQgaW4gdGhlIHByb3ZpZGVkIENhbnZhcyBjb250ZXh0LlxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IFRoZSBjYW52YXMgcmVuZGVyaW5nIGNvbnRleHRcblx0ICovXG4gXHRleGVjIChjdHgpIHtcbiBcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuIFx0fVxufVxuXG4vKipcbiAqIEBzZWUge0BsaW5rIGVhc2VsanMuR3JhcGhpY3MjYmVnaW5GaWxsfVxuICogQGFsaWFzIGVhc2VsanMuR3JhcGhpY3MuRmlsbFxuICogQHBhcmFtIHtPYmplY3R9IHN0eWxlIEEgdmFsaWQgQ29udGV4dDJEIGZpbGxTdHlsZS5cbiAqIEBwYXJhbSB7TWF0cml4MkR9IG1hdHJpeFxuICovXG5jbGFzcyBGaWxsIHtcblx0Y29uc3RydWN0b3IgKHN0eWxlLCBtYXRyaXgpIHtcblx0XHQvKipcblx0XHQgKiBBIHZhbGlkIENvbnRleHQyRCBmaWxsU3R5bGUuXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0XHR0aGlzLnN0eWxlID0gc3R5bGU7XG5cdFx0LyoqXG5cdFx0ICogQHR5cGUge2Vhc2VsanMuTWF0cml4MkR9XG5cdFx0ICovXG5cdFx0dGhpcy5tYXRyaXggPSBtYXRyaXg7XG5cdFx0LyoqXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICovXG5cdFx0dGhpcy5wYXRoID0gZmFsc2U7XG5cdH1cblx0LyoqXG5cdCAqIEV4ZWN1dGUgdGhlIEdyYXBoaWNzIGNvbW1hbmQgaW4gdGhlIHByb3ZpZGVkIENhbnZhcyBjb250ZXh0LlxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IFRoZSBjYW52YXMgcmVuZGVyaW5nIGNvbnRleHRcblx0ICovXG5cdGV4ZWMgKGN0eCkge1xuXHRcdGlmICghdGhpcy5zdHlsZSkgeyByZXR1cm47IH1cblx0XHRjdHguZmlsbFN0eWxlID0gdGhpcy5zdHlsZTtcblx0XHRsZXQgbXR4ID0gdGhpcy5tYXRyaXg7XG5cdFx0aWYgKG10eCkgeyBjdHguc2F2ZSgpOyBjdHgudHJhbnNmb3JtKG10eC5hLCBtdHguYiwgbXR4LmMsIG10eC5kLCBtdHgudHgsIG10eC50eSk7IH1cblx0XHRjdHguZmlsbCgpO1xuXHRcdGlmIChtdHgpIHsgY3R4LnJlc3RvcmUoKTsgfVxuXHR9XG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgbGluZWFyIGdyYWRpZW50IHN0eWxlIGFuZCBhc3NpZ25zIGl0IHRvIHtAbGluayBlYXNlbGpzLkdyYXBoaWNzLkZpbGwjc3R5bGV9LlxuXHQgKiBAc2VlIHtAbGluayBlYXNlbGpzLkdyYXBoaWNzI2JlZ2luTGluZWFyR3JhZGllbnRGaWxsfVxuXHQgKiBAcGFyYW0ge0FycmF5PFN0cmluZz59IGNvbG9yc1xuXHQgKiBAcGFyYW0ge0FycmF5PE51bWJlcj59IHJhdGlvc1xuXHQgKiBAcGFyYW0ge051bWJlcn0geDBcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkwXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MVxuXHQgKiBAcGFyYW0ge051bWJlcn0geTFcblx0ICogQHJldHVybiB7ZWFzZWxqcy5HcmFwaGljcy5GaWxsfSBSZXR1cm5zIHRoaXMgRmlsbCBvYmplY3QgZm9yIGNoYWluaW5nIG9yIGFzc2lnbm1lbnQuXG5cdCAqL1xuXHRsaW5lYXJHcmFkaWVudCAoY29sb3JzLCByYXRpb3MsIHgwLCB5MCwgeDEsIHkxKSB7XG5cdFx0bGV0IG8gPSB0aGlzLnN0eWxlID0gR3JhcGhpY3MuX2N0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCh4MCwgeTAsIHgxLCB5MSk7XG5cdFx0Y29uc3QgbCA9IGNvbG9ycy5sZW5ndGg7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpKyspIHsgby5hZGRDb2xvclN0b3AocmF0aW9zW2ldLCBjb2xvcnNbaV0pOyB9XG5cdFx0by5wcm9wcyA9IHtjb2xvcnMsIHJhdGlvcywgeDAsIHkwLCB4MSwgeTEsIHR5cGU6XCJsaW5lYXJcIn07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBsaW5lYXIgZ3JhZGllbnQgc3R5bGUgYW5kIGFzc2lnbnMgaXQgdG8ge0BsaW5rIGVhc2VsanMuR3JhcGhpY3MuRmlsbCNzdHlsZX0uXG5cdCAqIEBzZWUge0BsaW5rIGVhc2VsanMuR3JhcGhpY3MjYmVnaW5SYWRpYWxHcmFkaWVudEZpbGx9XG5cdCAqIEBwYXJhbSB7QXJyYXk8U3RyaW5nPn0gY29sb3JzXG5cdCAqIEBwYXJhbSB7QXJyYXk8TnVtYmVyPn0gcmF0aW9zXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MFxuXHQgKiBAcGFyYW0ge051bWJlcn0geTBcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHIwXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MVxuXHQgKiBAcGFyYW0ge051bWJlcn0geTFcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHIxXG5cdCAqIEByZXR1cm4ge2Vhc2VsanMuR3JhcGhpY3MuRmlsbH0gUmV0dXJucyB0aGlzIEZpbGwgb2JqZWN0IGZvciBjaGFpbmluZyBvciBhc3NpZ25tZW50LlxuXHQgKi9cblx0cmFkaWFsR3JhZGllbnQgKGNvbG9ycywgcmF0aW9zLCB4MCwgeTAsIHIwLCB4MSwgeTEsIHIxKSB7XG5cdFx0bGV0IG8gPSB0aGlzLnN0eWxlID0gR3JhcGhpY3MuX2N0eC5jcmVhdGVSYWRpYWxHcmFkaWVudCh4MCwgeTAsIHIwLCB4MSwgeTEsIHIxKTtcblx0XHRjb25zdCBsID0gY29sb3JzLmxlbmd0aDtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGw7IGkrKykgeyBvLmFkZENvbG9yU3RvcChyYXRpb3NbaV0sIGNvbG9yc1tpXSk7IH1cblx0XHRvLnByb3BzID0ge2NvbG9ycywgcmF0aW9zLCB4MCwgeTAsIHIwLCB4MSwgeTEsIHIxLCB0eXBlOiBcInJhZGlhbFwifTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0ICogQ3JlYXRlcyBhIGxpbmVhciBncmFkaWVudCBzdHlsZSBhbmQgYXNzaWducyBpdCB0byB7QGxpbmsgZWFzZWxqcy5HcmFwaGljcy5GaWxsI3N0eWxlfS5cblx0ICogQHNlZSB7QGxpbmsgZWFzZWxqcy5HcmFwaGljcyNiZWdpbkJpdG1hcEZpbGx9XG5cdCAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudCB8IEhUTUxDYW52YXNFbGVtZW50IHwgSFRNTFZpZGVvRWxlbWVudH0gaW1hZ2UgIE11c3QgYmUgbG9hZGVkIHByaW9yIHRvIGNyZWF0aW5nIGEgYml0bWFwIGZpbGwsIG9yIHRoZSBmaWxsIHdpbGwgYmUgZW1wdHkuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbcmVwZXRpdGlvbj1cIlwiXSBPbmUgb2Y6IHJlcGVhdCwgcmVwZWF0LXgsIHJlcGVhdC15LCBvciBuby1yZXBlYXQuXG5cdCAqIEByZXR1cm4ge2Vhc2VsanMuR3JhcGhpY3MuRmlsbH0gUmV0dXJucyB0aGlzIEZpbGwgb2JqZWN0IGZvciBjaGFpbmluZyBvciBhc3NpZ25tZW50LlxuXHQgKi9cblx0Yml0bWFwIChpbWFnZSwgcmVwZXRpdGlvbiA9IFwiXCIpIHtcblx0XHRpZiAoaW1hZ2UubmF0dXJhbFdpZHRoIHx8IGltYWdlLmdldENvbnRleHQgfHwgaW1hZ2UucmVhZHlTdGF0ZSA+PSAyKSB7XG5cdFx0XHRsZXQgbyA9IHRoaXMuc3R5bGUgPSBHcmFwaGljcy5fY3R4LmNyZWF0ZVBhdHRlcm4oaW1hZ2UsIHJlcGV0aXRpb24pO1xuXHRcdFx0by5wcm9wcyA9IHtpbWFnZSwgcmVwZXRpdGlvbiwgdHlwZTogXCJiaXRtYXBcIn07XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59XG5cbi8qKlxuICogQHNlZSB7QGxpbmsgZWFzZWxqcy5HcmFwaGljcyNiZWdpblN0cm9rZX1cbiAqIEBhbGlhcyBlYXNlbGpzLkdyYXBoaWNzLlN0cm9rZVxuICogQGV4dGVuZHMgZWFzZWxqcy5HcmFwaGljcy5GaWxsXG4gKiBAcGFyYW0ge09iamVjdH0gc3R5bGUgQSB2YWxpZCBDb250ZXh0MkQgZmlsbFN0eWxlLlxuICogQHBhcmFtIHtCb29sZWFufSBpZ25vcmVTY2FsZVxuICovXG5jbGFzcyBTdHJva2UgZXh0ZW5kcyBGaWxsIHtcblx0Y29uc3RydWN0b3IgKHN0eWxlLCBpZ25vcmVTY2FsZSkge1xuXHRcdHN1cGVyKCk7XG5cdFx0LyoqXG5cdFx0ICogQSB2YWxpZCBDb250ZXh0MkQgc3Ryb2tlU3R5bGUuXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0XHR0aGlzLnN0eWxlID0gc3R5bGU7XG5cdFx0LyoqXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICovXG5cdFx0dGhpcy5pZ25vcmVTY2FsZSA9IGlnbm9yZVNjYWxlO1xuXHRcdC8qKlxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqL1xuXHRcdHRoaXMucGF0aCA9IGZhbHNlO1xuXHR9XG5cdC8qKlxuXHQgKiBFeGVjdXRlIHRoZSBHcmFwaGljcyBjb21tYW5kIGluIHRoZSBwcm92aWRlZCBDYW52YXMgY29udGV4dC5cblx0ICogQG92ZXJyaWRlXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggVGhlIGNhbnZhcyByZW5kZXJpbmcgY29udGV4dFxuXHQgKi9cblx0ZXhlYyAoY3R4KSB7XG5cdFx0aWYgKCF0aGlzLnN0eWxlKSB7IHJldHVybjsgfVxuXHRcdGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuc3R5bGU7XG5cdFx0aWYgKHRoaXMuaWdub3JlU2NhbGUpIHsgY3R4LnNhdmUoKTsgY3R4LnNldFRyYW5zZm9ybSgxLDAsMCwxLDAsMCk7IH1cblx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0aWYgKHRoaXMuaWdub3JlU2NhbGUpIHsgY3R4LnJlc3RvcmUoKTsgfVxuXHR9XG59XG5cbi8qKlxuICogQHNlZSB7QGxpbmsgZWFzZWxqcy5HcmFwaGljcyNzZXRTdHJva2VTdHlsZX1cbiAqIEBhbGlhcyBlYXNlbGpzLkdyYXBoaWNzLlN0cm9rZVN0eWxlXG4gKiBAcGFyYW0ge051bWJlcn0gW3dpZHRoPTFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW2NhcHM9YnV0dF1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbam9pbnRzPW1pdGVyXVxuICogQHBhcmFtIHtOdW1iZXJ9IFttaXRlckxpbWl0PTEwXVxuICogQHBhcmFtIHtCb29sZWFufSBbaWdub3JlU2NhbGU9ZmFsc2VdXG4gKi9cbmNsYXNzIFN0cm9rZVN0eWxlIHtcblx0Y29uc3RydWN0b3IgKHdpZHRoPTEsIGNhcHM9XCJidXR0XCIsIGpvaW50cz1cIm1pdGVyXCIsIG1pdGVyTGltaXQ9MTAsIGlnbm9yZVNjYWxlPWZhbHNlKSB7XG5cdFx0LyoqXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKi9cblx0XHR0aGlzLndpZHRoID0gd2lkdGg7XG5cdFx0LyoqXG5cdFx0ICogT25lIG9mOiBidXR0LCByb3VuZCwgc3F1YXJlXG5cdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHQgKi9cblx0XHR0aGlzLmNhcHMgPSBjYXBzO1xuXHRcdC8qKlxuXHRcdCAqIE9uZSBvZjogcm91bmQsIGJldmVsLCBtaXRlclxuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICovXG5cdFx0dGhpcy5qb2ludHMgPSBqb2ludHM7XG5cdFx0LyoqXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKi9cblx0XHR0aGlzLm1pdGVyTGltaXQgPSBtaXRlckxpbWl0O1xuXHRcdC8qKlxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqL1xuXHRcdHRoaXMuaWdub3JlU2NhbGUgPSBpZ25vcmVTY2FsZTtcblx0XHQvKipcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKi9cblx0XHR0aGlzLnBhdGggPSBmYWxzZTtcblx0fVxuXHQvKipcblx0ICogRXhlY3V0ZSB0aGUgR3JhcGhpY3MgY29tbWFuZCBpbiB0aGUgcHJvdmlkZWQgQ2FudmFzIGNvbnRleHQuXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggVGhlIGNhbnZhcyByZW5kZXJpbmcgY29udGV4dFxuXHQgKi9cblx0ZXhlYyAoY3R4KSB7XG5cdFx0Y3R4LmxpbmVXaWR0aCA9IHRoaXMud2lkdGg7XG5cdFx0Y3R4LmxpbmVDYXAgPSAoaXNOYU4odGhpcy5jYXBzKSA/IHRoaXMuY2FwcyA6IEdyYXBoaWNzLl9TVFJPS0VfQ0FQU19NQVBbdGhpcy5jYXBzXSk7XG5cdFx0Y3R4LmxpbmVKb2luID0gKGlzTmFOKHRoaXMuam9pbnRzKSA/IHRoaXMuam9pbnRzIDogR3JhcGhpY3MuX1NUUk9LRV9KT0lOVFNfTUFQW3RoaXMuam9pbnRzXSk7XG5cdFx0Y3R4Lm1pdGVyTGltaXQgPSB0aGlzLm1pdGVyTGltaXQ7XG5cdFx0Y3R4Lmlnbm9yZVNjYWxlID0gdGhpcy5pZ25vcmVTY2FsZTtcblx0fVxufVxuXG4vKipcbiAqIEBzZWUge0BsaW5rIGVhc2VsanMuR3JhcGhpY3Mjc2V0U3Ryb2tlRGFzaH1cbiAqIEBhbGlhcyBlYXNlbGpzLkdyYXBoaWNzLlN0cm9rZURhc2hcbiAqIEBwYXJhbSB7QXJyYXl9IFtzZWdtZW50cz1bXV1cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb2Zmc2V0PTBdXG4gKi9cbmNsYXNzIFN0cm9rZURhc2gge1xuIFx0Y29uc3RydWN0b3IgKHNlZ21lbnRzPVtdLCBvZmZzZXQ9MCkge1xuXHRcdC8qKlxuXHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHQgKi9cblx0IFx0dGhpcy5zZWdtZW50cyA9IHNlZ21lbnRzO1xuXHRcdC8qKlxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICovXG5cdCBcdHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuIFx0fVxuXG5cdC8qKlxuXHQgKiBFeGVjdXRlIHRoZSBHcmFwaGljcyBjb21tYW5kIGluIHRoZSBwcm92aWRlZCBDYW52YXMgY29udGV4dC5cblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBUaGUgY2FudmFzIHJlbmRlcmluZyBjb250ZXh0XG5cdCAqL1xuIFx0ZXhlYyAoY3R4KSB7XG4gXHRcdGlmIChjdHguc2V0TGluZURhc2gpIHsgLy8gZmVhdHVyZSBkZXRlY3Rpb24uXG5cdCBcdFx0Y3R4LnNldExpbmVEYXNoKHRoaXMuc2VnbWVudHMpO1xuXHQgXHRcdGN0eC5saW5lRGFzaE9mZnNldCA9IHRoaXMub2Zmc2V0O1xuXHQgXHR9XG4gXHR9XG59XG5cbi8qKlxuICogQHNlZSB7QGxpbmsgZWFzZWxqcy5HcmFwaGljcyNkcmF3Um91bmRSZWN0Q29tcGxleH1cbiAqIEBhbGlhcyBlYXNlbGpzLkdyYXBoaWNzLlJvdW5kUmVjdFxuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gKiBAcGFyYW0ge051bWJlcn0gd1xuICogQHBhcmFtIHtOdW1iZXJ9IGhcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNUTFxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c1RSXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzQlJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNCTFxuICovXG5jbGFzcyBSb3VuZFJlY3Qge1xuIFx0Y29uc3RydWN0b3IgKHgsIHksIHcsIGgsIHJhZGl1c1RMLCByYWRpdXNUUiwgcmFkaXVzQlIsIHJhZGl1c0JMKSB7XG5cdFx0LyoqXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKi9cblx0IFx0dGhpcy54ID0geDtcblx0XHQvKipcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqL1xuXHRcdHRoaXMueSA9IHk7XG5cdFx0LyoqXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKi9cblx0IFx0dGhpcy53ID0gdztcblx0XHQvKipcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqL1xuXHRcdHRoaXMuaCA9IGg7XG5cdFx0LyoqXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKi9cblx0IFx0dGhpcy5yYWRpdXNUTCA9IHJhZGl1c1RMO1xuXHRcdC8qKlxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICovXG5cdFx0dGhpcy5yYWRpdXNUUiA9IHJhZGl1c1RSO1xuXHRcdC8qKlxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICovXG5cdCBcdHRoaXMucmFkaXVzQlIgPSByYWRpdXNCUjtcblx0XHQvKipcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqL1xuXHRcdHRoaXMucmFkaXVzQkwgPSByYWRpdXNCTDtcbiBcdH1cblx0LyoqXG5cdCAqIEV4ZWN1dGUgdGhlIEdyYXBoaWNzIGNvbW1hbmQgaW4gdGhlIHByb3ZpZGVkIENhbnZhcyBjb250ZXh0LlxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IFRoZSBjYW52YXMgcmVuZGVyaW5nIGNvbnRleHRcblx0ICovXG4gXHRleGVjIChjdHgpIHtcbiBcdFx0bGV0IG1heCA9ICh0aGlzLnc8dGhpcy5oP3RoaXMudzp0aGlzLmgpLzI7XG5cdCBcdGxldCBtVEw9MCwgbVRSPTAsIG1CUj0wLCBtQkw9MDtcblx0IFx0bGV0IHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHcgPSB0aGlzLncsIGggPSB0aGlzLmg7XG5cdCBcdGxldCByVEwgPSB0aGlzLnJhZGl1c1RMLCByVFIgPSB0aGlzLnJhZGl1c1RSLCByQlIgPSB0aGlzLnJhZGl1c0JSLCByQkwgPSB0aGlzLnJhZGl1c0JMO1xuXG5cdCBcdGlmIChyVEwgPCAwKSB7IHJUTCAqPSAobVRMPS0xKTsgfVxuXHQgXHRpZiAoclRMID4gbWF4KSB7IHJUTCA9IG1heDsgfVxuXHQgXHRpZiAoclRSIDwgMCkgeyByVFIgKj0gKG1UUj0tMSk7IH1cblx0IFx0aWYgKHJUUiA+IG1heCkgeyByVFIgPSBtYXg7IH1cblx0IFx0aWYgKHJCUiA8IDApIHsgckJSICo9IChtQlI9LTEpOyB9XG5cdCBcdGlmIChyQlIgPiBtYXgpIHsgckJSID0gbWF4OyB9XG5cdCBcdGlmIChyQkwgPCAwKSB7IHJCTCAqPSAobUJMPS0xKTsgfVxuXHQgXHRpZiAockJMID4gbWF4KSB7IHJCTCA9IG1heDsgfVxuXG5cdCBcdGN0eC5tb3ZlVG8oeCt3LXJUUiwgeSk7XG5cdCBcdGN0eC5hcmNUbyh4K3crclRSKm1UUiwgeS1yVFIqbVRSLCB4K3csIHkrclRSLCByVFIpO1xuXHQgXHRjdHgubGluZVRvKHgrdywgeStoLXJCUik7XG5cdCBcdGN0eC5hcmNUbyh4K3crckJSKm1CUiwgeStoK3JCUiptQlIsIHgrdy1yQlIsIHkraCwgckJSKTtcblx0IFx0Y3R4LmxpbmVUbyh4K3JCTCwgeStoKTtcblx0IFx0Y3R4LmFyY1RvKHgtckJMKm1CTCwgeStoK3JCTCptQkwsIHgsIHkraC1yQkwsIHJCTCk7XG5cdCBcdGN0eC5saW5lVG8oeCwgeStyVEwpO1xuXHQgXHRjdHguYXJjVG8oeC1yVEwqbVRMLCB5LXJUTCptVEwsIHgrclRMLCB5LCByVEwpO1xuXHQgXHRjdHguY2xvc2VQYXRoKCk7XG4gXHR9XG59XG5cbi8qKlxuICogQHNlZSB7QGxpbmsgZWFzZWxqcy5HcmFwaGljcyNkcmF3Q2lyY2xlfVxuICogQGFsaWFzIGVhc2VsanMuR3JhcGhpY3MuQ2lyY2xlXG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNcbiAqL1xuY2xhc3MgQ2lyY2xlIHtcbiBcdGNvbnN0cnVjdG9yICh4LCB5LCByYWRpdXMpIHtcblx0XHQvKipcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqL1xuXHQgXHR0aGlzLnggPSB4O1xuXHRcdC8qKlxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICovXG5cdFx0dGhpcy55ID0geTtcblx0XHQvKipcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqL1xuXHQgXHR0aGlzLnJhZGl1cyA9IHJhZGl1cztcbiBcdH1cblx0LyoqXG5cdCAqIEV4ZWN1dGUgdGhlIEdyYXBoaWNzIGNvbW1hbmQgaW4gdGhlIHByb3ZpZGVkIENhbnZhcyBjb250ZXh0LlxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IFRoZSBjYW52YXMgcmVuZGVyaW5nIGNvbnRleHRcblx0ICovXG4gXHRleGVjIChjdHgpIHtcbiBcdFx0Y3R4LmFyYyh0aGlzLngsIHRoaXMueSwgdGhpcy5yYWRpdXMsIDAsIE1hdGguUEkqMik7XG4gXHR9XG59XG5cbi8qKlxuICogQHNlZSB7QGxpbmsgZWFzZWxqcy5HcmFwaGljcyNkcmF3RWxsaXBzZX1cbiAqIEBhbGlhcyBlYXNlbGpzLkdyYXBoaWNzLkVsbGlwc2VcbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiBAcGFyYW0ge051bWJlcn0geVxuICogQHBhcmFtIHtOdW1iZXJ9IHdcbiAqIEBwYXJhbSB7TnVtYmVyfSBoXG4gKi9cbmNsYXNzIEVsbGlwc2Uge1xuIFx0Y29uc3RydWN0b3IgKHgsIHksIHcsIGgpIHtcblx0XHQvKipcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqL1xuXHQgXHR0aGlzLnggPSB4O1xuXHRcdC8qKlxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICovXG5cdFx0dGhpcy55ID0geTtcblx0XHQvKipcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqL1xuXHQgXHR0aGlzLncgPSB3O1xuXHRcdC8qKlxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICovXG5cdFx0dGhpcy5oID0gaDtcbiBcdH1cblx0LyoqXG5cdCAqIEV4ZWN1dGUgdGhlIEdyYXBoaWNzIGNvbW1hbmQgaW4gdGhlIHByb3ZpZGVkIENhbnZhcyBjb250ZXh0LlxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IFRoZSBjYW52YXMgcmVuZGVyaW5nIGNvbnRleHRcblx0ICovXG4gXHRleGVjIChjdHgpIHtcbiBcdFx0bGV0IHggPSB0aGlzLngsIHkgPSB0aGlzLnk7XG5cdCBcdGxldCB3ID0gdGhpcy53LCBoID0gdGhpcy5oO1xuXG5cdCBcdGxldCBrID0gMC41NTIyODQ4O1xuXHQgXHRsZXQgb3ggPSAodyAvIDIpICogaztcblx0IFx0bGV0IG95ID0gKGggLyAyKSAqIGs7XG5cdCBcdGxldCB4ZSA9IHggKyB3O1xuXHQgXHRsZXQgeWUgPSB5ICsgaDtcblx0IFx0bGV0IHhtID0geCArIHcgLyAyO1xuXHQgXHRsZXQgeW0gPSB5ICsgaCAvIDI7XG5cblx0IFx0Y3R4Lm1vdmVUbyh4LCB5bSk7XG5cdCBcdGN0eC5iZXppZXJDdXJ2ZVRvKHgsIHltLW95LCB4bS1veCwgeSwgeG0sIHkpO1xuXHQgXHRjdHguYmV6aWVyQ3VydmVUbyh4bStveCwgeSwgeGUsIHltLW95LCB4ZSwgeW0pO1xuXHQgXHRjdHguYmV6aWVyQ3VydmVUbyh4ZSwgeW0rb3ksIHhtK294LCB5ZSwgeG0sIHllKTtcblx0IFx0Y3R4LmJlemllckN1cnZlVG8oeG0tb3gsIHllLCB4LCB5bStveSwgeCwgeW0pO1xuIFx0fVxufVxuXG4vKipcbiAqICBAc2VlIHtAbGluayBlYXNlbGpzLkdyYXBoaWNzI2RyYXdQb2x5U3Rhcn1cbiAqIEBhbGlhcyBlYXNlbGpzLkdyYXBoaWNzLlBvbHlTdGFyXG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNcbiAqIEBwYXJhbSB7TnVtYmVyfSBzaWRlc1xuICogQHBhcmFtIHtOdW1iZXJ9IFtwb2ludFNpemU9MF1cbiAqIEBwYXJhbSB7TnVtYmVyfSBbYW5nbGU9MF1cbiAqL1xuY2xhc3MgUG9seVN0YXIge1xuIFx0Y29uc3RydWN0b3IgKHgsIHksIHJhZGl1cywgc2lkZXMsIHBvaW50U2l6ZT0wLCBhbmdsZT0wKSB7XG5cdFx0LyoqXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKi9cblx0IFx0dGhpcy54ID0geDtcblx0XHQvKipcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqL1xuXHRcdHRoaXMueSA9IHk7XG5cdFx0LyoqXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKi9cblx0IFx0dGhpcy5yYWRpdXMgPSByYWRpdXM7XG5cdFx0LyoqXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKi9cblx0IFx0dGhpcy5zaWRlcyA9IHNpZGVzO1xuXHRcdC8qKlxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICovXG5cdCBcdHRoaXMucG9pbnRTaXplID0gcG9pbnRTaXplO1xuXHRcdC8qKlxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICovXG5cdCBcdHRoaXMuYW5nbGUgPSBhbmdsZTtcbiBcdH1cblx0LyoqXG5cdCAqIEV4ZWN1dGUgdGhlIEdyYXBoaWNzIGNvbW1hbmQgaW4gdGhlIHByb3ZpZGVkIENhbnZhcyBjb250ZXh0LlxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IFRoZSBjYW52YXMgcmVuZGVyaW5nIGNvbnRleHRcblx0ICovXG4gXHRleGVjIChjdHgpIHtcbiBcdFx0bGV0IHggPSB0aGlzLngsIHkgPSB0aGlzLnk7XG5cdCBcdGxldCByYWRpdXMgPSB0aGlzLnJhZGl1cztcblx0IFx0bGV0IGFuZ2xlID0gdGhpcy5hbmdsZS8xODAqTWF0aC5QSTtcblx0IFx0bGV0IHNpZGVzID0gdGhpcy5zaWRlcztcblx0IFx0bGV0IHBzID0gMS10aGlzLnBvaW50U2l6ZTtcblx0IFx0bGV0IGEgPSBNYXRoLlBJL3NpZGVzO1xuXG5cdCBcdGN0eC5tb3ZlVG8oeCtNYXRoLmNvcyhhbmdsZSkqcmFkaXVzLCB5K01hdGguc2luKGFuZ2xlKSpyYWRpdXMpO1xuXHQgXHRmb3IgKGxldCBpID0gMDsgaSA8IHNpZGVzOyBpKyspIHtcblx0IFx0XHRhbmdsZSArPSBhO1xuXHQgXHRcdGlmIChwcyAhPSAxKSB7XG5cdCBcdFx0XHRjdHgubGluZVRvKHgrTWF0aC5jb3MoYW5nbGUpKnJhZGl1cypwcywgeStNYXRoLnNpbihhbmdsZSkqcmFkaXVzKnBzKTtcblx0IFx0XHR9XG5cdCBcdFx0YW5nbGUgKz0gYTtcblx0IFx0XHRjdHgubGluZVRvKHgrTWF0aC5jb3MoYW5nbGUpKnJhZGl1cywgeStNYXRoLnNpbihhbmdsZSkqcmFkaXVzKTtcblx0IFx0fVxuXHQgXHRjdHguY2xvc2VQYXRoKCk7XG4gXHR9XG59XG5cbi8qKlxuICogQSByZXVzYWJsZSBpbnN0YW5jZSBvZiB7QGxpbmsgZWFzZWxqcy5HcmFwaGljcy5CZWdpblBhdGh9IHRvIGF2b2lkIHVubmVjZXNzYXJ5IGluc3RhbnRpYXRpb24uXG4gKiBAc3RhdGljXG4gKiBAcmVhZG9ubHlcbiAqIEB0eXBlIHtlYXNlbGpzLkdyYXBoaWNzLkJlZ2luUGF0aH1cbiAqL1xuR3JhcGhpY3MuYmVnaW5DbWQgPSBuZXcgQmVnaW5QYXRoKCk7XG4vKipcbiAqIE1hcCBvZiBCYXNlNjQgY2hhcmFjdGVycyB0byB2YWx1ZXMuIFVzZWQgYnkge0BsaW5rIGVhc2VsanMuR3JhcGhpY3MjZGVjb2RlUGF0aH0uXG4gKiBAc3RhdGljXG4gKiBAcmVhZG9ubHlcbiAqIEBwcm90ZWN0ZWRcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbkdyYXBoaWNzLl9CQVNFXzY0ID0ge1wiQVwiOjAsXCJCXCI6MSxcIkNcIjoyLFwiRFwiOjMsXCJFXCI6NCxcIkZcIjo1LFwiR1wiOjYsXCJIXCI6NyxcIklcIjo4LFwiSlwiOjksXCJLXCI6MTAsXCJMXCI6MTEsXCJNXCI6MTIsXCJOXCI6MTMsXCJPXCI6MTQsXCJQXCI6MTUsXCJRXCI6MTYsXCJSXCI6MTcsXCJTXCI6MTgsXCJUXCI6MTksXCJVXCI6MjAsXCJWXCI6MjEsXCJXXCI6MjIsXCJYXCI6MjMsXCJZXCI6MjQsXCJaXCI6MjUsXCJhXCI6MjYsXCJiXCI6MjcsXCJjXCI6MjgsXCJkXCI6MjksXCJlXCI6MzAsXCJmXCI6MzEsXCJnXCI6MzIsXCJoXCI6MzMsXCJpXCI6MzQsXCJqXCI6MzUsXCJrXCI6MzYsXCJsXCI6MzcsXCJtXCI6MzgsXCJuXCI6MzksXCJvXCI6NDAsXCJwXCI6NDEsXCJxXCI6NDIsXCJyXCI6NDMsXCJzXCI6NDQsXCJ0XCI6NDUsXCJ1XCI6NDYsXCJ2XCI6NDcsXCJ3XCI6NDgsXCJ4XCI6NDksXCJ5XCI6NTAsXCJ6XCI6NTEsXCIwXCI6NTIsXCIxXCI6NTMsXCIyXCI6NTQsXCIzXCI6NTUsXCI0XCI6NTYsXCI1XCI6NTcsXCI2XCI6NTgsXCI3XCI6NTksXCI4XCI6NjAsXCI5XCI6NjEsXCIrXCI6NjIsXCIvXCI6NjN9O1xuLyoqXG4gKiBNYXBzIG51bWVyaWMgdmFsdWVzIGZvciB0aGUgY2FwcyBwYXJhbWV0ZXIgb2Yge0BsaW5rIGVhc2VsanMuR3JhcGhpY3Mjc2V0U3Ryb2tlU3R5bGV9IHRvXG4gKiBjb3JyZXNwb25kaW5nIHN0cmluZyB2YWx1ZXMuIFRoaXMgaXMgcHJpbWFyaWx5IGZvciB1c2Ugd2l0aCB0aGUgdGlueSBBUEkuPGJyIC8+XG4gKiBUaGUgbWFwcGluZ3MgYXJlIGFzIGZvbGxvd3M6XG4gKiA8dWw+XG4gKiAgIDxsaT4wIHRvIFwiYnV0dFwiPC9saT5cbiAqICAgPGxpPjEgdG8gXCJyb3VuZFwiPC9saT5cbiAqICAgPGxpPjIgdG8gXCJzcXVhcmVcIi48L2xpPlxuICogPC91bD5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5TZXQgbGluZSBjYXBzIHRvIFwic3F1YXJlXCI8L2NhcHRpb24+XG4gKiBncmFwaGljcy5zcygxNiwgMik7XG4gKlxuICogQHN0YXRpY1xuICogQHJlYWRvbmx5XG4gKiBAcHJvdGVjdGVkXG4gKiBAdHlwZSB7QXJyYXk8U3RyaW5nPn1cbiAqL1xuR3JhcGhpY3MuX1NUUk9LRV9DQVBTX01BUCA9IFtcImJ1dHRcIixcInJvdW5kXCIsXCJzcXVhcmVcIl07XG4vKipcbiAqIE1hcHMgbnVtZXJpYyB2YWx1ZXMgZm9yIHRoZSBqb2ludHMgcGFyYW1ldGVyIG9mIHtAbGluayBlYXNlbGpzLkdyYXBoaWNzI3NldFN0cm9rZVN0eWxlfSB0b1xuICogY29ycmVzcG9uZGluZyBzdHJpbmcgdmFsdWVzLiBUaGlzIGlzIHByaW1hcmlseSBmb3IgdXNlIHdpdGggdGhlIHRpbnkgQVBJLjxiciAvPlxuICogVGhlIG1hcHBpbmdzIGFyZSBhcyBmb2xsb3dzOlxuICogPHVsPlxuICogICA8bGk+MCB0byBcIm1pdGVyXCI8L2xpPlxuICogICA8bGk+MSB0byBcInJvdW5kXCI8L2xpPlxuICogICA8bGk+MiB0byBcImJldmVsXCIuPC9saT5cbiAqIDwvdWw+XG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+U2V0IHRoZSBsaW5lIGpvaW50cyB0byBcImJldmVsXCI8L2NhcHRpb24+XG4gKiBncmFwaGljcy5zcygxNiwgMCwgMik7XG4gKlxuICogQHN0YXRpY1xuICogQHJlYWRvbmx5XG4gKiBAcHJvdGVjdGVkXG4gKiBAdHlwZSB7QXJyYXk8U3RyaW5nPn1cbiAqL1xuR3JhcGhpY3MuX1NUUk9LRV9KT0lOVFNfTUFQID0gW1wibWl0ZXJcIiwgXCJyb3VuZFwiLCBcImJldmVsXCJdO1xuLyoqXG4gKiBAc3RhdGljXG4gKiBAcmVhZG9ubHlcbiAqIEBwcm90ZWN0ZWRcbiAqIEB0eXBlIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9XG4gKi9cbkdyYXBoaWNzLl9jdHggPSBjcmVhdGVDYW52YXMoKS5nZXRDb250ZXh0KFwiMmRcIik7XG4iLCIvKipcbiAqIEBsaWNlbnNlIEFic3RyYWN0VHdlZW5cbiAqIFZpc2l0IGh0dHA6Ly9jcmVhdGVqcy5jb20vIGZvciBkb2N1bWVudGF0aW9uLCB1cGRhdGVzIGFuZCBleGFtcGxlcy5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgZ3NraW5uZXIuY29tLCBpbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAqIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXG4gKiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXRcbiAqIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxuICogY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuICogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbiAqIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAqIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gKiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcbiAqIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gKiBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuICogSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXG4gKiBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcbiAqIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5pbXBvcnQgeyBFdmVudERpc3BhdGNoZXIgfSBmcm9tIFwiQGNyZWF0ZWpzL2NvcmVcIjtcbmltcG9ydCBUd2VlbiBmcm9tIFwiLi9Ud2VlblwiO1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgdGhhdCBib3RoIHtAbGluayB0d2VlbmpzLlR3ZWVufSBhbmQge0BsaW5rIHR3ZWVuanMuVGltZWxpbmV9IGV4dGVuZC4gU2hvdWxkIG5vdCBiZSBpbnN0YW50aWF0ZWQgZGlyZWN0bHkuXG4gKlxuICogQG1lbWJlcm9mIHR3ZWVuanNcbiAqIEBleHRlbmRzIGNvcmUuRXZlbnREaXNwYXRjaGVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wc10gVGhlIGNvbmZpZ3VyYXRpb24gcHJvcGVydGllcyB0byBhcHBseSB0byB0aGlzIGluc3RhbmNlIChleC4gYHtsb29wOi0xLCBwYXVzZWQ6dHJ1ZX1gKS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3Byb3BzLnVzZVRpY2tzPWZhbHNlXSBTZWUgdGhlIHtAbGluayB0d2VlbmpzLkFic3RyYWN0VHdlZW4jdXNlVGlja3N9IHByb3BlcnR5IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICogQHBhcmFtIHtCb29sZWFufSBbcHJvcHMuaWdub3JlR2xvYmFsUGF1c2U9ZmFsc2VdIFNlZSB0aGUge0BsaW5rIHR3ZWVuanMuQWJzdHJhY3RUd2VlbiNpZ25vcmVHbG9iYWxQYXVzZX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKiBAcGFyYW0ge051bWJlcnxCb29sZWFufSBbcHJvcHMubG9vcD0wXSBTZWUgdGhlIHtAbGluayB0d2VlbmpzLkFic3RyYWN0VHdlZW4jbG9vcH0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtwcm9wcy5yZXZlcnNlZD1mYWxzZV0gU2VlIHRoZSB7QGxpbmsgdHdlZW5qcy5BYnN0cmFjdFR3ZWVuI3JldmVyc2VkfSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3Byb3BzLmJvdW5jZT1mYWxzZV0gU2VlIHRoZSB7QGxpbmsgdHdlZW5qcy5BYnN0cmFjdFR3ZWVuI2JvdW5jZX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKiBAcGFyYW0ge051bWJlcn0gW3Byb3BzLnRpbWVTY2FsZT0xXSBTZWUgdGhlIHtAbGluayB0d2VlbmpzLkFic3RyYWN0VHdlZW4jdGltZVNjYWxlfSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcm9wcy5vbkNoYW5nZV0gQWRkcyB0aGUgc3BlY2lmaWVkIGZ1bmN0aW9uIGFzIGEgbGlzdGVuZXIgdG8gdGhlIHtAbGluayB0d2VlbmpzLkFic3RyYWN0VHdlZW4jZXZlbnQ6Y2hhbmdlfSBldmVudC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcm9wcy5vbkNvbXBsZXRlXSBBZGRzIHRoZSBzcGVjaWZpZWQgZnVuY3Rpb24gYXMgYSBsaXN0ZW5lciB0byB0aGUge0BsaW5rIHR3ZWVuanMuQWJzdHJhY3RUd2VlbiNldmVudDpjb21wbGV0ZX0gZXZlbnQuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFic3RyYWN0VHdlZW4gZXh0ZW5kcyBFdmVudERpc3BhdGNoZXIge1xuXG4gIGNvbnN0cnVjdG9yIChwcm9wcykge1xuICAgIHN1cGVyKCk7XG5cblx0XHQvKipcblx0XHQgKiBDYXVzZXMgdGhpcyB0d2VlbiB0byBjb250aW51ZSBwbGF5aW5nIHdoZW4gYSBnbG9iYWwgcGF1c2UgaXMgYWN0aXZlLiBGb3IgZXhhbXBsZSwgaWYgVHdlZW5KUyBpcyB1c2luZyB7QGxpbmsgY29yZS5UaWNrZXJ9LFxuXHRcdCAqIHRoZW4gc2V0dGluZyB0aGlzIHRvIGZhbHNlICh0aGUgZGVmYXVsdCkgd2lsbCBjYXVzZSB0aGlzIHR3ZWVuIHRvIGJlIHBhdXNlZCB3aGVuIGBUaWNrZXIuc2V0UGF1c2VkKHRydWUpYFxuXHRcdCAqIGlzIGNhbGxlZC4gU2VlIHRoZSB7QGxpbmsgdHdlZW5qcy5Ud2VlbiN0aWNrfSBtZXRob2QgZm9yIG1vcmUgaW5mby4gQ2FuIGJlIHNldCB2aWEgdGhlIGBwcm9wc2AgcGFyYW1ldGVyLlxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICovXG5cdFx0dGhpcy5pZ25vcmVHbG9iYWxQYXVzZSA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHRoZSBudW1iZXIgb2YgdGltZXMgdG8gbG9vcC4gSWYgc2V0IHRvIC0xLCB0aGUgdHdlZW4gd2lsbCBsb29wIGNvbnRpbnVvdXNseS5cblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKi9cblx0XHR0aGlzLmxvb3AgPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogVXNlcyB0aWNrcyBmb3IgYWxsIGR1cmF0aW9ucyBpbnN0ZWFkIG9mIG1pbGxpc2Vjb25kcy4gVGhpcyBhbHNvIGNoYW5nZXMgdGhlIGJlaGF2aW91ciBvZiBzb21lIGFjdGlvbnMgKHN1Y2ggYXMgYGNhbGxgKS5cblx0XHQgKiBDaGFuZ2luZyB0aGlzIHZhbHVlIG9uIGEgcnVubmluZyB0d2VlbiBjb3VsZCBoYXZlIHVuZXhwZWN0ZWQgcmVzdWx0cy5cblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqL1xuXHRcdHRoaXMudXNlVGlja3MgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIENhdXNlcyB0aGUgdHdlZW4gdG8gcGxheSBpbiByZXZlcnNlLlxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICovXG5cdFx0dGhpcy5yZXZlcnNlZCA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogQ2F1c2VzIHRoZSB0d2VlbiB0byByZXZlcnNlIGRpcmVjdGlvbiBhdCB0aGUgZW5kIG9mIGVhY2ggbG9vcC5cblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqL1xuXHRcdHRoaXMuYm91bmNlID0gZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBDaGFuZ2VzIHRoZSByYXRlIGF0IHdoaWNoIHRoZSB0d2VlbiBhZHZhbmNlcy4gRm9yIGV4YW1wbGUsIGEgYHRpbWVTY2FsZWAgdmFsdWUgb2YgYDJgIHdpbGwgZG91YmxlIHRoZVxuXHRcdCAqIHBsYXliYWNrIHNwZWVkLCBhIHZhbHVlIG9mIGAwLjVgIHdvdWxkIGhhbHZlIGl0LlxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMVxuXHRcdCAqL1xuXHRcdHRoaXMudGltZVNjYWxlID0gMTtcblxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyB0aGUgZHVyYXRpb24gb2YgdGhpcyB0d2VlbiBpbiBtaWxsaXNlY29uZHMgKG9yIHRpY2tzIGlmIGB1c2VUaWNrc2AgaXMgdHJ1ZSksIGlycmVzcGVjdGl2ZSBvZiBgbG9vcHNgLlxuXHRcdCAqIFRoaXMgdmFsdWUgaXMgYXV0b21hdGljYWxseSB1cGRhdGVkIGFzIHlvdSBtb2RpZnkgdGhlIHR3ZWVuLiBDaGFuZ2luZyBpdCBkaXJlY3RseSBjb3VsZCByZXN1bHQgaW4gdW5leHBlY3RlZFxuXHRcdCAqIGJlaGF2aW91ci5cblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKi9cblx0XHR0aGlzLmR1cmF0aW9uID0gMDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBjdXJyZW50IG5vcm1hbGl6ZWQgcG9zaXRpb24gb2YgdGhlIHR3ZWVuLiBUaGlzIHdpbGwgYWx3YXlzIGJlIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCBgZHVyYXRpb25gLlxuXHRcdCAqIENoYW5naW5nIHRoaXMgcHJvcGVydHkgZGlyZWN0bHkgd2lsbCBoYXZlIHVuZXhwZWN0ZWQgcmVzdWx0cywgdXNlIHtAbGluayB0d2VlbmpzLlR3ZWVuI3NldFBvc2l0aW9ufS5cblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKi9cblx0XHR0aGlzLnBvc2l0aW9uID0gMDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSByYXcgdHdlZW4gcG9zaXRpb24uIFRoaXMgdmFsdWUgd2lsbCBiZSBiZXR3ZWVuIGAwYCBhbmQgYGxvb3BzICogZHVyYXRpb25gIHdoaWxlIHRoZSB0d2VlbiBpcyBhY3RpdmUsIG9yIC0xIGJlZm9yZSBpdCBhY3RpdmF0ZXMuXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAtMVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqL1xuXHRcdHRoaXMucmF3UG9zaXRpb24gPSAtMTtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKi9cblx0XHR0aGlzLl9wYXVzZWQgPSB0cnVlO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAdHlwZSB7VHdlZW59XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuX25leHQgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAdHlwZSB7VHdlZW59XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuX3ByZXYgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLl9wYXJlbnQgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHRcdHRoaXMuX2xhYmVscyA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEB0eXBlIHtPYmplY3RbXX1cblx0XHQgKi9cblx0XHR0aGlzLl9sYWJlbExpc3QgPSBudWxsO1xuXG5cdFx0aWYgKHByb3BzKSB7XG5cdFx0XHR0aGlzLnVzZVRpY2tzID0gISFwcm9wcy51c2VUaWNrcztcblx0XHRcdHRoaXMuaWdub3JlR2xvYmFsUGF1c2UgPSAhIXByb3BzLmlnbm9yZUdsb2JhbFBhdXNlO1xuXHRcdFx0dGhpcy5sb29wID0gcHJvcHMubG9vcCA9PT0gdHJ1ZSA/IC0xIDogKHByb3BzLmxvb3B8fDApO1xuXHRcdFx0dGhpcy5yZXZlcnNlZCA9ICEhcHJvcHMucmV2ZXJzZWQ7XG5cdFx0XHR0aGlzLmJvdW5jZSA9ICEhcHJvcHMuYm91bmNlO1xuXHRcdFx0dGhpcy50aW1lU2NhbGUgPSBwcm9wcy50aW1lU2NhbGV8fDE7XG5cdFx0XHRwcm9wcy5vbkNoYW5nZSAmJiB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgcHJvcHMub25DaGFuZ2UpO1xuXHRcdFx0cHJvcHMub25Db21wbGV0ZSAmJiB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoXCJjb21wbGV0ZVwiLCBwcm9wcy5vbkNvbXBsZXRlKTtcblx0XHR9XG5cblx0XHQvLyB3aGlsZSBgcG9zaXRpb25gIGlzIHNoYXJlZCwgaXQgbmVlZHMgdG8gaGFwcGVuIGFmdGVyIEFMTCBwcm9wcyBhcmUgc2V0LCBzbyBpdCdzIGhhbmRsZWQgaW4gX2luaXQoKVxuICB9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBsaXN0IG9mIHRoZSBsYWJlbHMgZGVmaW5lZCBvbiB0aGlzIHR3ZWVuIHNvcnRlZCBieSBwb3NpdGlvbi5cblx0ICogQHR5cGUge09iamVjdFtdfVxuXHQgKi9cblx0Z2V0IGxhYmVscyAoKSB7XG5cdFx0bGV0IGxpc3QgPSB0aGlzLl9sYWJlbExpc3Q7XG5cdFx0aWYgKCFsaXN0KSB7XG5cdFx0XHRsaXN0ID0gdGhpcy5fbGFiZWxMaXN0ID0gW107XG5cdFx0XHRsZXQgbGFiZWxzID0gdGhpcy5fbGFiZWxzO1xuXHRcdFx0Zm9yIChsZXQgbGFiZWwgaW4gbGFiZWxzKSB7XG5cdFx0XHRcdGxpc3QucHVzaCh7IGxhYmVsLCBwb3NpdGlvbjogbGFiZWxzW2xhYmVsXSB9KTtcblx0XHRcdH1cblx0XHRcdGxpc3Quc29ydCgoYSwgYikgPT4gYS5wb3NpdGlvbiAtIGIucG9zaXRpb24pO1xuXHRcdH1cblx0XHRyZXR1cm4gbGlzdDtcblx0fVxuXHRzZXQgbGFiZWxzIChsYWJlbHMpIHtcblx0XHR0aGlzLl9sYWJlbHMgPSBsYWJlbHM7XG5cdFx0dGhpcy5fbGFiZWxMaXN0ID0gbnVsbDtcblx0fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBsYWJlbCBvbiBvciBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGN1cnJlbnQgcG9zaXRpb24uIEZvciBleGFtcGxlLCBnaXZlbiBhIHR3ZWVuIHdpdGhcbiAgICogdHdvIGxhYmVscywgXCJmaXJzdFwiIG9uIGZyYW1lIGluZGV4IDQsIGFuZCBcInNlY29uZFwiIG9uIGZyYW1lIDgsIGN1cnJlbnRMYWJlbCB3b3VsZCByZXR1cm46XG4gICAqIDx1bD5cbiAgICogICA8bGk+bnVsbCBpZiB0aGUgY3VycmVudCBwb3NpdGlvbiBpcyAyLjwvbGk+XG4gICAqICAgPGxpPlwiZmlyc3RcIiBpZiB0aGUgY3VycmVudCBwb3NpdGlvbiBpcyA0LjwvbGk+XG4gICAqICAgPGxpPlwiZmlyc3RcIiBpZiB0aGUgY3VycmVudCBwb3NpdGlvbiBpcyA3LjwvbGk+XG4gICAqICAgPGxpPlwic2Vjb25kXCIgaWYgdGhlIGN1cnJlbnQgcG9zaXRpb24gaXMgMTUuPC9saT5cbiAgICogPC91bD5cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgY3VycmVudExhYmVsICgpIHtcbiAgICBsZXQgbGFiZWxzID0gdGhpcy5sYWJlbHM7XG4gICAgbGV0IHBvcyA9IHRoaXMucG9zaXRpb247XG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSBsYWJlbHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7IGlmIChwb3MgPCBsYWJlbHNbaV0ucG9zaXRpb24pIHsgYnJlYWs7IH0gfVxuICAgIHJldHVybiAoaSA9PT0gMCkgPyBudWxsIDogbGFiZWxzW2ktMV0ubGFiZWw7XG4gIH1cblxuICAvKipcbiAgICogUGF1c2VzIG9yIHVucGF1c2VzIHRoZSB0d2Vlbi4gQSBwYXVzZWQgdHdlZW4gaXMgcmVtb3ZlZCBmcm9tIHRoZSBnbG9iYWwgcmVnaXN0cnkgYW5kIGlzIGVsaWdpYmxlIGZvciBnYXJiYWdlIGNvbGxlY3Rpb25cbiAgICogaWYgbm8gb3RoZXIgcmVmZXJlbmNlcyB0byBpdCBleGlzdC5cbiAgICogQHR5cGUge0Jvb2xlYW59XG5cdCAqL1xuXHRnZXQgcGF1c2VkICgpIHsgcmV0dXJuIHRoaXMuX3BhdXNlZDsgfVxuICBzZXQgcGF1c2VkIChwYXVzZWQpIHtcbiAgICBUd2Vlbi5fcmVnaXN0ZXIodGhpcywgcGF1c2VkKTtcblx0XHR0aGlzLl9wYXVzZWQgPSBwYXVzZWQ7XG4gIH1cblxuXHQvKipcblx0ICogQWR2YW5jZXMgdGhlIHR3ZWVuIGJ5IGEgc3BlY2lmaWVkIGFtb3VudC5cdCAqXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YSBUaGUgYW1vdW50IHRvIGFkdmFuY2UgaW4gbWlsbGlzZWNvbmRzIChvciB0aWNrcyBpZiB1c2VUaWNrcyBpcyB0cnVlKS4gTmVnYXRpdmUgdmFsdWVzIGFyZSBzdXBwb3J0ZWQuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lnbm9yZUFjdGlvbnM9ZmFsc2VdIElmIHRydWUsIGFjdGlvbnMgd2lsbCBub3QgYmUgZXhlY3V0ZWQgZHVlIHRvIHRoaXMgY2hhbmdlIGluIHBvc2l0aW9uLlxuXHQgKi9cblx0YWR2YW5jZSAoZGVsdGEsIGlnbm9yZUFjdGlvbnMgPSBmYWxzZSkge1xuXHRcdHRoaXMuc2V0UG9zaXRpb24odGhpcy5yYXdQb3NpdGlvbiArIGRlbHRhICogdGhpcy50aW1lU2NhbGUsIGlnbm9yZUFjdGlvbnMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkdmFuY2VzIHRoZSB0d2VlbiB0byBhIHNwZWNpZmllZCBwb3NpdGlvbi5cblx0ICpcblx0ICogQGVtaXRzIHR3ZWVuanMuQWJzdHJhY3RUd2VlbiNldmVudDpjaGFuZ2Vcblx0ICogQGVtaXRzIHR3ZWVuanMuQWJzdHJhY3RUd2VlbiNldmVudDpjb21wbGV0ZVxuXHQgKlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmF3UG9zaXRpb24gVGhlIHJhdyBwb3NpdGlvbiB0byBzZWVrIHRvIGluIG1pbGxpc2Vjb25kcyAob3IgdGlja3MgaWYgdXNlVGlja3MgaXMgdHJ1ZSkuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lnbm9yZUFjdGlvbnM9ZmFsc2VdIElmIHRydWUsIGRvIG5vdCBydW4gYW55IGFjdGlvbnMgdGhhdCB3b3VsZCBiZSB0cmlnZ2VyZWQgYnkgdGhpcyBvcGVyYXRpb24uXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW2p1bXA9ZmFsc2VdIElmIHRydWUsIG9ubHkgYWN0aW9ucyBhdCB0aGUgbmV3IHBvc2l0aW9uIHdpbGwgYmUgcnVuLiBJZiBmYWxzZSwgYWN0aW9ucyBiZXR3ZWVuIHRoZSBvbGQgYW5kIG5ldyBwb3NpdGlvbiBhcmUgcnVuLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFByaW1hcmlseSBmb3IgdXNlIHdpdGggTW92aWVDbGlwLCB0aGlzIGNhbGxiYWNrIGlzIGNhbGxlZCBhZnRlciBwcm9wZXJ0aWVzIGFyZSB1cGRhdGVkLCBidXQgYmVmb3JlIGFjdGlvbnMgYXJlIHJ1bi5cblx0ICovXG5cdHNldFBvc2l0aW9uIChyYXdQb3NpdGlvbiwgaWdub3JlQWN0aW9ucyA9IGZhbHNlLCBqdW1wID0gZmFsc2UsIGNhbGxiYWNrKSB7XG5cdFx0Y29uc3QgZCA9IHRoaXMuZHVyYXRpb24sIGxvb3BDb3VudCA9IHRoaXMubG9vcCwgcHJldlJhd1BvcyA9IHRoaXMucmF3UG9zaXRpb247XG4gICAgbGV0IGxvb3AgPSAwLCB0ID0gMCwgZW5kID0gZmFsc2U7XG5cblx0XHQvLyBub3JtYWxpemUgcG9zaXRpb246XG5cdFx0aWYgKHJhd1Bvc2l0aW9uIDwgMCkgeyByYXdQb3NpdGlvbiA9IDA7IH1cblxuXHRcdGlmIChkID09PSAwKSB7XG5cdFx0XHQvLyBkZWFsIHdpdGggMCBsZW5ndGggdHdlZW5zLlxuXHRcdFx0ZW5kID0gdHJ1ZTtcblx0XHRcdGlmIChwcmV2UmF3UG9zICE9PSAtMSkgeyByZXR1cm4gZW5kOyB9IC8vIHdlIGNhbiBhdm9pZCBkb2luZyBhbnl0aGluZyBlbHNlIGlmIHdlJ3JlIGFscmVhZHkgYXQgMC5cblx0XHR9IGVsc2Uge1xuXHRcdFx0bG9vcCA9IHJhd1Bvc2l0aW9uIC8gZCB8IDA7XG5cdFx0XHR0ID0gcmF3UG9zaXRpb24gLSBsb29wICogZDtcblxuXHRcdFx0ZW5kID0gKGxvb3BDb3VudCAhPT0gLTEgJiYgcmF3UG9zaXRpb24gPj0gbG9vcENvdW50ICogZCArIGQpO1xuXHRcdFx0aWYgKGVuZCkgeyByYXdQb3NpdGlvbiA9ICh0ID0gZCkgKiAobG9vcCA9IGxvb3BDb3VudCkgKyBkOyB9XG5cdFx0XHRpZiAocmF3UG9zaXRpb24gPT09IHByZXZSYXdQb3MpIHsgcmV0dXJuIGVuZDsgfSAvLyBubyBuZWVkIHRvIHVwZGF0ZVxuXG5cdFx0XHQvLyBjdXJyZW50IGxvb3AgaXMgcmV2ZXJzZWRcblx0XHRcdGlmICghdGhpcy5yZXZlcnNlZCAhPT0gISh0aGlzLmJvdW5jZSAmJiBsb29wICUgMikpIHsgdCA9IGQgLSB0OyB9XG5cdFx0fVxuXG5cdFx0Ly8gc2V0IHRoaXMgaW4gYWR2YW5jZSBpbiBjYXNlIGFuIGFjdGlvbiBtb2RpZmllcyBwb3NpdGlvbjpcblx0XHR0aGlzLnBvc2l0aW9uID0gdDtcblx0XHR0aGlzLnJhd1Bvc2l0aW9uID0gcmF3UG9zaXRpb247XG5cblx0XHR0aGlzLl91cGRhdGVQb3NpdGlvbihqdW1wLCBlbmQpO1xuXHRcdGlmIChlbmQpIHsgdGhpcy5wYXVzZWQgPSB0cnVlOyB9XG5cblx0XHRjYWxsYmFjayAmJiBjYWxsYmFjayh0aGlzKTtcblxuXHRcdGlmICghaWdub3JlQWN0aW9ucykgeyB0aGlzLl9ydW5BY3Rpb25zKHByZXZSYXdQb3MsIHJhd1Bvc2l0aW9uLCBqdW1wLCAhanVtcCAmJiBwcmV2UmF3UG9zID09PSAtMSk7IH1cblxuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChcImNoYW5nZVwiKTtcblx0XHRpZiAoZW5kKSB7IHRoaXMuZGlzcGF0Y2hFdmVudChcImNvbXBsZXRlXCIpOyB9XG5cdH1cblxuXHQvKipcblx0ICogQ2FsY3VsYXRlcyBhIG5vcm1hbGl6ZWQgcG9zaXRpb24gYmFzZWQgb24gYSByYXcgcG9zaXRpb24uXG5cdCAqXG5cdCAqIEBleGFtcGxlXG5cdCAqIC8vIGdpdmVuIGEgdHdlZW4gd2l0aCBhIGR1cmF0aW9uIG9mIDMwMDBtcyBzZXQgdG8gbG9vcDpcblx0ICogY29uc29sZS5sb2cobXlUd2Vlbi5jYWxjdWxhdGVQb3NpdGlvbigzNzAwKTsgLy8gNzAwXG5cdCAqXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYXdQb3NpdGlvbiBBIHJhdyBwb3NpdGlvbi5cblx0ICovXG5cdGNhbGN1bGF0ZVBvc2l0aW9uIChyYXdQb3NpdGlvbikge1xuXHRcdC8vIGxhcmdlbHkgZHVwbGljYXRlZCBmcm9tIHNldFBvc2l0aW9uLCBidXQgbmVjZXNzYXJ5IHRvIGF2b2lkIGhhdmluZyB0byBpbnN0YW50aWF0ZSBnZW5lcmljIG9iamVjdHMgdG8gcGFzcyB2YWx1ZXMgKGVuZCwgbG9vcCwgcG9zaXRpb24pIGJhY2suXG5cdFx0Y29uc3QgZCA9IHRoaXMuZHVyYXRpb24sIGxvb3BDb3VudCA9IHRoaXMubG9vcDtcbiAgICBsZXQgbG9vcCA9IDAsIHQgPSAwO1xuXG5cdFx0aWYgKGQgPT09IDApIHsgcmV0dXJuIDA7IH1cblx0XHRpZiAobG9vcENvdW50ICE9PSAtMSAmJiByYXdQb3NpdGlvbiA+PSBsb29wQ291bnQgKiBkICsgZCkge1xuICAgICAgdCA9IGQ7XG4gICAgICBsb29wID0gbG9vcENvdW50XG4gICAgfSBlbHNlIGlmIChyYXdQb3NpdGlvbiA8IDApIHtcbiAgICAgIHQgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb29wID0gcmF3UG9zaXRpb24gLyBkIHwgMDtcbiAgICAgIHQgPSByYXdQb3NpdGlvbiAtIGxvb3AgKiBkO1xuICAgIH1cblxuXHRcdHJldHVybiAoIXRoaXMucmV2ZXJzZWQgIT09ICEodGhpcy5ib3VuY2UgJiYgbG9vcCAlIDIpKSA/IGQgLSB0IDogdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgbGFiZWwgdGhhdCBjYW4gYmUgdXNlZCB3aXRoIHtAbGluayB0d2VlbmpzLlRpbWVsaW5lI2dvdG9BbmRQbGF5fS97QGxpbmsgdHdlZW5qcy5UaW1lbGluZSNnb3RvQW5kU3RvcH0uXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBsYWJlbCBUaGUgbGFiZWwgbmFtZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uIFRoZSBwb3NpdGlvbiB0aGlzIGxhYmVsIHJlcHJlc2VudHMuXG5cdCAqL1xuXHRhZGRMYWJlbCAobGFiZWwsIHBvc2l0aW9uKSB7XG5cdFx0aWYgKCF0aGlzLl9sYWJlbHMpIHsgdGhpcy5fbGFiZWxzID0ge307IH1cblx0XHR0aGlzLl9sYWJlbHNbbGFiZWxdID0gcG9zaXRpb247XG5cdFx0Y29uc3QgbGlzdCA9IHRoaXMuX2xhYmVsTGlzdDtcblx0XHRpZiAobGlzdCkge1xuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykgeyBpZiAocG9zaXRpb24gPCBsaXN0W2ldLnBvc2l0aW9uKSB7IGJyZWFrOyB9IH1cblx0XHRcdGxpc3Quc3BsaWNlKGksIDAsIHsgbGFiZWwsIHBvc2l0aW9uIH0pO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBVbnBhdXNlcyB0aGlzIHRpbWVsaW5lIGFuZCBqdW1wcyB0byB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uIG9yIGxhYmVsLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHBvc2l0aW9uT3JMYWJlbCBUaGUgcG9zaXRpb24gaW4gbWlsbGlzZWNvbmRzIChvciB0aWNrcyBpZiBgdXNlVGlja3NgIGlzIGB0cnVlYClcblx0ICogb3IgbGFiZWwgdG8ganVtcCB0by5cblx0ICovXG5cdGdvdG9BbmRQbGF5IChwb3NpdGlvbk9yTGFiZWwpIHtcblx0XHR0aGlzLnBhdXNlZCA9IGZhbHNlO1xuXHRcdHRoaXMuX2dvdG8ocG9zaXRpb25PckxhYmVsKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBQYXVzZXMgdGhpcyB0aW1lbGluZSBhbmQganVtcHMgdG8gdGhlIHNwZWNpZmllZCBwb3NpdGlvbiBvciBsYWJlbC5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBwb3NpdGlvbk9yTGFiZWwgVGhlIHBvc2l0aW9uIGluIG1pbGxpc2Vjb25kcyAob3IgdGlja3MgaWYgYHVzZVRpY2tzYCBpcyBgdHJ1ZWApIG9yIGxhYmVsXG5cdCAqIHRvIGp1bXAgdG8uXG5cdCAqL1xuXHRnb3RvQW5kU3RvcCAocG9zaXRpb25PckxhYmVsKSB7XG5cdFx0dGhpcy5wYXVzZWQgPSB0cnVlO1xuXHRcdHRoaXMuX2dvdG8ocG9zaXRpb25PckxhYmVsKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBJZiBhIG51bWVyaWMgcG9zaXRpb24gaXMgcGFzc2VkLCBpdCBpcyByZXR1cm5lZCB1bmNoYW5nZWQuIElmIGEgc3RyaW5nIGlzIHBhc3NlZCwgdGhlIHBvc2l0aW9uIG9mIHRoZVxuXHQgKiBjb3JyZXNwb25kaW5nIGZyYW1lIGxhYmVsIHdpbGwgYmUgcmV0dXJuZWQsIG9yIGBudWxsYCBpZiBhIG1hdGNoaW5nIGxhYmVsIGlzIG5vdCBkZWZpbmVkLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHBvc2l0aW9uT3JMYWJlbCBBIG51bWVyaWMgcG9zaXRpb24gdmFsdWUgb3IgbGFiZWwgU3RyaW5nLlxuXHQgKi9cblx0cmVzb2x2ZSAocG9zaXRpb25PckxhYmVsKSB7XG5cdFx0Y29uc3QgcG9zID0gTnVtYmVyKHBvc2l0aW9uT3JMYWJlbCk7XG4gICAgcmV0dXJuIGlzTmFOKHBvcykgPyB0aGlzLl9sYWJlbHMgJiYgdGhpcy5fbGFiZWxzW3Bvc2l0aW9uT3JMYWJlbF0gOiBwb3M7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cblx0ICpcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXG5cdCAqL1xuXHR0b1N0cmluZyAoKSB7XG5cdFx0cmV0dXJuIGBbJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9JHt0aGlzLm5hbWUgPyBgIChuYW1lPSR7dGhpcy5uYW1lfSlgIDogXCJcIn1dYDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAdGhyb3dzIEFic3RyYWN0VHdlZW4gY2Fubm90IGJlIGNsb25lZC5cblx0ICovXG5cdGNsb25lICgpIHtcblx0XHR0aHJvdyBcIkFic3RyYWN0VHdlZW4gY2Fubm90IGJlIGNsb25lZC5cIjtcblx0fVxuXG5cdC8qKlxuXHQgKiBTaGFyZWQgbG9naWMgdGhhdCBleGVjdXRlcyBhdCB0aGUgZW5kIG9mIHRoZSBzdWJjbGFzcyBjb25zdHJ1Y3Rvci5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IFtwcm9wc11cblx0ICovXG5cdF9pbml0IChwcm9wcykge1xuXHRcdGlmICghcHJvcHMgfHwgIXByb3BzLnBhdXNlZCkgeyB0aGlzLnBhdXNlZCA9IGZhbHNlOyB9XG5cdFx0aWYgKHByb3BzICYmIHByb3BzLnBvc2l0aW9uICE9IG51bGwpIHsgdGhpcy5zZXRQb3NpdGlvbihwcm9wcy5wb3NpdGlvbik7IH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHBvc2l0aW9uT3JMYWJlbFxuXHQgKi9cblx0X2dvdG8gKHBvc2l0aW9uT3JMYWJlbCkge1xuXHRcdGNvbnN0IHBvcyA9IHRoaXMucmVzb2x2ZShwb3NpdGlvbk9yTGFiZWwpO1xuXHRcdGlmIChwb3MgIT0gbnVsbCkgeyB0aGlzLnNldFBvc2l0aW9uKHBvcywgZmFsc2UsIHRydWUpOyB9XG5cdH1cblxuXHQvKipcbiAgICogUnVucyBhY3Rpb25zIGJldHdlZW4gc3RhcnRQb3MgJiBlbmRQb3MuIFNlcGFyYXRlZCB0byBzdXBwb3J0IGFjdGlvbiBkZWZlcnJhbC5cbiAgICpcblx0ICogQHByaXZhdGVcblx0ICpcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0UmF3UG9zXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBlbmRSYXdQb3Ncblx0ICogQHBhcmFtIHtCb29sZWFufSBqdW1wXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5jbHVkZVN0YXJ0XG5cdCAqL1xuXHRfcnVuQWN0aW9ucyAoc3RhcnRSYXdQb3MsIGVuZFJhd1BvcywganVtcCwgaW5jbHVkZVN0YXJ0KSB7XG5cdCAgLy8gY29uc29sZS5sb2codGhpcy5wYXNzaXZlID09PSBmYWxzZSA/IFwiID4gVHdlZW5cIiA6IFwiVGltZWxpbmVcIiwgXCJydW5cIiwgc3RhcnRSYXdQb3MsIGVuZFJhd1BvcywganVtcCwgaW5jbHVkZVN0YXJ0KTtcblx0XHQvLyBpZiB3ZSBkb24ndCBoYXZlIGFueSBhY3Rpb25zLCBhbmQgd2UncmUgbm90IGEgVGltZWxpbmUsIHRoZW4gcmV0dXJuOlxuXHRcdC8vIFRPRE86IGEgY2xlYW5lciB3YXkgdG8gaGFuZGxlIHRoaXMgd291bGQgYmUgdG8gb3ZlcnJpZGUgdGhpcyBtZXRob2QgaW4gVHdlZW4sIGJ1dCBJJ20gbm90IHN1cmUgaXQncyB3b3J0aCB0aGUgb3ZlcmhlYWQuXG5cdFx0aWYgKCF0aGlzLl9hY3Rpb25IZWFkICYmICF0aGlzLnR3ZWVucykgeyByZXR1cm47IH1cblxuXHRcdGNvbnN0IGQgPSB0aGlzLmR1cmF0aW9uLCBsb29wQ291bnQgPSB0aGlzLmxvb3A7XG4gICAgbGV0IHJldmVyc2VkID0gdGhpcy5yZXZlcnNlZCwgYm91bmNlID0gdGhpcy5ib3VuY2U7XG5cdFx0bGV0IGxvb3AwLCBsb29wMSwgdDAsIHQxO1xuXG5cdFx0aWYgKGQgPT09IDApIHtcblx0XHRcdC8vIGRlYWwgd2l0aCAwIGxlbmd0aCB0d2VlbnM6XG5cdFx0XHRsb29wMCA9IGxvb3AxID0gdDAgPSB0MSA9IDA7XG5cdFx0XHRyZXZlcnNlZCA9IGJvdW5jZSA9IGZhbHNlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRsb29wMCA9IHN0YXJ0UmF3UG9zIC8gZCB8IDA7XG5cdFx0XHRsb29wMSA9IGVuZFJhd1BvcyAvIGQgfCAwO1xuXHRcdFx0dDAgPSBzdGFydFJhd1BvcyAtIGxvb3AwICogZDtcblx0XHRcdHQxID0gZW5kUmF3UG9zIC0gbG9vcDEgKiBkO1xuXHRcdH1cblxuXHRcdC8vIGNhdGNoIHBvc2l0aW9ucyB0aGF0IGFyZSBwYXN0IHRoZSBlbmQ6XG5cdFx0aWYgKGxvb3BDb3VudCAhPT0gLTEpIHtcblx0XHRcdGlmIChsb29wMSA+IGxvb3BDb3VudCkgeyB0MSA9IGQ7IGxvb3AxID0gbG9vcENvdW50OyB9XG5cdFx0XHRpZiAobG9vcDAgPiBsb29wQ291bnQpIHsgdDAgPSBkOyBsb29wMCA9IGxvb3BDb3VudDsgfVxuXHRcdH1cblxuXHRcdC8vIHNwZWNpYWwgY2FzZXM6XG5cdFx0aWYgKGp1bXApIHsgcmV0dXJuIHRoaXMuX3J1bkFjdGlvbnNSYW5nZSh0MSwgdDEsIGp1bXAsIGluY2x1ZGVTdGFydCk7IH0gLy8ganVtcC5cbiAgICBlbHNlIGlmIChsb29wMCA9PT0gbG9vcDEgJiYgdDAgPT09IHQxICYmICFqdW1wICYmICFpbmNsdWRlU3RhcnQpIHsgcmV0dXJuOyB9IC8vIG5vIGFjdGlvbnMgaWYgdGhlIHBvc2l0aW9uIGlzIGlkZW50aWNhbCBhbmQgd2UgYXJlbid0IGluY2x1ZGluZyB0aGUgc3RhcnRcblx0XHRlbHNlIGlmIChsb29wMCA9PT0gLTEpIHsgbG9vcDAgPSB0MCA9IDA7IH0gLy8gY29ycmVjdCB0aGUgLTEgdmFsdWUgZm9yIGZpcnN0IGFkdmFuY2UsIGltcG9ydGFudCB3aXRoIHVzZVRpY2tzLlxuXG5cdFx0Y29uc3QgZGlyID0gKHN0YXJ0UmF3UG9zIDw9IGVuZFJhd1Bvcyk7XG5cdFx0bGV0IGxvb3AgPSBsb29wMDtcblx0XHRkbyB7XG5cdFx0XHRsZXQgcmV2ID0gIXJldmVyc2VkICE9PSAhKGJvdW5jZSAmJiBsb29wICUgMik7XG5cdFx0XHRsZXQgc3RhcnQgPSAobG9vcCA9PT0gbG9vcDApID8gdDAgOiBkaXIgPyAwIDogZDtcblx0XHRcdGxldCBlbmQgPSAobG9vcCA9PT0gbG9vcDEpID8gdDEgOiBkaXIgPyBkIDogMDtcblxuXHRcdFx0aWYgKHJldikge1xuXHRcdFx0XHRzdGFydCA9IGQgLSBzdGFydDtcblx0XHRcdFx0ZW5kID0gZCAtIGVuZDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGJvdW5jZSAmJiBsb29wICE9PSBsb29wMCAmJiBzdGFydCA9PT0gZW5kKSB7IC8qIGJvdW5jZWQgb250byB0aGUgc2FtZSB0aW1lL2ZyYW1lLCBkb24ndCByZS1leGVjdXRlIGVuZCBhY3Rpb25zICovIH1cblx0XHRcdGVsc2UgaWYgKHRoaXMuX3J1bkFjdGlvbnNSYW5nZShzdGFydCwgZW5kLCBqdW1wLCBpbmNsdWRlU3RhcnQgfHwgKGxvb3AgIT09IGxvb3AwICYmICFib3VuY2UpKSkgeyByZXR1cm4gdHJ1ZTsgfVxuXG5cdFx0XHRpbmNsdWRlU3RhcnQgPSBmYWxzZTtcblx0XHR9IHdoaWxlICgoZGlyICYmICsrbG9vcCA8PSBsb29wMSkgfHwgKCFkaXIgJiYgLS1sb29wID49IGxvb3AxKSk7XG5cdH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQGFic3RyYWN0XG4gICAqIEB0aHJvd3MgTXVzdCBiZSBvdmVycmlkZGVuIGJ5IGEgc3ViY2xhc3MuXG5cdCAqL1xuXHRfcnVuQWN0aW9uc1JhbmdlIChzdGFydFBvcywgZW5kUG9zLCBqdW1wLCBpbmNsdWRlU3RhcnQpIHtcblx0XHR0aHJvdyBcIl9ydW5BY3Rpb25zUmFuZ2UgaXMgYWJzdHJhY3QgYW5kIG11c3QgYmUgb3ZlcnJpZGRlbiBieSBhIHN1YmNsYXNzLlwiO1xuXHR9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAdGhyb3dzIE11c3QgYmUgb3ZlcnJpZGRlbiBieSBhIHN1YmNsYXNzLlxuXHQgKi9cblx0X3VwZGF0ZVBvc2l0aW9uIChqdW1wLCBlbmQpIHtcbiAgICB0aHJvdyBcIl91cGRhdGVQb3NpdGlvbiBpcyBhYnN0cmFjdCBhbmQgbXVzdCBiZSBvdmVycmlkZGVuIGJ5IGEgc3ViY2xhc3MuXCI7XG5cdH1cblxufVxuXG4vKipcbiAqIERpc3BhdGNoZWQgd2hlbmV2ZXIgdGhlIHR3ZWVuJ3MgcG9zaXRpb24gY2hhbmdlcy4gSXQgb2NjdXJzIGFmdGVyIGFsbCB0d2VlbmVkIHByb3BlcnRpZXMgYXJlIHVwZGF0ZWQgYW5kIGFjdGlvbnNcbiAqIGFyZSBleGVjdXRlZC5cbiAqIEBldmVudCB0d2VlbmpzLkFic3RyYWN0VHdlZW4jY2hhbmdlXG4gKi9cbi8qKlxuICogRGlzcGF0Y2hlZCB3aGVuIHRoZSB0d2VlbiByZWFjaGVzIGl0cyBlbmQgYW5kIGhhcyBwYXVzZWQgaXRzZWxmLiBUaGlzIGRvZXMgbm90IGZpcmUgdW50aWwgYWxsIGxvb3BzIGFyZSBjb21wbGV0ZTtcbiAqIHR3ZWVucyB0aGF0IGxvb3AgY29udGludW91c2x5IHdpbGwgbmV2ZXIgZmlyZSBhIGNvbXBsZXRlIGV2ZW50LlxuICogQGV2ZW50IHR3ZWVuanMuQWJzdHJhY3RUd2VlbiNjb21wbGV0ZVxuICovXG4iLCIvKipcbiAqIEBsaWNlbnNlIEVhc2VcbiAqIFZpc2l0IGh0dHA6Ly9jcmVhdGVqcy5jb20vIGZvciBkb2N1bWVudGF0aW9uLCB1cGRhdGVzIGFuZCBleGFtcGxlcy5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgZ3NraW5uZXIuY29tLCBpbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAqIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXG4gKiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXRcbiAqIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxuICogY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuICogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbiAqIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAqIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gKiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcbiAqIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gKiBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuICogSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXG4gKiBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcbiAqIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKipcbiAqIFRoZSBFYXNlIGNsYXNzIHByb3ZpZGVzIGEgY29sbGVjdGlvbiBvZiBlYXNpbmcgZnVuY3Rpb25zIGZvciB1c2Ugd2l0aCBUd2VlbkpTLiBJdCBkb2VzIG5vdCB1c2UgdGhlIHN0YW5kYXJkIDQgcGFyYW1cbiAqIGVhc2luZyBzaWduYXR1cmUuIEluc3RlYWQgaXQgdXNlcyBhIHNpbmdsZSBwYXJhbSB3aGljaCBpbmRpY2F0ZXMgdGhlIGN1cnJlbnQgbGluZWFyIHJhdGlvICgwIHRvIDEpIG9mIHRoZSB0d2Vlbi5cbiAqXG4gKiBNb3N0IG1ldGhvZHMgb24gRWFzZSBjYW4gYmUgcGFzc2VkIGRpcmVjdGx5IGFzIGVhc2luZyBmdW5jdGlvbnM6XG4gKlxuICogICAgICBUd2Vlbi5nZXQodGFyZ2V0KS50byh7eDoxMDB9LCA1MDAsIEVhc2UubGluZWFyKTtcbiAqXG4gKiBIb3dldmVyLCBtZXRob2RzIGJlZ2lubmluZyB3aXRoIFwiZ2V0XCIgd2lsbCByZXR1cm4gYW4gZWFzaW5nIGZ1bmN0aW9uIGJhc2VkIG9uIHBhcmFtZXRlciB2YWx1ZXM6XG4gKlxuICogICAgICBUd2Vlbi5nZXQodGFyZ2V0KS50byh7eToyMDB9LCA1MDAsIEVhc2UuZ2V0UG93SW4oMi4yKSk7XG4gKlxuICogUGxlYXNlIHNlZSB0aGUgPGEgaHJlZj1cImh0dHA6Ly93d3cuY3JlYXRlanMuY29tL0RlbW9zL1R3ZWVuSlMvVHdlZW5fU3BhcmtUYWJsZVwiPnNwYXJrIHRhYmxlIGRlbW88L2E+IGZvciBhblxuICogb3ZlcnZpZXcgb2YgdGhlIGRpZmZlcmVudCBlYXNlIHR5cGVzIG9uIDxhIGhyZWY9XCJodHRwOi8vdHdlZW5qcy5jb21cIj5Ud2VlbkpTLmNvbTwvYT4uXG4gKlxuICogPGVtPkVxdWF0aW9ucyBkZXJpdmVkIGZyb20gd29yayBieSBSb2JlcnQgUGVubmVyLjwvZW0+XG4gKlxuICogQG1lbWJlcm9mIHR3ZWVuanNcbiAqIEBtb2R1bGUgRWFzZVxuICovXG5cbi8qKlxuICogQHBhcmFtIHtOdW1iZXJ9IHRcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpbmVhciAodCkge1xuXHRyZXR1cm4gdDtcbn1cblxuLyoqXG4gKiBNaW1pY3MgdGhlIHNpbXBsZSAtMTAwIHRvIDEwMCBlYXNpbmcgaW4gRmxhc2ggUHJvLlxuICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudCBBIHZhbHVlIGZyb20gLTEgKGVhc2UgaW4pIHRvIDEgKGVhc2Ugb3V0KSBpbmRpY2F0aW5nIHRoZSBzdHJlbmd0aCBhbmQgZGlyZWN0aW9uIG9mIHRoZSBlYXNlLlxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXQgKGFtb3VudCkge1xuXHRpZiAoYW1vdW50IDwgLTEpIHsgYW1vdW50ID0gLTE7IH0gZWxzZSBpZiAoYW1vdW50ID4gMSkgeyBhbW91bnQgPSAxOyB9XG5cdHJldHVybiBmdW5jdGlvbiAodCkge1xuXHRcdGlmIChhbW91bnQgPT0gMCkgeyByZXR1cm4gdDsgfVxuXHRcdGlmIChhbW91bnQgPCAwKSB7IHJldHVybiB0ICogKHQgKiAtYW1vdW50ICsgMSArIGFtb3VudCk7IH1cblx0XHRyZXR1cm4gdCAqICgoMiAtIHQpICogYW1vdW50ICsgKDEgLSBhbW91bnQpKTtcblx0fTtcbn1cblxuLyoqXG4gKiBDb25maWd1cmFibGUgZXhwb25lbnRpYWwgZWFzZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBwb3cgVGhlIGV4cG9uZW50IHRvIHVzZSAoZXguIDMgd291bGQgcmV0dXJuIGEgY3ViaWMgZWFzZSkuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFBvd0luIChwb3cpIHtcblx0cmV0dXJuIGZ1bmN0aW9uICh0KSB7XG5cdFx0cmV0dXJuIE1hdGgucG93KHQsIHBvdyk7XG5cdH07XG59XG5cbi8qKlxuICogQ29uZmlndXJhYmxlIGV4cG9uZW50aWFsIGVhc2UuXG4gKiBAcGFyYW0ge051bWJlcn0gcG93IFRoZSBleHBvbmVudCB0byB1c2UgKGV4LiAzIHdvdWxkIHJldHVybiBhIGN1YmljIGVhc2UpLlxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRQb3dPdXQgKHBvdykge1xuXHRyZXR1cm4gZnVuY3Rpb24gKHQpIHtcblx0XHRyZXR1cm4gMSAtIE1hdGgucG93KDEgLSB0LCBwb3cpO1xuXHR9O1xufVxuXG4vKipcbiAqIENvbmZpZ3VyYWJsZSBleHBvbmVudGlhbCBlYXNlLlxuICogQHBhcmFtIHtOdW1iZXJ9IHBvdyBUaGUgZXhwb25lbnQgdG8gdXNlIChleC4gMyB3b3VsZCByZXR1cm4gYSBjdWJpYyBlYXNlKS5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UG93SW5PdXQgKHBvdykge1xuXHRyZXR1cm4gZnVuY3Rpb24gKHQpIHtcblx0XHRpZiAoKHQgKj0gMikgPCAxKSByZXR1cm4gMC41ICogTWF0aC5wb3codCwgcG93KTtcblx0XHRyZXR1cm4gMSAtIDAuNSAqIE1hdGguYWJzKE1hdGgucG93KDIgLSB0LCBwb3cpKTtcblx0fTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge051bWJlcn0gdFxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2luZUluICh0KSB7XG5cdHJldHVybiAxIC0gTWF0aC5jb3ModCAqIE1hdGguUEkgLyAyKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge051bWJlcn0gdFxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2luZU91dCAodCkge1xuXHRyZXR1cm4gTWF0aC5zaW4odCAqIE1hdGguUEkgLyAyKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge051bWJlcn0gdFxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2luZUluT3V0ICh0KSB7XG5cdHJldHVybiAtMC41ICogKE1hdGguY29zKE1hdGguUEkgKiB0KSAtIDEpO1xufVxuXG4vKipcbiAqIENvbmZpZ3VyYWJsZSBcImJhY2sgaW5cIiBlYXNlLlxuICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudCBUaGUgc3RyZW5ndGggb2YgdGhlIGVhc2UuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEJhY2tJbiAoYW1vdW50KSB7XG5cdHJldHVybiBmdW5jdGlvbiAodCkge1xuXHRcdHJldHVybiB0ICogdCAqICgoYW1vdW50ICsgMSkgKiB0IC0gYW1vdW50KTtcblx0fTtcbn1cblxuLyoqXG4gKiBDb25maWd1cmFibGUgXCJiYWNrIG91dFwiIGVhc2UuXG4gKiBAcGFyYW0ge051bWJlcn0gYW1vdW50IFRoZSBzdHJlbmd0aCBvZiB0aGUgZWFzZS5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QmFja091dCAoYW1vdW50KSB7XG5cdHJldHVybiBmdW5jdGlvbiAodCkge1xuXHRcdHJldHVybiAoLS10ICogdCAqICgoYW1vdW50ICsgMSkgKiB0ICsgYW1vdW50KSArIDEpO1xuXHR9O1xufVxuXG4vKipcbiAqIENvbmZpZ3VyYWJsZSBcImJhY2sgaW4gb3V0XCIgZWFzZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBhbW91bnQgVGhlIHN0cmVuZ3RoIG9mIHRoZSBlYXNlLlxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRCYWNrSW5PdXQgKGFtb3VudCkge1xuXHRhbW91bnQgKj0gMS41MjU7XG5cdHJldHVybiBmdW5jdGlvbiAodCkge1xuXHRcdGlmICgodCAqPSAyKSA8IDEpIHJldHVybiAwLjUgKiAodCAqIHQgKiAoKGFtb3VudCArIDEpICogdCAtIGFtb3VudCkpO1xuXHRcdHJldHVybiAwLjUgKiAoKHQgLT0gMikgKiB0ICogKChhbW91bnQgKyAxKSAqIHQgKyBhbW91bnQpICsgMik7XG5cdH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtOdW1iZXJ9IHRcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNpcmNJbiAodCkge1xuXHRyZXR1cm4gLShNYXRoLnNxcnQoMSAtIHQgKiB0KSAtIDEpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7TnVtYmVyfSB0XG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaXJjT3V0ICh0KSB7XG5cdHJldHVybiBNYXRoLnNxcnQoMSAtIC0tdCAqIHQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7TnVtYmVyfSB0XG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaXJjSW5PdXQgKHQpIHtcblx0aWYgKCh0ICo9IDIpIDwgMSkgcmV0dXJuIC0wLjUgKiAoTWF0aC5zcXJ0KDEgLSB0ICogdCkgLSAxKTtcblx0cmV0dXJuIDAuNSAqIChNYXRoLnNxcnQoMSAtICh0IC09IDIpICogdCkgKyAxKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge051bWJlcn0gdFxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYm91bmNlSW4gKHQpIHtcblx0cmV0dXJuIDEgLSBFYXNlLmJvdW5jZU91dCgxIC0gdCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtOdW1iZXJ9IHRcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJvdW5jZU91dCAodCkge1xuXHRpZiAodCA8IDEgLyAyLjc1KSB7XG5cdFx0cmV0dXJuIDcuNTYyNSAqIHQgKiB0O1xuXHR9IGVsc2UgaWYgKHQgPCAyIC8gMi43NSkge1xuXHRcdHJldHVybiA3LjU2MjUgKiAodCAtPSAxLjUgLyAyLjc1KSAqIHQgKyAwLjc1O1xuXHR9IGVsc2UgaWYgKHQgPCAyLjUgLyAyLjc1KSB7XG5cdFx0cmV0dXJuIDcuNTYyNSAqICh0IC09IDIuMjUgLyAyLjc1KSAqIHQgKyAwLjkzNzU7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIDcuNTYyNSAqICh0IC09IDIuNjI1IC8gMi43NSkgKiB0ICsgMC45ODQzNzU7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge051bWJlcn0gdFxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYm91bmNlSW5PdXQgKHQpIHtcblx0aWYgKHQgPCAwLjUpIHJldHVybiBFYXNlLmJvdW5jZUluKHQgKiAyKSAqIDAuNTtcblx0cmV0dXJuIEVhc2UuYm91bmNlT3V0KHQgKiAyIC0gMSkgKiAwLjUgKyAwLjU7XG59XG5cbi8qKlxuICogQ29uZmlndXJhYmxlIGVsYXN0aWMgZWFzZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBhbXBsaXR1ZGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBwZXJpb2RcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RWxhc3RpY0luIChhbXBsaXR1ZGUsIHBlcmlvZCkge1xuXHRsZXQgcGkyID0gTWF0aC5QSSAqIDI7XG5cdHJldHVybiBmdW5jdGlvbiAodCkge1xuXHRcdGlmICh0ID09PSAwIHx8IHQgPT09IDEpIHJldHVybiB0O1xuXHRcdGxldCBzID0gcGVyaW9kIC8gcGkyICogTWF0aC5hc2luKDEgLyBhbXBsaXR1ZGUpO1xuXHRcdHJldHVybiAtKGFtcGxpdHVkZSAqIE1hdGgucG93KDIsIDEwICogKHQgLT0gMSkpICogTWF0aC5zaW4oKHQgLSBzKSAqIHBpMiAvIHBlcmlvZCkpO1xuXHR9O1xufVxuXG4vKipcbiAqIENvbmZpZ3VyYWJsZSBlbGFzdGljIGVhc2UuXG4gKiBAcGFyYW0ge051bWJlcn0gYW1wbGl0dWRlXG4gKiBAcGFyYW0ge051bWJlcn0gcGVyaW9kXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEVsYXN0aWNPdXQgKGFtcGxpdHVkZSwgcGVyaW9kKSB7XG5cdGxldCBwaTIgPSBNYXRoLlBJICogMjtcblx0cmV0dXJuIGZ1bmN0aW9uICh0KSB7XG5cdFx0aWYgKHQgPT09IDAgfHwgdCA9PT0gMSkgcmV0dXJuIHQ7XG5cdFx0bGV0IHMgPSBwZXJpb2QgLyBwaTIgKiBNYXRoLmFzaW4oMSAvIGFtcGxpdHVkZSk7XG5cdFx0cmV0dXJuIGFtcGxpdHVkZSAqIE1hdGgucG93KDIsIC0xMCAqIHQpICogTWF0aC5zaW4oKHQgLSBzKSAqIHBpMiAvIHBlcmlvZCkgKyAxO1xuXHR9O1xufVxuXG4vKipcbiAqIENvbmZpZ3VyYWJsZSBlbGFzdGljIGVhc2UuXG4gKiBAcGFyYW0ge051bWJlcn0gYW1wbGl0dWRlXG4gKiBAcGFyYW0ge051bWJlcn0gcGVyaW9kXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEVsYXN0aWNJbk91dCAoYW1wbGl0dWRlLCBwZXJpb2QpIHtcblx0bGV0IHBpMiA9IE1hdGguUEkgKiAyO1xuXHRyZXR1cm4gZnVuY3Rpb24gKHQpIHtcblx0XHRsZXQgcyA9IHBlcmlvZCAvIHBpMiAqIE1hdGguYXNpbigxIC8gYW1wbGl0dWRlKTtcblx0XHRpZiAoKHQgKj0gMikgPCAxKSByZXR1cm4gLTAuNSAqIChhbXBsaXR1ZGUgKiBNYXRoLnBvdygyLCAxMCAqICh0IC09IDEpKSAqIE1hdGguc2luKCh0IC0gcykgKiBwaTIgLyBwZXJpb2QpKTtcblx0XHRyZXR1cm4gYW1wbGl0dWRlICogTWF0aC5wb3coMiwgLTEwICogKHQgLT0gMSkpICogTWF0aC5zaW4oKHQgLSBzKSAqIHBpMiAvIHBlcmlvZCkgKiAwLjUgKyAxO1xuXHR9O1xufVxuXG4vKipcbiAqIElkZW50aWNhbCB0byBsaW5lYXIuXG4gKiBAcGFyYW0ge051bWJlcn0gdFxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5leHBvcnQgY29uc3Qgbm9uZSA9IGxpbmVhcjtcbi8qKlxuICogQHBhcmFtIHtOdW1iZXJ9IHRcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IHF1YWRJbiA9IGdldFBvd0luKDIpO1xuLyoqXG4gKiBAcGFyYW0ge051bWJlcn0gdFxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgcXVhZE91dCA9IGdldFBvd091dCgyKTtcbi8qKlxuICogQHBhcmFtIHtOdW1iZXJ9IHRcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IHF1YWRJbk91dCA9IGdldFBvd0luT3V0KDIpO1xuLyoqXG4gKiBAcGFyYW0ge051bWJlcn0gdFxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgY3ViaWNJbiA9IGdldFBvd0luKDMpO1xuLyoqXG4gKiBAcGFyYW0ge051bWJlcn0gdFxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgY3ViaWNPdXQgPSBnZXRQb3dPdXQoMyk7XG4vKipcbiAqIEBwYXJhbSB7TnVtYmVyfSB0XG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBjdWJpY0luT3V0ID0gZ2V0UG93SW5PdXQoMyk7XG4vKipcbiAqIEBwYXJhbSB7TnVtYmVyfSB0XG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBxdWFydEluID0gZ2V0UG93SW4oNCk7XG4vKipcbiAqIEBwYXJhbSB7TnVtYmVyfSB0XG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBxdWFydE91dCA9IGdldFBvd091dCg0KTtcbi8qKlxuICogQHBhcmFtIHtOdW1iZXJ9IHRcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IHF1YXJ0SW5PdXQgPSBnZXRQb3dJbk91dCg0KTtcbi8qKlxuICogQHBhcmFtIHtOdW1iZXJ9IHRcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IHF1aW50SW4gPSBnZXRQb3dJbig1KTtcbi8qKlxuICogQHBhcmFtIHtOdW1iZXJ9IHRcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IHF1aW50T3V0ID0gZ2V0UG93T3V0KDUpO1xuLyoqXG4gKiBAcGFyYW0ge051bWJlcn0gdFxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgcXVpbnRJbk91dCA9IGdldFBvd0luT3V0KDUpO1xuLyoqXG4gKiBAcGFyYW0ge051bWJlcn0gdFxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgYmFja0luID0gZ2V0QmFja0luKDEuNyk7XG4vKipcbiAqIEBwYXJhbSB7TnVtYmVyfSB0XG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBiYWNrT3V0ID0gZ2V0QmFja091dCgxLjcpO1xuLyoqXG4gKiBAcGFyYW0ge051bWJlcn0gdFxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgYmFja0luT3V0ID0gZ2V0QmFja0luT3V0KDEuNyk7XG4vKipcbiAqIEBwYXJhbSB7TnVtYmVyfSB0XG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBlbGFzdGljSW4gPSBnZXRFbGFzdGljSW4oMSwgMC4zKTtcbi8qKlxuICogQHBhcmFtIHtOdW1iZXJ9IHRcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IGVsYXN0aWNPdXQgPSBnZXRFbGFzdGljT3V0KDEsIDAuMyk7XG4vKipcbiAqIEBwYXJhbSB7TnVtYmVyfSB0XG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBlbGFzdGljSW5PdXQgPSBnZXRFbGFzdGljSW5PdXQoMSwgMC4zICogMS41KTtcbiIsIi8qKlxuICogQGxpY2Vuc2UgVHdlZW5cbiAqIFZpc2l0IGh0dHA6Ly9jcmVhdGVqcy5jb20vIGZvciBkb2N1bWVudGF0aW9uLCB1cGRhdGVzIGFuZCBleGFtcGxlcy5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgZ3NraW5uZXIuY29tLCBpbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAqIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXG4gKiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXRcbiAqIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxuICogY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuICogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbiAqIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAqIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gKiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcbiAqIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gKiBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuICogSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXG4gKiBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcbiAqIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5pbXBvcnQgQWJzdHJhY3RUd2VlbiBmcm9tIFwiLi9BYnN0cmFjdFR3ZWVuXCI7XG5pbXBvcnQgeyBsaW5lYXIgfSBmcm9tIFwiLi9FYXNlXCI7XG5pbXBvcnQgVGlja2VyIGZyb20gXCJAY3JlYXRlanMvY29yZS9zcmMvdXRpbHMvVGlja2VyXCI7XG5cbi8qKlxuICogVHdlZW5zIHByb3BlcnRpZXMgZm9yIGEgc2luZ2xlIHRhcmdldC4gTWV0aG9kcyBjYW4gYmUgY2hhaW5lZCB0byBjcmVhdGUgY29tcGxleCBhbmltYXRpb24gc2VxdWVuY2VzOlxuICpcbiAqIEBleGFtcGxlXG4gKiBUd2Vlbi5nZXQodGFyZ2V0KVxuICogICAud2FpdCg1MDApXG4gKiAgIC50byh7IGFscGhhOiAwLCB2aXNpYmxlOiBmYWxzZSB9LCAxMDAwKVxuICogICAuY2FsbChoYW5kbGVDb21wbGV0ZSk7XG4gKlxuICogTXVsdGlwbGUgdHdlZW5zIGNhbiBzaGFyZSBhIHRhcmdldCwgaG93ZXZlciBpZiB0aGV5IGFmZmVjdCB0aGUgc2FtZSBwcm9wZXJ0aWVzIHRoZXJlIGNvdWxkIGJlIHVuZXhwZWN0ZWRcbiAqIGJlaGF2aW91ci4gVG8gc3RvcCBhbGwgdHdlZW5zIG9uIGFuIG9iamVjdCwgdXNlIHtAbGluayB0d2VlbmpzLlR3ZWVuI3JlbW92ZVR3ZWVuc30gb3IgcGFzcyBgb3ZlcnJpZGU6dHJ1ZWBcbiAqIGluIHRoZSBwcm9wcyBhcmd1bWVudC5cbiAqXG4gKiBcdGNyZWF0ZWpzLlR3ZWVuLmdldCh0YXJnZXQsIHtvdmVycmlkZTp0cnVlfSkudG8oe3g6MTAwfSk7XG4gKlxuICogU3Vic2NyaWJlIHRvIHRoZSB7QGxpbmsgdHdlZW5qcy5Ud2VlbiNldmVudDpjaGFuZ2V9IGV2ZW50IHRvIGJlIG5vdGlmaWVkIHdoZW4gdGhlIHR3ZWVuIHBvc2l0aW9uIGNoYW5nZXMuXG4gKlxuICogXHRjcmVhdGVqcy5Ud2Vlbi5nZXQodGFyZ2V0LCB7b3ZlcnJpZGU6dHJ1ZX0pLnRvKHt4OjEwMH0pLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaGFuZGxlQ2hhbmdlKTtcbiAqIFx0ZnVuY3Rpb24gaGFuZGxlQ2hhbmdlKGV2ZW50KSB7XG4gKiBcdFx0Ly8gVGhlIHR3ZWVuIGNoYW5nZWQuXG4gKiBcdH1cbiAqXG4gKiBAc2VlIHtAbGluayB0d2VlbmpzLlR3ZWVuLmdldH1cbiAqXG4gKiBAbWVtYmVyb2YgdHdlZW5qc1xuICogQGV4dGVuZHMgdHdlZW5qcy5BYnN0cmFjdFR3ZWVuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgdGFyZ2V0IG9iamVjdCB0aGF0IHdpbGwgaGF2ZSBpdHMgcHJvcGVydGllcyB0d2VlbmVkLlxuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wc10gVGhlIGNvbmZpZ3VyYXRpb24gcHJvcGVydGllcyB0byBhcHBseSB0byB0aGlzIGluc3RhbmNlIChleC4gYHtsb29wOi0xLCBwYXVzZWQ6dHJ1ZX1gKS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3Byb3BzLnVzZVRpY2tzXVxuICogQHBhcmFtIHtCb29sZWFufSBbcHJvcHMuaWdub3JlR2xvYmFsUGF1c2VdXG4gKiBAcGFyYW0ge051bWJlcnxCb29sZWFufSBbcHJvcHMubG9vcF1cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3Byb3BzLnJldmVyc2VkXVxuICogQHBhcmFtIHtCb29sZWFufSBbcHJvcHMuYm91bmNlXVxuICogQHBhcmFtIHtOdW1iZXJ9IFtwcm9wcy50aW1lU2NhbGVdXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BzLnBsdWdpbkRhdGFdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtwcm9wcy5wYXVzZWRdXG4gKiBAcGFyYW0geyp9IFtwcm9wcy5wb3NpdGlvbl0gaW5kaWNhdGVzIHRoZSBpbml0aWFsIHBvc2l0aW9uIGZvciB0aGlzIHR3ZWVuXG4gKiBAcGFyYW0geyp9IFtwcm9wcy5vbkNoYW5nZV0gYWRkcyB0aGUgc3BlY2lmaWVkIGZ1bmN0aW9uIGFzIGEgbGlzdGVuZXIgdG8gdGhlIGBjaGFuZ2VgIGV2ZW50XG4gKiBAcGFyYW0geyp9IFtwcm9wcy5vbkNvbXBsZXRlXSBhZGRzIHRoZSBzcGVjaWZpZWQgZnVuY3Rpb24gYXMgYSBsaXN0ZW5lciB0byB0aGUgYGNvbXBsZXRlYCBldmVudFxuICogQHBhcmFtIHsqfSBbcHJvcHMub3ZlcnJpZGVdIGlmIHRydWUsIHJlbW92ZXMgYWxsIGV4aXN0aW5nIHR3ZWVucyBmb3IgdGhlIHRhcmdldFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUd2VlbiBleHRlbmRzIEFic3RyYWN0VHdlZW4ge1xuXG5cdGNvbnN0cnVjdG9yICh0YXJnZXQsIHByb3BzKSB7XG5cdFx0c3VwZXIocHJvcHMpO1xuXG5cdFx0LyoqXG5cdFx0ICogQWxsb3dzIHlvdSB0byBzcGVjaWZ5IGRhdGEgdGhhdCB3aWxsIGJlIHVzZWQgYnkgaW5zdGFsbGVkIHBsdWdpbnMuIEVhY2ggcGx1Z2luIHVzZXMgdGhpcyBkaWZmZXJlbnRseSwgYnV0IGluIGdlbmVyYWxcblx0XHQgKiB5b3Ugc3BlY2lmeSBkYXRhIGJ5IGFzc2lnbmluZyBpdCB0byBhIHByb3BlcnR5IG9mIGBwbHVnaW5EYXRhYCB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgdGhlIHBsdWdpbi5cblx0XHQgKiBOb3RlIHRoYXQgaW4gbWFueSBjYXNlcywgdGhpcyBkYXRhIGlzIHVzZWQgYXMgc29vbiBhcyB0aGUgcGx1Z2luIGluaXRpYWxpemVzIGl0c2VsZiBmb3IgdGhlIHR3ZWVuLlxuXHRcdCAqIEFzIHN1Y2gsIHRoaXMgZGF0YSBzaG91bGQgYmUgc2V0IGJlZm9yZSB0aGUgZmlyc3QgYHRvYCBjYWxsIGluIG1vc3QgY2FzZXMuXG5cdFx0ICpcblx0XHQgKiBTb21lIHBsdWdpbnMgYWxzbyBzdG9yZSB3b3JraW5nIGRhdGEgaW4gdGhpcyBvYmplY3QsIHVzdWFsbHkgaW4gYSBwcm9wZXJ0eSBuYW1lZCBgX1BsdWdpbkNsYXNzTmFtZWAuXG5cdFx0ICogU2VlIHRoZSBkb2N1bWVudGF0aW9uIGZvciBpbmRpdmlkdWFsIHBsdWdpbnMgZm9yIG1vcmUgZGV0YWlscy5cblx0XHQgKlxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogbXlUd2Vlbi5wbHVnaW5EYXRhLlNtYXJ0Um90YXRpb24gPSBkYXRhO1xuXHRcdCAqIG15VHdlZW4ucGx1Z2luRGF0YS5TbWFydFJvdGF0aW9uX2Rpc2FibGVkID0gdHJ1ZTtcblx0XHQgKlxuXHRcdCAqXG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdFx0dGhpcy5wbHVnaW5EYXRhID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSB0YXJnZXQgb2YgdGhpcyB0d2Vlbi4gVGhpcyBpcyB0aGUgb2JqZWN0IG9uIHdoaWNoIHRoZSB0d2VlbmVkIHByb3BlcnRpZXMgd2lsbCBiZSBjaGFuZ2VkLlxuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICovXG5cdFx0dGhpcy50YXJnZXQgPSB0YXJnZXQ7XG5cblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgdGhlIHR3ZWVuJ3MgY3VycmVudCBwb3NpdGlvbiBpcyB3aXRoaW4gYSBwYXNzaXZlIHdhaXQuXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKi9cblx0XHR0aGlzLnBhc3NpdmUgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQHR5cGUge1R3ZWVuU3RlcH1cblx0XHQgKi9cblx0XHR0aGlzLl9zdGVwSGVhZCA9IG5ldyBUd2VlblN0ZXAobnVsbCwgMCwgMCwge30sIG51bGwsIHRydWUpO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAdHlwZSB7VHdlZW5TdGVwfVxuXHRcdCAqL1xuXHRcdHRoaXMuX3N0ZXBUYWlsID0gdGhpcy5fc3RlcEhlYWQ7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgcG9zaXRpb24gd2l0aGluIHRoZSBjdXJyZW50IHN0ZXAuIFVzZWQgYnkgTW92aWVDbGlwLlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0dGhpcy5fc3RlcFBvc2l0aW9uID0gMDtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQHR5cGUge1R3ZWVuQWN0aW9ufVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLl9hY3Rpb25IZWFkID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQHR5cGUge1R3ZWVuQWN0aW9ufVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLl9hY3Rpb25UYWlsID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIFBsdWdpbnMgYWRkZWQgdG8gdGhpcyB0d2VlbiBpbnN0YW5jZS5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEB0eXBlIHtPYmplY3RbXX1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5fcGx1Z2lucyA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBIYXNoIGZvciBxdWlja2x5IGxvb2tpbmcgdXAgYWRkZWQgcGx1Z2lucy4gTnVsbCB1bnRpbCBhIHBsdWdpbiBpcyBhZGRlZC5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuX3BsdWdpbklkcyA9IG51bGw7XG5cblxuXHRcdC8qKlxuXHRcdCAqIFVzZWQgYnkgcGx1Z2lucyB0byBpbmplY3QgbmV3IHByb3BlcnRpZXMuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLl9pbmplY3RlZCA9IG51bGw7XG5cblx0XHRpZiAocHJvcHMpIHtcblx0XHRcdHRoaXMucGx1Z2luRGF0YSA9IHByb3BzLnBsdWdpbkRhdGE7XG5cdFx0XHRpZiAocHJvcHMub3ZlcnJpZGUpIHsgVHdlZW4ucmVtb3ZlVHdlZW5zKHRhcmdldCk7IH1cblx0XHR9XG5cdFx0aWYgKCF0aGlzLnBsdWdpbkRhdGEpIHsgdGhpcy5wbHVnaW5EYXRhID0ge307IH1cblxuXHRcdHRoaXMuX2luaXQocHJvcHMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBuZXcgdHdlZW4gaW5zdGFuY2UuIFRoaXMgaXMgZnVuY3Rpb25hbGx5IGlkZW50aWNhbCB0byB1c2luZyBgbmV3IFR3ZWVuKC4uLilgLCBidXQgbWF5IGxvb2sgY2xlYW5lclxuXHQgKiB3aXRoIHRoZSBjaGFpbmVkIHN5bnRheCBvZiBUd2VlbkpTLlxuXHQgKlxuXHQgKiBAc3RhdGljXG5cdCAqIEBleGFtcGxlXG5cdCAqIGxldCB0d2VlbiA9IFR3ZWVuLmdldCh0YXJnZXQpLnRvKHsgeDogMTAwIH0sIDUwMCk7XG5cdCAqIC8vIGVxdWl2YWxlbnQgdG86XG5cdCAqIGxldCB0d2VlbiA9IG5ldyBUd2Vlbih0YXJnZXQpLnRvKHsgeDogMTAwIH0sIDUwMCk7XG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIHRhcmdldCBvYmplY3QgdGhhdCB3aWxsIGhhdmUgaXRzIHByb3BlcnRpZXMgdHdlZW5lZC5cblx0ICogQHBhcmFtIHtPYmplY3R9IFtwcm9wc10gVGhlIGNvbmZpZ3VyYXRpb24gcHJvcGVydGllcyB0byBhcHBseSB0byB0aGlzIGluc3RhbmNlIChleC4gYHtsb29wOi0xLCBwYXVzZWQ6dHJ1ZX1gKS5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbcHJvcHMudXNlVGlja3NdXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3Byb3BzLmlnbm9yZUdsb2JhbFBhdXNlXVxuXHQgKiBAcGFyYW0ge051bWJlcnxCb29sZWFufSBbcHJvcHMubG9vcF1cblx0ICogQHBhcmFtIHtCb29sZWFufSBbcHJvcHMucmV2ZXJzZWRdXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3Byb3BzLmJvdW5jZV1cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtwcm9wcy50aW1lU2NhbGVdXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMucGx1Z2luRGF0YV1cblx0ICogQHBhcmFtIHtCb29sZWFufSBbcHJvcHMucGF1c2VkXVxuXHQgKiBAcGFyYW0geyp9IFtwcm9wcy5wb3NpdGlvbl0gaW5kaWNhdGVzIHRoZSBpbml0aWFsIHBvc2l0aW9uIGZvciB0aGlzIHR3ZWVuXG5cdCAqIEBwYXJhbSB7Kn0gW3Byb3BzLm9uQ2hhbmdlXSBhZGRzIHRoZSBzcGVjaWZpZWQgZnVuY3Rpb24gYXMgYSBsaXN0ZW5lciB0byB0aGUgYGNoYW5nZWAgZXZlbnRcblx0ICogQHBhcmFtIHsqfSBbcHJvcHMub25Db21wbGV0ZV0gYWRkcyB0aGUgc3BlY2lmaWVkIGZ1bmN0aW9uIGFzIGEgbGlzdGVuZXIgdG8gdGhlIGBjb21wbGV0ZWAgZXZlbnRcblx0ICogQHBhcmFtIHsqfSBbcHJvcHMub3ZlcnJpZGVdIGlmIHRydWUsIHJlbW92ZXMgYWxsIGV4aXN0aW5nIHR3ZWVucyBmb3IgdGhlIHRhcmdldFxuXHQgKiBAcmV0dXJuIHtUd2Vlbn0gQSByZWZlcmVuY2UgdG8gdGhlIGNyZWF0ZWQgdHdlZW4uXG5cdCAqL1xuXHRzdGF0aWMgZ2V0ICh0YXJnZXQsIHByb3BzKSB7XG5cdFx0cmV0dXJuIG5ldyBUd2Vlbih0YXJnZXQsIHByb3BzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZHZhbmNlcyBhbGwgdHdlZW5zLiBUaGlzIHR5cGljYWxseSB1c2VzIHRoZSB7eyNjcm9zc0xpbmsgXCJUaWNrZXJcIn19e3svY3Jvc3NMaW5rfX0gY2xhc3MsIGJ1dCB5b3UgY2FuIGNhbGwgaXRcblx0ICogbWFudWFsbHkgaWYgeW91IHByZWZlciB0byB1c2UgeW91ciBvd24gXCJoZWFydGJlYXRcIiBpbXBsZW1lbnRhdGlvbi5cblx0ICpcblx0ICogQHN0YXRpY1xuXHQgKlxuXHQgKiBAcGFyYW0ge051bWJlcn0gZGVsdGEgVGhlIGNoYW5nZSBpbiB0aW1lIGluIG1pbGxpc2Vjb25kcyBzaW5jZSB0aGUgbGFzdCB0aWNrLiBSZXF1aXJlZCB1bmxlc3MgYWxsIHR3ZWVucyBoYXZlXG5cdCAqIGB1c2VUaWNrc2Agc2V0IHRvIHRydWUuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gcGF1c2VkIEluZGljYXRlcyB3aGV0aGVyIGEgZ2xvYmFsIHBhdXNlIGlzIGluIGVmZmVjdC4gVHdlZW5zIHdpdGgge0BsaW5rIHR3ZWVuanMuVHdlZW4jaWdub3JlR2xvYmFsUGF1c2V9XG5cdCAqIHdpbGwgaWdub3JlIHRoaXMsIGJ1dCBhbGwgb3RoZXJzIHdpbGwgcGF1c2UgaWYgdGhpcyBpcyBgdHJ1ZWAuXG5cdCAqL1xuXHRzdGF0aWMgdGljayAoZGVsdGEsIHBhdXNlZCkge1xuXHRcdGxldCB0d2VlbiA9IFR3ZWVuLl90d2VlbkhlYWQ7XG5cdFx0d2hpbGUgKHR3ZWVuKSB7XG5cdFx0XHRsZXQgbmV4dCA9IHR3ZWVuLl9uZXh0OyAvLyBpbiBjYXNlIGl0IGNvbXBsZXRlcyBhbmQgd2lwZXMgaXRzIF9uZXh0IHByb3BlcnR5XG5cdFx0XHRpZiAoKHBhdXNlZCAmJiAhdHdlZW4uaWdub3JlR2xvYmFsUGF1c2UpIHx8IHR3ZWVuLl9wYXVzZWQpIHsgLyogcGF1c2VkICovIH1cblx0XHRcdGVsc2UgeyB0d2Vlbi5hZHZhbmNlKHR3ZWVuLnVzZVRpY2tzID8gMTogZGVsdGEpOyB9XG5cdFx0XHR0d2VlbiA9IG5leHQ7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEhhbmRsZSBldmVudHMgdGhhdCByZXN1bHQgZnJvbSBUd2VlbiBiZWluZyB1c2VkIGFzIGFuIGV2ZW50IGhhbmRsZXIuIFRoaXMgaXMgaW5jbHVkZWQgdG8gYWxsb3cgVHdlZW4gdG8gaGFuZGxlXG5cdCAqIHtAbGluayB0d2VlbmpzLlRpY2tlciNldmVudDp0aWNrfSBldmVudHMgZnJvbSB0aGUge0BsaW5rIHR3ZWVuanMuVGlja2VyfS5cblx0ICogTm8gb3RoZXIgZXZlbnRzIGFyZSBoYW5kbGVkIGluIFR3ZWVuLlxuXHQgKlxuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjQuMlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgQW4gZXZlbnQgb2JqZWN0IHBhc3NlZCBpbiBieSB0aGUge0BsaW5rIGNvcmUuRXZlbnREaXNwYXRjaGVyfS4gV2lsbFxuXHQgKiB1c3VhbGx5IGJlIG9mIHR5cGUgXCJ0aWNrXCIuXG5cdCAqL1xuXHRzdGF0aWMgaGFuZGxlRXZlbnQgKGV2ZW50KSB7XG5cdFx0aWYgKGV2ZW50LnR5cGUgPT09IFwidGlja1wiKSB7XG5cdFx0XHR0aGlzLnRpY2soZXZlbnQuZGVsdGEsIGV2ZW50LnBhdXNlZCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgYWxsIGV4aXN0aW5nIHR3ZWVucyBmb3IgYSB0YXJnZXQuIFRoaXMgaXMgY2FsbGVkIGF1dG9tYXRpY2FsbHkgYnkgbmV3IHR3ZWVucyBpZiB0aGUgYG92ZXJyaWRlYFxuXHQgKiBwcm9wZXJ0eSBpcyBgdHJ1ZWAuXG5cdCAqXG5cdCAqIEBzdGF0aWNcblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgdGFyZ2V0IG9iamVjdCB0byByZW1vdmUgZXhpc3RpbmcgdHdlZW5zIGZyb20uPVxuXHQgKi9cblx0c3RhdGljIHJlbW92ZVR3ZWVucyAodGFyZ2V0KSB7XG5cdFx0aWYgKCF0YXJnZXQudHdlZW5qc19jb3VudCkgeyByZXR1cm47IH1cblx0XHRsZXQgdHdlZW4gPSBUd2Vlbi5fdHdlZW5IZWFkO1xuXHRcdHdoaWxlICh0d2Vlbikge1xuXHRcdFx0bGV0IG5leHQgPSB0d2Vlbi5fbmV4dDtcblx0XHRcdGlmICh0d2Vlbi50YXJnZXQgPT09IHRhcmdldCkgeyB0d2Vlbi5wYXVzZWQgPSB0cnVlOyB9XG5cdFx0XHR0d2VlbiA9IG5leHQ7XG5cdFx0fVxuXHRcdHRhcmdldC50d2VlbmpzX2NvdW50ID0gMDtcblx0fVxuXG5cdC8qKlxuXHQgKiBTdG9wIGFuZCByZW1vdmUgYWxsIGV4aXN0aW5nIHR3ZWVucy5cblx0ICpcblx0ICogQHN0YXRpY1xuXHQgKiBAc2luY2UgMC40LjFcblx0ICovXG5cdHN0YXRpYyByZW1vdmVBbGxUd2VlbnMgKCkge1xuXHRcdGxldCB0d2VlbiA9IFR3ZWVuLl90d2VlbkhlYWQ7XG5cdFx0d2hpbGUgKHR3ZWVuKSB7XG5cdFx0XHRsZXQgbmV4dCA9IHR3ZWVuLl9uZXh0O1xuXHRcdFx0dHdlZW4uX3BhdXNlZCA9IHRydWU7XG5cdFx0XHR0d2Vlbi50YXJnZXQgJiYgKHR3ZWVuLnRhcmdldC50d2VlbmpzX2NvdW50ID0gMCk7XG5cdFx0XHR0d2Vlbi5fbmV4dCA9IHR3ZWVuLl9wcmV2ID0gbnVsbDtcblx0XHRcdHR3ZWVuID0gbmV4dDtcblx0XHR9XG5cdFx0VHdlZW4uX3R3ZWVuSGVhZCA9IFR3ZWVuLl90d2VlblRhaWwgPSBudWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIEluZGljYXRlcyB3aGV0aGVyIHRoZXJlIGFyZSBhbnkgYWN0aXZlIHR3ZWVucyBvbiB0aGUgdGFyZ2V0IG9iamVjdCAoaWYgc3BlY2lmaWVkKSBvciBpbiBnZW5lcmFsLlxuXHQgKlxuXHQgKiBAc3RhdGljXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbdGFyZ2V0XSBUaGUgdGFyZ2V0IHRvIGNoZWNrIGZvciBhY3RpdmUgdHdlZW5zLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgcmV0dXJuIHZhbHVlIHdpbGwgaW5kaWNhdGVcblx0ICogaWYgdGhlcmUgYXJlIGFueSBhY3RpdmUgdHdlZW5zIG9uIGFueSB0YXJnZXQuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IEluZGljYXRlcyBpZiB0aGVyZSBhcmUgYWN0aXZlIHR3ZWVucy5cblx0ICovXG5cdHN0YXRpYyBoYXNBY3RpdmVUd2VlbnMgKHRhcmdldCkge1xuXHRcdGlmICh0YXJnZXQpIHsgcmV0dXJuICEhdGFyZ2V0LnR3ZWVuanNfY291bnQ7IH1cblx0XHRyZXR1cm4gISFUd2Vlbi5fdHdlZW5IZWFkO1xuXHR9XG5cblx0LyoqXG5cdCAqIEluc3RhbGxzIGEgcGx1Z2luLCB3aGljaCBjYW4gbW9kaWZ5IGhvdyBjZXJ0YWluIHByb3BlcnRpZXMgYXJlIGhhbmRsZWQgd2hlbiB0d2VlbmVkLiBTZWUgdGhlIHt7I2Nyb3NzTGluayBcIlNhbXBsZVBsdWdpblwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBmb3IgYW4gZXhhbXBsZSBvZiBob3cgdG8gd3JpdGUgVHdlZW5KUyBwbHVnaW5zLiBQbHVnaW5zIHNob3VsZCBnZW5lcmFsbHkgYmUgaW5zdGFsbGVkIHZpYSB0aGVpciBvd24gYGluc3RhbGxgIG1ldGhvZCwgaW4gb3JkZXIgdG8gcHJvdmlkZVxuXHQgKiB0aGUgcGx1Z2luIHdpdGggYW4gb3Bwb3J0dW5pdHkgdG8gY29uZmlndXJlIGl0c2VsZi5cblx0ICpcblx0ICogQHN0YXRpY1xuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gcGx1Z2luIFRoZSBwbHVnaW4gdG8gaW5zdGFsbFxuXHQgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgVGhlIHByb3BzIHRvIHBhc3MgdG8gdGhlIHBsdWdpblxuXHQgKi9cblx0c3RhdGljIGluc3RhbGxQbHVnaW4gKHBsdWdpbiwgcHJvcHMpIHtcblx0XHRwbHVnaW4uaW5zdGFsbChwcm9wcyk7XG5cdFx0Y29uc3QgcHJpb3JpdHkgPSAocGx1Z2luLnByaW9yaXR5ID0gcGx1Z2luLnByaW9yaXR5IHx8IDApLCBhcnIgPSAoVHdlZW4uX3BsdWdpbnMgPSBUd2Vlbi5fcGx1Z2lucyB8fCBbXSk7XG5cdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBhcnIubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRpZiAocHJpb3JpdHkgPCBhcnJbaV0ucHJpb3JpdHkpIHsgYnJlYWs7IH1cblx0XHR9XG5cdFx0YXJyLnNwbGljZShpLCAwLCBwbHVnaW4pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlZ2lzdGVycyBvciB1bnJlZ2lzdGVycyBhIHR3ZWVuIHdpdGggdGhlIHRpY2tpbmcgc3lzdGVtLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAc3RhdGljXG5cdCAqXG5cdCAqIEBwYXJhbSB7VHdlZW59IHR3ZWVuIFRoZSB0d2VlbiBpbnN0YW5jZSB0byByZWdpc3RlciBvciB1bnJlZ2lzdGVyLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHBhdXNlZCBJZiBgZmFsc2VgLCB0aGUgdHdlZW4gaXMgcmVnaXN0ZXJlZC4gSWYgYHRydWVgIHRoZSB0d2VlbiBpcyB1bnJlZ2lzdGVyZWQuXG5cdCAqL1xuXHRzdGF0aWMgX3JlZ2lzdGVyICh0d2VlbiwgcGF1c2VkKSB7XG5cdFx0Y29uc3QgdGFyZ2V0ID0gdHdlZW4udGFyZ2V0O1xuXHRcdGlmICghcGF1c2VkICYmIHR3ZWVuLl9wYXVzZWQpIHtcblx0XHRcdC8vIFRPRE86IHRoaXMgYXBwcm9hY2ggbWlnaHQgZmFpbCBpZiBhIGRldiBpcyB1c2luZyBzZWFsZWQgb2JqZWN0c1xuXHRcdFx0aWYgKHRhcmdldCkgeyB0YXJnZXQudHdlZW5qc19jb3VudCA9IHRhcmdldC50d2VlbmpzX2NvdW50ID8gdGFyZ2V0LnR3ZWVuanNfY291bnQgKyAxIDogMTsgfVxuXHRcdFx0bGV0IHRhaWwgPSBUd2Vlbi5fdHdlZW5UYWlsO1xuXHRcdFx0aWYgKCF0YWlsKSB7IFR3ZWVuLl90d2VlbkhlYWQgPSBUd2Vlbi5fdHdlZW5UYWlsID0gdHdlZW47IH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRUd2Vlbi5fdHdlZW5UYWlsID0gdGFpbC5fbmV4dCA9IHR3ZWVuO1xuXHRcdFx0XHR0d2Vlbi5fcHJldiA9IHRhaWw7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIVR3ZWVuLl9pbml0ZWQpIHsgVGlja2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJ0aWNrXCIsIFR3ZWVuKTsgVHdlZW4uX2luaXRlZCA9IHRydWU7IH1cblx0XHR9IGVsc2UgaWYgKHBhdXNlZCAmJiAhdHdlZW4uX3BhdXNlZCkge1xuXHRcdFx0aWYgKHRhcmdldCkgeyB0YXJnZXQudHdlZW5qc19jb3VudC0tOyB9XG5cdFx0XHRsZXQgbmV4dCA9IHR3ZWVuLl9uZXh0LCBwcmV2ID0gdHdlZW4uX3ByZXY7XG5cblx0XHRcdGlmIChuZXh0KSB7IG5leHQuX3ByZXYgPSBwcmV2OyB9XG5cdFx0XHRlbHNlIHsgVHdlZW4uX3R3ZWVuVGFpbCA9IHByZXY7IH0gLy8gd2FzIHRhaWxcblx0XHRcdGlmIChwcmV2KSB7IHByZXYuX25leHQgPSBuZXh0OyB9XG5cdFx0XHRlbHNlIHsgVHdlZW4uX3R3ZWVuSGVhZCA9IG5leHQ7IH0gLy8gd2FzIGhlYWQuXG5cblx0XHRcdHR3ZWVuLl9uZXh0ID0gdHdlZW4uX3ByZXYgPSBudWxsO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgd2FpdCAoZXNzZW50aWFsbHkgYW4gZW1wdHkgdHdlZW4pLlxuXHQgKlxuXHQgKiBAZXhhbXBsZVxuXHQgKiAvLyBUaGlzIHR3ZWVuIHdpbGwgd2FpdCAxcyBiZWZvcmUgYWxwaGEgaXMgZmFkZWQgdG8gMC5cblx0ICogVHdlZW4uZ2V0KHRhcmdldClcblx0ICogICAud2FpdCgxMDAwKVxuXHQgKiAgIC50byh7IGFscGhhOiAwIH0sIDEwMDApO1xuXHQgKlxuXHQgKiBAcGFyYW0ge051bWJlcn0gZHVyYXRpb24gVGhlIGR1cmF0aW9uIG9mIHRoZSB3YWl0IGluIG1pbGxpc2Vjb25kcyAob3IgaW4gdGlja3MgaWYgYHVzZVRpY2tzYCBpcyB0cnVlKS5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbcGFzc2l2ZT1mYWxzZV0gVHdlZW4gcHJvcGVydGllcyB3aWxsIG5vdCBiZSB1cGRhdGVkIGR1cmluZyBhIHBhc3NpdmUgd2FpdC4gVGhpc1xuXHQgKiBpcyBtb3N0bHkgdXNlZnVsIGZvciB1c2Ugd2l0aCB7QGxpbmsgdHdlZW5qcy5UaW1lbGluZX0gaW5zdGFuY2VzIHRoYXQgY29udGFpbiBtdWx0aXBsZSB0d2VlbnNcblx0ICogYWZmZWN0aW5nIHRoZSBzYW1lIHRhcmdldCBhdCBkaWZmZXJlbnQgdGltZXMuXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdHdhaXQgKGR1cmF0aW9uLCBwYXNzaXZlID0gZmFsc2UpIHtcblx0XHRpZiAoZHVyYXRpb24gPiAwKSB7IHRoaXMuX2FkZFN0ZXAoK2R1cmF0aW9uLCB0aGlzLl9zdGVwVGFpbC5wcm9wcywgbnVsbCwgcGFzc2l2ZSk7IH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgdHdlZW4gZnJvbSB0aGUgY3VycmVudCB2YWx1ZXMgdG8gdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLiBTZXQgZHVyYXRpb24gdG8gMCB0byBqdW1wIHRvIHRoZXNlIHZhbHVlLlxuXHQgKiBOdW1lcmljIHByb3BlcnRpZXMgd2lsbCBiZSB0d2VlbmVkIGZyb20gdGhlaXIgY3VycmVudCB2YWx1ZSBpbiB0aGUgdHdlZW4gdG8gdGhlIHRhcmdldCB2YWx1ZS4gTm9uLW51bWVyaWNcblx0ICogcHJvcGVydGllcyB3aWxsIGJlIHNldCBhdCB0aGUgZW5kIG9mIHRoZSBzcGVjaWZpZWQgZHVyYXRpb24uXG5cdCAqXG5cdCAqIEBleGFtcGxlXG5cdCAqIFR3ZWVuLmdldCh0YXJnZXQpXG5cdCAqICAgLnRvKHsgYWxwaGE6IDAsIHZpc2libGU6IGZhbHNlIH0sIDEwMDApO1xuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQW4gb2JqZWN0IHNwZWNpZnlpbmcgcHJvcGVydHkgdGFyZ2V0IHZhbHVlcyBmb3IgdGhpcyB0d2VlbiAoRXguIGB7eDozMDB9YCB3b3VsZCB0d2VlbiB0aGUgeFxuXHQgKiBwcm9wZXJ0eSBvZiB0aGUgdGFyZ2V0IHRvIDMwMCkuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbZHVyYXRpb249MF0gVGhlIGR1cmF0aW9uIG9mIHRoZSB0d2VlbiBpbiBtaWxsaXNlY29uZHMgKG9yIGluIHRpY2tzIGlmIGB1c2VUaWNrc2AgaXMgdHJ1ZSkuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IFtlYXNlPUVhc2UubGluZWFyXSBUaGUgZWFzaW5nIGZ1bmN0aW9uIHRvIHVzZSBmb3IgdGhpcyB0d2Vlbi4gU2VlIHRoZSB7QGxpbmsgdHdlZW5qcy5FYXNlfVxuXHQgKiBjbGFzcyBmb3IgYSBsaXN0IG9mIGJ1aWx0LWluIGVhc2UgZnVuY3Rpb25zLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHR0byAocHJvcHMsIGR1cmF0aW9uID0gMCwgZWFzZSA9IGxpbmVhcikge1xuXHRcdGlmIChkdXJhdGlvbiA8IDApIHsgZHVyYXRpb24gPSAwOyB9XG5cdFx0Y29uc3Qgc3RlcCA9IHRoaXMuX2FkZFN0ZXAoK2R1cmF0aW9uLCBudWxsLCBlYXNlKTtcblx0XHR0aGlzLl9hcHBlbmRQcm9wcyhwcm9wcywgc3RlcCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIGxhYmVsIHRoYXQgY2FuIGJlIHVzZWQgd2l0aCB7QGxpbmsgdHdlZW5qcy5Ud2VlbiNnb3RvQW5kUGxheX0ve0BsaW5rIHR3ZWVuanMuVHdlZW4jZ290b0FuZFN0b3B9XG5cdCAqIGF0IHRoZSBjdXJyZW50IHBvaW50IGluIHRoZSB0d2Vlbi5cblx0ICpcblx0ICogQGV4YW1wbGVcblx0ICogbGV0IHR3ZWVuID0gVHdlZW4uZ2V0KGZvbylcblx0ICogICAudG8oeyB4OiAxMDAgfSwgMTAwMClcblx0ICogICAubGFiZWwoXCJteUxhYmVsXCIpXG5cdCAqICAgLnRvKHsgeDogMjAwIH0sIDEwMDApO1xuXHQgKiAvLyAuLi5cblx0ICogdHdlZW4uZ290b0FuZFBsYXkoXCJteUxhYmVsXCIpOyAvLyB3b3VsZCBwbGF5IGZyb20gMTAwMG1zIGluLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbGFiZWwgVGhlIGxhYmVsIG5hbWUuXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdGxhYmVsIChuYW1lKSB7XG5cdFx0dGhpcy5hZGRMYWJlbChuYW1lLCB0aGlzLmR1cmF0aW9uKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGFuIGFjdGlvbiB0byBjYWxsIHRoZSBzcGVjaWZpZWQgZnVuY3Rpb24uXG5cdCAqXG5cdCAqIEBleGFtcGxlXG5cdCAqIC8vIHdvdWxkIGNhbGwgbXlGdW5jdGlvbigpIGFmdGVyIDEgc2Vjb25kLlxuXHQgKiBUd2Vlbi5nZXQoKVxuXHQgKiAgIC53YWl0KDEwMDApXG5cdCAqICAgLmNhbGwobXlGdW5jdGlvbik7XG5cdCAqXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBjYWxsLlxuXHQgKiBAcGFyYW0ge0FycmF5fSBbcGFyYW1zXS4gVGhlIHBhcmFtZXRlcnMgdG8gY2FsbCB0aGUgZnVuY3Rpb24gd2l0aC4gSWYgdGhpcyBpcyBvbWl0dGVkLCB0aGVuIHRoZSBmdW5jdGlvblxuXHQgKiB3aWxsIGJlIGNhbGxlZCB3aXRoIGEgc2luZ2xlIHBhcmFtIHBvaW50aW5nIHRvIHRoaXMgdHdlZW4uXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbc2NvcGVdLiBUaGUgc2NvcGUgdG8gY2FsbCB0aGUgZnVuY3Rpb24gaW4uIElmIG9taXR0ZWQsIGl0IHdpbGwgYmUgY2FsbGVkIGluIHRoZSB0YXJnZXQncyBzY29wZS5cblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0Y2FsbCAoY2FsbGJhY2ssIHBhcmFtcywgc2NvcGUpIHtcblx0XHRyZXR1cm4gdGhpcy5fYWRkQWN0aW9uKHNjb3BlIHx8IHRoaXMudGFyZ2V0LCBjYWxsYmFjaywgcGFyYW1zIHx8IFt0aGlzXSk7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhbiBhY3Rpb24gdG8gc2V0IHRoZSBzcGVjaWZpZWQgcHJvcHMgb24gdGhlIHNwZWNpZmllZCB0YXJnZXQuIElmIGB0YXJnZXRgIGlzIG51bGwsIGl0IHdpbGwgdXNlIHRoaXMgdHdlZW4nc1xuXHQgKiB0YXJnZXQuIE5vdGUgdGhhdCBmb3IgcHJvcGVydGllcyBvbiB0aGUgdGFyZ2V0IG9iamVjdCwgeW91IHNob3VsZCBjb25zaWRlciB1c2luZyBhIHplcm8gZHVyYXRpb24ge0BsaW5rIHR3ZWVuanMuVHdlZW4jdG99XG5cdCAqIG9wZXJhdGlvbiBpbnN0ZWFkIHNvIHRoZSB2YWx1ZXMgYXJlIHJlZ2lzdGVyZWQgYXMgdHdlZW5lZCBwcm9wcy5cblx0ICpcblx0ICogQGV4YW1wbGVcblx0ICogdHdlZW4ud2FpdCgxMDAwKVxuXHQgKiAgIC5zZXQoeyB2aXNpYmxlOiBmYWxzZSB9LCBmb28pO1xuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgVGhlIHByb3BlcnRpZXMgdG8gc2V0IChleC4gYHsgdmlzaWJsZTogZmFsc2UgfWApLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW3RhcmdldF0gVGhlIHRhcmdldCB0byBzZXQgdGhlIHByb3BlcnRpZXMgb24uIElmIG9taXR0ZWQsIHRoZXkgd2lsbCBiZSBzZXQgb24gdGhlIHR3ZWVuJ3MgdGFyZ2V0LlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRzZXQgKHByb3BzLCB0YXJnZXQpIHtcblx0XHRyZXR1cm4gdGhpcy5fYWRkQWN0aW9uKHRhcmdldCB8fCB0aGlzLnRhcmdldCwgdGhpcy5fc2V0LCBbIHByb3BzIF0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYW4gYWN0aW9uIHRvIHBsYXkgKHVucGF1c2UpIHRoZSBzcGVjaWZpZWQgdHdlZW4uIFRoaXMgZW5hYmxlcyB5b3UgdG8gc2VxdWVuY2UgbXVsdGlwbGUgdHdlZW5zLlxuXHQgKlxuXHQgKiBAZXhhbXBsZVxuXHQgKiB0d2Vlbi50byh7IHg6IDEwMCB9LCA1MDApXG5cdCAqICAgLnBsYXkob3RoZXJUd2Vlbik7XG5cdCAqXG5cdCAqIEBwYXJhbSB7VHdlZW59IFt0d2Vlbl0gVGhlIHR3ZWVuIHRvIHBsYXkuIERlZmF1bHRzIHRvIHRoaXMgdHdlZW4uXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdHBsYXkgKHR3ZWVuKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZEFjdGlvbih0d2VlbiB8fCB0aGlzLCB0aGlzLl9zZXQsIFt7IHBhdXNlZDogZmFsc2UgfV0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYW4gYWN0aW9uIHRvIHBhdXNlIHRoZSBzcGVjaWZpZWQgdHdlZW4uXG5cdCAqIEF0IDYwZnBzIHRoZSB0d2VlbiB3aWxsIGFkdmFuY2UgYnkgfjE2bXMgcGVyIHRpY2ssIGlmIHRoZSB0d2VlbiBhYm92ZSB3YXMgYXQgOTk5bXMgcHJpb3IgdG8gdGhlIGN1cnJlbnQgdGljaywgaXRcbiAgICogd2lsbCBhZHZhbmNlIHRvIDEwMTVtcyAoMTVtcyBpbnRvIHRoZSBzZWNvbmQgXCJzdGVwXCIpIGFuZCB0aGVuIHBhdXNlLlxuXHQgKlxuXHQgKiBAZXhhbXBsZVxuXHQgKiB0d2Vlbi5wYXVzZShvdGhlclR3ZWVuKVxuXHQgKiAgIC50byh7IGFscGhhOiAxIH0sIDEwMDApXG5cdCAqICAgLnBsYXkob3RoZXJUd2Vlbik7XG5cdCAqXG5cdCAqIC8vIE5vdGUgdGhhdCB0aGlzIGV4ZWN1dGVzIGF0IHRoZSBlbmQgb2YgYSB0d2VlbiB1cGRhdGUsXG5cdCAqIC8vIHNvIHRoZSB0d2VlbiBtYXkgYWR2YW5jZSBiZXlvbmQgdGhlIHRpbWUgdGhlIHBhdXNlIGFjdGlvbiB3YXMgaW5zZXJ0ZWQgYXQuXG4gICAqXG4gICAqIHR3ZWVuLnRvKHsgZm9vOiAwIH0sIDEwMDApXG4gICAqICAgLnBhdXNlKClcbiAgICogICAudG8oeyBmb286IDEgfSwgMTAwMCk7XG5cdCAqXG5cdCAqIEBwYXJhbSB7VHdlZW59IFt0d2Vlbl0gVGhlIHR3ZWVuIHRvIHBhdXNlLiBEZWZhdWx0cyB0byB0aGlzIHR3ZWVuLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRwYXVzZSAodHdlZW4pIHtcblx0XHRyZXR1cm4gdGhpcy5fYWRkQWN0aW9uKHR3ZWVuIHx8IHRoaXMsIHRoaXMuX3NldCwgW3sgcGF1c2VkOiBmYWxzZSB9XSk7XG5cdH1cblxuXHQvKipcblx0ICogQHRocm93cyBUd2VlbiBjYW5ub3QgYmUgY2xvbmVkLlxuXHQgKi9cblx0Y2xvbmUgKCkge1xuXHRcdHRocm93IFwiVHdlZW4gY2FuIG5vdCBiZSBjbG9uZWQuXCI7XG5cdH1cblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtPYmplY3R9IHBsdWdpblxuXHQgKi9cblx0X2FkZFBsdWdpbiAocGx1Z2luKSB7XG5cdFx0bGV0IGlkcyA9IHRoaXMuX3BsdWdpbklkcyB8fCAodGhpcy5fcGx1Z2luSWRzID0ge30pLCBpZCA9IHBsdWdpbi5pZDtcblx0XHRpZiAoIWlkIHx8IGlkc1tpZF0pIHsgcmV0dXJuOyB9IC8vIGFscmVhZHkgYWRkZWRcblxuXHRcdGlkc1tpZF0gPSB0cnVlO1xuXHRcdGxldCBwbHVnaW5zID0gdGhpcy5fcGx1Z2lucyB8fCAodGhpcy5fcGx1Z2lucyA9IFtdKSwgcHJpb3JpdHkgPSBwbHVnaW4ucHJpb3JpdHkgfHwgMDtcblx0XHRmb3IgKGxldCBpID0gMCwgbCA9IHBsdWdpbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRpZiAocHJpb3JpdHkgPCBwbHVnaW5zW2ldLnByaW9yaXR5KSB7XG5cdFx0XHRcdHBsdWdpbnMuc3BsaWNlKGksIDAsIHBsdWdpbik7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9XG5cdFx0cGx1Z2lucy5wdXNoKHBsdWdpbik7XG5cdH1cblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHt9IGp1bXBcblx0ICogQHBhcmFtIHtCb29sZWFufSBlbmRcbiAgICovXG5cdF91cGRhdGVQb3NpdGlvbiAoanVtcCwgZW5kKSB7XG5cdFx0bGV0IHN0ZXAgPSB0aGlzLl9zdGVwSGVhZC5uZXh0LCB0ID0gdGhpcy5wb3NpdGlvbiwgZCA9IHRoaXMuZHVyYXRpb247XG5cdFx0aWYgKHRoaXMudGFyZ2V0ICYmIHN0ZXApIHtcblx0XHRcdC8vIGZpbmQgb3VyIG5ldyBzdGVwIGluZGV4OlxuXHRcdFx0bGV0IHN0ZXBOZXh0ID0gc3RlcC5uZXh0O1xuXHRcdFx0d2hpbGUgKHN0ZXBOZXh0ICYmIHN0ZXBOZXh0LnQgPD0gdCkgeyBzdGVwID0gc3RlcC5uZXh0OyBzdGVwTmV4dCA9IHN0ZXAubmV4dDsgfVxuXHRcdFx0bGV0IHJhdGlvID0gZW5kID8gZCA9PT0gMCA/IDEgOiB0L2QgOiAodC1zdGVwLnQpL3N0ZXAuZDsgLy8gVE9ETzogcmV2aXNpdCB0aGlzLlxuXHRcdFx0dGhpcy5fdXBkYXRlVGFyZ2V0UHJvcHMoc3RlcCwgcmF0aW8sIGVuZCk7XG5cdFx0fVxuXHRcdHRoaXMuX3N0ZXBQb3NpdGlvbiA9IHN0ZXAgPyB0IC0gc3RlcC50IDogMDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gc3RlcFxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmF0aW9cblx0ICogQHBhcmFtIHtCb29sZWFufSBlbmQgSW5kaWNhdGVzIHRvIHBsdWdpbnMgdGhhdCB0aGUgZnVsbCB0d2VlbiBoYXMgZW5kZWQuXG5cdCAqL1xuXHRfdXBkYXRlVGFyZ2V0UHJvcHMgKHN0ZXAsIHJhdGlvLCBlbmQpIHtcblx0XHRpZiAodGhpcy5wYXNzaXZlID0gISFzdGVwLnBhc3NpdmUpIHsgcmV0dXJuOyB9IC8vIGRvbid0IHVwZGF0ZSBwcm9wcy5cblxuXHRcdGxldCB2LCB2MCwgdjEsIGVhc2U7XG5cdFx0bGV0IHAwID0gc3RlcC5wcmV2LnByb3BzO1xuXHRcdGxldCBwMSA9IHN0ZXAucHJvcHM7XG5cdFx0aWYgKGVhc2UgPSBzdGVwLmVhc2UpIHsgcmF0aW8gPSBlYXNlKHJhdGlvLCAwLCAxLCAxKTsgfVxuXG5cdFx0bGV0IHBsdWdpbnMgPSB0aGlzLl9wbHVnaW5zO1xuXHRcdHByb3Bsb29wIDogZm9yIChsZXQgbiBpbiBwMCkge1xuXHRcdFx0djAgPSBwMFtuXTtcblx0XHRcdHYxID0gcDFbbl07XG5cblx0XHRcdC8vIHZhbHVlcyBhcmUgZGlmZmVyZW50ICYgaXQgaXMgbnVtZXJpYyB0aGVuIGludGVycG9sYXRlOlxuXHRcdFx0aWYgKHYwICE9PSB2MSAmJiAodHlwZW9mKHYwKSA9PT0gXCJudW1iZXJcIikpIHtcblx0XHRcdFx0diA9IHYwICsgKHYxIC0gdjApICogcmF0aW87XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2ID0gcmF0aW8gPj0gMSA/IHYxIDogdjA7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChwbHVnaW5zKSB7XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gcGx1Z2lucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRsZXQgdmFsdWUgPSBwbHVnaW5zW2ldLmNoYW5nZSh0aGlzLCBzdGVwLCBuLCB2LCByYXRpbywgZW5kKTtcblx0XHRcdFx0XHRpZiAodmFsdWUgPT09IFR3ZWVuLklHTk9SRSkgeyBjb250aW51ZSBwcm9wbG9vcDsgfVxuXHRcdFx0XHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7IHYgPSB2YWx1ZTsgfVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnRhcmdldFtuXSA9IHY7XG5cdFx0fVxuXG5cdH1cblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0UG9zXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBlbmRQb3Ncblx0ICogQHBhcmFtIHtCb29sZWFufSBpbmNsdWRlU3RhcnRcblx0ICovXG5cdF9ydW5BY3Rpb25zUmFuZ2UgKHN0YXJ0UG9zLCBlbmRQb3MsIGp1bXAsIGluY2x1ZGVTdGFydCkge1xuXHRcdGxldCByZXYgPSBzdGFydFBvcyA+IGVuZFBvcztcblx0XHRsZXQgYWN0aW9uID0gcmV2ID8gdGhpcy5fYWN0aW9uVGFpbCA6IHRoaXMuX2FjdGlvbkhlYWQ7XG5cdFx0bGV0IGVQb3MgPSBlbmRQb3MsIHNQb3MgPSBzdGFydFBvcztcblx0XHRpZiAocmV2KSB7IGVQb3MgPSBzdGFydFBvczsgc1BvcyA9IGVuZFBvczsgfVxuXHRcdGxldCB0ID0gdGhpcy5wb3NpdGlvbjtcblx0XHR3aGlsZSAoYWN0aW9uKSB7XG5cdFx0XHRsZXQgcG9zID0gYWN0aW9uLnQ7XG5cdFx0XHRpZiAocG9zID09PSBlbmRQb3MgfHwgKHBvcyA+IHNQb3MgJiYgcG9zIDwgZVBvcykgfHwgKGluY2x1ZGVTdGFydCAmJiBwb3MgPT09IHN0YXJ0UG9zKSkge1xuXHRcdFx0XHRhY3Rpb24uZnVuY3QuYXBwbHkoYWN0aW9uLnNjb3BlLCBhY3Rpb24ucGFyYW1zKTtcblx0XHRcdFx0aWYgKHQgIT09IHRoaXMucG9zaXRpb24pIHsgcmV0dXJuIHRydWU7IH1cblx0XHRcdH1cblx0XHRcdGFjdGlvbiA9IHJldiA/IGFjdGlvbi5wcmV2IDogYWN0aW9uLm5leHQ7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wc1xuXHQgKi9cblx0X2FwcGVuZFByb3BzIChwcm9wcywgc3RlcCwgc3RlcFBsdWdpbnMpIHtcblx0XHRsZXQgaW5pdFByb3BzID0gdGhpcy5fc3RlcEhlYWQucHJvcHMsIHRhcmdldCA9IHRoaXMudGFyZ2V0LCBwbHVnaW5zID0gVHdlZW4uX3BsdWdpbnM7XG5cdFx0bGV0IG4sIGksIGwsIHZhbHVlLCBpbml0VmFsdWUsIGluamVjdDtcblxuXHRcdGxldCBvbGRTdGVwID0gc3RlcC5wcmV2LCBvbGRQcm9wcyA9IG9sZFN0ZXAucHJvcHM7XG5cdFx0bGV0IHN0ZXBQcm9wcyA9IHN0ZXAucHJvcHMgfHwgKHN0ZXAucHJvcHMgPSB0aGlzLl9jbG9uZVByb3BzKG9sZFByb3BzKSk7XG5cdFx0bGV0IGNsZWFuUHJvcHMgPSB7fTtcblxuXHRcdGZvciAobiBpbiBwcm9wcykge1xuXHRcdFx0aWYgKCFwcm9wcy5oYXNPd25Qcm9wZXJ0eShuKSkgeyBjb250aW51ZTsgfVxuXHRcdFx0Y2xlYW5Qcm9wc1tuXSA9IHN0ZXBQcm9wc1tuXSA9IHByb3BzW25dO1xuXG5cdFx0XHRpZiAoaW5pdFByb3BzW25dICE9PSB1bmRlZmluZWQpIHsgY29udGludWU7IH1cblxuXHRcdFx0aW5pdFZhbHVlID0gdW5kZWZpbmVkOyAvLyBhY2Nlc3NpbmcgbWlzc2luZyBwcm9wZXJ0aWVzIG9uIERPTUVsZW1lbnRzIHdoZW4gdXNpbmcgQ1NTUGx1Z2luIGlzIElOU0FORUxZIGV4cGVuc2l2ZSwgc28gd2UgbGV0IHRoZSBwbHVnaW4gdGFrZSBhIGZpcnN0IHN3aW5nIGF0IGl0LlxuXHRcdFx0aWYgKHBsdWdpbnMpIHtcbiAgICAgICAgZm9yIChpID0gcGx1Z2lucy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRcdHZhbHVlID0gcGx1Z2luc1tpXS5pbml0KHRoaXMsIG4sIGluaXRWYWx1ZSk7XG5cdFx0XHRcdFx0aWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHsgaW5pdFZhbHVlID0gdmFsdWU7IH1cblx0XHRcdFx0XHRpZiAoaW5pdFZhbHVlID09PSBUd2Vlbi5JR05PUkUpIHtcblx0XHRcdFx0XHRcdChpZ25vcmVkID0gaWdub3JlZCB8fCB7fSlbbl0gPSB0cnVlO1xuXHRcdFx0XHRcdFx0ZGVsZXRlKHN0ZXBQcm9wc1tuXSk7XG5cdFx0XHRcdFx0XHRkZWxldGUoY2xlYW5Qcm9wc1tuXSk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKGluaXRWYWx1ZSAhPT0gVHdlZW4uSUdOT1JFKSB7XG5cdFx0XHRcdGlmIChpbml0VmFsdWUgPT09IHVuZGVmaW5lZCkgeyBpbml0VmFsdWUgPSB0YXJnZXRbbl07IH1cblx0XHRcdFx0b2xkUHJvcHNbbl0gPSAoaW5pdFZhbHVlID09PSB1bmRlZmluZWQpID8gbnVsbCA6IGluaXRWYWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKG4gaW4gY2xlYW5Qcm9wcykge1xuXHRcdFx0dmFsdWUgPSBwcm9wc1tuXTtcblxuXHRcdFx0Ly8gcHJvcGFnYXRlIG9sZCB2YWx1ZSB0byBwcmV2aW91cyBzdGVwczpcblx0XHRcdGxldCBvLCBwcmV2ID0gb2xkU3RlcDtcblx0XHRcdHdoaWxlICgobyA9IHByZXYpICYmIChwcmV2ID0gby5wcmV2KSkge1xuXHRcdFx0XHRpZiAocHJldi5wcm9wcyA9PT0gby5wcm9wcykgeyBjb250aW51ZTsgfSAvLyB3YWl0IHN0ZXBcblx0XHRcdFx0aWYgKHByZXYucHJvcHNbbl0gIT09IHVuZGVmaW5lZCkgeyBicmVhazsgfSAvLyBhbHJlYWR5IGhhcyBhIHZhbHVlLCB3ZSdyZSBkb25lLlxuXHRcdFx0XHRwcmV2LnByb3BzW25dID0gb2xkUHJvcHNbbl07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHN0ZXBQbHVnaW5zICYmIChwbHVnaW5zID0gdGhpcy5fcGx1Z2lucykpIHtcbiAgICAgIGZvciAoaSA9IHBsdWdpbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0cGx1Z2luc1tpXS5zdGVwKHRoaXMsIHN0ZXAsIGNsZWFuUHJvcHMpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChpbmplY3QgPSB0aGlzLl9pbmplY3RlZCkge1xuXHRcdFx0dGhpcy5faW5qZWN0ZWQgPSBudWxsO1xuXHRcdFx0dGhpcy5fYXBwZW5kUHJvcHMoaW5qZWN0LCBzdGVwLCBmYWxzZSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFVzZWQgYnkgcGx1Z2lucyB0byBpbmplY3QgcHJvcGVydGllcyBvbnRvIHRoZSBjdXJyZW50IHN0ZXAuIENhbGxlZCBmcm9tIHdpdGhpbiBgUGx1Z2luLnN0ZXBgIGNhbGxzLlxuXHQgKiBGb3IgZXhhbXBsZSwgYSBwbHVnaW4gZGVhbGluZyB3aXRoIGNvbG9yLCBjb3VsZCByZWFkIGEgaGV4IGNvbG9yLCBhbmQgaW5qZWN0IHJlZCwgZ3JlZW4sIGFuZCBibHVlIHByb3BzIGludG8gdGhlIHR3ZWVuLlxuXHQgKiBTZWUgdGhlIFNhbXBsZVBsdWdpbiBmb3IgbW9yZSBpbmZvLlxuXHQgKiBAc2VlIHR3ZWVuanMuU2FtcGxlUGx1Z2luXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuXHQgKi9cblx0X2luamVjdFByb3AgKG5hbWUsIHZhbHVlKSB7XG5cdFx0bGV0IG8gPSB0aGlzLl9pbmplY3RlZCB8fCAodGhpcy5faW5qZWN0ZWQgPSB7fSk7XG5cdFx0b1tuYW1lXSA9IHZhbHVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkdXJhdGlvblxuXHQgKiBAcGFyYW0ge09iamVjdH0gcHJvcHNcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZWFzZVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtwYXNzaXZlPWZhbHNlXVxuXHQgKi9cblx0X2FkZFN0ZXAgKGR1cmF0aW9uLCBwcm9wcywgZWFzZSwgcGFzc2l2ZSA9IGZhbHNlKSB7XG5cdFx0bGV0IHN0ZXAgPSBuZXcgVHdlZW5TdGVwKHRoaXMuX3N0ZXBUYWlsLCB0aGlzLmR1cmF0aW9uLCBkdXJhdGlvbiwgcHJvcHMsIGVhc2UsIHBhc3NpdmUpO1xuXHRcdHRoaXMuZHVyYXRpb24gKz0gZHVyYXRpb247XG5cdFx0cmV0dXJuIHRoaXMuX3N0ZXBUYWlsID0gKHRoaXMuX3N0ZXBUYWlsLm5leHQgPSBzdGVwKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gc2NvcGVcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuY3Rcblx0ICogQHBhcmFtIHtBcnJheX0gcGFyYW1zXG5cdCAqL1xuXHRfYWRkQWN0aW9uIChzY29wZSwgZnVuY3QsIHBhcmFtcykge1xuXHRcdGxldCBhY3Rpb24gPSBuZXcgVHdlZW5BY3Rpb24odGhpcy5fYWN0aW9uVGFpbCwgdGhpcy5kdXJhdGlvbiwgc2NvcGUsIGZ1bmN0LCBwYXJhbXMpO1xuXHRcdGlmICh0aGlzLl9hY3Rpb25UYWlsKSB7IHRoaXMuX2FjdGlvblRhaWwubmV4dCA9IGFjdGlvbjsgfVxuXHRcdGVsc2UgeyB0aGlzLl9hY3Rpb25IZWFkID0gYWN0aW9uOyB9XG5cdFx0dGhpcy5fYWN0aW9uVGFpbCA9IGFjdGlvbjtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gcHJvcHNcblx0ICovXG5cdF9zZXQgKHByb3BzKSB7XG5cdFx0Zm9yIChsZXQgbiBpbiBwcm9wcykge1xuXHRcdFx0dGhpc1tuXSA9IHByb3BzW25dO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gcHJvcHNcblx0ICovXG5cdF9jbG9uZVByb3BzIChwcm9wcykge1xuXHRcdGxldCBvID0ge307XG5cdFx0Zm9yIChsZXQgbiBpbiBwcm9wcykgeyBvW25dID0gcHJvcHNbbl07IH1cblx0XHRyZXR1cm4gbztcblx0fVxuXG59XG5cbi8vIHRpbnkgYXBpIChwcmltYXJpbHkgZm9yIHRvb2wgb3V0cHV0KTpcbntcblx0bGV0IHAgPSBUd2Vlbi5wcm90b3R5cGU7XG5cdHAudyA9IHAud2FpdDtcblx0cC50ID0gcC50bztcblx0cC5jID0gcC5jYWxsO1xuXHRwLnMgPSBwLnNldDtcbn1cblxuLy8gc3RhdGljIHByb3BlcnRpZXNcbi8qKlxuICogQ29uc3RhbnQgcmV0dXJuZWQgYnkgcGx1Z2lucyB0byB0ZWxsIHRoZSB0d2VlbiBub3QgdG8gdXNlIGRlZmF1bHQgYXNzaWdubWVudC5cbiAqIEBwcm9wZXJ0eSBJR05PUkVcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAc3RhdGljXG4gKi9cblR3ZWVuLklHTk9SRSA9IHt9O1xuXG4vKipcbiAqIEBwcm9wZXJ0eSBfbGlzdGVuZXJzXG4gKiBAdHlwZSB7VHdlZW5bXX1cbiAqIEBzdGF0aWNcbiAqIEBwcml2YXRlXG4gKi9cblR3ZWVuLl90d2VlbnMgPSBbXTtcblxuLyoqXG4gKiBAcHJvcGVydHkgX3BsdWdpbnNcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAc3RhdGljXG4gKiBAcHJpdmF0ZVxuICovXG5Ud2Vlbi5fcGx1Z2lucyA9IG51bGw7XG5cbi8qKlxuICogQHByb3BlcnR5IF90d2VlbkhlYWRcbiAqIEB0eXBlIHtUd2Vlbn1cbiAqIEBzdGF0aWNcbiAqIEBwcml2YXRlXG4gKi9cblR3ZWVuLl90d2VlbkhlYWQgPSBudWxsO1xuXG4vKipcbiAqIEBwcm9wZXJ0eSBfdHdlZW5UYWlsXG4gKiBAdHlwZSB7VHdlZW59XG4gKiBAc3RhdGljXG4gKiBAcHJpdmF0ZVxuICovXG5Ud2Vlbi5fdHdlZW5UYWlsID0gbnVsbDtcblxuLy8gaGVscGVyczpcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSBwcmV2XG4gKiBAcGFyYW0geyp9IHRcbiAqIEBwYXJhbSB7Kn0gZFxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQHBhcmFtIHsqfSBlYXNlXG4gKiBAcGFyYW0geyp9IHBhc3NpdmVcbiAqL1xuY2xhc3MgVHdlZW5TdGVwIHtcblxuXHRjb25zdHJ1Y3RvciAocHJldiwgdCwgZCwgcHJvcHMsIGVhc2UsIHBhc3NpdmUpIHtcblx0XHR0aGlzLm5leHQgPSBudWxsO1xuXHRcdHRoaXMucHJldiA9IHByZXY7XG5cdFx0dGhpcy50ID0gdDtcblx0XHR0aGlzLmQgPSBkO1xuXHRcdHRoaXMucHJvcHMgPSBwcm9wcztcblx0XHR0aGlzLmVhc2UgPSBlYXNlO1xuXHRcdHRoaXMucGFzc2l2ZSA9IHBhc3NpdmU7XG5cdFx0dGhpcy5pbmRleCA9IHByZXYgPyBwcmV2LmluZGV4ICsgMSA6IDA7XG5cdH1cblxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHByZXZcbiAqIEBwYXJhbSB7Kn0gdFxuICogQHBhcmFtIHsqfSBzY29wZVxuICogQHBhcmFtIHsqfSBmdW5jdFxuICogQHBhcmFtIHsqfSBwYXJhbXNcbiAqL1xuY2xhc3MgVHdlZW5BY3Rpb24ge1xuXG5cdGNvbnN0cnVjdG9yIChwcmV2LCB0LCBzY29wZSwgZnVuY3QsIHBhcmFtcykge1xuXHRcdHRoaXMubmV4dCA9IG51bGw7XG5cdFx0dGhpcy5kID0gMDtcblx0XHR0aGlzLnByZXYgPSBwcmV2O1xuXHRcdHRoaXMudCA9IHQ7XG5cdFx0dGhpcy5zY29wZSA9IHNjb3BlO1xuXHRcdHRoaXMuZnVuY3QgPSBmdW5jdDtcblx0XHR0aGlzLnBhcmFtcyA9IHBhcmFtcztcblx0fVxuXG59XG4iLCIvKipcbiAqIEBsaWNlbnNlIFRpbWVsaW5lXG4gKiBWaXNpdCBodHRwOi8vY3JlYXRlanMuY29tLyBmb3IgZG9jdW1lbnRhdGlvbiwgdXBkYXRlcyBhbmQgZXhhbXBsZXMuXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwIGdza2lubmVyLmNvbSwgaW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gKiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxuICogZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0XG4gKiByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSxcbiAqIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiAqIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXG4gKiBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gKiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICogRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTXG4gKiBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICogTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcbiAqIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLFxuICogV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4gKiBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SXG4gKiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gKi9cblxuaW1wb3J0IEFic3RyYWN0VHdlZW4gZnJvbSBcIi4vQWJzdHJhY3RUd2VlblwiO1xuXG4vKipcbiAqIFRoZSBUaW1lbGluZSBjbGFzcyBzeW5jaHJvbml6ZXMgbXVsdGlwbGUgdHdlZW5zIGFuZCBhbGxvd3MgdGhlbSB0byBiZSBjb250cm9sbGVkIGFzIGEgZ3JvdXAuIFBsZWFzZSBub3RlIHRoYXQgaWYgYVxuICogdGltZWxpbmUgaXMgbG9vcGluZywgdGhlIHR3ZWVucyBvbiBpdCBtYXkgYXBwZWFyIHRvIGxvb3AgZXZlbiBpZiB0aGUgXCJsb29wXCIgcHJvcGVydHkgb2YgdGhlIHR3ZWVuIGlzIGZhbHNlLlxuICpcbiAqIE5PVEU6IFRpbWVsaW5lIGN1cnJlbnRseSBhbHNvIGFjY2VwdHMgYSBwYXJhbSBsaXN0IGluIHRoZSBmb3JtOiBgdHdlZW5zLCBsYWJlbHMsIHByb3BzYC4gVGhpcyBpcyBmb3IgYmFja3dhcmRzXG4gKiBjb21wYXRpYmlsaXR5IG9ubHkgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgZnV0dXJlLiBJbmNsdWRlIHR3ZWVucyBhbmQgbGFiZWxzIGFzIHByb3BlcnRpZXMgb24gdGhlIHByb3BzIG9iamVjdC5cbiAqXG4gKiBAbWVtYmVyb2YgdHdlZW5qc1xuICogQGV4dGVuZHMgdHdlZW5qcy5BYnN0cmFjdFR3ZWVuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wc10gVGhlIGNvbmZpZ3VyYXRpb24gcHJvcGVydGllcyB0byBhcHBseSB0byB0aGlzIGluc3RhbmNlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtwcm9wcy51c2VUaWNrcz1mYWxzZV0gU2VlIHRoZSB7QGxpbmsgdHdlZW5qcy5BYnN0cmFjdFR3ZWVuI3VzZVRpY2tzfSBwcm9wZXJ0eSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3Byb3BzLmlnbm9yZUdsb2JhbFBhdXNlPWZhbHNlXSBTZWUgdGhlIHtAbGluayB0d2VlbmpzLkFic3RyYWN0VHdlZW4jaWdub3JlR2xvYmFsUGF1c2V9IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICogQHBhcmFtIHtOdW1iZXJ8Qm9vbGVhbn0gW3Byb3BzLmxvb3A9MF0gU2VlIHRoZSB7QGxpbmsgdHdlZW5qcy5BYnN0cmFjdFR3ZWVuI2xvb3B9IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICogQHBhcmFtIHtCb29sZWFufSBbcHJvcHMucmV2ZXJzZWQ9ZmFsc2VdIFNlZSB0aGUge0BsaW5rIHR3ZWVuanMuQWJzdHJhY3RUd2VlbiNyZXZlcnNlZH0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtwcm9wcy5ib3VuY2U9ZmFsc2VdIFNlZSB0aGUge0BsaW5rIHR3ZWVuanMuQWJzdHJhY3RUd2VlbiNib3VuY2V9IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtwcm9wcy50aW1lU2NhbGU9MV0gU2VlIHRoZSB7QGxpbmsgdHdlZW5qcy5BYnN0cmFjdFR3ZWVuI3RpbWVTY2FsZX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtwcm9wcy5wYXVzZWQ9ZmFsc2VdIFNlZSB0aGUge0BsaW5rIHR3ZWVuanMuQWJzdHJhY3RUd2VlbiNwYXVzZWR9IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtwcm9wcy5wb3NpdGlvbl0gU2VlIHRoZSB7QGxpbmsgdHdlZW5qcy5BYnN0cmFjdFR3ZWVuI3Bvc2l0aW9ufSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3Byb3BzLnR3ZWVuc11cbiAqIEBwYXJhbSB7TnVtYmVyfSBbcHJvcHMubGFiZWxzXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3Byb3BzLm9uQ2hhbmdlXSBBZGRzIHRoZSBzcGVjaWZpZWQgZnVuY3Rpb24gYXMgYSBsaXN0ZW5lciB0byB0aGUge0BsaW5rIHR3ZWVuanMuQWJzdHJhY3RUd2VlbiNldmVudDpjaGFuZ2V9IGV2ZW50LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3Byb3BzLm9uQ29tcGxldGVdIEFkZHMgdGhlIHNwZWNpZmllZCBmdW5jdGlvbiBhcyBhIGxpc3RlbmVyIHRvIHRoZSB7QGxpbmsgdHdlZW5qcy5BYnN0cmFjdFR3ZWVuI2V2ZW50OmNvbXBsZXRlfSBldmVudC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGltZWxpbmUgZXh0ZW5kcyBBYnN0cmFjdFR3ZWVuIHtcblxuXHRjb25zdHJ1Y3RvciAocHJvcHMgPSB7fSkge1xuXHRcdHN1cGVyKHByb3BzKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBhcnJheSBvZiB0d2VlbnMgaW4gdGhlIHRpbWVsaW5lLiBJdCBpcyAqc3Ryb25nbHkqIHJlY29tbWVuZGVkIHRoYXQgeW91IHVzZVxuXHRcdCAqIHtAbGluayB0d2VlbmpzLlR3ZWVuI2FkZFR3ZWVufSBhbmQge0BsaW5rIHR3ZWVuanMuVHdlZW4jcmVtb3ZlVHdlZW59LFxuXHRcdCAqIHJhdGhlciB0aGFuIGFjY2Vzc2luZyB0aGlzIGRpcmVjdGx5LCBidXQgaXQgaXMgaW5jbHVkZWQgZm9yIGFkdmFuY2VkIHVzZXMuXG5cdFx0ICogQHR5cGUge1R3ZWVuW119XG5cdFx0ICovXG5cdFx0dGhpcy50d2VlbnMgPSBbXTtcblxuXHRcdGlmIChwcm9wcy50d2VlbnMpIHsgdGhpcy5hZGRUd2VlbiguLi5wcm9wcy50d2VlbnMpOyB9XG5cdFx0aWYgKHByb3BzLmxhYmVscykgeyB0aGlzLmxhYmVscyA9IHByb3BzLmxhYmVsczsgfVxuXG5cdFx0dGhpcy5faW5pdChwcm9wcyk7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBvbmUgb3IgbW9yZSB0d2VlbnMgKG9yIHRpbWVsaW5lcykgdG8gdGhpcyB0aW1lbGluZS4gVGhlIHR3ZWVucyB3aWxsIGJlIHBhdXNlZCAodG8gcmVtb3ZlIHRoZW0gZnJvbSB0aGVcblx0ICogbm9ybWFsIHRpY2tpbmcgc3lzdGVtKSBhbmQgbWFuYWdlZCBieSB0aGlzIHRpbWVsaW5lLiBBZGRpbmcgYSB0d2VlbiB0byBtdWx0aXBsZSB0aW1lbGluZXMgd2lsbCByZXN1bHQgaW5cblx0ICogdW5leHBlY3RlZCBiZWhhdmlvdXIuXG5cdCAqXG5cdCAqIEBwYXJhbSB7VHdlZW59IC4uLnR3ZWVucyBUaGUgdHdlZW4ocykgdG8gYWRkLiBBY2NlcHRzIG11bHRpcGxlIGFyZ3VtZW50cy5cblx0ICogQHJldHVybiB7VHdlZW59IFRoZSBmaXJzdCB0d2VlbiB0aGF0IHdhcyBwYXNzZWQgaW4uXG5cdCAqL1xuXHRhZGRUd2VlbiAoLi4udHdlZW5zKSB7XG5cdFx0Y29uc3QgbCA9IHR3ZWVucy5sZW5ndGg7XG5cdFx0aWYgKGwgPT09IDEpIHtcblx0XHRcdGNvbnN0IHR3ZWVuID0gdHdlZW5zWzBdO1xuXHRcdFx0dGhpcy50d2VlbnMucHVzaCh0d2Vlbik7XG5cdFx0XHR0d2Vlbi5fcGFyZW50ID0gdGhpcztcblx0XHRcdHR3ZWVuLnBhdXNlZCA9IHRydWU7XG5cdFx0XHRsZXQgZCA9IHR3ZWVuLmR1cmF0aW9uO1xuXHRcdFx0aWYgKHR3ZWVuLmxvb3AgPiAwKSB7IGQgKj0gdHdlZW4ubG9vcCArIDE7IH1cblx0XHRcdGlmIChkID4gdGhpcy5kdXJhdGlvbikgeyB0aGlzLmR1cmF0aW9uID0gZDsgfVxuXHRcdFx0aWYgKHRoaXMucmF3UG9zaXRpb24gPj0gMCkgeyB0d2Vlbi5zZXRQb3NpdGlvbih0aGlzLnJhd1Bvc2l0aW9uKTsgfVxuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH1cblx0XHRpZiAobCA+IDEpIHtcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbDsgaSsrKSB7IHRoaXMuYWRkVHdlZW4odHdlZW5zW2ldKTsgfVxuXHRcdFx0cmV0dXJuIHR3ZWVuc1tsIC0gMV07XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgb25lIG9yIG1vcmUgdHdlZW5zIGZyb20gdGhpcyB0aW1lbGluZS5cblx0ICpcblx0ICogQHBhcmFtIHtUd2Vlbn0gLi4udHdlZW5zIFRoZSB0d2VlbihzKSB0byByZW1vdmUuIEFjY2VwdHMgbXVsdGlwbGUgYXJndW1lbnRzLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbGwgb2YgdGhlIHR3ZWVucyB3ZXJlIHN1Y2Nlc3NmdWxseSByZW1vdmVkLlxuXHQgKi9cblx0cmVtb3ZlVHdlZW4gKC4uLnR3ZWVucykge1xuXHRcdGNvbnN0IGwgPSB0d2VlbnMubGVuZ3RoO1xuXHRcdGlmIChsID09PSAxKSB7XG5cdFx0XHRjb25zdCB0dyA9IHRoaXMudHdlZW5zO1xuXHRcdFx0Y29uc3QgdHdlZW4gPSB0d2VlbnNbMF07XG5cdFx0XHRsZXQgaSA9IHR3Lmxlbmd0aDtcblx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0aWYgKHR3W2ldID09PSB0d2Vlbikge1xuXHRcdFx0XHRcdHR3LnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHR0d2Vlbi5fcGFyZW50ID0gbnVsbDtcblx0XHRcdFx0XHRpZiAodHdlZW4uZHVyYXRpb24gPj0gdGhpcy5kdXJhdGlvbikgeyB0aGlzLnVwZGF0ZUR1cmF0aW9uKCk7IH1cblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRpZiAobCA+IDEpIHtcblx0XHRcdGxldCBnb29kID0gdHJ1ZTtcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbDsgaSsrKSB7IGdvb2QgPSBnb29kICYmIHRoaXMucmVtb3ZlVHdlZW4odHdlZW5zW2ldKTsgfVxuXHRcdFx0cmV0dXJuIGdvb2Q7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlY2FsY3VsYXRlcyB0aGUgZHVyYXRpb24gb2YgdGhlIHRpbWVsaW5lLiBUaGUgZHVyYXRpb24gaXMgYXV0b21hdGljYWxseSB1cGRhdGVkIHdoZW4gdHdlZW5zIGFyZSBhZGRlZCBvciByZW1vdmVkLFxuXHQgKiBidXQgdGhpcyBtZXRob2QgaXMgdXNlZnVsIGlmIHlvdSBtb2RpZnkgYSB0d2VlbiBhZnRlciBpdCB3YXMgYWRkZWQgdG8gdGhlIHRpbWVsaW5lLlxuXHQgKi9cblx0dXBkYXRlRHVyYXRpb24gKCkge1xuXHRcdHRoaXMuZHVyYXRpb24gPSAwO1xuXHRcdGZvciAobGV0IGkgPSAwLCBsID0gdGhpcy50d2VlbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRsZXQgdHdlZW4gPSB0aGlzLnR3ZWVuc1tpXTtcblx0XHRcdGxldCBkID0gdHdlZW4uZHVyYXRpb247XG5cdFx0XHRpZiAodHdlZW4ubG9vcCA+IDApIHsgZCAqPSB0d2Vlbi5sb29wICsgMTsgfVxuXHRcdFx0aWYgKGQgPiB0aGlzLmR1cmF0aW9uKSB7IHRoaXMuZHVyYXRpb24gPSBkOyB9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEB0aHJvd3MgVGltZWxpbmUgY2Fubm90IGJlIGNsb25lZC5cblx0ICovXG5cdGNsb25lICgpIHtcblx0XHR0aHJvdyBcIlRpbWVsaW5lIGNhbiBub3QgYmUgY2xvbmVkLlwiO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfdXBkYXRlUG9zaXRpb24gKGp1bXAsIGVuZCkge1xuXHRcdGNvbnN0IHQgPSB0aGlzLnBvc2l0aW9uO1xuXHRcdGZvciAobGV0IGkgPSAwLCBsID0gdGhpcy50d2VlbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR0aGlzLnR3ZWVuc1tpXS5zZXRQb3NpdGlvbih0LCB0cnVlLCBqdW1wKTsgLy8gYWN0aW9ucyB3aWxsIHJ1biBhZnRlciBhbGwgdGhlIHR3ZWVucyB1cGRhdGUuXG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfcnVuQWN0aW9uc1JhbmdlIChzdGFydFBvcywgZW5kUG9zLCBqdW1wLCBpbmNsdWRlU3RhcnQpIHtcblx0XHQvL2NvbnNvbGUubG9nKFwiXHRyYW5nZVwiLCBzdGFydFBvcywgZW5kUG9zLCBqdW1wLCBpbmNsdWRlU3RhcnQpO1xuXHRcdGNvbnN0IHQgPSB0aGlzLnBvc2l0aW9uO1xuXHRcdGZvciAobGV0IGkgPSAwLCBsID0gdGhpcy50d2VlbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR0aGlzLnR3ZWVuc1tpXS5fcnVuQWN0aW9ucyhzdGFydFBvcywgZW5kUG9zLCBqdW1wLCBpbmNsdWRlU3RhcnQpO1xuXHRcdFx0aWYgKHQgIT09IHRoaXMucG9zaXRpb24pIHsgcmV0dXJuIHRydWU7IH0gLy8gYW4gYWN0aW9uIGNoYW5nZWQgdGhpcyB0aW1lbGluZSdzIHBvc2l0aW9uLlxuXHRcdH1cblx0fVxuXG59XG4iLCIvKipcbiAqIFJFQURNRTogRXhwb3J0IE9yZGVyXG4gKlxuICogRHVlIHRvIHNvbWUgY2xhc3NlcyBoYXZpbmcgY2lyY3VsYXIgaW1wb3J0IGJpbmRpbmdzICh3aGV0aGVyIGF0IHRoZSB0b3Agb2YgdGhlIGltcG9ydCBjaGFpbiBvciBkZWVwZXIgaW4pLFxuICogc29tZSBleHBvcnRzIGhlcmUgYXJlIGluIHJldmVyc2Ugb3JkZXIgKHN1Y2ggYXMgVHdlZW4gYmVpbmcgZXhwb3J0ZWQgYmVmb3JlIEFic3RyYWN0VHdlZW4pLlxuICogVGhpcyBpcyBleHBsYWluZWQgaGVyZTogaHR0cHM6Ly9naXRodWIuY29tL3JvbGx1cC9yb2xsdXAvaXNzdWVzLzg0NSNpc3N1ZWNvbW1lbnQtMjQwMjc3MTk0XG4gKi9cblxuLyoqXG4gKiBAbmFtZXNwYWNlIHR3ZWVuanNcbiAqL1xuXG5leHBvcnQgeyBFdmVudCwgRXZlbnREaXNwYXRjaGVyLCBUaWNrZXIgfSBmcm9tIFwiQGNyZWF0ZWpzL2NvcmVcIjtcblxuZXhwb3J0IHsgZGVmYXVsdCBhcyBUd2VlbiB9IGZyb20gXCIuL1R3ZWVuXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEFic3RyYWN0VHdlZW4gfSBmcm9tIFwiLi9BYnN0cmFjdFR3ZWVuXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFRpbWVsaW5lIH0gZnJvbSBcIi4vVGltZWxpbmVcIjtcbmltcG9ydCAqIGFzIEVhc2UgZnJvbSBcIi4vRWFzZVwiO1xuZXhwb3J0IHsgRWFzZSB9O1xuIiwiLyoqXG4gKiBAbGljZW5zZSBNb3ZpZUNsaXBcbiAqIFZpc2l0IGh0dHA6Ly9jcmVhdGVqcy5jb20vIGZvciBkb2N1bWVudGF0aW9uLCB1cGRhdGVzIGFuZCBleGFtcGxlcy5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgZ3NraW5uZXIuY29tLCBpbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAqIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXG4gKiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXRcbiAqIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxuICogY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuICogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbiAqIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAqIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gKiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcbiAqIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gKiBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuICogSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXG4gKiBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcbiAqIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5pbXBvcnQgQ29udGFpbmVyIGZyb20gXCIuL0NvbnRhaW5lclwiO1xuaW1wb3J0IERpc3BsYXlPYmplY3QgZnJvbSBcIi4vRGlzcGxheU9iamVjdFwiO1xuaW1wb3J0IHsgVHdlZW4sIFRpbWVsaW5lIH0gZnJvbSBcIkBjcmVhdGVqcy90d2VlbmpzXCI7XG5cbi8qKlxuICogVGhlIE1vdmllQ2xpcCBjbGFzcyBhc3NvY2lhdGVzIGEgVHdlZW5KUyBUaW1lbGluZSB3aXRoIGFuIEVhc2VsSlMge0BsaW5rIGVhc2VsanMuQ29udGFpbmVyfS4gSXQgYWxsb3dzXG4gKiB5b3UgdG8gY3JlYXRlIG9iamVjdHMgd2hpY2ggZW5jYXBzdWxhdGUgdGltZWxpbmUgYW5pbWF0aW9ucywgc3RhdGUgY2hhbmdlcywgYW5kIHN5bmNoZWQgYWN0aW9ucy4gRHVlIHRvIHRoZVxuICogY29tcGxleGl0aWVzIGluaGVyZW50IGluIGNvcnJlY3RseSBzZXR0aW5nIHVwIGEgTW92aWVDbGlwLCBpdCBpcyBsYXJnZWx5IGludGVuZGVkIGZvciB0b29sIG91dHB1dCBhbmQgaXMgbm90IGluY2x1ZGVkXG4gKiBpbiB0aGUgbWFpbiBFYXNlbEpTIGxpYnJhcnkuXG4gKlxuICogQ3VycmVudGx5IE1vdmllQ2xpcCBvbmx5IHdvcmtzIHByb3Blcmx5IGlmIGl0IGlzIHRpY2sgYmFzZWQgKGFzIG9wcG9zZWQgdG8gdGltZSBiYXNlZCkgdGhvdWdoIHNvbWUgY29uY2Vzc2lvbnMgaGF2ZVxuICogYmVlbiBtYWRlIHRvIHN1cHBvcnQgdGltZS1iYXNlZCB0aW1lbGluZXMgaW4gdGhlIGZ1dHVyZS5cbiAqXG4gKiBJdCBpcyByZWNvbW1lbmRlZCB0byB1c2UgYHR3ZWVuLnRvKClgIHRvIGFuaW1hdGUgYW5kIHNldCBwcm9wZXJ0aWVzICh1c2Ugbm8gZHVyYXRpb24gdG8gaGF2ZSBpdCBzZXRcbiAqIGltbWVkaWF0ZWx5KSwgYW5kIHRoZSBgdHdlZW4ud2FpdCgpYCBtZXRob2QgdG8gY3JlYXRlIGRlbGF5cyBiZXR3ZWVuIGFuaW1hdGlvbnMuIE5vdGUgdGhhdCB1c2luZyB0aGVcbiAqIGB0d2Vlbi5zZXQoKWAgbWV0aG9kIHRvIGFmZmVjdCBwcm9wZXJ0aWVzIHdpbGwgbGlrZWx5IG5vdCBwcm92aWRlIHRoZSBkZXNpcmVkIHJlc3VsdC5cbiAqXG4gKiBAbWVtYmVyb2YgZWFzZWxqc1xuICogQGV4YW1wbGUgPGNhcHRpb24+QW5pbWF0ZSB0d28gc2hhcGVzIGJhY2sgYW5kIGZvcnRoPC9jYXB0aW9uPlxuICogbGV0IHN0YWdlID0gbmV3IFN0YWdlKFwiY2FudmFzXCIpO1xuICogVGlja2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJ0aWNrXCIsIHN0YWdlKTtcbiAqXG4gKiBsZXQgbWMgPSBuZXcgTW92aWVDbGlwKG51bGwsIDAsIHRydWUsIHtzdGFydDoyMH0pO1xuICogc3RhZ2UuYWRkQ2hpbGQobWMpO1xuICpcbiAqIGxldCBjaGlsZDEgPSBuZXcgU2hhcGUoXG4gKiAgIG5ldyBHcmFwaGljcygpLmJlZ2luRmlsbChcIiM5OTk5OTlcIikuZHJhd0NpcmNsZSgzMCwzMCwzMClcbiAqICk7XG4gKiBsZXQgY2hpbGQyID0gbmV3IFNoYXBlKFxuICogICBuZXcgR3JhcGhpY3MoKS5iZWdpbkZpbGwoXCIjNWE5Y2ZiXCIpLmRyYXdDaXJjbGUoMzAsMzAsMzApXG4gKiApO1xuICpcbiAqIG1jLnRpbWVsaW5lLmFkZFR3ZWVuKFxuICogICBUd2Vlbi5nZXQoY2hpbGQxKS50byh7eDowfSkudG8oe3g6NjB9LCA1MCkudG8oe3g6MH0sIDUwKVxuICogKTtcbiAqIG1jLnRpbWVsaW5lLmFkZFR3ZWVuKFxuICogICBUd2Vlbi5nZXQoY2hpbGQyKS50byh7eDo2MH0pLnRvKHt4OjB9LCA1MCkudG8oe3g6NjB9LCA1MClcbiAqICk7XG4gKlxuICogbWMuZ290b0FuZFBsYXkoXCJzdGFydFwiKTtcbiAqXG4gKiBAZXh0ZW5kcyBlYXNlbGpzLkNvbnRhaW5lclxuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wc10gVGhlIGNvbmZpZ3VyYXRpb24gcHJvcGVydGllcyB0byBhcHBseSB0byB0aGlzIGluc3RhbmNlcy5cbiAqIFRoaXMgb2JqZWN0IHdpbGwgYWxzbyBiZSBwYXNzZWQgaW50byB0aGUgVGltZWxpbmUgaW5zdGFuY2UgYXNzb2NpYXRlZCB3aXRoIHRoaXMgTW92aWVDbGlwLlxuICogU2VlIHRoZSBkb2N1bWVudGF0aW9uIGZvciBUaW1lbGluZSBmb3IgYSBsaXN0IG9mIHN1cHBvcnRlZCBwcm9wcy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTW92aWVDbGlwIGV4dGVuZHMgQ29udGFpbmVyIHtcblxuXHRjb25zdHJ1Y3RvciAocHJvcHMpIHtcblx0XHRzdXBlcigpO1xuXHRcdCFNb3ZpZUNsaXAuaW5pdGVkICYmIE1vdmllQ2xpcC5pbml0KCk7XG5cblx0XHQvKipcblx0XHQgKiBDb250cm9scyBob3cgdGhpcyBNb3ZpZUNsaXAgYWR2YW5jZXMgaXRzIHRpbWUuIE11c3QgYmUgb25lIG9mIDAgKElOREVQRU5ERU5UKSwgMSAoU0lOR0xFX0ZSQU1FKSwgb3IgMiAoU1lOQ0hFRCkuXG5cdFx0ICogU2VlIGVhY2ggY29uc3RhbnQgZm9yIGEgZGVzY3JpcHRpb24gb2YgdGhlIGJlaGF2aW91ci5cblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKi9cblx0XHR0aGlzLm1vZGUgPSBwcm9wcy5tb2RlICE9IG51bGwgPyBwcm9wcy5tb2RlIDogTW92aWVDbGlwLklOREVQRU5ERU5UO1xuXG5cdFx0LyoqXG5cdFx0ICogU3BlY2lmaWVzIHdoYXQgdGhlIGZpcnN0IGZyYW1lIHRvIHBsYXkgaW4gdGhpcyBtb3ZpZWNsaXAsIG9yIHRoZSBvbmx5IGZyYW1lIHRvIGRpc3BsYXkgaWYgbW9kZSBpcyBTSU5HTEVfRlJBTUUuXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0dGhpcy5zdGFydFBvc2l0aW9uID0gcHJvcHMuc3RhcnRQb3NpdGlvbiAhPSBudWxsID8gcHJvcHMuc3RhcnRQb3NpdGlvbiA6IDA7XG5cblx0XHQvKipcbiAgICAgKiBTcGVjaWZpZXMgaG93IG1hbnkgdGltZXMgdGhpcyBNb3ZpZUNsaXAgc2hvdWxkIGxvb3AuIEEgdmFsdWUgb2YgLTEgaW5kaWNhdGVzIGl0IHNob3VsZCBsb29wIGluZGVmaW5pdGVseS4gQSB2YWx1ZSBvZlxuICAgICAqIDEgd291bGQgY2F1c2UgaXQgdG8gbG9vcCBvbmNlIChpZS4gcGxheSBhIHRvdGFsIG9mIHR3aWNlKS5cbiAgICAgKiBAcHJvcGVydHkgbG9vcFxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgLTFcblx0XHQgKi9cblx0XHRpZiAodHlwZW9mIHByb3BzLmxvb3AgPT09IFwibnVtYmVyXCIpIHtcblx0XHRcdHRoaXMubG9vcCA9IHByb3BzLmxvb3A7XG5cdFx0fSBlbHNlIGlmIChwcm9wcy5sb29wID09PSBmYWxzZSkge1xuXHRcdFx0dGhpcy5sb29wID0gMDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5sb29wID0gLTE7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGN1cnJlbnQgZnJhbWUgb2YgdGhlIG1vdmllY2xpcC5cblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICovXG5cdFx0dGhpcy5jdXJyZW50RnJhbWUgPSAwO1xuXG5cdFx0LyoqXG4gICAgICogVGhlIFR3ZWVuSlMgVGltZWxpbmUgdGhhdCBpcyBhc3NvY2lhdGVkIHdpdGggdGhpcyBNb3ZpZUNsaXAuIFRoaXMgaXMgY3JlYXRlZCBhdXRvbWF0aWNhbGx5IHdoZW4gdGhlIE1vdmllQ2xpcFxuICAgICAqIGluc3RhbmNlIGlzIGluaXRpYWxpemVkLiBBbmltYXRpb25zIGFyZSBjcmVhdGVkIGJ5IGFkZGluZyA8YSBocmVmPVwiaHR0cDovL3R3ZWVuanMuY29tXCI+VHdlZW5KUzwvYT4gVHdlZW5cbiAgICAgKiBpbnN0YW5jZXMgdG8gdGhlIHRpbWVsaW5lLlxuICAgICAqXG4gICAgICogRWxlbWVudHMgY2FuIGJlIGFkZGVkIGFuZCByZW1vdmVkIGZyb20gdGhlIHRpbWVsaW5lIGJ5IHRvZ2dsaW5nIGFuIFwiX29mZlwiIHByb3BlcnR5XG4gICAgICogdXNpbmcgdGhlIGB0d2Vlbkluc3RhbmNlLnRvKClgIG1ldGhvZC4gTm90ZSB0aGF0IHVzaW5nIGBUd2Vlbi5zZXRgIGlzIG5vdCByZWNvbW1lbmRlZCB0b1xuICAgICAqIGNyZWF0ZSBNb3ZpZUNsaXAgYW5pbWF0aW9ucy4gVGhlIGZvbGxvd2luZyBleGFtcGxlIHdpbGwgdG9nZ2xlIHRoZSB0YXJnZXQgb2ZmIG9uIGZyYW1lIDAsIGFuZCB0aGVuIGJhY2sgb24gZm9yXG4gICAgICogZnJhbWUgMS4gWW91IGNhbiB1c2UgdGhlIFwidmlzaWJsZVwiIHByb3BlcnR5IHRvIGFjaGlldmUgdGhlIHNhbWUgZWZmZWN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBsZXQgdHdlZW4gPSBUd2Vlbi5nZXQodGFyZ2V0KS50byh7eDowfSkudG8oe3g6MTAwfSwgMzApO1xuICAgICAqIGxldCBtYyA9IG5ldyBNb3ZpZUNsaXAoKTtcbiAgICAgKiBtYy50aW1lbGluZS5hZGRUd2Vlbih0d2Vlbik7XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIFR3ZWVuLmdldCh0YXJnZXQpLnRvKHtfb2ZmOmZhbHNlfSlcbiAgICAgKiAgIC53YWl0KDEpLnRvKHtfb2ZmOnRydWV9KVxuICAgICAqICAgLndhaXQoMSkudG8oe19vZmY6ZmFsc2V9KTtcbiAgICAgKlxuICAgICAqIEB0eXBlIHtlYXNlbGpzLlRpbWVsaW5lfVxuXHRcdCAqL1xuXHRcdHRoaXMudGltZWxpbmUgPSBuZXcgVGltZWxpbmUoT2JqZWN0LmFzc2lnbih7IHVzZVRpY2tzOiB0cnVlLCBwYXVzZWQ6IHRydWUgfSwgcHJvcHMpKTtcblxuXHRcdC8qKlxuXHRcdCAqIElmIHRydWUsIHRoZSBNb3ZpZUNsaXAncyBwb3NpdGlvbiB3aWxsIG5vdCBhZHZhbmNlIHdoZW4gdGlja2VkLlxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICovXG5cdFx0dGhpcy5wYXVzZWQgPSBwcm9wcy5wYXVzZWQgIT0gbnVsbCA/IHByb3BzLnBhdXNlZCA6IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogSWYgdHJ1ZSwgYWN0aW9ucyBpbiB0aGlzIE1vdmllQ2xpcCdzIHR3ZWVucyB3aWxsIGJlIHJ1biB3aGVuIHRoZSBwbGF5aGVhZCBhZHZhbmNlcy5cblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0dGhpcy5hY3Rpb25zRW5hYmxlZCA9IHRydWU7XG5cblx0XHQvKipcblx0XHQgKiBJZiB0cnVlLCB0aGUgTW92aWVDbGlwIHdpbGwgYXV0b21hdGljYWxseSBiZSByZXNldCB0byBpdHMgZmlyc3QgZnJhbWUgd2hlbmV2ZXIgdGhlIHRpbWVsaW5lIGFkZHNcblx0XHQgKiBpdCBiYWNrIG9udG8gdGhlIGRpc3BsYXkgbGlzdC4gVGhpcyBvbmx5IGFwcGxpZXMgdG8gTW92aWVDbGlwIGluc3RhbmNlcyB3aXRoIG1vZGU9SU5ERVBFTkRFTlQuXG5cdFx0ICogPGJyPjxicj5cblx0XHQgKiBGb3IgZXhhbXBsZSwgaWYgeW91IGhhZCBhIGNoYXJhY3RlciBhbmltYXRpb24gd2l0aCBhIFwiYm9keVwiIGNoaWxkIE1vdmllQ2xpcCBpbnN0YW5jZVxuXHRcdCAqIHdpdGggZGlmZmVyZW50IGNvc3R1bWVzIG9uIGVhY2ggZnJhbWUsIHlvdSBjb3VsZCBzZXQgYGJvZHkuYXV0b1Jlc2V0ID0gZmFsc2VgLCBzbyB0aGF0XG5cdFx0ICogeW91IGNhbiBtYW51YWxseSBjaGFuZ2UgdGhlIGZyYW1lIGl0IGlzIG9uLCB3aXRob3V0IHdvcnJ5aW5nIHRoYXQgaXQgd2lsbCBiZSByZXNldFxuXHRcdCAqIGF1dG9tYXRpY2FsbHkuXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdHRoaXMuYXV0b1Jlc2V0ID0gdHJ1ZTtcblxuXHRcdC8qKlxuXHRcdCAqIEFuIGFycmF5IG9mIGJvdW5kcyBmb3IgZWFjaCBmcmFtZSBpbiB0aGUgTW92aWVDbGlwLiBUaGlzIGlzIG1haW5seSBpbnRlbmRlZCBmb3IgdG9vbCBvdXRwdXQuXG5cdFx0ICogQHR5cGUge0FycmF5fVxuXHRcdCAqL1xuXHRcdHRoaXMuZnJhbWVCb3VuZHMgPSB0aGlzLmZyYW1lQm91bmRzIHx8IHByb3BzLmZyYW1lQm91bmRzOyAvLyBmcmFtZUJvdW5kcyBhcmUgc2V0IG9uIHRoZSBwcm90b3R5cGUgaW4gQW5pbWF0ZS5cblxuXHRcdC8qKlxuXHRcdCAqIEJ5IGRlZmF1bHQgTW92aWVDbGlwIGluc3RhbmNlcyBhZHZhbmNlIG9uZSBmcmFtZSBwZXIgdGljay4gU3BlY2lmeWluZyBhIGZyYW1lcmF0ZSBmb3IgdGhlIE1vdmllQ2xpcFxuXHRcdCAqIHdpbGwgY2F1c2UgaXQgdG8gYWR2YW5jZSBiYXNlZCBvbiBlbGFwc2VkIHRpbWUgYmV0d2VlbiB0aWNrcyBhcyBhcHByb3ByaWF0ZSB0byBtYWludGFpbiB0aGUgdGFyZ2V0XG5cdFx0ICogZnJhbWVyYXRlLlxuXHRcdCAqXG5cdFx0ICogRm9yIGV4YW1wbGUsIGlmIGEgTW92aWVDbGlwIHdpdGggYSBmcmFtZXJhdGUgb2YgMTAgaXMgcGxhY2VkIG9uIGEgU3RhZ2UgYmVpbmcgdXBkYXRlZCBhdCA0MGZwcywgdGhlbiB0aGUgTW92aWVDbGlwIHdpbGxcblx0XHQgKiBhZHZhbmNlIHJvdWdobHkgb25lIGZyYW1lIGV2ZXJ5IDQgdGlja3MuIFRoaXMgd2lsbCBub3QgYmUgZXhhY3QsIGJlY2F1c2UgdGhlIHRpbWUgYmV0d2VlbiBlYWNoIHRpY2sgd2lsbFxuXHRcdCAqIHZhcnkgc2xpZ2h0bHkgYmV0d2VlbiBmcmFtZXMuXG5cdFx0ICpcblx0XHQgKiBUaGlzIGZlYXR1cmUgaXMgZGVwZW5kZW50IG9uIHRoZSB0aWNrIGV2ZW50IG9iamVjdCAob3IgYW4gb2JqZWN0IHdpdGggYW4gYXBwcm9wcmlhdGUgXCJkZWx0YVwiIHByb3BlcnR5KSBiZWluZ1xuXHRcdCAqIHBhc3NlZCBpbnRvIHtAbGluayBlYXNlbGpzLlN0YWdlI3VwZGF0ZX0uXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5mcmFtZXJhdGUgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9zeW5jaE9mZnNldCA9IDA7XG5cblx0XHQvKipcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IC0xXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9yYXdQb3NpdGlvbiA9IC0xOyAvLyBUT0RPOiBldmFsdWF0ZSB1c2luZyBhIC5fcmVzZXQgQm9vbGVhbiBwcm9wIGluc3RlYWQgb2YgLTEuXG5cblx0XHQvKipcblx0XHQgKiBUaGUgdGltZSByZW1haW5pbmcgZnJvbSB0aGUgcHJldmlvdXMgdGljaywgb25seSBhcHBsaWNhYmxlIHdoZW4gLmZyYW1lcmF0ZSBpcyBzZXQuXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX3QgPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogTGlzdCBvZiBkaXNwbGF5IG9iamVjdHMgdGhhdCBhcmUgYWN0aXZlbHkgYmVpbmcgbWFuYWdlZCBieSB0aGUgTW92aWVDbGlwLlxuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9tYW5hZ2VkID0ge307XG5cblx0XHQvKipcblx0XHQgKiBAdHlwZSB7RnVuY3Rpb259XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9ib3VuZF9yZXNvbHZlU3RhdGUgPSB0aGlzLl9yZXNvbHZlU3RhdGUuYmluZCh0aGlzKTtcblx0fVxuXG5cdHN0YXRpYyBpbml0ICgpIHtcblx0XHRpZiAoTW92aWVDbGlwLmluaXRlZCkgeyByZXR1cm47IH1cblx0XHQvLyBwbHVnaW5zIGludHJvZHVjZSBzb21lIG92ZXJoZWFkIHRvIFR3ZWVuLCBzbyB3ZSBvbmx5IGluc3RhbGwgdGhpcyBpZiBhbiBNQyBpcyBpbnN0YW50aWF0ZWQuXG5cdFx0TW92aWVDbGlwUGx1Z2luLmluc3RhbGwoKTtcblx0XHRNb3ZpZUNsaXAuaW5pdGVkID0gdHJ1ZTtcblx0fVxuXG5cdC8vIFRPRE86IGNhbiB3ZSBqdXN0IHByb3h5IGBnZXQgY3VycmVudEZyYW1lYCB0byB0aW1lbGluZS5wb3NpdGlvbiBhcyB3ZWxsPyBEaXR0byBmb3IgYGdldCBsb29wYCAob3IganVzdCByZW1vdmUgZW50aXJlbHkpLlxuXHQvL1xuXHQvKipcblx0ICogUmV0dXJucyBhbiBhcnJheSBvZiBvYmplY3RzIHdpdGggbGFiZWwgYW5kIHBvc2l0aW9uIChha2EgZnJhbWUpIHByb3BlcnRpZXMsIHNvcnRlZCBieSBwb3NpdGlvbi5cblx0ICogQHNlZSB7QGxpbmsgdHdlZW5qcy5UaW1lbGluZSNsYWJlbHN9XG5cdCAqIEB0eXBlIHtBcnJheX1cblx0ICogQHJlYWRvbmx5XG5cdCAqL1xuXHRnZXQgbGFiZWxzICgpIHtcblx0XHRyZXR1cm4gdGhpcy50aW1lbGluZS5sYWJlbHM7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbmFtZSBvZiB0aGUgbGFiZWwgb24gb3IgaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBjdXJyZW50IGZyYW1lLlxuXHQgKiBAc2VlIHtAbGluayB0d2VlbmpzLlRpbWVsaW5lI2N1cnJlbnRMYWJlbH1cblx0ICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEByZWFkb25seVxuXHQgKi9cblx0Z2V0IGN1cnJlbnRMYWJlbCAoKSB7XG5cdFx0cmV0dXJuIHRoaXMudGltZWxpbmUuY3VycmVudExhYmVsO1xuXHR9XG5cblx0IC8qKlxuIFx0ICogUmV0dXJucyB0aGUgZHVyYXRpb24gb2YgdGhpcyBNb3ZpZUNsaXAgaW4gc2Vjb25kcyBvciB0aWNrcy5cbiBcdCAqIEBzZWUge0BsaW5rIHR3ZWVuanMuVGltZWxpbmUjZHVyYXRpb259XG4gXHQgKiBAdHlwZSB7TnVtYmVyfVxuIFx0ICogQHJlYWRvbmx5XG4gXHQgKi9cbiBcdGdldCBkdXJhdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMudGltZWxpbmUuZHVyYXRpb247XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgZHVyYXRpb24gb2YgdGhpcyBNb3ZpZUNsaXAgaW4gc2Vjb25kcyBvciB0aWNrcy4gSWRlbnRpY2FsIHRvIHtAbGluayBlYXNlbGpzLk1vdmllQ2xpcCNkdXJhdGlvbn1cblx0ICogYW5kIHByb3ZpZGVkIGZvciBBZG9iZSBGbGFzaC9BbmltYXRlIEFQSSBjb21wYXRpYmlsaXR5LlxuXHQgKiBAc2VlIHtAbGluayB0d2VlbmpzLlRpbWVsaW5lI2R1cmF0aW9ufVxuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAcmVhZG9ubHlcblx0ICovXG5cdGdldCB0b3RhbEZyYW1lcyAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuZHVyYXRpb247XG5cdH1cblxuXHRpc1Zpc2libGUgKCkge1xuXHRcdC8vIGNoaWxkcmVuIGFyZSBwbGFjZWQgaW4gZHJhdywgc28gd2UgY2FuJ3QgZGV0ZXJtaW5lIGlmIHdlIGhhdmUgY29udGVudC5cblx0XHRyZXR1cm4gISEodGhpcy52aXNpYmxlICYmIHRoaXMuYWxwaGEgPiAwICYmIHRoaXMuc2NhbGVYICE9IDAgJiYgdGhpcy5zY2FsZVkgIT0gMCk7XG5cdH1cblxuXHRkcmF3IChjdHgsIGlnbm9yZUNhY2hlKSB7XG5cdFx0Ly8gZHJhdyB0byBjYWNoZSBmaXJzdDpcblx0XHRpZiAodGhpcy5kcmF3Q2FjaGUoY3R4LCBpZ25vcmVDYWNoZSkpIHsgcmV0dXJuIHRydWU7IH1cbiAgICB0aGlzLl91cGRhdGVTdGF0ZSgpO1xuXHRcdHN1cGVyLmRyYXcoY3R4LCBpZ25vcmVDYWNoZSk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyBwYXVzZWQgdG8gZmFsc2UuXG5cdCAqL1xuXHRwbGF5ICgpIHtcblx0XHR0aGlzLnBhdXNlZCA9IGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgcGF1c2VkIHRvIHRydWUuXG5cdCAqL1xuXHRzdG9wICgpIHtcblx0XHR0aGlzLnBhdXNlZCA9IHRydWU7XG5cdH1cblxuXHQvKipcblx0ICogQWR2YW5jZXMgdGhpcyBtb3ZpZSBjbGlwIHRvIHRoZSBzcGVjaWZpZWQgcG9zaXRpb24gb3IgbGFiZWwgYW5kIHBsYXlzIHRoZSB0aW1lbGluZS5cblx0ICogQHBhcmFtIHtTdHJpbmcgfCBOdW1iZXJ9IHBvc2l0aW9uT3JMYWJlbCBUaGUgYW5pbWF0aW9uIG5hbWUgb3IgZnJhbWUgbnVtYmVyIHRvIGdvIHRvLlxuXHQgKi9cblx0Z290b0FuZFBsYXkgKHBvc2l0aW9uT3JMYWJlbCkge1xuXHRcdHRoaXMucGxheSgpO1xuXHRcdHRoaXMuX2dvdG8ocG9zaXRpb25PckxhYmVsKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZHZhbmNlcyB0aGlzIG1vdmllIGNsaXAgdG8gdGhlIHNwZWNpZmllZCBwb3NpdGlvbiBvciBsYWJlbCBhbmQgc3RvcHMgdGhlIHRpbWVsaW5lLlxuXHQgKiBAcGFyYW0ge1N0cmluZyB8IE51bWJlcn0gcG9zaXRpb25PckxhYmVsIFRoZSBhbmltYXRpb24gb3IgZnJhbWUgbmFtZSB0byBnbyB0by5cblx0ICovXG5cdGdvdG9BbmRTdG9wIChwb3NpdGlvbk9yTGFiZWwpIHtcblx0XHR0aGlzLnN0b3AoKTtcblx0XHR0aGlzLl9nb3RvKHBvc2l0aW9uT3JMYWJlbCk7XG5cdH1cblxuXHQvKipcblx0ICogQWR2YW5jZXMgdGhlIHBsYXloZWFkLiBUaGlzIG9jY3VycyBhdXRvbWF0aWNhbGx5IGVhY2ggdGljayBieSBkZWZhdWx0LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3RpbWVdIFRoZSBhbW91bnQgb2YgdGltZSBpbiBtcyB0byBhZHZhbmNlIGJ5LiBPbmx5IGFwcGxpY2FibGUgaWYgZnJhbWVyYXRlIGlzIHNldC5cblx0Ki9cblx0YWR2YW5jZSAodGltZSkge1xuXHRcdGlmICh0aGlzLm1vZGUgIT09IE1vdmllQ2xpcC5JTkRFUEVOREVOVCkgeyByZXR1cm47IH0gLy8gdXBkYXRlIGhhcHBlbnMgaW4gZHJhdyBmb3Igc3luY2hlZCBjbGlwc1xuXHRcdC8vIGlmIHRoaXMgTUMgZG9lc24ndCBoYXZlIGEgZnJhbWVyYXRlLCBodW50IGFuY2VzdG9ycyBmb3Igb25lOlxuXHRcdGxldCBvID0gdGhpcywgZnBzID0gby5mcmFtZXJhdGU7XG5cdFx0d2hpbGUgKChvID0gby5wYXJlbnQpICYmIGZwcyA9PT0gbnVsbCkge1xuXHRcdFx0aWYgKG8ubW9kZSA9PT0gTW92aWVDbGlwLklOREVQRU5ERU5UKSB7IGZwcyA9IG8uX2ZyYW1lcmF0ZTsgfVxuXHRcdH1cblx0XHR0aGlzLl9mcmFtZXJhdGUgPSBmcHM7XG5cblx0XHRpZiAodGhpcy5wYXVzZWQpIHsgcmV0dXJuOyB9XG5cdFx0Ly8gY2FsY3VsYXRlIGhvdyBtYW55IGZyYW1lcyB0byBhZHZhbmNlOlxuXHRcdGxldCB0ID0gKGZwcyAhPT0gbnVsbCAmJiBmcHMgIT09IC0xICYmIHRpbWUgIT09IG51bGwpID8gdGltZSAvICgxMDAwIC8gZnBzKSArIHRoaXMuX3QgOiAxO1xuXHRcdGxldCBmcmFtZXMgPSB0IHwgMDtcblx0XHR0aGlzLl90ID0gdCAtIGZyYW1lczsgLy8gbGVmdG92ZXIgdGltZSwgc2F2ZSB0byBhZGQgdG8gbmV4dCBhZHZhbmNlLlxuXG5cdFx0d2hpbGUgKGZyYW1lcy0tKSB7XG5cdFx0XHR0aGlzLl91cGRhdGVUaW1lbGluZSh0aGlzLl9yYXdQb3NpdGlvbiArIDEsIGZhbHNlKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogTW92aWVDbGlwIGluc3RhbmNlcyBjYW5ub3QgYmUgY2xvbmVkLlxuXHQgKiBAdGhyb3dzIE1vdmllQ2xpcCBjYW5ub3QgYmUgY2xvbmVkLlxuXHQgKi9cblx0Y2xvbmUgKCkge1xuXHRcdC8vIFRPRE86IGFkZCBzdXBwb3J0IGZvciB0aGlzPyBOZWVkIHRvIGNsb25lIHRoZSBUaW1lbGluZSAmIHJldGFyZ2V0IHR3ZWVucyAtIHByZXR0eSBjb21wbGV4LlxuXHRcdHRocm93IFwiTW92aWVDbGlwIGNhbm5vdCBiZSBjbG9uZWQuXCI7XG5cdH1cblxuXHRfdXBkYXRlU3RhdGUgKCkge1xuXHRcdGlmICh0aGlzLl9yYXdQb3NpdGlvbiA9PT0gLTEgfHwgdGhpcy5tb2RlICE9PSBNb3ZpZUNsaXAuSU5ERVBFTkRFTlQpIHsgdGhpcy5fdXBkYXRlVGltZWxpbmUoLTEpOyB9XG5cdH1cblxuXHRfdGljayAoZXZ0T2JqKSB7XG5cdFx0dGhpcy5hZHZhbmNlKGV2dE9iaiAmJiBldnRPYmouZGVsdGEpO1xuXHRcdHN1cGVyLl90aWNrKGV2dE9iaik7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtTdHJpbmcgfCBOdW1iZXJ9IHBvc2l0aW9uT3JMYWJlbCBUaGUgYW5pbWF0aW9uIG5hbWUgb3IgZnJhbWUgbnVtYmVyIHRvIGdvIHRvLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRfZ290byAocG9zaXRpb25PckxhYmVsKSB7XG5cdFx0bGV0IHBvcyA9IHRoaXMudGltZWxpbmUucmVzb2x2ZShwb3NpdGlvbk9yTGFiZWwpO1xuXHRcdGlmIChwb3MgPT0gbnVsbCkgeyByZXR1cm47IH1cblx0XHR0aGlzLl90ID0gMDtcblx0XHR0aGlzLl91cGRhdGVUaW1lbGluZShwb3MsIHRydWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfcmVzZXQgKCkge1xuXHRcdHRoaXMuX3Jhd1Bvc2l0aW9uID0gLTE7XG5cdFx0dGhpcy5fdCA9IHRoaXMuY3VycmVudEZyYW1lID0gMDtcblx0XHR0aGlzLnBhdXNlZCA9IGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYXdQb3NpdGlvblxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGp1bXAgSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyB1cGRhdGUgaXMgZHVlIHRvIGp1bXBpbmcgKHZpYSBnb3RvQW5kWFgpIHRvIGEgbmV3IHBvc2l0aW9uLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRfdXBkYXRlVGltZWxpbmUgKHJhd1Bvc2l0aW9uLCBqdW1wKSB7XG5cdFx0bGV0IHN5bmNlZCA9IHRoaXMubW9kZSAhPT0gTW92aWVDbGlwLklOREVQRU5ERU5ULCB0bCA9IHRoaXMudGltZWxpbmU7XG5cdFx0aWYgKHN5bmNlZCkgeyByYXdQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbiArICh0aGlzLm1vZGUgPT09IE1vdmllQ2xpcC5TSU5HTEVfRlJBTUUgPyAwIDogdGhpcy5fc3luY2hPZmZzZXQpOyB9XG5cdFx0aWYgKHJhd1Bvc2l0aW9uIDwgMSkgeyByYXdQb3NpdGlvbiA9IDA7IH1cblx0XHRpZiAodGhpcy5fcmF3UG9zaXRpb24gPT09IHJhd1Bvc2l0aW9uICYmICFzeW5jZWQpIHsgcmV0dXJuOyB9XG5cdFx0dGhpcy5fcmF3UG9zaXRpb24gPSByYXdQb3NpdGlvbjtcblxuXHRcdC8vIHVwZGF0ZSB0aW1lbGluZSBwb3NpdGlvbiwgaWdub3JpbmcgYWN0aW9ucyBpZiB0aGlzIGlzIGEgZ3JhcGhpYy5cblx0XHR0bC5sb29wID0gdGhpcy5sb29wOyAvLyBUT0RPOiBzaG91bGQgd2UgbWFpbnRhaW4gdGhpcyBvbiBNb3ZpZUNsaXAsIG9yIGp1c3QgaGF2ZSBpdCBvbiB0aW1lbGluZT9cblx0XHR0bC5zZXRQb3NpdGlvbihyYXdQb3NpdGlvbiwgc3luY2VkIHx8ICF0aGlzLmFjdGlvbnNFbmFibGVkLCBqdW1wLCB0aGlzLl9ib3VuZF9yZXNvbHZlU3RhdGUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlbmRlcnMgcG9zaXRpb24gMCB3aXRob3V0IHJ1bm5pbmcgYWN0aW9ucyBvciB1cGRhdGluZyBfcmF3UG9zaXRpb24uXG5cdCAqIFByaW1hcmlseSB1c2VkIGJ5IEFuaW1hdGUgQ0MgdG8gYnVpbGQgb3V0IHRoZSBmaXJzdCBmcmFtZSBpbiB0aGUgY29uc3RydWN0b3Igb2YgTUMgc3ltYm9scy5cblx0ICogTk9URTogbm90IHRlc3RlZCB3aGVuIHJ1biBhZnRlciB0aGUgTUMgYWR2YW5jZXMgcGFzdCB0aGUgZmlyc3QgZnJhbWUuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdF9yZW5kZXJGaXJzdEZyYW1lICgpIHtcblx0XHRjb25zdCB0bCA9IHRoaXMudGltZWxpbmUsIHBvcyA9IHRsLnJhd1Bvc2l0aW9uO1xuXHRcdHRsLnNldFBvc2l0aW9uKDAsIHRydWUsIHRydWUsIHRoaXMuX2JvdW5kX3Jlc29sdmVTdGF0ZSk7XG5cdFx0dGwucmF3UG9zaXRpb24gPSBwb3M7XG5cdH1cblxuXHQvKipcblx0ICogUnVucyB2aWEgYSBjYWxsYmFjayBhZnRlciB0aW1lbGluZSBwcm9wZXJ0eSB1cGRhdGVzIGFuZCBiZWZvcmUgYWN0aW9ucy5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0X3Jlc29sdmVTdGF0ZSAoKSB7XG5cdFx0bGV0IHRsID0gdGhpcy50aW1lbGluZTtcblx0XHR0aGlzLmN1cnJlbnRGcmFtZSA9IHRsLnBvc2l0aW9uO1xuXG5cdFx0Zm9yIChsZXQgbiBpbiB0aGlzLl9tYW5hZ2VkKSB7IHRoaXMuX21hbmFnZWRbbl0gPSAxOyB9XG5cblx0XHRsZXQgdHdlZW5zID0gdGwudHdlZW5zO1xuXHRcdGZvciAobGV0IHR3ZWVuIG9mIHR3ZWVucykge1xuXHRcdFx0bGV0IHRhcmdldCA9IHR3ZWVuLnRhcmdldDtcblx0XHRcdGlmICh0YXJnZXQgPT09IHRoaXMgfHwgdHdlZW4ucGFzc2l2ZSkgeyBjb250aW51ZTsgfSAvLyBUT0RPOiB0aGlzIGFzc3VtZXMgdGhlIGFjdGlvbnMgdHdlZW4gZnJvbSBBbmltYXRlIGhhcyBgdGhpc2AgYXMgdGhlIHRhcmdldC4gTGlrZWx5IGEgYmV0dGVyIGFwcHJvYWNoLlxuXHRcdFx0bGV0IG9mZnNldCA9IHR3ZWVuLl9zdGVwUG9zaXRpb247XG5cblx0XHRcdGlmICh0YXJnZXQgaW5zdGFuY2VvZiBEaXNwbGF5T2JqZWN0KSB7XG5cdFx0XHRcdC8vIG1vdGlvbiB0d2Vlbi5cblx0XHRcdFx0dGhpcy5fYWRkTWFuYWdlZENoaWxkKHRhcmdldCwgb2Zmc2V0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIHN0YXRlIHR3ZWVuLlxuXHRcdFx0XHR0aGlzLl9zZXRTdGF0ZSh0YXJnZXQuc3RhdGUsIG9mZnNldCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0bGV0IGtpZHMgPSB0aGlzLmNoaWxkcmVuO1xuXHRcdGZvciAobGV0IGk9a2lkcy5sZW5ndGgtMTsgaT49MDsgaS0tKSB7XG5cdFx0XHRsZXQgaWQgPSBraWRzW2ldLmlkO1xuXHRcdFx0aWYgKHRoaXMuX21hbmFnZWRbaWRdID09PSAxKSB7XG5cdFx0XHRcdHRoaXMucmVtb3ZlQ2hpbGRBdChpKTtcblx0XHRcdFx0ZGVsZXRlKHRoaXMuX21hbmFnZWRbaWRdKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtBcnJheX0gc3RhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRfc2V0U3RhdGUgKHN0YXRlLCBvZmZzZXQpIHtcblx0XHRpZiAoIXN0YXRlKSB7IHJldHVybjsgfVxuXHRcdGZvciAobGV0IGkgPSBzdGF0ZS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0bGV0IG8gPSBzdGF0ZVtpXTtcblx0XHRcdGxldCB0YXJnZXQgPSBvLnQ7XG5cdFx0XHRsZXQgcHJvcHMgPSBvLnA7XG5cdFx0XHRmb3IgKGxldCBuIGluIHByb3BzKSB7IHRhcmdldFtuXSA9IHByb3BzW25dOyB9XG5cdFx0XHR0aGlzLl9hZGRNYW5hZ2VkQ2hpbGQodGFyZ2V0LCBvZmZzZXQpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgY2hpbGQgdG8gdGhlIHRpbWVsaW5lLCBhbmQgc2V0cyBpdCB1cCBhcyBhIG1hbmFnZWQgY2hpbGQuXG5cdCAqIEBwYXJhbSB7ZWFzZWxqcy5Nb3ZpZUNsaXB9IGNoaWxkIFRoZSBjaGlsZCBNb3ZpZUNsaXAgdG8gbWFuYWdlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9hZGRNYW5hZ2VkQ2hpbGQgKGNoaWxkLCBvZmZzZXQpIHtcblx0XHRpZiAoY2hpbGQuX29mZikgeyByZXR1cm47IH1cblx0XHR0aGlzLmFkZENoaWxkQXQoY2hpbGQsIDApO1xuXG5cdFx0aWYgKGNoaWxkIGluc3RhbmNlb2YgTW92aWVDbGlwKSB7XG5cdFx0XHRjaGlsZC5fc3luY2hPZmZzZXQgPSBvZmZzZXQ7XG5cdFx0XHQvLyBUT0RPOiB0aGlzIGRvZXMgbm90IHByZWNpc2VseSBtYXRjaCBBZG9iZSBGbGFzaC9BbmltYXRlLCB3aGljaCBsb3NlcyB0cmFjayBvZiB0aGUgY2xpcCBpZiBpdCBpcyByZW5hbWVkIG9yIHJlbW92ZWQgZnJvbSB0aGUgdGltZWxpbmUsIHdoaWNoIGNhdXNlcyBpdCB0byByZXNldC5cbiAgICAgIC8vIFRPRE86IHNob3VsZCBhbHNvIHJlc2V0IHdoZW4gTW92aWVDbGlwIGxvb3BzLCB0aG91Z2ggdGhhdCB3aWxsIGJlIGEgYml0IHRyaWNreSB0byBkZXRlY3QuXG5cdFx0XHRpZiAoY2hpbGQubW9kZSA9PT0gTW92aWVDbGlwLklOREVQRU5ERU5UICYmIGNoaWxkLmF1dG9SZXNldCAmJiAhdGhpcy5fbWFuYWdlZFtjaGlsZC5pZF0pIHsgY2hpbGQuX3Jlc2V0KCk7IH1cblx0XHR9XG5cdFx0dGhpcy5fbWFuYWdlZFtjaGlsZC5pZF0gPSAyO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7ZWFzZWxqcy5NYXRyaXgyRH0gbWF0cml4XG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaWdub3JlVHJhbnNmb3JtXG5cdCAqIEByZXR1cm4ge2Vhc2VsanMuUmVjdGFuZ2xlfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRfZ2V0Qm91bmRzIChtYXRyaXgsIGlnbm9yZVRyYW5zZm9ybSkge1xuXHRcdGxldCBib3VuZHMgPSB0aGlzLmdldEJvdW5kcygpO1xuXHRcdGlmICghYm91bmRzICYmIHRoaXMuZnJhbWVCb3VuZHMpIHsgYm91bmRzID0gdGhpcy5fcmVjdGFuZ2xlLmNvcHkodGhpcy5mcmFtZUJvdW5kc1t0aGlzLmN1cnJlbnRGcmFtZV0pOyB9XG5cdFx0aWYgKGJvdW5kcykgeyByZXR1cm4gdGhpcy5fdHJhbnNmb3JtQm91bmRzKGJvdW5kcywgbWF0cml4LCBpZ25vcmVUcmFuc2Zvcm0pOyB9XG5cdFx0cmV0dXJuIHN1cGVyLl9nZXRCb3VuZHMobWF0cml4LCBpZ25vcmVUcmFuc2Zvcm0pO1xuXHR9XG5cbn1cblxuLyoqXG4gKiBUaGUgTW92aWVDbGlwIHdpbGwgYWR2YW5jZSBpbmRlcGVuZGVudGx5IG9mIGl0cyBwYXJlbnQsIGV2ZW4gaWYgaXRzIHBhcmVudCBpcyBwYXVzZWQuXG4gKiBUaGlzIGlzIHRoZSBkZWZhdWx0IG1vZGUuXG4gKiBAc3RhdGljXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGRlZmF1bHQgaW5kZXBlbmRlbnRcbiAqIEByZWFkb25seVxuICovXG5Nb3ZpZUNsaXAuSU5ERVBFTkRFTlQgPSBcImluZGVwZW5kZW50XCI7XG4vKipcbiAqIFRoZSBNb3ZpZUNsaXAgd2lsbCBvbmx5IGRpc3BsYXkgYSBzaW5nbGUgZnJhbWUgKGFzIGRldGVybWluZWQgYnkgdGhlIHN0YXJ0UG9zaXRpb24gcHJvcGVydHkpLlxuICogQHN0YXRpY1xuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZWZhdWx0IHNpbmdsZVxuICogQHJlYWRvbmx5XG4gKi9cbk1vdmllQ2xpcC5TSU5HTEVfRlJBTUUgPSBcInNpbmdsZVwiO1xuLyoqXG4gKiBUaGUgTW92aWVDbGlwIHdpbGwgYmUgYWR2YW5jZWQgb25seSB3aGVuIGl0cyBwYXJlbnQgYWR2YW5jZXMgYW5kIHdpbGwgYmUgc3luY2hlZCB0byB0aGUgcG9zaXRpb24gb2ZcbiAqIHRoZSBwYXJlbnQgTW92aWVDbGlwLlxuICogQHN0YXRpY1xuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZWZhdWx0IHN5bmNoZWRcbiAqIEByZWFkb25seVxuICovXG5Nb3ZpZUNsaXAuU1lOQ0hFRCA9IFwic3luY2hlZFwiO1xuLyoqXG4gKiBIYXMgdGhlIE1vdmllQ2xpcFBsdWdpbiBiZWVuIGluc3RhbGxlZCB0byBUd2VlbkpTIHlldD9cbiAqIEBzdGF0aWNcbiAqIEB0eXBlIHtCb29sZWFufVxuICogQGRlZmF1bHQgZmFsc2VcbiAqIEByZWFkb25seVxuICovXG5Nb3ZpZUNsaXAuaW5pdGVkID0gZmFsc2U7XG5cbi8qKlxuICogVGhpcyBwbHVnaW4gd29ya3Mgd2l0aCA8YSBocmVmPVwiaHR0cDovL3R3ZWVuanMuY29tXCIgdGFyZ2V0PVwiX2JsYW5rXCI+VHdlZW5KUzwvYT4gdG8gcHJldmVudCB0aGUgc3RhcnRQb3NpdGlvbiBwcm9wZXJ0eSBmcm9tIHR3ZWVuaW5nLlxuICogQHRvZG8gdXBkYXRlIHRvIG5ldyBwbHVnaW4gbW9kZWxcbiAqIEBzdGF0aWNcbiAqIEBpbm5lclxuICovXG5jbGFzcyBNb3ZpZUNsaXBQbHVnaW4ge1xuXG5cdGNvbnN0cnVjdG9yICgpIHtcblx0XHR0aHJvdyBcIk1vdmllQ2xpcFBsdWdpbiBjYW5ub3QgYmUgaW5zdGFudGlhdGVkLlwiO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRzdGF0aWMgaW5zdGFsbCAoKSB7XG5cdFx0VHdlZW4uaW5zdGFsbFBsdWdpbihNb3ZpZUNsaXBQbHVnaW4pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7dHdlZW5qcy5Ud2Vlbn0gdHdlZW5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHByb3Bcblx0ICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfEJvb2xlYW59IHZhbHVlXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRzdGF0aWMgaW5pdCAodHdlZW4sIHByb3AsIHZhbHVlKSB7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7dHdlZW5qcy5Ud2Vlbn0gdHdlZW5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHByb3Bcblx0ICogQHBhcmFtIHtTdHJpbmcgfCBOdW1iZXIgfCBCb29sZWFufSB2YWx1ZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBzdGFydFZhbHVlc1xuXHQgKiBAcGFyYW0ge0FycmF5fSBlbmRWYWx1ZXNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhdGlvXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB3YWl0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBlbmRcblx0ICogQHJldHVybiB7Kn1cblx0ICovXG5cdHN0YXRpYyB0d2VlbiAodHdlZW4sIHByb3AsIHZhbHVlLCBzdGFydFZhbHVlcywgZW5kVmFsdWVzLCByYXRpbywgd2FpdCwgZW5kKSB7XG5cdFx0aWYgKCEodHdlZW4udGFyZ2V0IGluc3RhbmNlb2YgTW92aWVDbGlwKSkgeyByZXR1cm4gdmFsdWU7IH1cblx0XHRyZXR1cm4gKHJhdGlvID09PSAxID8gZW5kVmFsdWVzW3Byb3BdIDogc3RhcnRWYWx1ZXNbcHJvcF0pO1xuXHR9XG5cbn1cblxuLyoqXG4gKiBAc3RhdGljXG4gKiBAdHlwZSB7TnVtYmVyfVxuICogQGRlZmF1bHQgMTAwXG4gKiBAcmVhZG9ubHlcbiAqL1xuTW92aWVDbGlwUGx1Z2luLnByaW9yaXR5ID0gMTAwO1xuIiwiLyoqXG4gKiBAbGljZW5zZSBTaGFwZVxuICogVmlzaXQgaHR0cDovL2NyZWF0ZWpzLmNvbS8gZm9yIGRvY3VtZW50YXRpb24sIHVwZGF0ZXMgYW5kIGV4YW1wbGVzLlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNyBnc2tpbm5lci5jb20sIGluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICogb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cbiAqIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxuICogcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsXG4gKiBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4gKiBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuICogY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAqIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xuICogT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAqIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4gKiBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcbiAqIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuICogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUlxuICogT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICovXG5cbmltcG9ydCBEaXNwbGF5T2JqZWN0IGZyb20gXCIuL0Rpc3BsYXlPYmplY3RcIjtcbmltcG9ydCBHcmFwaGljcyBmcm9tIFwiLi9HcmFwaGljc1wiO1xuXG4vKipcbiAqIEEgU2hhcGUgYWxsb3dzIHlvdSB0byBkaXNwbGF5IHZlY3RvciBhcnQgaW4gdGhlIGRpc3BsYXkgbGlzdC4gSXQgY29tcG9zaXRlcyBhIHtAbGluayBlYXNlbGpzLkdyYXBoaWNzfVxuICogaW5zdGFuY2Ugd2hpY2ggZXhwb3NlcyBhbGwgb2YgdGhlIHZlY3RvciBkcmF3aW5nIG1ldGhvZHMuIFRoZSBHcmFwaGljcyBpbnN0YW5jZSBjYW4gYmUgc2hhcmVkIGJldHdlZW4gbXVsdGlwbGUgU2hhcGVcbiAqIGluc3RhbmNlcyB0byBkaXNwbGF5IHRoZSBzYW1lIHZlY3RvciBncmFwaGljcyB3aXRoIGRpZmZlcmVudCBwb3NpdGlvbnMgb3IgdHJhbnNmb3Jtcy5cbiAqXG4gKiBJZiB0aGUgdmVjdG9yIGFydCB3aWxsIG5vdCBjaGFuZ2UgYmV0d2VlbiBkcmF3cywgeW91IG1heSB3YW50IHRvIHVzZSB0aGUge0BsaW5rIGVhc2VsanMuRGlzcGxheU9iamVjdCNjYWNoZX1cbiAqIG1ldGhvZCB0byByZWR1Y2UgdGhlIHJlbmRlcmluZyBjb3N0LlxuICpcbiAqIEBtZW1iZXJvZiBlYXNlbGpzXG4gKiBAZXhhbXBsZVxuICogdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKCkuYmVnaW5GaWxsKFwiI2ZmMDAwMFwiKS5kcmF3UmVjdCgwLCAwLCAxMDAsIDEwMCk7XG4gKiB2YXIgc2hhcGUgPSBuZXcgU2hhcGUoZ3JhcGhpY3MpO1xuICogLy8gQWx0ZXJuYXRpdmVseSB1c2UgY2FuIGFsc28gdXNlIHRoZSBncmFwaGljcyBwcm9wZXJ0eSBvZiB0aGUgU2hhcGUgY2xhc3MgdG8gcmVuZGVyZXIgdGhlIHNhbWUgYXMgYWJvdmUuXG4gKiB2YXIgc2hhcGUgPSBuZXcgU2hhcGUoKTtcbiAqIHNoYXBlLmdyYXBoaWNzLmJlZ2luRmlsbChcIiNmZjAwMDBcIikuZHJhd1JlY3QoMCwgMCwgMTAwLCAxMDApO1xuICpcbiAqIEBleHRlbmRzIGVhc2VsanMuRGlzcGxheU9iamVjdFxuICogQHBhcmFtIHtlYXNlbGpzLkdyYXBoaWNzfSBbZ3JhcGhpY3NdIFRoZSBncmFwaGljcyBpbnN0YW5jZSB0byBkaXNwbGF5LiBJZiBudWxsLCBhIG5ldyBHcmFwaGljcyBpbnN0YW5jZSB3aWxsIGJlIGNyZWF0ZWQuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNoYXBlIGV4dGVuZHMgRGlzcGxheU9iamVjdCB7XG5cblx0Y29uc3RydWN0b3IgKGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKCkpIHtcblx0XHRzdXBlcigpO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGdyYXBoaWNzIGluc3RhbmNlIHRvIGRpc3BsYXkuXG5cdFx0ICogQHR5cGUge2Vhc2VsanMuR3JhcGhpY3N9XG5cdFx0ICovXG5cdFx0dGhpcy5ncmFwaGljcyA9IGdyYXBoaWNzO1xuXHR9XG5cblx0aXNWaXNpYmxlICgpIHtcblx0XHRsZXQgaGFzQ29udGVudCA9IHRoaXMuY2FjaGVDYW52YXMgfHwgKHRoaXMuZ3JhcGhpY3MgJiYgIXRoaXMuZ3JhcGhpY3MuaXNFbXB0eSgpKTtcblx0XHRyZXR1cm4gISEodGhpcy52aXNpYmxlICYmIHRoaXMuYWxwaGEgPiAwICYmIHRoaXMuc2NhbGVYICE9IDAgJiYgdGhpcy5zY2FsZVkgIT0gMCAmJiBoYXNDb250ZW50KTtcblx0fVxuXG5cdGRyYXcgKGN0eCwgaWdub3JlQ2FjaGUgPSBmYWxzZSkge1xuXHRcdGlmIChzdXBlci5kcmF3KGN0eCwgaWdub3JlQ2FjaGUpKSB7IHJldHVybiB0cnVlOyB9XG5cdFx0dGhpcy5ncmFwaGljcy5kcmF3KGN0eCwgdGhpcyk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIGNsb25lIG9mIHRoaXMgU2hhcGUuIFNvbWUgcHJvcGVydGllcyB0aGF0IGFyZSBzcGVjaWZpYyB0byB0aGlzIGluc3RhbmNlJ3MgY3VycmVudCBjb250ZXh0IGFyZSByZXZlcnRlZCB0b1xuXHQgKiB0aGVpciBkZWZhdWx0cyAoZm9yIGV4YW1wbGUgLnBhcmVudCkuXG5cdCAqIEBvdmVycmlkZVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtyZWN1cnNpdmU9ZmFsc2VdIElmIHRydWUsIHRoaXMgU2hhcGUncyB7QGxpbmsgZWFzZWxqcy5HcmFwaGljc30gaW5zdGFuY2Ugd2lsbCBhbHNvIGJlXG5cdCAqIGNsb25lZC4gSWYgZmFsc2UsIHRoZSBHcmFwaGljcyBpbnN0YW5jZSB3aWxsIGJlIHNoYXJlZCB3aXRoIHRoZSBuZXcgU2hhcGUuXG5cdCAqL1xuXHRjbG9uZSAocmVjdXJzaXZlID0gZmFsc2UpIHtcblx0XHRsZXQgZyA9IChyZWN1cnNpdmUgJiYgdGhpcy5ncmFwaGljcykgPyB0aGlzLmdyYXBoaWNzLmNsb25lKCkgOiB0aGlzLmdyYXBoaWNzO1xuXHRcdHJldHVybiB0aGlzLl9jbG9uZVByb3BzKG5ldyBTaGFwZShnKSk7XG5cdH1cblxufVxuIiwiLyoqXG4gKiBAbGljZW5zZSBTcHJpdGVTaGVldFxuICogVmlzaXQgaHR0cDovL2NyZWF0ZWpzLmNvbS8gZm9yIGRvY3VtZW50YXRpb24sIHVwZGF0ZXMgYW5kIGV4YW1wbGVzLlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNyBnc2tpbm5lci5jb20sIGluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICogb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cbiAqIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxuICogcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsXG4gKiBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4gKiBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuICogY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAqIEVYUFJFU1MgT1IgSU1QbGlFRCwgSU5DTFVESU5HIEJVVCBOT1QgbGlNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xuICogT0YgTUVSQ0hBTlRBQklsaVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAqIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4gKiBIb2xERVJTIEJFIGxpQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIGxpQUJJbGlUWSxcbiAqIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuICogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUlxuICogT1RIRVIgREVBbGlOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICovXG5cbmltcG9ydCB7IEV2ZW50RGlzcGF0Y2hlciwgRXZlbnQgfSBmcm9tIFwiQGNyZWF0ZWpzL2NvcmVcIjtcbmltcG9ydCBSZWN0YW5nbGUgZnJvbSBcIi4uL2dlb20vUmVjdGFuZ2xlXCI7XG5cbi8qKlxuICogRW5jYXBzdWxhdGVzIHRoZSBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIGFzc29jaWF0ZWQgd2l0aCBhIHNwcml0ZSBzaGVldC4gQSBzcHJpdGUgc2hlZXQgaXMgYSBzZXJpZXMgb2YgaW1hZ2VzICh1c3VhbGx5XG4gKiBhbmltYXRpb24gZnJhbWVzKSBjb21iaW5lZCBpbnRvIGEgbGFyZ2VyIGltYWdlIChvciBpbWFnZXMpLiBGb3IgZXhhbXBsZSwgYW4gYW5pbWF0aW9uIGNvbnNpc3Rpbmcgb2YgZWlnaHQgMTAweDEwMFxuICogaW1hZ2VzIGNvdWxkIGJlIGNvbWJpbmVkIGludG8gYSBzaW5nbGUgNDAweDIwMCBzcHJpdGUgc2hlZXQgKDQgZnJhbWVzIGFjcm9zcyBieSAyIGhpZ2gpLlxuICogPGJyIC8+XG4gKiBUaGUgZGF0YSBwYXNzZWQgdG8gdGhlIFNwcml0ZVNoZWV0IGNvbnN0cnVjdG9yIGRlZmluZXM6XG4gKiA8b2w+XG4gKiBcdDxsaT4gVGhlIHNvdXJjZSBpbWFnZSBvciBpbWFnZXMgdG8gdXNlLjwvbGk+XG4gKiBcdDxsaT4gVGhlIHBvc2l0aW9ucyBvZiBpbmRpdmlkdWFsIGltYWdlIGZyYW1lcy48L2xpPlxuICogXHQ8bGk+IFNlcXVlbmNlcyBvZiBmcmFtZXMgdGhhdCBmb3JtIG5hbWVkIGFuaW1hdGlvbnMuIE9wdGlvbmFsLjwvbGk+XG4gKiBcdDxsaT4gVGhlIHRhcmdldCBwbGF5YmFjayBmcmFtZXJhdGUuIE9wdGlvbmFsLjwvbGk+XG4gKiA8L29sPlxuICpcbiAqIDxoMz5TcHJpdGVTaGVldCBGb3JtYXQ8L2gzPlxuICogU3ByaXRlU2hlZXRzIGFyZSBhbiBvYmplY3Qgd2l0aCB0d28gcmVxdWlyZWQgcHJvcGVydGllcyAoYGltYWdlc2AgYW5kIGBmcmFtZXNgKSwgYW5kIHR3byBvcHRpb25hbCBwcm9wZXJ0aWVzXG4gKiAoYGZyYW1lcmF0ZWAgYW5kIGBhbmltYXRpb25zYCkuIFRoaXMgbWFrZXMgdGhlbSBlYXN5IHRvIGRlZmluZSBpbiBqYXZhc2NyaXB0IGNvZGUsIG9yIGluIEpTT04uXG4gKlxuICogPGg0PmltYWdlczwvaDQ+XG4gKiBBbiBhcnJheSBvZiBzb3VyY2UgaW1hZ2VzLiBJbWFnZXMgY2FuIGJlIGVpdGhlciBhbiBIVE1saW1hZ2VcbiAqIGluc3RhbmNlLCBvciBhIHVyaSB0byBhbiBpbWFnZS4gVGhlIGZvcm1lciBpcyByZWNvbW1lbmRlZCB0byBjb250cm9sIHByZWxvYWRpbmcuXG4gKlxuICogXHRpbWFnZXM6IFtpbWFnZTEsIFwicGF0aC90by9pbWFnZTIucG5nXCJdLFxuICpcbiAqIDxoND5mcmFtZXM8L2g0PlxuICogRGVmaW5lcyB0aGUgaW5kaXZpZHVhbCBmcmFtZXMuIFRoZXJlIGFyZSB0d28gc3VwcG9ydGVkIGZvcm1hdHMgZm9yIGZyYW1lIGRhdGE6XG4gKiBXaGVuIGFsbCBvZiB0aGUgZnJhbWVzIGFyZSB0aGUgc2FtZSBzaXplIChpbiBhIGdyaWQpLCB1c2UgYW4gb2JqZWN0IHdpdGggYHdpZHRoYCwgYGhlaWdodGAsIGByZWdYYCwgYHJlZ1lgLFxuICogYW5kIGBjb3VudGAgcHJvcGVydGllcy5cbiAqXG4gKiA8dWw+XG4gKiAgPGxpPmB3aWR0aGAgJiBgaGVpZ2h0YCBhcmUgcmVxdWlyZWQgYW5kIHNwZWNpZnkgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIGZyYW1lczwvbGk+XG4gKiAgPGxpPmByZWdYYCAmIGByZWdZYCBpbmRpY2F0ZSB0aGUgcmVnaXN0cmF0aW9uIHBvaW50IG9yIFwib3JpZ2luXCIgb2YgdGhlIGZyYW1lczwvbGk+XG4gKiAgPGxpPmBzcGFjaW5nYCBpbmRpY2F0ZSB0aGUgc3BhY2luZyBiZXR3ZWVuIGZyYW1lczwvbGk+XG4gKiAgPGxpPmBtYXJnaW5gIHNwZWNpZnkgdGhlIG1hcmdpbiBhcm91bmQgdGhlIGltYWdlKHMpPC9saT5cbiAqICA8bGk+YGNvdW50YCBhbGxvd3MgeW91IHRvIHNwZWNpZnkgdGhlIHRvdGFsIG51bWJlciBvZiBmcmFtZXMgaW4gdGhlIHNwcml0ZXNoZWV0OyBpZiBvbWl0dGVkLCB0aGlzIHdpbGxcbiAqICBiZSBjYWxjdWxhdGVkIGJhc2VkIG9uIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBzb3VyY2UgaW1hZ2VzIGFuZCB0aGUgZnJhbWVzLiBGcmFtZXMgd2lsbCBiZSBhc3NpZ25lZFxuICogIGluZGV4ZXMgYmFzZWQgb24gdGhlaXIgcG9zaXRpb24gaW4gdGhlIHNvdXJjZSBpbWFnZXMgKGxlZnQgdG8gcmlnaHQsIHRvcCB0byBib3R0b20pLjwvbGk+XG4gKiA8L3VsPlxuICpcbiAqICBcdGZyYW1lczoge3dpZHRoOjY0LCBoZWlnaHQ6NjQsIGNvdW50OjIwLCByZWdYOiAzMiwgcmVnWTo2NCwgc3BhY2luZzowLCBtYXJnaW46MH1cbiAqXG4gKiBJZiB0aGUgZnJhbWVzIGFyZSBvZiBkaWZmZXJlbnQgc2l6ZXMsIHVzZSBhbiBhcnJheSBvZiBmcmFtZSBkZWZpbml0aW9ucy4gRWFjaCBkZWZpbml0aW9uIGlzIGl0c2VsZiBhbiBhcnJheVxuICogd2l0aCA0IHJlcXVpcmVkIGFuZCAzIG9wdGlvbmFsIGVudHJpZXMsIGluIHRoZSBvcmRlcjpcbiAqXG4gKiA8dWw+XG4gKiAgPGxpPlRoZSBmaXJzdCBmb3VyLCBgeGAsIGB5YCwgYHdpZHRoYCwgYW5kIGBoZWlnaHRgIGFyZSByZXF1aXJlZCBhbmQgZGVmaW5lIHRoZSBmcmFtZSByZWN0YW5nbGUuPC9saT5cbiAqICA8bGk+VGhlIGZpZnRoLCBgaW1hZ2VJbmRleGAsIHNwZWNpZmllcyB0aGUgaW5kZXggb2YgdGhlIHNvdXJjZSBpbWFnZSAoZGVmYXVsdHMgdG8gMCk8L2xpPlxuICogIDxsaT5UaGUgbGFzdCB0d28sIGByZWdYYCBhbmQgYHJlZ1lgIHNwZWNpZnkgdGhlIHJlZ2lzdHJhdGlvbiBwb2ludCBvZiB0aGUgZnJhbWU8L2xpPlxuICogPC91bD5cbiAqXG4gKiBcdGZyYW1lczogW1xuICogXHRcdC8vIHgsIHksIHdpZHRoLCBoZWlnaHQsIGltYWdlSW5kZXgqLCByZWdYKiwgcmVnWSpcbiAqIFx0XHRbNjQsIDAsIDk2LCA2NF0sXG4gKiBcdFx0WzAsIDAsIDY0LCA2NCwgMSwgMzIsIDMyXVxuICogXHRcdC8vIGV0Yy5cbiAqIFx0XVxuICpcbiAqIDxoND5hbmltYXRpb25zPC9oND5cbiAqIE9wdGlvbmFsLiBBbiBvYmplY3QgZGVmaW5pbmcgc2VxdWVuY2VzIG9mIGZyYW1lcyB0byBwbGF5IGFzIG5hbWVkIGFuaW1hdGlvbnMuIEVhY2ggcHJvcGVydHkgY29ycmVzcG9uZHMgdG8gYW5cbiAqIGFuaW1hdGlvbiBvZiB0aGUgc2FtZSBuYW1lLiBFYWNoIGFuaW1hdGlvbiBtdXN0IHNwZWNpZnkgdGhlIGZyYW1lcyB0byBwbGF5LCBhbmQgbWF5XG4gKiBhbHNvIGluY2x1ZGUgYSByZWxhdGl2ZSBwbGF5YmFjayBgc3BlZWRgIChleC4gMiB3b3VsZCBwbGF5YmFjayBhdCBkb3VibGUgc3BlZWQsIDAuNSBhdCBoYWxmKSwgYW5kXG4gKiB0aGUgbmFtZSBvZiB0aGUgYG5leHRgIGFuaW1hdGlvbiB0byBzZXF1ZW5jZSB0byBhZnRlciBpdCBjb21wbGV0ZXMuXG4gKlxuICogVGhlcmUgYXJlIHRocmVlIGZvcm1hdHMgc3VwcG9ydGVkIGZvciBkZWZpbmluZyB0aGUgZnJhbWVzIGluIGFuIGFuaW1hdGlvbiwgd2hpY2ggY2FuIGJlIG1peGVkIGFuZCBtYXRjaGVkIGFzIGFwcHJvcHJpYXRlOlxuICogPG9sPlxuICogXHQ8bGk+Zm9yIGEgc2luZ2xlIGZyYW1lIGFuaW1hdGlvbiwgeW91IGNhbiBzaW1wbHkgc3BlY2lmeSB0aGUgZnJhbWUgaW5kZXhcbiAqXG4gKiBcdFx0YW5pbWF0aW9uczoge1xuICogXHRcdFx0c2l0OiA3XG4gKiBcdFx0fVxuICpcbiAqIDwvbGk+XG4gKiA8bGk+XG4gKiAgICAgIGZvciBhbiBhbmltYXRpb24gb2YgY29uc2VjdXRpdmUgZnJhbWVzLCB5b3UgY2FuIHVzZSBhbiBhcnJheSB3aXRoIHR3byByZXF1aXJlZCwgYW5kIHR3byBvcHRpb25hbCBlbnRyaWVzXG4gKiBcdFx0aW4gdGhlIG9yZGVyOiBgc3RhcnRgLCBgZW5kYCwgYG5leHRgLCBhbmQgYHNwZWVkYC4gVGhpcyB3aWxsIHBsYXkgdGhlIGZyYW1lcyBmcm9tIHN0YXJ0IHRvIGVuZCBpbmNsdXNpdmUuXG4gKlxuICogXHRcdGFuaW1hdGlvbnM6IHtcbiAqIFx0XHRcdC8vIHN0YXJ0LCBlbmQsIG5leHQqLCBzcGVlZCpcbiAqIFx0XHRcdHJ1bjogWzAsIDhdLFxuICogXHRcdFx0anVtcDogWzksIDEyLCBcInJ1blwiLCAyXVxuICogXHRcdH1cbiAqXG4gKiAgPC9saT5cbiAqICA8bGk+XG4gKiAgICAgZm9yIG5vbi1jb25zZWN1dGl2ZSBmcmFtZXMsIHlvdSBjYW4gdXNlIGFuIG9iamVjdCB3aXRoIGEgYGZyYW1lc2AgcHJvcGVydHkgZGVmaW5pbmcgYW4gYXJyYXkgb2YgZnJhbWVcbiAqICAgICBpbmRleGVzIHRvIHBsYXkgaW4gb3JkZXIuIFRoZSBvYmplY3QgY2FuIGFsc28gc3BlY2lmeSBgbmV4dGAgYW5kIGBzcGVlZGAgcHJvcGVydGllcy5cbiAqXG4gKiBcdFx0YW5pbWF0aW9uczoge1xuICogXHRcdFx0d2Fsazoge1xuICogXHRcdFx0XHRmcmFtZXM6IFsxLDIsMywzLDIsMV1cbiAqIFx0XHRcdH0sXG4gKiBcdFx0XHRzaG9vdDoge1xuICogXHRcdFx0XHRmcmFtZXM6IFsxLDQsNSw2XSxcbiAqIFx0XHRcdFx0bmV4dDogXCJ3YWxrXCIsXG4gKiBcdFx0XHRcdHNwZWVkOiAwLjVcbiAqIFx0XHRcdH1cbiAqIFx0XHR9XG4gKlxuICogIDwvbGk+XG4gKiA8L29sPlxuICogPHN0cm9uZz5Ob3RlOjwvc3Ryb25nPiB0aGUgYHNwZWVkYCBwcm9wZXJ0eSB3YXMgYWRkZWQgaW4gRWFzZWxKUyAwLjcuMC4gRWFybGllciB2ZXJzaW9ucyBoYWQgYSBgZnJlcXVlbmN5YFxuICogcHJvcGVydHkgaW5zdGVhZCwgd2hpY2ggd2FzIHRoZSBpbnZlcnNlIG9mIGBzcGVlZGAuIEZvciBleGFtcGxlLCBhIHZhbHVlIG9mIFwiNFwiIHdvdWxkIGJlIDEvNCBub3JtYWwgc3BlZWQgaW5cbiAqIGVhcmxpZXIgdmVyc2lvbnMsIGJ1dCBpcyA0eCBub3JtYWwgc3BlZWQgaW4gRWFzZWxKUyAwLjcuMCsuXG4gKlxuICogPGg0PmZyYW1lcmF0ZTwvaDQ+XG4gKiBPcHRpb25hbC4gSW5kaWNhdGVzIHRoZSBkZWZhdWx0IGZyYW1lcmF0ZSB0byBwbGF5IHRoaXMgc3ByaXRlc2hlZXQgYXQgaW4gZnJhbWVzIHBlciBzZWNvbmQuIFNlZVxuICoge3sjY3Jvc3NMaW5rIFwiU3ByaXRlU2hlZXQvZnJhbWVyYXRlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIFx0XHRmcmFtZXJhdGU6IDIwXG4gKlxuICogTm90ZSB0aGF0IHRoZSBTcHJpdGUgZnJhbWVyYXRlIHdpbGwgb25seSB3b3JrIGlmIHRoZSBzdGFnZSB1cGRhdGUgbWV0aG9kIGlzIHByb3ZpZGVkIHdpdGggdGhlIHt7I2Nyb3NzTGluayBcIlRpY2tlci90aWNrOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319XG4gKiBldmVudCBnZW5lcmF0ZWQgYnkgdGhlIHt7I2Nyb3NzTGluayBcIlRpY2tlclwifX17ey9jcm9zc0xpbmt9fS5cbiAqXG4gKiBcdFx0Y3JlYXRlanMuVGlja2VyLm9uKFwidGlja1wiLCBoYW5kbGVUaWNrKTtcbiAqIFx0XHRmdW5jdGlvbiBoYW5kbGVUaWNrKGV2ZW50KSB7XG4gKlx0XHRcdHN0YWdlLnVwZGF0ZShldmVudCk7XG4gKlx0XHR9XG4gKlxuICogPGgzPkV4YW1wbGU8L2gzPlxuICogVG8gZGVmaW5lIGEgc2ltcGxlIHNwcml0ZSBzaGVldCwgd2l0aCBhIHNpbmdsZSBpbWFnZSBcInNwcml0ZXMuanBnXCIgYXJyYW5nZWQgaW4gYSByZWd1bGFyIDUweDUwIGdyaWQgd2l0aCB0aHJlZVxuICogYW5pbWF0aW9uczogXCJzdGFuZFwiIHNob3dpbmcgdGhlIGZpcnN0IGZyYW1lLCBcInJ1blwiIGxvb3BpbmcgZnJhbWUgMS01IGluY2x1c2l2ZSwgYW5kIFwianVtcFwiIHBsYXlpbmcgZnJhbWUgNi04IGFuZFxuICogc2VxdWVuY2luZyBiYWNrIHRvIHJ1bi5cbiAqXG4gKiBcdFx0dmFyIGRhdGEgPSB7XG4gKiBcdFx0XHRpbWFnZXM6IFtcInNwcml0ZXMuanBnXCJdLFxuICogXHRcdFx0ZnJhbWVzOiB7d2lkdGg6NTAsIGhlaWdodDo1MH0sXG4gKiBcdFx0XHRhbmltYXRpb25zOiB7XG4gKiBcdFx0XHRcdHN0YW5kOjAsXG4gKiBcdFx0XHRcdHJ1bjpbMSw1XSxcbiAqIFx0XHRcdFx0anVtcDpbNiw4LFwicnVuXCJdXG4gKiBcdFx0XHR9XG4gKiBcdFx0fTtcbiAqIFx0XHR2YXIgc3ByaXRlU2hlZXQgPSBuZXcgY3JlYXRlanMuU3ByaXRlU2hlZXQoZGF0YSk7XG4gKiBcdFx0dmFyIGFuaW1hdGlvbiA9IG5ldyBjcmVhdGVqcy5TcHJpdGUoc3ByaXRlU2hlZXQsIFwicnVuXCIpO1xuICpcbiAqIDxoMz5HZW5lcmF0aW5nIFNwcml0ZVNoZWV0IEltYWdlczwvaDM+XG4gKiBTcHJpdGVzaGVldHMgY2FuIGJlIGNyZWF0ZWQgbWFudWFsbHkgYnkgY29tYmluaW5nIGltYWdlcyBpbiBQaG90b1Nob3AsIGFuZCBzcGVjaWZ5aW5nIHRoZSBmcmFtZSBzaXplIG9yXG4gKiBjb29yZGluYXRlcyBtYW51YWxseSwgaG93ZXZlciB0aGVyZSBhcmUgYSBudW1iZXIgb2YgdG9vbHMgdGhhdCBmYWNpbGl0YXRlIHRoaXMuXG4gKiA8dWw+XG4gKiAgICAgPGxpPkV4cG9ydGluZyBTcHJpdGVTaGVldHMgb3IgSFRNTDUgY29udGVudCBmcm9tIEFkb2JlIEZsYXNoL0FuaW1hdGUgc3VwcG9ydHMgdGhlIEVhc2VsSlMgU3ByaXRlU2hlZXQgZm9ybWF0LjwvbGk+XG4gKiAgICAgPGxpPlRoZSBwb3B1bGFyIDxhIGhyZWY9XCJodHRwczovL3d3dy5jb2RlYW5kd2ViLmNvbS90ZXh0dXJlcGFja2VyL2Vhc2VsanNcIiB0YXJnZXQ9XCJfYmxhbmtcIj5UZXh0dXJlIFBhY2tlcjwvYT4gaGFzXG4gKiAgICAgRWFzZWxKUyBzdXBwb3J0LlxuICogICAgIDxsaT5TV0YgYW5pbWF0aW9ucyBpbiBBZG9iZSBGbGFzaC9BbmltYXRlIGNhbiBiZSBleHBvcnRlZCB0byBTcHJpdGVTaGVldHMgdXNpbmcgPGEgaHJlZj1cImh0dHA6Ly9jcmVhdGVqcy5jb20vem9lXCIgdGFyZ2V0PVwiX2JsYW5rXCI+PC9hPjwvbGk+XG4gKiA8L3VsPlxuICpcbiAqIDxoMz5Dcm9zcyBPcmlnaW4gSXNzdWVzPC9oMz5cbiAqIDxzdHJvbmc+V2FybmluZzo8L3N0cm9uZz4gSW1hZ2VzIGxvYWRlZCBjcm9zcy1vcmlnaW4gd2lsbCB0aHJvdyBjcm9zcy1vcmlnaW4gc2VjdXJpdHkgZXJyb3JzIHdoZW4gaW50ZXJhY3RlZCB3aXRoXG4gKiB1c2luZzpcbiAqIDx1bD5cbiAqICAgICA8bGk+YSBtb3VzZTwvbGk+XG4gKiAgICAgPGxpPm1ldGhvZHMgc3VjaCBhcyB7eyNjcm9zc0xpbmsgXCJDb250YWluZXIvZ2V0T2JqZWN0VW5kZXJQb2ludFwifX17ey9jcm9zc0xpbmt9fTwvbGk+XG4gKiAgICAgPGxpPkZpbHRlcnMgKHNlZSB7eyNjcm9zc0xpbmsgXCJGaWx0ZXJcIn19e3svY3Jvc3NMaW5rfX0pPC9saT5cbiAqICAgICA8bGk+Y2FjaGluZyAoc2VlIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvY2FjaGVcIn19e3svY3Jvc3NMaW5rfX0pPC9saT5cbiAqIDwvdWw+XG4gKiBZb3UgY2FuIGdldCBhcm91bmQgdGhpcyBieSBzZXR0aW5nIGBjcm9zc09yaWdpbmAgcHJvcGVydHkgb24geW91ciBpbWFnZXMgYmVmb3JlIHBhc3NpbmcgdGhlbSB0byBFYXNlbEpTLCBvclxuICogc2V0dGluZyB0aGUgYGNyb3NzT3JpZ2luYCBwcm9wZXJ0eSBvbiBQcmVsb2FkSlMnIExvYWRRdWV1ZSBvciBMb2FkSXRlbXMuXG4gKlxuICogXHRcdHZhciBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICogXHRcdGltZy5jcm9zc09yaWdpbj1cIkFub255bW91c1wiO1xuICogXHRcdGltZy5zcmMgPSBcImh0dHA6Ly9zZXJ2ZXItd2l0aC1DT1JTLXN1cHBvcnQuY29tL3BhdGgvdG8vaW1hZ2UuanBnXCI7XG4gKlxuICogSWYgeW91IHBhc3Mgc3RyaW5nIHBhdGhzIHRvIFNwcml0ZVNoZWV0cywgdGhleSB3aWxsIG5vdCB3b3JrIGNyb3NzLW9yaWdpbi4gVGhlIHNlcnZlciB0aGF0IHN0b3JlcyB0aGUgaW1hZ2UgbXVzdFxuICogc3VwcG9ydCBjcm9zcy1vcmlnaW4gcmVxdWVzdHMsIG9yIHRoaXMgd2lsbCBub3Qgd29yay4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIGNoZWNrIG91dFxuICogPGEgaHJlZj1cImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvQWNjZXNzX2NvbnRyb2xfQ09SU1wiIHRhcmdldD1cIl9ibGFua1wiPkNPUlMgb3ZlcnZpZXcgb24gTUROPC9hPi5cbiAqXG4gKiBAbWVtYmVyb2YgZWFzZWxqc1xuICogQGV4dGVuZHMgY29yZS5FdmVudERpc3BhdGNoZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIEFuIG9iamVjdCBkZXNjcmliaW5nIHRoZSBTcHJpdGVTaGVldCBkYXRhLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTcHJpdGVTaGVldCBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlciB7XG5cblx0Y29uc3RydWN0b3IgKGRhdGEpIHtcblx0XHRzdXBlcigpO1xuXG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHdoZXRoZXIgYWxsIGltYWdlcyBhcmUgZmluaXNoZWQgbG9hZGluZy5cblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKi9cblx0XHR0aGlzLmNvbXBsZXRlID0gdHJ1ZTtcblxuXHRcdC8qKlxuXHRcdCAqIFNwZWNpZmllcyB0aGUgZnJhbWVyYXRlIHRvIHVzZSBieSBkZWZhdWx0IGZvciBTcHJpdGUgaW5zdGFuY2VzIHVzaW5nIHRoZSBTcHJpdGVTaGVldC4gU2VlIHRoZSBTcHJpdGUgY2xhc3Ncblx0XHQgKiB7QGxpbmsgZWFzZWxqcy5TcHJpdGUjZnJhbWVyYXRlfSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKi9cblx0XHR0aGlzLmZyYW1lcmF0ZSA9IDA7XG5cblx0XHQvKipcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge0FycmF5fVxuXHRcdCAqL1xuXHRcdHRoaXMuX2FuaW1hdGlvbnMgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHQgKi9cblx0XHR0aGlzLl9mcmFtZXMgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHQgKi9cblx0XHR0aGlzLl9pbWFnZXMgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdFx0dGhpcy5fZGF0YSA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKi9cblx0XHR0aGlzLl9sb2FkQ291bnQgPSAwO1xuXG5cdFx0Ly8gb25seSB1c2VkIGZvciBzaW1wbGUgZnJhbWUgZGVmczpcblx0XHQvKipcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKi9cblx0XHR0aGlzLl9mcmFtZUhlaWdodCA9IDA7XG5cblx0XHQvKipcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKi9cblx0XHR0aGlzLl9mcmFtZVdpZHRoID0gMDtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqL1xuXHRcdHRoaXMuX251bUZyYW1lcyA9IDA7XG5cblx0XHQvKipcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKi9cblx0XHR0aGlzLl9yZWdYID0gMDtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqL1xuXHRcdHRoaXMuX3JlZ1kgPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICovXG5cdFx0dGhpcy5fc3BhY2luZyA9IDA7XG5cblx0XHQvKipcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKi9cblx0XHR0aGlzLl9tYXJnaW4gPSAwO1xuXG5cdFx0dGhpcy5fcGFyc2VEYXRhKGRhdGEpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYW4gYXJyYXkgb2YgYWxsIGF2YWlsYWJsZSBhbmltYXRpb24gbmFtZXMgYXZhaWxhYmxlIG9uIHRoaXMgc3ByaXRlIHNoZWV0IGFzIHN0cmluZ3MuXG5cdCAqIEB0eXBlIHtBcnJheX1cblx0ICogQHJlYWRvbmx5XG5cdCAqL1xuXHRnZXQgYW5pbWF0aW9ucyAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2FuaW1hdGlvbnMuc2xpY2UoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSB0b3RhbCBudW1iZXIgb2YgZnJhbWVzIGluIHRoZSBzcGVjaWZpZWQgYW5pbWF0aW9uLCBvciBpbiB0aGUgd2hvbGUgc3ByaXRlXG5cdCAqIHNoZWV0IGlmIHRoZSBhbmltYXRpb24gcGFyYW0gaXMgb21pdHRlZC4gUmV0dXJucyAwIGlmIHRoZSBzcHJpdGVzaGVldCByZWxpZXMgb24gY2FsY3VsYXRlZCBmcmFtZSBjb3VudHMsIGFuZFxuXHQgKiB0aGUgaW1hZ2VzIGhhdmUgbm90IGJlZW4gZnVsbHkgbG9hZGVkLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gYW5pbWF0aW9uIFRoZSBuYW1lIG9mIHRoZSBhbmltYXRpb24gdG8gZ2V0IGEgZnJhbWUgY291bnQgZm9yLlxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBudW1iZXIgb2YgZnJhbWVzIGluIHRoZSBhbmltYXRpb24sIG9yIGluIHRoZSBlbnRpcmUgc3ByaXRlIHNoZWV0IGlmIHRoZSBhbmltYXRpb24gcGFyYW0gaXMgb21pdHRlZC5cblx0ICovXG5cdGdldE51bUZyYW1lcyAoYW5pbWF0aW9uKSB7XG5cdFx0aWYgKGFuaW1hdGlvbiA9PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fZnJhbWVzID8gdGhpcy5fZnJhbWVzLmxlbmd0aCA6IHRoaXMuX251bUZyYW1lcyB8fCAwO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRsZXQgZGF0YSA9IHRoaXMuX2RhdGFbYW5pbWF0aW9uXTtcblx0XHRcdGlmIChkYXRhID09IG51bGwpIHsgcmV0dXJuIDA7IH1cblx0XHRcdGVsc2UgeyByZXR1cm4gZGF0YS5mcmFtZXMubGVuZ3RoOyB9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYW4gb2JqZWN0IGRlZmluaW5nIHRoZSBzcGVjaWZpZWQgYW5pbWF0aW9uLiBUaGUgcmV0dXJuZWQgb2JqZWN0IGNvbnRhaW5zOlxuXHQgKiA8dWw+XG5cdCAqIFx0PGxpPmZyYW1lczogYW4gYXJyYXkgb2YgdGhlIGZyYW1lIGlkcyBpbiB0aGUgYW5pbWF0aW9uPC9saT5cblx0ICogXHQ8bGk+c3BlZWQ6IHRoZSBwbGF5YmFjayBzcGVlZCBmb3IgdGhpcyBhbmltYXRpb248L2xpPlxuXHQgKiBcdDxsaT5uYW1lOiB0aGUgbmFtZSBvZiB0aGUgYW5pbWF0aW9uPC9saT5cblx0ICogXHQ8bGk+bmV4dDogdGhlIGRlZmF1bHQgYW5pbWF0aW9uIHRvIHBsYXkgbmV4dC4gSWYgdGhlIGFuaW1hdGlvbiBsb29wcywgdGhlIG5hbWUgYW5kIG5leHQgcHJvcGVydHkgd2lsbCBiZSB0aGUgc2FtZS48L2xpPlxuXHQgKiA8L3VsPlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgYW5pbWF0aW9uIHRvIGdldC5cblx0ICogQHJldHVybiB7T2JqZWN0fSBhIGdlbmVyaWMgb2JqZWN0IHdpdGggZnJhbWVzLCBzcGVlZCwgbmFtZSwgYW5kIG5leHQgcHJvcGVydGllcy5cblx0ICovXG5cdGdldEFuaW1hdGlvbiAobmFtZSkge1xuXHRcdHJldHVybiB0aGlzLl9kYXRhW25hbWVdO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYW4gb2JqZWN0IHNwZWNpZnlpbmcgdGhlIGltYWdlIGFuZCBzb3VyY2UgcmVjdCBvZiB0aGUgc3BlY2lmaWVkIGZyYW1lLiBUaGUgcmV0dXJuZWQgb2JqZWN0IGhhczpcblx0ICogPHVsPlxuXHQgKiBcdDxsaT5hbiBpbWFnZSBwcm9wZXJ0eSBob2xkaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBpbWFnZSBvYmplY3QgaW4gd2hpY2ggdGhlIGZyYW1lIGlzIGZvdW5kPC9saT5cblx0ICogXHQ8bGk+YSByZWN0IHByb3BlcnR5IGNvbnRhaW5pbmcgYSBSZWN0YW5nbGUgaW5zdGFuY2Ugd2hpY2ggZGVmaW5lcyB0aGUgYm91bmRhcmllcyBmb3IgdGhlIGZyYW1lIHdpdGhpbiB0aGF0IGltYWdlLjwvbGk+XG5cdCAqIFx0PGxpPiBBIHJlZ1ggYW5kIHJlZ1kgcHJvcGVydHkgY29ycmVzcG9uZGluZyB0byB0aGUgcmVnWC9ZIHZhbHVlcyBmb3IgdGhlIGZyYW1lLlxuXHQgKiA8L3VsPlxuXHQgKiBAcGFyYW0ge051bWJlcn0gZnJhbWVJbmRleCBUaGUgaW5kZXggb2YgdGhlIGZyYW1lLlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IGEgZ2VuZXJpYyBvYmplY3Qgd2l0aCBpbWFnZSBhbmQgcmVjdCBwcm9wZXJ0aWVzLiBSZXR1cm5zIG51bGwgaWYgdGhlIGZyYW1lIGRvZXMgbm90IGV4aXN0LlxuXHQgKi9cblx0Z2V0RnJhbWUgKGZyYW1lSW5kZXgpIHtcblx0XHRsZXQgZnJhbWU7XG5cdFx0aWYgKHRoaXMuX2ZyYW1lcyAmJiAoZnJhbWUgPSB0aGlzLl9mcmFtZXNbZnJhbWVJbmRleF0pKSB7IHJldHVybiBmcmFtZTsgfVxuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSB7QGxpbmsgZWFzZWxqcy5SZWN0YW5nbGV9IGluc3RhbmNlIGRlZmluaW5nIHRoZSBib3VuZHMgb2YgdGhlIHNwZWNpZmllZCBmcmFtZSByZWxhdGl2ZVxuXHQgKiB0byB0aGUgb3JpZ2luLlxuXHQgKlxuXHQgKiBAcGFyYW0ge051bWJlcn0gZnJhbWVJbmRleCBUaGUgaW5kZXggb2YgdGhlIGZyYW1lLlxuXHQgKiBAcGFyYW0ge2Vhc2VsanMuUmVjdGFuZ2xlfSBbcmVjdGFuZ2xlXSBBIFJlY3RhbmdsZSBpbnN0YW5jZSB0byBjb3B5IHRoZSB2YWx1ZXMgaW50by4gQnkgZGVmYXVsdCBhIG5ldyBpbnN0YW5jZSBpcyBjcmVhdGVkLlxuXHQgKiBAcmV0dXJuIHtlYXNlbGpzLlJlY3RhbmdsZX0gQSBSZWN0YW5nbGUgaW5zdGFuY2UuIFJldHVybnMgbnVsbCBpZiB0aGUgZnJhbWUgZG9lcyBub3QgZXhpc3QsIG9yIHRoZSBpbWFnZSBpcyBub3QgZnVsbHkgbG9hZGVkLlxuXHQgKi9cblx0Z2V0RnJhbWVCb3VuZHMgKGZyYW1lSW5kZXgsIHJlY3RhbmdsZSA9IG5ldyBSZWN0YW5nbGUoKSkge1xuXHRcdGxldCBmcmFtZSA9IHRoaXMuZ2V0RnJhbWUoZnJhbWVJbmRleCk7XG5cdFx0cmV0dXJuIGZyYW1lID8gcmVjdGFuZ2xlLnNldFZhbHVlcygtZnJhbWUucmVnWCwgLWZyYW1lLnJlZ1ksIGZyYW1lLnJlY3Qud2lkdGgsIGZyYW1lLnJlY3QuaGVpZ2h0KSA6IG51bGw7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXG5cdCAqL1xuXHR0b1N0cmluZyAoKSB7XG5cdFx0cmV0dXJuIGBbJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9XWA7XG5cdH1cblxuXHQvKipcblx0ICogU3ByaXRlU2hlZXQgY2Fubm90IGJlIGNsb25lZC4gQSBTcHJpdGVTaGVldCBjYW4gYmUgc2hhcmVkIGJ5IG11bHRpcGxlIFNwcml0ZSBpbnN0YW5jZXMgd2l0aG91dCBjbG9uaW5nIGl0LlxuXHQgKiBAb3ZlcnJpZGVcblx0ICogQHRocm93cyBTcHJpdGVTaGVldCBjYW5ub3QgYmUgY2xvbmVkLlxuXHQgKi9cblx0Y2xvbmUgKCkge1xuXHRcdHRocm93IFwiU3ByaXRlU2hlZXQgY2Fubm90IGJlIGNsb25lZC5cIjtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBBbiBvYmplY3QgZGVzY3JpYmluZyB0aGUgU3ByaXRlU2hlZXQgZGF0YS5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0X3BhcnNlRGF0YSAoZGF0YSkge1xuXHRcdGlmIChkYXRhID09IG51bGwpIHsgcmV0dXJuOyB9XG5cdFx0dGhpcy5mcmFtZXJhdGUgPSBkYXRhLmZyYW1lcmF0ZXx8MDtcblxuXHRcdC8vIHBhcnNlIGltYWdlczpcblx0XHRpZiAoZGF0YS5pbWFnZXMpIHtcblx0XHRcdGZvciAobGV0IGltZyBvZiBkYXRhLmltYWdlcykge1xuXHRcdFx0XHRsZXQgYSA9IHRoaXMuX2ltYWdlcyA9IFtdO1xuXHRcdFx0XHRsZXQgc3JjO1xuXHRcdFx0XHRpZiAodHlwZW9mIGltZyA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRcdHNyYyA9IGltZztcblx0XHRcdFx0XHRpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuXHRcdFx0XHRcdGltZy5zcmMgPSBzcmM7XG5cdFx0XHRcdH1cblx0XHRcdFx0YS5wdXNoKGltZyk7XG5cdFx0XHRcdGlmICghaW1nLmdldENvbnRleHQgJiYgIWltZy5uYXR1cmFsV2lkdGgpIHtcblx0XHRcdFx0XHR0aGlzLl9sb2FkQ291bnQrKztcblx0XHRcdFx0XHR0aGlzLmNvbXBsZXRlID0gZmFsc2U7XG5cdFx0XHRcdFx0aW1nLm9ubG9hZCA9ICgpID0+IHRoaXMuX2hhbmRsZUltYWdlTG9hZChzcmMpO1xuXHRcdFx0XHRcdGltZy5vbmVycm9yID0gKCkgPT4gdGhpcy5faGFuZGxlSW1hZ2VFcnJvcihzcmMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gcGFyc2UgZnJhbWVzOlxuXHRcdGlmIChkYXRhLmZyYW1lcyAhPSBudWxsKSB7XG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShkYXRhLmZyYW1lcykpIHtcblx0XHRcdFx0dGhpcy5fZnJhbWVzID0gW107XG5cdFx0XHRcdGZvciAobGV0IGFyciBvZiBkYXRhLmZyYW1lcykge1xuXHRcdFx0XHRcdHRoaXMuX2ZyYW1lcy5wdXNoKHtpbWFnZTp0aGlzLl9pbWFnZXNbYXJyWzRdP2Fycls0XTowXSwgcmVjdDpuZXcgUmVjdGFuZ2xlKGFyclswXSxhcnJbMV0sYXJyWzJdLGFyclszXSksIHJlZ1g6YXJyWzVdfHwwLCByZWdZOmFycls2XXx8MCB9KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bGV0IG8gPSBkYXRhLmZyYW1lcztcblx0XHRcdFx0dGhpcy5fZnJhbWVXaWR0aCA9IG8ud2lkdGg7XG5cdFx0XHRcdHRoaXMuX2ZyYW1lSGVpZ2h0ID0gby5oZWlnaHQ7XG5cdFx0XHRcdHRoaXMuX3JlZ1ggPSBvLnJlZ1h8fDA7XG5cdFx0XHRcdHRoaXMuX3JlZ1kgPSBvLnJlZ1l8fDA7XG5cdFx0XHRcdHRoaXMuX3NwYWNpbmcgPSBvLnNwYWNpbmd8fDA7XG5cdFx0XHRcdHRoaXMuX21hcmdpbiA9IG8ubWFyZ2lufHwwO1xuXHRcdFx0XHR0aGlzLl9udW1GcmFtZXMgPSBvLmNvdW50O1xuXHRcdFx0XHRpZiAodGhpcy5fbG9hZENvdW50ID09PSAwKSB7IHRoaXMuX2NhbGN1bGF0ZUZyYW1lcygpOyB9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gcGFyc2UgYW5pbWF0aW9uczpcblx0XHR0aGlzLl9hbmltYXRpb25zID0gW107XG5cdFx0aWYgKGRhdGEuYW5pbWF0aW9ucyAhPSBudWxsKSB7XG5cdFx0XHR0aGlzLl9kYXRhID0ge307XG5cdFx0XHRsZXQgbyA9IGRhdGEuYW5pbWF0aW9ucztcblx0XHRcdGZvciAobGV0IG5hbWUgaW4gbykge1xuXHRcdFx0XHRsZXQgYW5pbSA9IHsgbmFtZSB9O1xuXHRcdFx0XHRsZXQgb2JqID0gb1tuYW1lXTtcblx0XHRcdFx0bGV0IGE7XG5cdFx0XHRcdGlmICh0eXBlb2Ygb2JqID09PSBcIm51bWJlclwiKSB7IC8vIHNpbmdsZSBmcmFtZVxuXHRcdFx0XHRcdGEgPSBhbmltLmZyYW1lcyA9IFtvYmpdO1xuXHRcdFx0XHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkgeyAvLyBzaW1wbGVcblx0XHRcdFx0XHRpZiAob2JqLmxlbmd0aCA9PT0gMSkgeyBhbmltLmZyYW1lcyA9IFtvYmpbMF1dOyB9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRhbmltLnNwZWVkID0gb2JqWzNdO1xuXHRcdFx0XHRcdFx0YW5pbS5uZXh0ID0gb2JqWzJdO1xuXHRcdFx0XHRcdFx0YSA9IGFuaW0uZnJhbWVzID0gW107XG5cdFx0XHRcdFx0XHRmb3IgKGxldCBpPW9ialswXTtpPD1vYmpbMV07aSsrKSB7XG5cdFx0XHRcdFx0XHRcdGEucHVzaChpKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7IC8vIGNvbXBsZXhcblx0XHRcdFx0XHRhbmltLnNwZWVkID0gb2JqLnNwZWVkO1xuXHRcdFx0XHRcdGFuaW0ubmV4dCA9IG9iai5uZXh0O1xuXHRcdFx0XHRcdGxldCBmcmFtZXMgPSBvYmouZnJhbWVzO1xuXHRcdFx0XHRcdGEgPSBhbmltLmZyYW1lcyA9ICh0eXBlb2YgZnJhbWVzID09PSBcIm51bWJlclwiKSA/IFtmcmFtZXNdIDogZnJhbWVzLnNsaWNlKDApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChhbmltLm5leHQgPT09IHRydWUgfHwgYW5pbS5uZXh0ID09PSB1bmRlZmluZWQpIHsgYW5pbS5uZXh0ID0gbmFtZTsgfSAvLyBsb29wXG5cdFx0XHRcdGlmIChhbmltLm5leHQgPT09IGZhbHNlIHx8IChhLmxlbmd0aCA8IDIgJiYgYW5pbS5uZXh0ID09PSBuYW1lKSkgeyBhbmltLm5leHQgPSBudWxsOyB9IC8vIHN0b3Bcblx0XHRcdFx0aWYgKCFhbmltLnNwZWVkKSB7IGFuaW0uc3BlZWQgPSAxOyB9XG5cdFx0XHRcdHRoaXMuX2FuaW1hdGlvbnMucHVzaChuYW1lKTtcblx0XHRcdFx0dGhpcy5fZGF0YVtuYW1lXSA9IGFuaW07XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBlbWl0cyBlYXNlbGpzLlNwcml0ZVNoZWV0I2V2ZW50OmNvbXBsZXRlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHBhcmFtIHtPYmplY3R9IHNyY1xuXHQgKi9cblx0IF9oYW5kbGVJbWFnZUxvYWQgKHNyYykge1xuXHRcdGlmICgtLXRoaXMuX2xvYWRDb3VudCA9PT0gMCkge1xuXHRcdFx0dGhpcy5fY2FsY3VsYXRlRnJhbWVzKCk7XG5cdFx0XHR0aGlzLmNvbXBsZXRlID0gdHJ1ZTtcblx0XHRcdHRoaXMuZGlzcGF0Y2hFdmVudChcImNvbXBsZXRlXCIpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAZW1pdHMgZWFzZWxqcy5TcHJpdGVTaGVldCNldmVudDpjb21wbGV0ZVxuXHQgKiBAZW1pdHMgZWFzZWxqcy5TcHJpdGVTaGVldCNldmVudDplcnJvclxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzcmNcblx0ICovXG5cdF9oYW5kbGVJbWFnZUVycm9yIChzcmMpIHtcblx0XHRsZXQgZXJyb3JFdmVudCA9IG5ldyBFdmVudChcImVycm9yXCIpO1xuXHRcdGVycm9yRXZlbnQuc3JjID0gc3JjO1xuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChlcnJvckV2ZW50KTtcblxuXHRcdC8vIENvbXBsZXRlIGlzIHN0aWxsIGRpc3BhdGNoZWQuXG5cdFx0aWYgKC0tdGhpcy5fbG9hZENvdW50ID09PSAwKSB7XG5cdFx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoXCJjb21wbGV0ZVwiKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0X2NhbGN1bGF0ZUZyYW1lcyAoKSB7XG5cdFx0aWYgKHRoaXMuX2ZyYW1lcyB8fCB0aGlzLl9mcmFtZVdpZHRoID09PSAwKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fZnJhbWVzID0gW107XG5cblx0XHRsZXQgbWF4RnJhbWVzID0gdGhpcy5fbnVtRnJhbWVzIHx8IDEwMDAwMDsgLy8gaWYgd2UgZ28gb3ZlciB0aGlzLCBzb21ldGhpbmcgaXMgd3JvbmcuXG5cdFx0bGV0IGZyYW1lQ291bnQgPSAwLCBmcmFtZVdpZHRoID0gdGhpcy5fZnJhbWVXaWR0aCwgZnJhbWVIZWlnaHQgPSB0aGlzLl9mcmFtZUhlaWdodDtcblx0XHRsZXQgc3BhY2luZyA9IHRoaXMuX3NwYWNpbmcsIG1hcmdpbiA9IHRoaXMuX21hcmdpbjtcblxuXHRcdGltZ0xvb3A6XG5cdFx0Zm9yIChsZXQgaT0wLCBpbWdzPXRoaXMuX2ltYWdlcywgbD1pbWdzLmxlbmd0aDsgaTxsOyBpKyspIHtcblx0XHRcdGxldCBpbWcgPSBpbWdzW2ldLFxuXHRcdFx0XHRpbWdXID0gKGltZy53aWR0aHx8aW1nLm5hdHVyYWxXaWR0aCksXG5cdFx0XHRcdGltZ0ggPSAoaW1nLmhlaWdodHx8aW1nLm5hdHVyYWxIZWlnaHQpO1xuXG5cdFx0XHRsZXQgeSA9IG1hcmdpbjtcblx0XHRcdHdoaWxlICh5IDw9IGltZ0gtbWFyZ2luLWZyYW1lSGVpZ2h0KSB7XG5cdFx0XHRcdGxldCB4ID0gbWFyZ2luO1xuXHRcdFx0XHR3aGlsZSAoeCA8PSBpbWdXLW1hcmdpbi1mcmFtZVdpZHRoKSB7XG5cdFx0XHRcdFx0aWYgKGZyYW1lQ291bnQgPj0gbWF4RnJhbWVzKSB7IGJyZWFrIGltZ0xvb3A7IH1cblx0XHRcdFx0XHRmcmFtZUNvdW50Kys7XG5cdFx0XHRcdFx0dGhpcy5fZnJhbWVzLnB1c2goe1xuXHRcdFx0XHRcdFx0aW1hZ2U6IGltZyxcblx0XHRcdFx0XHRcdHJlY3Q6IG5ldyBSZWN0YW5nbGUoeCwgeSwgZnJhbWVXaWR0aCwgZnJhbWVIZWlnaHQpLFxuXHRcdFx0XHRcdFx0cmVnWDogdGhpcy5fcmVnWCxcblx0XHRcdFx0XHRcdHJlZ1k6IHRoaXMuX3JlZ1lcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR4ICs9IGZyYW1lV2lkdGgrc3BhY2luZztcblx0XHRcdFx0fVxuXHRcdFx0XHR5ICs9IGZyYW1lSGVpZ2h0K3NwYWNpbmc7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMuX251bUZyYW1lcyA9IGZyYW1lQ291bnQ7XG5cdH1cblxufVxuXG4vKipcbiAqIERpc3BhdGNoZWQgd2hlbiBhbGwgaW1hZ2VzIGFyZSBsb2FkZWQuICBOb3RlIHRoYXQgdGhpcyBvbmx5IGZpcmVzIGlmIHRoZSBpbWFnZXNcbiAqIHdlcmUgbm90IGZ1bGx5IGxvYWRlZCB3aGVuIHRoZSBzcHJpdGUgc2hlZXQgd2FzIGluaXRpYWxpemVkLiBZb3Ugc2hvdWxkIGNoZWNrIHRoZSBjb21wbGV0ZSBwcm9wZXJ0eVxuICogdG8gcHJpb3IgdG8gYWRkaW5nIGEgbGlzdGVuZXIuIEV4LlxuICpcbiAqIFx0dmFyIHNoZWV0ID0gbmV3IGNyZWF0ZWpzLlNwcml0ZVNoZWV0KGRhdGEpO1xuICogXHRpZiAoIXNoZWV0LmNvbXBsZXRlKSB7XG4gKiBcdFx0Ly8gbm90IHByZWxvYWRlZCwgbGlzdGVuIGZvciB0aGUgY29tcGxldGUgZXZlbnQ6XG4gKiBcdFx0c2hlZXQuYWRkRXZlbnRMaXN0ZW5lcihcImNvbXBsZXRlXCIsIGhhbmRsZXIpO1xuICogXHR9XG4gKlxuICogQGV2ZW50IGVhc2VsanMuU3ByaXRlU2hlZXQjY29tcGxldGVcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSB0YXJnZXQgVGhlIG9iamVjdCB0aGF0IGRpc3BhdGNoZWQgdGhlIGV2ZW50LlxuICogQHByb3BlcnR5IHtTdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGUuXG4gKiBAc2luY2UgMC42LjBcbiAqL1xuXG4vKipcbiAqIERpc3BhdGNoZWQgd2hlbiBnZXRGcmFtZSBpcyBjYWxsZWQgd2l0aCBhIHZhbGlkIGZyYW1lIGluZGV4LiBUaGlzIGlzIHByaW1hcmlseSBpbnRlbmRlZCBmb3IgdXNlIGJ5IHtAbGluayBlYXNlbGpzLlNwcml0ZVNoZWV0QnVpbGRlcn1cbiAqIHdoZW4gZG9pbmcgb24tZGVtYW5kIHJlbmRlcmluZy5cbiAqIEBldmVudCBlYXNlbGpzLlNwcml0ZVNoZWV0I2dldGZyYW1lXG4gKiBAcHJvcGVydHkge051bWJlcn0gaW5kZXggVGhlIGZyYW1lIGluZGV4LlxuICogQHByb3BlcnR5IHtPYmplY3R9IGZyYW1lIFRoZSBmcmFtZSBvYmplY3QgdGhhdCBnZXRGcmFtZSB3aWxsIHJldHVybi5cbiAqL1xuXG4vKipcbiAqIERpc3BhdGNoZWQgd2hlbiBhbiBpbWFnZSBlbmNvdW50ZXJzIGFuIGVycm9yLiBBIFNwcml0ZVNoZWV0IHdpbGwgZGlzcGF0Y2ggYW4gZXJyb3IgZXZlbnQgZm9yIGVhY2ggaW1hZ2UgdGhhdFxuICogZW5jb3VudGVycyBhbiBlcnJvciwgYW5kIHdpbGwgc3RpbGwgZGlzcGF0Y2ggYSB7QGxpbmsgZWFzZWxqcy5TcHJpdGVTaGVldCNldmVudDpjb21wbGV0ZX1cbiAqIGV2ZW50IG9uY2UgYWxsIGltYWdlcyBhcmUgZmluaXNoZWQgcHJvY2Vzc2luZywgZXZlbiBpZiBhbiBlcnJvciBpcyBlbmNvdW50ZXJlZC5cbiAqIEBldmVudCBlYXNlbGpzLlNwcml0ZVNoZWV0I2Vycm9yXG4gKiBAcHJvcGVydHkge1N0cmluZ30gc3JjIFRoZSBzb3VyY2Ugb2YgdGhlIGltYWdlIHRoYXQgZmFpbGVkIHRvIGxvYWQuXG4gKiBAc2luY2UgMC44LjJcbiAqL1xuIiwiLyoqXG4gKiBAbGljZW5zZSBUZXh0XG4gKiBWaXNpdCBodHRwOi8vY3JlYXRlanMuY29tLyBmb3IgZG9jdW1lbnRhdGlvbiwgdXBkYXRlcyBhbmQgZXhhbXBsZXMuXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IGdza2lubmVyLmNvbSwgaW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gKiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxuICogZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0XG4gKiByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSxcbiAqIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiAqIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXG4gKiBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gKiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICogRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTXG4gKiBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICogTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcbiAqIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLFxuICogV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4gKiBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SXG4gKiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gKi9cblxuaW1wb3J0IERpc3BsYXlPYmplY3QgZnJvbSBcIi4vRGlzcGxheU9iamVjdFwiO1xuaW1wb3J0IGNyZWF0ZUNhbnZhcyBmcm9tIFwiLi4vdXRpbHMvQ2FudmFzXCI7XG5cbi8qKlxuICogRGlzcGxheSBvbmUgb3IgbW9yZSBsaW5lcyBvZiBkeW5hbWljIHRleHQgKG5vdCB1c2VyIGVkaXRhYmxlKSBpbiB0aGUgZGlzcGxheSBsaXN0LiBMaW5lIHdyYXBwaW5nIHN1cHBvcnQgKHVzaW5nIHRoZVxuICogbGluZVdpZHRoKSBpcyB2ZXJ5IGJhc2ljLCB3cmFwcGluZyBvbiBzcGFjZXMgYW5kIHRhYnMgb25seS4gTm90ZSB0aGF0IGFzIGFuIGFsdGVybmF0aXZlIHRvIFRleHQsIHlvdSBjYW4gcG9zaXRpb24gSFRNTFxuICogdGV4dCBhYm92ZSBvciBiZWxvdyB0aGUgY2FudmFzIHJlbGF0aXZlIHRvIGl0ZW1zIGluIHRoZSBkaXNwbGF5IGxpc3QgdXNpbmcgdGhlIHtAbGluayBlYXNlbGpzLkRpc3BsYXlPYmplY3QjbG9jYWxUb0dsb2JhbH1cbiAqIG1ldGhvZCwgb3IgdXNpbmcge0BsaW5rIGVhc2VsanMuRE9NRWxlbWVudH0uXG4gKlxuICogPGI+UGxlYXNlIG5vdGUgdGhhdCBUZXh0IGRvZXMgbm90IHN1cHBvcnQgSFRNTCB0ZXh0LCBhbmQgY2FuIG9ubHkgZGlzcGxheSBvbmUgZm9udCBzdHlsZSBhdCBhIHRpbWUuPC9iPiBUbyB1c2VcbiAqIG11bHRpcGxlIGZvbnQgc3R5bGVzLCB5b3Ugd2lsbCBuZWVkIHRvIGNyZWF0ZSBtdWx0aXBsZSB0ZXh0IGluc3RhbmNlcywgYW5kIHBvc2l0aW9uIHRoZW0gbWFudWFsbHkuXG4gKlxuICogQ3JlYXRlSlMgVGV4dCBzdXBwb3J0cyB3ZWIgZm9udHMgKHRoZSBzYW1lIHJ1bGVzIGFzIENhbnZhcykuIFRoZSBmb250IG11c3QgYmUgbG9hZGVkIGFuZCBzdXBwb3J0ZWQgYnkgdGhlIGJyb3dzZXJcbiAqIGJlZm9yZSBpdCBjYW4gYmUgZGlzcGxheWVkLlxuICpcbiAqIDxzdHJvbmc+Tm90ZTo8L3N0cm9uZz4gVGV4dCBjYW4gYmUgZXhwZW5zaXZlIHRvIGdlbmVyYXRlLCBzbyBjYWNoZSBpbnN0YW5jZXMgd2hlcmUgcG9zc2libGUuIEJlIGF3YXJlIHRoYXQgbm90IGFsbFxuICogYnJvd3NlcnMgd2lsbCByZW5kZXIgVGV4dCBleGFjdGx5IHRoZSBzYW1lLlxuICpcbiAqIEBtZW1iZXJvZiBlYXNlbGpzXG4gKiBAZXh0ZW5kcyBlYXNlbGpzLkRpc3BsYXlPYmplY3RcbiAqIEBleGFtcGxlXG4gKiBsZXQgdGV4dCA9IG5ldyBUZXh0KFwiSGVsbG8gV29ybGRcIiwgXCIyMHB4IEFyaWFsXCIsIFwiI2ZmNzcwMFwiKTtcbiAqIHRleHQueCA9IDEwMDtcbiAqIHRleHQudGV4dEJhc2VsaW5lID0gXCJhbHBoYWJldGljXCI7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFt0ZXh0XSBUaGUgdGV4dCB0byBkaXNwbGF5LlxuICogQHBhcmFtIHtTdHJpbmd9IFtmb250XSBUaGUgZm9udCBzdHlsZSB0byB1c2UuIEFueSB2YWxpZCB2YWx1ZSBmb3IgdGhlIENTUyBmb250IGF0dHJpYnV0ZSBpcyBhY2NlcHRhYmxlIChleC4gXCJib2xkXG4gKiAzNnB4IEFyaWFsXCIpLlxuICogQHBhcmFtIHtTdHJpbmd9IFtjb2xvcl0gVGhlIGNvbG9yIHRvIGRyYXcgdGhlIHRleHQgaW4uIEFueSB2YWxpZCB2YWx1ZSBmb3IgdGhlIENTUyBjb2xvciBhdHRyaWJ1dGUgaXMgYWNjZXB0YWJsZSAoZXguXG4gKiBcIiNGMDBcIiwgXCJyZWRcIiwgb3IgXCIjRkYwMDAwXCIpLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZXh0IGV4dGVuZHMgRGlzcGxheU9iamVjdCB7XG5cblx0Y29uc3RydWN0b3IgKHRleHQsIGZvbnQsIGNvbG9yKSB7XG5cdFx0c3VwZXIoKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSB0ZXh0IHRvIGRpc3BsYXkuXG5cdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHQgKi9cblx0XHR0aGlzLnRleHQgPSB0ZXh0O1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGZvbnQgc3R5bGUgdG8gdXNlLiBBbnkgdmFsaWQgdmFsdWUgZm9yIHRoZSBDU1MgZm9udCBhdHRyaWJ1dGUgaXMgYWNjZXB0YWJsZSAoZXguIFwiYm9sZCAzNnB4IEFyaWFsXCIpLlxuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICovXG5cdFx0dGhpcy5mb250ID0gZm9udDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBjb2xvciB0byBkcmF3IHRoZSB0ZXh0IGluLiBBbnkgdmFsaWQgdmFsdWUgZm9yIHRoZSBDU1MgY29sb3IgYXR0cmlidXRlIGlzIGFjY2VwdGFibGUgKGV4LiBcIiNGMDBcIikuIERlZmF1bHQgaXMgXCIjMDAwXCIuXG5cdFx0ICogSXQgd2lsbCBhbHNvIGFjY2VwdCB2YWxpZCBjYW52YXMgZmlsbFN0eWxlIHZhbHVlcy5cblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxuXHRcdCAqL1xuXHRcdHRoaXMuY29sb3IgPSBjb2xvcjtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBob3Jpem9udGFsIHRleHQgYWxpZ25tZW50LiBBbnkgb2YgXCJzdGFydFwiLCBcImVuZFwiLCBcImxlZnRcIiwgXCJyaWdodFwiLCBhbmQgXCJjZW50ZXJcIi5cblx0XHQgKiBAc2VlIHtAbGluayBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aGUtY2FudmFzLWVsZW1lbnQuaHRtbCN0ZXh0LXN0eWxlcyBcIldIQVRXRyBzcGVjXCJ9XG5cdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHQgKiBAZGVmYXVsdCBsZWZ0XG5cdFx0ICovXG5cdFx0dGhpcy50ZXh0QWxpZ24gPSBcImxlZnRcIjtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSB2ZXJ0aWNhbCBhbGlnbm1lbnQgcG9pbnQgb24gdGhlIGZvbnQuIEFueSBvZiBcInRvcFwiLCBcImhhbmdpbmdcIiwgXCJtaWRkbGVcIiwgXCJhbHBoYWJldGljXCIsIFwiaWRlb2dyYXBoaWNcIiwgb3IgXCJib3R0b21cIi5cblx0XHQgKiBAc2VlIHtAbGluayBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aGUtY2FudmFzLWVsZW1lbnQuaHRtbCN0ZXh0LXN0eWxlcyBcIldIQVRXRyBzcGVjXCJ9XG5cdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHQgKiBAZGVmYXVsdCB0b3Bcblx0XHQqL1xuXHRcdHRoaXMudGV4dEJhc2VsaW5lID0gXCJ0b3BcIjtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBtYXhpbXVtIHdpZHRoIHRvIGRyYXcgdGhlIHRleHQuIElmIG1heFdpZHRoIGlzIHNwZWNpZmllZCAobm90IG51bGwpLCB0aGUgdGV4dCB3aWxsIGJlIGNvbmRlbnNlZCBvclxuXHRcdCAqIHNocnVuayB0byBtYWtlIGl0IGZpdCBpbiB0aGlzIHdpZHRoLlxuXHRcdCAqIEBzZWUge0BsaW5rIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3RoZS1jYW52YXMtZWxlbWVudC5odG1sI3RleHQtc3R5bGVzIFwiV0hBVFdHIHNwZWNcIn1cblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCovXG5cdFx0dGhpcy5tYXhXaWR0aCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBJZiBncmVhdGVyIHRoYW4gMCwgdGhlIHRleHQgd2lsbCBiZSBkcmF3biBhcyBhIHN0cm9rZSAob3V0bGluZSkgb2YgdGhlIHNwZWNpZmllZCB3aWR0aC5cblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqL1xuXHRcdHRoaXMub3V0bGluZSA9IDA7XG5cblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgdGhlIGxpbmUgaGVpZ2h0ICh2ZXJ0aWNhbCBkaXN0YW5jZSBiZXR3ZWVuIGJhc2VsaW5lcykgZm9yIG11bHRpLWxpbmUgdGV4dC4gSWYgbnVsbCBvciAwLFxuXHRcdCAqIHRoZSB2YWx1ZSBvZiBnZXRNZWFzdXJlZExpbmVIZWlnaHQgaXMgdXNlZC5cblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKi9cblx0XHR0aGlzLmxpbmVIZWlnaHQgPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHRoZSBtYXhpbXVtIHdpZHRoIGZvciBhIGxpbmUgb2YgdGV4dCBiZWZvcmUgaXQgaXMgd3JhcHBlZCB0byBtdWx0aXBsZSBsaW5lcy4gSWYgbnVsbCxcblx0XHQgKiB0aGUgdGV4dCB3aWxsIG5vdCBiZSB3cmFwcGVkLlxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICovXG5cdFx0dGhpcy5saW5lV2lkdGggPSBudWxsO1xuXHR9XG5cbiBcdGlzVmlzaWJsZSAoKSB7XG4gXHRcdGxldCBoYXNDb250ZW50ID0gdGhpcy5jYWNoZUNhbnZhcyB8fCAodGhpcy50ZXh0ICE9IG51bGwgJiYgdGhpcy50ZXh0ICE9PSBcIlwiKTtcbiBcdFx0cmV0dXJuICEhKHRoaXMudmlzaWJsZSAmJiB0aGlzLmFscGhhID4gMCAmJiB0aGlzLnNjYWxlWCAhPSAwICYmIHRoaXMuc2NhbGVZICE9IDAgJiYgaGFzQ29udGVudCk7XG4gXHR9XG5cbiBcdGRyYXcgKGN0eCwgaWdub3JlQ2FjaGUpIHtcbiBcdFx0aWYgKHN1cGVyLmRyYXcoY3R4LCBpZ25vcmVDYWNoZSkpIHsgcmV0dXJuIHRydWU7IH1cblxuIFx0XHRsZXQgY29sID0gdGhpcy5jb2xvciB8fCBcIiMwMDBcIjtcbiBcdFx0aWYgKHRoaXMub3V0bGluZSkgeyBjdHguc3Ryb2tlU3R5bGUgPSBjb2w7IGN0eC5saW5lV2lkdGggPSB0aGlzLm91dGxpbmUqMTsgfVxuIFx0XHRlbHNlIHsgY3R4LmZpbGxTdHlsZSA9IGNvbDsgfVxuXG4gXHRcdHRoaXMuX2RyYXdUZXh0KHRoaXMuX3ByZXBDb250ZXh0KGN0eCkpO1xuIFx0XHRyZXR1cm4gdHJ1ZTtcbiBcdH1cblxuIFx0LyoqXG4gXHQgKiBSZXR1cm5zIHRoZSBtZWFzdXJlZCwgdW50cmFuc2Zvcm1lZCB3aWR0aCBvZiB0aGUgdGV4dCB3aXRob3V0IHdyYXBwaW5nLiBVc2UgZ2V0Qm91bmRzIGZvciBhIG1vcmUgcm9idXN0IHZhbHVlLlxuIFx0ICogQHJldHVybiB7TnVtYmVyfSBUaGUgbWVhc3VyZWQsIHVudHJhbnNmb3JtZWQgd2lkdGggb2YgdGhlIHRleHQuXG4gXHQgKi9cbiBcdGdldE1lYXN1cmVkV2lkdGggKCkge1xuIFx0XHRyZXR1cm4gdGhpcy5fZ2V0TWVhc3VyZWRXaWR0aCh0aGlzLnRleHQpO1xuIFx0fVxuXG4gXHQvKipcbiBcdCAqIFJldHVybnMgYW4gYXBwcm94aW1hdGUgbGluZSBoZWlnaHQgb2YgdGhlIHRleHQsIGlnbm9yaW5nIHRoZSBsaW5lSGVpZ2h0IHByb3BlcnR5LiBUaGlzIGlzIGJhc2VkIG9uIHRoZSBtZWFzdXJlZFxuIFx0ICogd2lkdGggb2YgYSBcIk1cIiBjaGFyYWN0ZXIgbXVsdGlwbGllZCBieSAxLjIsIHdoaWNoIHByb3ZpZGVzIGFuIGFwcHJveGltYXRlIGxpbmUgaGVpZ2h0IGZvciBtb3N0IGZvbnRzLlxuIFx0ICogQHJldHVybiB7TnVtYmVyfSBhbiBhcHByb3hpbWF0ZSBsaW5lIGhlaWdodCBvZiB0aGUgdGV4dCwgaWdub3JpbmcgdGhlIGxpbmVIZWlnaHQgcHJvcGVydHkuIFRoaXMgaXNcbiBcdCAqIGJhc2VkIG9uIHRoZSBtZWFzdXJlZCB3aWR0aCBvZiBhIFwiTVwiIGNoYXJhY3RlciBtdWx0aXBsaWVkIGJ5IDEuMiwgd2hpY2ggYXBwcm94aW1hdGVzIGVtIGZvciBtb3N0IGZvbnRzLlxuIFx0ICovXG4gXHRnZXRNZWFzdXJlZExpbmVIZWlnaHQgKCkge1xuIFx0XHRyZXR1cm4gdGhpcy5fZ2V0TWVhc3VyZWRXaWR0aChcIk1cIikqMS4yO1xuIFx0fVxuXG4gXHQvKipcbiBcdCAqIFJldHVybnMgdGhlIGFwcHJveGltYXRlIGhlaWdodCBvZiBtdWx0aS1saW5lIHRleHQgYnkgbXVsdGlwbHlpbmcgdGhlIG51bWJlciBvZiBsaW5lcyBhZ2FpbnN0IGVpdGhlciB0aGVcbiBcdCAqIGBsaW5lSGVpZ2h0YCAoaWYgc3BlY2lmaWVkKSBvciB7QGxpbmsgZWFzZWxqcy5UZXh0I2dldE1lYXN1cmVkTGluZUhlaWdodH0uIE5vdGUgdGhhdFxuIFx0ICogdGhpcyBvcGVyYXRpb24gcmVxdWlyZXMgdGhlIHRleHQgZmxvd2luZyBsb2dpYyB0byBydW4sIHdoaWNoIGhhcyBhbiBhc3NvY2lhdGVkIENQVSBjb3N0LlxuIFx0ICogQHJldHVybiB7TnVtYmVyfSBUaGUgYXBwcm94aW1hdGUgaGVpZ2h0IG9mIHRoZSB1bnRyYW5zZm9ybWVkIG11bHRpLWxpbmUgdGV4dC5cbiBcdCAqL1xuIFx0Z2V0TWVhc3VyZWRIZWlnaHQgKCkge1xuIFx0XHRyZXR1cm4gdGhpcy5fZHJhd1RleHQobnVsbCwge30pLmhlaWdodDtcbiBcdH1cblxuIFx0Z2V0Qm91bmRzICgpIHtcbiBcdFx0bGV0IHJlY3QgPSBzdXBlci5nZXRCb3VuZHMoKTtcbiBcdFx0aWYgKHJlY3QpIHsgcmV0dXJuIHJlY3Q7IH1cbiBcdFx0aWYgKHRoaXMudGV4dCA9PSBudWxsIHx8IHRoaXMudGV4dCA9PT0gXCJcIikgeyByZXR1cm4gbnVsbDsgfVxuIFx0XHRsZXQgbyA9IHRoaXMuX2RyYXdUZXh0KG51bGwsIHt9KTtcbiBcdFx0bGV0IHcgPSAodGhpcy5tYXhXaWR0aCAmJiB0aGlzLm1heFdpZHRoIDwgby53aWR0aCkgPyB0aGlzLm1heFdpZHRoIDogby53aWR0aDtcbiBcdFx0bGV0IHggPSB3ICogVGV4dC5IX09GRlNFVFNbdGhpcy50ZXh0QWxpZ258fFwibGVmdFwiXTtcbiBcdFx0bGV0IGxpbmVIZWlnaHQgPSB0aGlzLmxpbmVIZWlnaHR8fHRoaXMuZ2V0TWVhc3VyZWRMaW5lSGVpZ2h0KCk7XG4gXHRcdGxldCB5ID0gbGluZUhlaWdodCAqIFRleHQuVl9PRkZTRVRTW3RoaXMudGV4dEJhc2VsaW5lfHxcInRvcFwiXTtcbiBcdFx0cmV0dXJuIHRoaXMuX3JlY3RhbmdsZS5zZXRWYWx1ZXMoeCwgeSwgdywgby5oZWlnaHQpO1xuIFx0fVxuXG4gXHQvKipcbiBcdCAqIFJldHVybnMgYW4gb2JqZWN0IHdpdGggd2lkdGgsIGhlaWdodCwgYW5kIGxpbmVzIHByb3BlcnRpZXMuIFRoZSB3aWR0aCBhbmQgaGVpZ2h0IGFyZSB0aGUgdmlzdWFsIHdpZHRoIGFuZCBoZWlnaHRcbiBcdCAqIG9mIHRoZSBkcmF3biB0ZXh0LiBUaGUgbGluZXMgcHJvcGVydHkgY29udGFpbnMgYW4gYXJyYXkgb2Ygc3RyaW5ncywgb25lIGZvclxuIFx0ICogZWFjaCBsaW5lIG9mIHRleHQgdGhhdCB3aWxsIGJlIGRyYXduLCBhY2NvdW50aW5nIGZvciBsaW5lIGJyZWFrcyBhbmQgd3JhcHBpbmcuIFRoZXNlIHN0cmluZ3MgaGF2ZSB0cmFpbGluZ1xuIFx0ICogd2hpdGVzcGFjZSByZW1vdmVkLlxuIFx0ICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCB3aWR0aCwgaGVpZ2h0LCBhbmQgbGluZXMgcHJvcGVydGllcy5cbiBcdCAqL1xuIFx0Z2V0TWV0cmljcyAoKSB7XG4gXHRcdGxldCBvID0ge2xpbmVzOltdfTtcbiBcdFx0by5saW5lSGVpZ2h0ID0gdGhpcy5saW5lSGVpZ2h0IHx8IHRoaXMuZ2V0TWVhc3VyZWRMaW5lSGVpZ2h0KCk7XG4gXHRcdG8udk9mZnNldCA9IG8ubGluZUhlaWdodCAqIFRleHQuVl9PRkZTRVRTW3RoaXMudGV4dEJhc2VsaW5lfHxcInRvcFwiXTtcbiBcdFx0cmV0dXJuIHRoaXMuX2RyYXdUZXh0KG51bGwsIG8sIG8ubGluZXMpO1xuIFx0fVxuXG4gXHQvKipcbiBcdCAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGUgVGV4dCBpbnN0YW5jZS5cbiBcdCAqIEByZXR1cm4ge2Vhc2VsanMuVGV4dH0gYSBjbG9uZSBvZiB0aGUgVGV4dCBpbnN0YW5jZS5cbiBcdCAqL1xuIFx0Y2xvbmUgKCkge1xuIFx0XHRyZXR1cm4gdGhpcy5fY2xvbmVQcm9wcyhuZXcgVGV4dCh0aGlzLnRleHQsIHRoaXMuZm9udCwgdGhpcy5jb2xvcikpO1xuIFx0fVxuXG4gXHQvKipcbiBcdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG4gXHQgKiBAb3ZlcnJpZGVcbiBcdCAqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxuIFx0ICovXG4gXHR0b1N0cmluZyAoKSB7XG4gXHRcdHJldHVybiBgWyR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfSAodGV4dD0ke3RoaXMudGV4dC5sZW5ndGggPiAyMCA/IGAke3RoaXMudGV4dC5zdWJzdHIoMCwgMTcpfS4uLmAgOiB0aGlzLnRleHR9KV1gO1xuIFx0fVxuXG4gXHQvKipcbiBcdCAqIEBwYXJhbSB7ZWFzZWxqcy5UZXh0fSBvXG4gXHQgKiBAcHJvdGVjdGVkXG4gXHQgKiBAcmV0dXJuIHtlYXNlbGpzLlRleHR9IG9cbiBcdCAqL1xuIFx0X2Nsb25lUHJvcHMgKG8pIHtcbiBcdFx0c3VwZXIuX2Nsb25lUHJvcHMobyk7XG4gXHRcdG8udGV4dEFsaWduID0gdGhpcy50ZXh0QWxpZ247XG4gXHRcdG8udGV4dEJhc2VsaW5lID0gdGhpcy50ZXh0QmFzZWxpbmU7XG4gXHRcdG8ubWF4V2lkdGggPSB0aGlzLm1heFdpZHRoO1xuIFx0XHRvLm91dGxpbmUgPSB0aGlzLm91dGxpbmU7XG4gXHRcdG8ubGluZUhlaWdodCA9IHRoaXMubGluZUhlaWdodDtcbiBcdFx0by5saW5lV2lkdGggPSB0aGlzLmxpbmVXaWR0aDtcbiBcdFx0cmV0dXJuIG87XG4gXHR9XG5cbiBcdC8qKlxuIFx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuIFx0ICogQHJldHVybiB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfVxuIFx0ICogQHByb3RlY3RlZFxuIFx0ICovXG4gXHRfcHJlcENvbnRleHQgKGN0eCkge1xuIFx0XHRjdHguZm9udCA9IHRoaXMuZm9udHx8XCIxMHB4IHNhbnMtc2VyaWZcIjtcbiBcdFx0Y3R4LnRleHRBbGlnbiA9IHRoaXMudGV4dEFsaWdufHxcImxlZnRcIjtcbiBcdFx0Y3R4LnRleHRCYXNlbGluZSA9IHRoaXMudGV4dEJhc2VsaW5lfHxcInRvcFwiO1xuXHRcdGN0eC5saW5lSm9pbiA9IFwibWl0ZXJcIjtcblx0XHRjdHgubWl0ZXJMaW1pdCA9IDIuNTtcblx0XHRyZXR1cm4gY3R4O1xuXHR9XG5cblx0LyoqXG5cdCAqIERyYXdzIG11bHRpbGluZSB0ZXh0LlxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGxpbmVzXG5cdCAqIEByZXR1cm4ge09iamVjdH1cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiBcdF9kcmF3VGV4dCAoY3R4LCBvLCBsaW5lcykge1xuIFx0XHRjb25zdCBwYWludCA9ICEhY3R4O1xuIFx0XHRpZiAoIXBhaW50KSB7XG4gXHRcdFx0Y3R4ID0gVGV4dC5fY3R4O1xuIFx0XHRcdGN0eC5zYXZlKCk7XG4gXHRcdFx0dGhpcy5fcHJlcENvbnRleHQoY3R4KTtcbiBcdFx0fVxuIFx0XHRsZXQgbGluZUhlaWdodCA9IHRoaXMubGluZUhlaWdodHx8dGhpcy5nZXRNZWFzdXJlZExpbmVIZWlnaHQoKTtcblxuIFx0XHRsZXQgbWF4VyA9IDAsIGNvdW50ID0gMDtcbiBcdFx0bGV0IGhhcmRMaW5lcyA9IFN0cmluZyh0aGlzLnRleHQpLnNwbGl0KC8oPzpcXHJcXG58XFxyfFxcbikvKTtcbiBcdFx0Zm9yIChsZXQgc3RyIG9mIGhhcmRMaW5lcykge1xuIFx0XHRcdGxldCB3ID0gbnVsbDtcblxuIFx0XHRcdGlmICh0aGlzLmxpbmVXaWR0aCAhPSBudWxsICYmICh3ID0gY3R4Lm1lYXN1cmVUZXh0KHN0cikud2lkdGgpID4gdGhpcy5saW5lV2lkdGgpIHtcbiBcdFx0XHRcdC8vIHRleHQgd3JhcHBpbmc6XG4gXHRcdFx0XHRsZXQgd29yZHMgPSBzdHIuc3BsaXQoLyhcXHMpLyk7XG4gXHRcdFx0XHRzdHIgPSB3b3Jkc1swXTtcbiBcdFx0XHRcdHcgPSBjdHgubWVhc3VyZVRleHQoc3RyKS53aWR0aDtcblxuXHRcdFx0XHRjb25zdCBsID0gd29yZHMubGVuZ3RoO1xuIFx0XHRcdFx0Zm9yIChsZXQgaT0xOyBpPGw7IGkrPTIpIHtcbiBcdFx0XHRcdFx0Ly8gTGluZSBuZWVkcyB0byB3cmFwOlxuIFx0XHRcdFx0XHRsZXQgd29yZFcgPSBjdHgubWVhc3VyZVRleHQod29yZHNbaV0gKyB3b3Jkc1tpKzFdKS53aWR0aDtcbiBcdFx0XHRcdFx0aWYgKHcgKyB3b3JkVyA+IHRoaXMubGluZVdpZHRoKSB7XG4gXHRcdFx0XHRcdFx0aWYgKHBhaW50KSB7IHRoaXMuX2RyYXdUZXh0TGluZShjdHgsIHN0ciwgY291bnQqbGluZUhlaWdodCk7IH1cbiBcdFx0XHRcdFx0XHRpZiAobGluZXMpIHsgbGluZXMucHVzaChzdHIpOyB9XG4gXHRcdFx0XHRcdFx0aWYgKHcgPiBtYXhXKSB7IG1heFcgPSB3OyB9XG4gXHRcdFx0XHRcdFx0c3RyID0gd29yZHNbaSsxXTtcbiBcdFx0XHRcdFx0XHR3ID0gY3R4Lm1lYXN1cmVUZXh0KHN0cikud2lkdGg7XG4gXHRcdFx0XHRcdFx0Y291bnQrKztcbiBcdFx0XHRcdFx0fSBlbHNlIHtcbiBcdFx0XHRcdFx0XHRzdHIgKz0gd29yZHNbaV0gKyB3b3Jkc1tpKzFdO1xuIFx0XHRcdFx0XHRcdHcgKz0gd29yZFc7XG4gXHRcdFx0XHRcdH1cbiBcdFx0XHRcdH1cbiBcdFx0XHR9XG5cbiBcdFx0XHRpZiAocGFpbnQpIHsgdGhpcy5fZHJhd1RleHRMaW5lKGN0eCwgc3RyLCBjb3VudCpsaW5lSGVpZ2h0KTsgfVxuIFx0XHRcdGlmIChsaW5lcykgeyBsaW5lcy5wdXNoKHN0cik7IH1cbiBcdFx0XHRpZiAobyAmJiB3ID09IG51bGwpIHsgdyA9IGN0eC5tZWFzdXJlVGV4dChzdHIpLndpZHRoOyB9XG4gXHRcdFx0aWYgKHcgPiBtYXhXKSB7IG1heFcgPSB3OyB9XG4gXHRcdFx0Y291bnQrKztcbiBcdFx0fVxuXG4gXHRcdGlmIChvKSB7XG4gXHRcdFx0by53aWR0aCA9IG1heFc7XG4gXHRcdFx0by5oZWlnaHQgPSBjb3VudCpsaW5lSGVpZ2h0O1xuIFx0XHR9XG4gXHRcdGlmICghcGFpbnQpIHsgY3R4LnJlc3RvcmUoKTsgfVxuIFx0XHRyZXR1cm4gbztcbiBcdH1cblxuIFx0LyoqXG4gXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gXHQgKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuIFx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcbiBcdCAqIEBwcm90ZWN0ZWRcbiBcdCAqL1xuIFx0X2RyYXdUZXh0TGluZSAoY3R4LCB0ZXh0LCB5KSB7XG4gXHRcdC8vIENocm9tZSAxNyB3aWxsIGZhaWwgdG8gZHJhdyB0aGUgdGV4dCBpZiB0aGUgbGFzdCBwYXJhbSBpcyBpbmNsdWRlZCBidXQgbnVsbCwgc28gd2UgZmVlZCBpdCBhIGxhcmdlIHZhbHVlIGluc3RlYWQ6XG4gXHRcdGlmICh0aGlzLm91dGxpbmUpIHsgY3R4LnN0cm9rZVRleHQodGV4dCwgMCwgeSwgdGhpcy5tYXhXaWR0aHx8MHhGRkZGKTsgfVxuIFx0XHRlbHNlIHsgY3R4LmZpbGxUZXh0KHRleHQsIDAsIHksIHRoaXMubWF4V2lkdGh8fDB4RkZGRik7IH1cbiBcdH1cblxuIFx0LyoqXG4gXHQgKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuIFx0ICogQHByb3RlY3RlZFxuIFx0ICovXG4gXHRfZ2V0TWVhc3VyZWRXaWR0aCAodGV4dCkge1xuIFx0XHRsZXQgY3R4ID0gVGV4dC5fY3R4O1xuIFx0XHRjdHguc2F2ZSgpO1xuIFx0XHRsZXQgdyA9IHRoaXMuX3ByZXBDb250ZXh0KGN0eCkubWVhc3VyZVRleHQodGV4dCkud2lkdGg7XG4gXHRcdGN0eC5yZXN0b3JlKCk7XG4gXHRcdHJldHVybiB3O1xuIFx0fVxuXG59XG5cbi8qKlxuICogTG9va3VwIHRhYmxlIGZvciB0aGUgcmF0aW8gdG8gb2Zmc2V0IGJvdW5kcyB4IGNhbGN1bGF0aW9ucyBiYXNlZCBvbiB0aGUgdGV4dEFsaWduIHByb3BlcnR5LlxuICogQHR5cGUge09iamVjdH1cbiAqIEByZWFkb25seVxuICogQHN0YXRpY1xuICovXG5UZXh0LkhfT0ZGU0VUUyA9IHtzdGFydDogMCwgbGVmdDogMCwgY2VudGVyOiAtMC41LCBlbmQ6IC0xLCByaWdodDogLTF9O1xuLyoqXG4gKiBMb29rdXAgdGFibGUgZm9yIHRoZSByYXRpbyB0byBvZmZzZXQgYm91bmRzIHkgY2FsY3VsYXRpb25zIGJhc2VkIG9uIHRoZSB0ZXh0QmFzZWxpbmUgcHJvcGVydHkuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHJlYWRvbmx5XG4gKiBAc3RhdGljXG4gKi9cblRleHQuVl9PRkZTRVRTID0ge3RvcDogMCwgaGFuZ2luZzogLTAuMDEsIG1pZGRsZTogLTAuNCwgYWxwaGFiZXRpYzogLTAuOCwgaWRlb2dyYXBoaWM6IC0wLjg1LCBib3R0b206IC0xfTtcblxuLyoqXG4gKiBAcHJvcGVydHkgX2N0eFxuICogQHR5cGUge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH1cbiAqIEBwcml2YXRlXG4gKiBAc3RhdGljXG4gKi9cblRleHQuX2N0eCA9IGNyZWF0ZUNhbnZhcygpLmdldENvbnRleHQoXCIyZFwiKTtcbiIsIi8qKlxuICogQGxpY2Vuc2UgQWxwaGFNYXBGaWx0ZXJcbiAqIFZpc2l0IGh0dHA6Ly9jcmVhdGVqcy5jb20vIGZvciBkb2N1bWVudGF0aW9uLCB1cGRhdGVzIGFuZCBleGFtcGxlcy5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgZ3NraW5uZXIuY29tLCBpbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAqIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXG4gKiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXRcbiAqIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxuICogY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuICogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbiAqIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAqIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gKiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcbiAqIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gKiBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuICogSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXG4gKiBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcbiAqIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5pbXBvcnQgRmlsdGVyIGZyb20gXCIuL0ZpbHRlclwiO1xuXG4vKipcbiAqIEFwcGxpZXMgYSBncmV5c2NhbGUgYWxwaGEgbWFwIGltYWdlIChvciBjYW52YXMpIHRvIHRoZSB0YXJnZXQsIHN1Y2ggdGhhdCB0aGUgYWxwaGEgY2hhbm5lbCBvZiB0aGUgcmVzdWx0IHdpbGxcbiAqIGJlIGNvcGllZCBmcm9tIHRoZSByZWQgY2hhbm5lbCBvZiB0aGUgbWFwLCBhbmQgdGhlIFJHQiBjaGFubmVscyB3aWxsIGJlIGNvcGllZCBmcm9tIHRoZSB0YXJnZXQuXG4gKlxuICogR2VuZXJhbGx5LCBpdCBpcyByZWNvbW1lbmRlZCB0aGF0IHlvdSB1c2Uge0BsaW5rIGVhc2VsanMuQWxwaGFNYXNrRmlsdGVyfSwgYmVjYXVzZSBpdCBoYXMgbXVjaCBiZXR0ZXIgcGVyZm9ybWFuY2UuXG4gKlxuICogQG1lbWJlcm9mIGVhc2VsanNcbiAqIEBleHRlbmRzIGVhc2VsanMuRmlsdGVyXG4gKiBAZXhhbXBsZSAqXG4gKiBsZXQgYm94ID0gbmV3IFNoYXBlKCk7XG4gKiBib3guZ3JhcGhpY3MuYmVnaW5MaW5lYXJHcmFkaWVudEZpbGwoW1wiI2ZmMDAwMFwiLCBcIiMwMDAwZmZcIl0sIFswLCAxXSwgMCwgMCwgMCwgMTAwKVxuICogYm94LmdyYXBoaWNzLmRyYXdSZWN0KDAsIDAsIDEwMCwgMTAwKTtcbiAqIGJveC5jYWNoZSgwLCAwLCAxMDAsIDEwMCk7XG4gKiBsZXQgYm1wID0gbmV3IEJpdG1hcChcInBhdGgvdG8vaW1hZ2UuanBnXCIpO1xuICogYm1wLmZpbHRlcnMgPSBbIG5ldyBBbHBoYU1hcEZpbHRlcihib3guY2FjaGVDYW52YXMpIF07XG4gKiBibXAuY2FjaGUoMCwgMCwgMTAwLCAxMDApO1xuICpcbiAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudCB8IEhUTUxDYW52YXNFbGVtZW50fSBhbHBoYU1hcCBUaGUgZ3JleXNjYWxlIGltYWdlIChvciBjYW52YXMpIHRvIHVzZSBhcyB0aGUgYWxwaGEgdmFsdWUgZm9yIHRoZVxuICogcmVzdWx0LiBUaGlzIHNob3VsZCBiZSBleGFjdGx5IHRoZSBzYW1lIGRpbWVuc2lvbnMgYXMgdGhlIHRhcmdldC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQWxwaGFNYXBGaWx0ZXIgZXh0ZW5kcyBGaWx0ZXIge1xuXG5cdGNvbnN0cnVjdG9yIChhbHBoYU1hcCkge1xuXHRcdHN1cGVyKCk7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgZ3JleXNjYWxlIGltYWdlIChvciBjYW52YXMpIHRvIHVzZSBhcyB0aGUgYWxwaGEgdmFsdWUgZm9yIHRoZSByZXN1bHQuIFRoaXMgc2hvdWxkIGJlIGV4YWN0bHkgdGhlIHNhbWVcblx0XHQgKiBkaW1lbnNpb25zIGFzIHRoZSB0YXJnZXQuXG5cdFx0ICogQHR5cGUge0hUTUxJbWFnZUVsZW1lbnQgfCBIVE1MQ2FudmFzRWxlbWVudH1cblx0XHQgKi9cblx0XHR0aGlzLmFscGhhTWFwID0gYWxwaGFNYXA7XG5cblx0XHQvKipcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge0hUTUxJbWFnZUVsZW1lbnQgfCBIVE1MQ2FudmFzRWxlbWVudH1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5fYWxwaGFNYXAgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtVaW50OENsYW1wZWRBcnJheX1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5fbWFwRGF0YSA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUgeyp9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuX21hcFRleHR1cmUgPSBudWxsO1xuXG5cdFx0dGhpcy5GUkFHX1NIQURFUl9CT0RZID0gYFxuXHRcdFx0dW5pZm9ybSBzYW1wbGVyMkQgdUFscGhhU2FtcGxlcjtcblxuXHRcdFx0dm9pZCBtYWluICh2b2lkKSB7XG5cdFx0XHRcdHZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZSZW5kZXJDb29yZCk7XG5cdFx0XHRcdHZlYzQgYWxwaGFNYXAgPSB0ZXh0dXJlMkQodUFscGhhU2FtcGxlciwgdlRleHR1cmVDb29yZCk7XG5cblx0XHRcdFx0Ly8gc29tZSBpbWFnZSBmb3JtYXRzIGNhbiBoYXZlIHRyYW5zcGFyZW50IHdoaXRlIHJnYmEoMSwxLDEsIDApIHdoZW4gcHV0IG9uIHRoZSBHUFUsIHRoaXMgbWVhbnMgd2UgbmVlZCBhIHNsaWdodCB0d2Vha1xuXHRcdFx0XHQvLyB1c2luZyBjZWlsIGVuc3VyZSB0aGF0IHRoZSBjb2xvdXIgd2lsbCBiZSB1c2VkIHNvIGxvbmcgYXMgaXQgZXhpc3RzIGJ1dCBwdXJlIHRyYW5zcGFyZW5jeSB3aWxsIGJlIHRyZWF0ZWQgYmxhY2tcblx0XHRcdFx0Z2xfRnJhZ0NvbG9yID0gdmVjNChjb2xvci5yZ2IsIGNvbG9yLmEgKiAoYWxwaGFNYXAuciAqIGNlaWwoYWxwaGFNYXAuYSkpKTtcblx0XHRcdH1cblx0XHRgO1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0b2RvIGRvY3Ncblx0ICogQHBhcmFtIHsqfSBnbFxuXHQgKiBAcGFyYW0geyp9IHN0YWdlXG5cdCAqIEBwYXJhbSB7Kn0gc2hhZGVyUHJvZ3JhbVxuXHQgKi9cblx0c2hhZGVyUGFyYW1TZXR1cCAoZ2wsIHN0YWdlLCBzaGFkZXJQcm9ncmFtKSB7XG5cdFx0aWYgKCF0aGlzLl9tYXBUZXh0dXJlKSB7IHRoaXMuX21hcFRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7IH1cblxuXHRcdGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTEpO1xuXHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMuX21hcFRleHR1cmUpO1xuXHRcdHN0YWdlLnNldFRleHR1cmVQYXJhbXMoZ2wpO1xuXHRcdGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgdGhpcy5hbHBoYU1hcCk7XG5cblx0XHRnbC51bmlmb3JtMWkoXG5cdFx0XHRnbC5nZXRVbmlmb3JtTG9jYXRpb24oc2hhZGVyUHJvZ3JhbSwgXCJ1QWxwaGFTYW1wbGVyXCIpLFxuXHRcdFx0MVxuXHRcdCk7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybiB7ZWFzZWxqcy5BbHBoYU1hcEZpbHRlcn1cblx0ICovXG5cdGNsb25lICgpIHtcblx0XHRsZXQgbyA9IG5ldyBBbHBoYU1hcEZpbHRlcih0aGlzLmFscGhhTWFwKTtcblx0XHRvLl9hbHBoYU1hcCA9IHRoaXMuX2FscGhhTWFwO1xuXHRcdG8uX21hcERhdGEgPSB0aGlzLl9tYXBEYXRhO1xuXHRcdHJldHVybiBvO1xuXHR9XG5cblx0X2FwcGx5RmlsdGVyIChpbWFnZURhdGEpIHtcblx0XHRpZiAoIXRoaXMuYWxwaGFNYXApIHsgcmV0dXJuIHRydWU7IH1cblx0XHRpZiAoIXRoaXMuX3ByZXBBbHBoYU1hcCgpKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdFx0Ly8gVE9ETzogdXBkYXRlIHRvIHN1cHBvcnQgc2NlbmFyaW9zIHdoZXJlIHRoZSB0YXJnZXQgaGFzIGRpZmZlcmVudCBkaW1lbnNpb25zLlxuXHRcdGxldCBkYXRhID0gaW1hZ2VEYXRhLmRhdGE7XG5cdFx0bGV0IG1hcCA9IHRoaXMuX21hcERhdGE7XG5cdFx0Y29uc3QgbCA9IGRhdGEubGVuZ3RoO1xuXHRcdGZvciAobGV0IGk9MDsgaTxsOyBpICs9IDQpIHsgZGF0YVtpICsgM10gPSBtYXBbaV0gfHwgMDsgfVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0X3ByZXBBbHBoYU1hcCAoKSB7XG5cdFx0aWYgKCF0aGlzLmFscGhhTWFwKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdGlmICh0aGlzLmFscGhhTWFwID09PSB0aGlzLl9hbHBoYU1hcCAmJiB0aGlzLl9tYXBEYXRhKSB7IHJldHVybiB0cnVlOyB9XG5cdFx0dGhpcy5fbWFwRGF0YSA9IG51bGw7XG5cblx0XHRsZXQgbWFwID0gdGhpcy5fYWxwaGFNYXAgPSB0aGlzLmFscGhhTWFwO1xuXHRcdGxldCBjYW52YXMgPSBtYXA7XG5cdFx0bGV0IGN0eDtcblx0XHRpZiAobWFwIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQpIHtcblx0XHRcdGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNhbnZhcyA9IHdpbmRvdy5jcmVhdGVqcyAmJiBjcmVhdGVqcy5jcmVhdGVDYW52YXMgPyBjcmVhdGVqcy5jcmVhdGVDYW52YXMoKSA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG5cdFx0XHRjYW52YXMud2lkdGggPSBtYXAud2lkdGg7XG5cdFx0XHRjYW52YXMuaGVpZ2h0ID0gbWFwLmhlaWdodDtcblx0XHRcdGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5cdFx0XHRjdHguZHJhd0ltYWdlKG1hcCwgMCwgMCk7XG5cdFx0fVxuXG5cdFx0dHJ5IHtcblx0XHRcdHRoaXMuX21hcERhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIG1hcC53aWR0aCwgbWFwLmhlaWdodCkuZGF0YVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0Ly9pZiAoIXRoaXMuc3VwcHJlc3NDcm9zc0RvbWFpbkVycm9ycykgdGhyb3cgbmV3IEVycm9yKFwidW5hYmxlIHRvIGFjY2VzcyBsb2NhbCBpbWFnZSBkYXRhOiBcIiArIGUpO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fVxuXG59XG4iLCIvKipcbiAqIEBsaWNlbnNlIEFscGhhTWFza0ZpbHRlclxuICogVmlzaXQgaHR0cDovL2NyZWF0ZWpzLmNvbS8gZm9yIGRvY3VtZW50YXRpb24sIHVwZGF0ZXMgYW5kIGV4YW1wbGVzLlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNyBnc2tpbm5lci5jb20sIGluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICogb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cbiAqIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxuICogcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsXG4gKiBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4gKiBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuICogY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAqIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xuICogT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAqIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4gKiBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcbiAqIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuICogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUlxuICogT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICovXG5cbmltcG9ydCBGaWx0ZXIgZnJvbSBcIi4vRmlsdGVyXCI7XG5cbi8qKlxuICogQXBwbGllcyB0aGUgYWxwaGEgZnJvbSB0aGUgbWFzayBpbWFnZSAob3IgY2FudmFzKSB0byB0aGUgdGFyZ2V0LCBzdWNoIHRoYXQgdGhlIGFscGhhIGNoYW5uZWwgb2YgdGhlIHJlc3VsdCB3aWxsXG4gKiBiZSBkZXJpdmVkIGZyb20gdGhlIG1hc2ssIGFuZCB0aGUgUkdCIGNoYW5uZWxzIHdpbGwgYmUgY29waWVkIGZyb20gdGhlIHRhcmdldC4gVGhpcyBjYW4gYmUgdXNlZCwgZm9yIGV4YW1wbGUsIHRvXG4gKiBhcHBseSBhbiBhbHBoYSBtYXNrIHRvIGEgZGlzcGxheSBvYmplY3QuIFRoaXMgY2FuIGFsc28gYmUgdXNlZCB0byBjb21iaW5lIGEgSlBHIGNvbXByZXNzZWQgUkdCIGltYWdlIHdpdGggYSBQTkczMlxuICogYWxwaGEgbWFzaywgd2hpY2ggY2FuIHJlc3VsdCBpbiBhIG11Y2ggc21hbGxlciBmaWxlIHNpemUgdGhhbiBhIHNpbmdsZSBQTkczMiBjb250YWluaW5nIEFSR0IuXG4gKlxuICogPGI+SU1QT1JUQU5UIE5PVEU6IFRoaXMgZmlsdGVyIGN1cnJlbnRseSBkb2VzIG5vdCBzdXBwb3J0IHRoZSB0YXJnZXRDdHgsIG9yIHRhcmdldFgvWSBwYXJhbWV0ZXJzIGNvcnJlY3RseS48L2I+XG4gKlxuICogQG1lbWJlcm9mIGVhc2VsanNcbiAqIEBleHRlbmRzIGVhc2VsanMuRmlsdGVyXG4gKiBAZXhhbXBsZVxuICogdmFyIGJveCA9IG5ldyBTaGFwZSgpO1xuICogYm94LmdyYXBoaWNzLmJlZ2luTGluZWFyR3JhZGllbnRGaWxsKFtcIiMwMDAwMDBcIiwgXCJyZ2JhKDAsIDAsIDAsIDApXCJdLCBbMCwgMV0sIDAsIDAsIDEwMCwgMTAwKVxuICogYm94LmdyYXBoaWNzLmRyYXdSZWN0KDAsIDAsIDEwMCwgMTAwKTtcbiAqIGJveC5jYWNoZSgwLCAwLCAxMDAsIDEwMCk7XG4gKiB2YXIgYm1wID0gbmV3IEJpdG1hcChcInBhdGgvdG8vaW1hZ2UuanBnXCIpO1xuICogYm1wLmZpbHRlcnMgPSBbIG5ldyBBbHBoYU1hc2tGaWx0ZXIoYm94LmNhY2hlQ2FudmFzKSBdO1xuICogYm1wLmNhY2hlKDAsIDAsIDEwMCwgMTAwKTtcbiAqXG4gKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnQgfCBIVE1MQ2FudmFzRWxlbWVudH0gbWFza1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBbHBoYU1hc2tGaWx0ZXIgZXh0ZW5kcyBGaWx0ZXIge1xuXG5cdGNvbnN0cnVjdG9yIChtYXNrKSB7XG5cdFx0c3VwZXIoKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBpbWFnZSAob3IgY2FudmFzKSB0byB1c2UgYXMgdGhlIG1hc2suXG5cdFx0ICogQHR5cGUge0hUTUxJbWFnZUVsZW1lbnQgfCBIVE1MQ2FudmFzRWxlbWVudH1cblx0XHQgKi9cblx0XHR0aGlzLm1hc2sgPSBtYXNrO1xuXG5cdFx0dGhpcy51c2VzQ29udGV4dCA9IHRydWU7XG5cblx0XHR0aGlzLkZSQUdfU0hBREVSX0JPRFkgPSBgXG5cdFx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1QWxwaGFTYW1wbGVyO1xuXG5cdFx0XHR2b2lkIG1haW4gKHZvaWQpIHtcblx0XHRcdFx0dmVjNCBjb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlJlbmRlckNvb3JkKTtcblx0XHRcdFx0dmVjNCBhbHBoYU1hcCA9IHRleHR1cmUyRCh1QWxwaGFTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKTtcblxuXHRcdFx0XHRnbF9GcmFnQ29sb3IgPSB2ZWM0KGNvbG9yLnJnYiwgY29sb3IuYSAqIGFscGhhTWFwLmEpO1xuXHRcdFx0fVxuXHRcdGA7XG5cdH1cblxuXHQvKipcblx0ICogQXBwbGllcyB0aGUgZmlsdGVyIHRvIHRoZSBzcGVjaWZpZWQgY29udGV4dC5cblx0ICpcblx0ICogPHN0cm9uZz5JTVBPUlRBTlQgTk9URTogVGhpcyBmaWx0ZXIgY3VycmVudGx5IGRvZXMgbm90IHN1cHBvcnQgdGhlIHRhcmdldEN0eCwgb3IgdGFyZ2V0WC9ZIHBhcmFtZXRlcnMgY29ycmVjdGx5Ljwvc3Ryb25nPlxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IFRoZSAyRCBjb250ZXh0IHRvIHVzZSBhcyB0aGUgc291cmNlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgeCBwb3NpdGlvbiB0byB1c2UgZm9yIHRoZSBzb3VyY2UgcmVjdC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHkgcG9zaXRpb24gdG8gdXNlIGZvciB0aGUgc291cmNlIHJlY3QuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCBUaGUgd2lkdGggdG8gdXNlIGZvciB0aGUgc291cmNlIHJlY3QuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgVGhlIGhlaWdodCB0byB1c2UgZm9yIHRoZSBzb3VyY2UgcmVjdC5cblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IFt0YXJnZXRDdHhdIE5PVCBTVVBQT1JURUQgSU4gVEhJUyBGSUxURVIuIFRoZSAyRCBjb250ZXh0IHRvIGRyYXcgdGhlIHJlc3VsdCB0by4gRGVmYXVsdHMgdG8gdGhlIGNvbnRleHQgcGFzc2VkIHRvIGN0eC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt0YXJnZXRYXSBOT1QgU1VQUE9SVEVEIElOIFRISVMgRklMVEVSLiBUaGUgeCBwb3NpdGlvbiB0byBkcmF3IHRoZSByZXN1bHQgdG8uIERlZmF1bHRzIHRvIHRoZSB2YWx1ZSBwYXNzZWQgdG8geC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt0YXJnZXRZXSBOT1QgU1VQUE9SVEVEIElOIFRISVMgRklMVEVSLiBUaGUgeSBwb3NpdGlvbiB0byBkcmF3IHRoZSByZXN1bHQgdG8uIERlZmF1bHRzIHRvIHRoZSB2YWx1ZSBwYXNzZWQgdG8geS5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gSWYgdGhlIGZpbHRlciB3YXMgYXBwbGllZCBzdWNjZXNzZnVsbHkuXG5cdCAqL1xuXHRhcHBseUZpbHRlciAoY3R4LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCB0YXJnZXRDdHgsIHRhcmdldFgsIHRhcmdldFkpIHtcblx0XHRpZiAoIXRoaXMubWFzaykgeyByZXR1cm4gdHJ1ZTsgfVxuXHRcdHRhcmdldEN0eCA9IHRhcmdldEN0eCB8fCBjdHg7XG5cdFx0aWYgKHRhcmdldFggPT0gbnVsbCkgeyB0YXJnZXRYID0geDsgfVxuXHRcdGlmICh0YXJnZXRZID09IG51bGwpIHsgdGFyZ2V0WSA9IHk7IH1cblxuXHRcdHRhcmdldEN0eC5zYXZlKCk7XG5cdFx0aWYgKGN0eCAhPSB0YXJnZXRDdHgpIHtcblx0XHRcdC8vIFRPRE86IHN1cHBvcnQgdGFyZ2V0Q3R4IGFuZCB0YXJnZXRYL1lcblx0XHRcdC8vIGNsZWFyUmVjdCwgdGhlbiBkcmF3IHRoZSBjdHggaW4/XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0dGFyZ2V0Q3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwiZGVzdGluYXRpb24taW5cIjtcblx0XHR0YXJnZXRDdHguZHJhd0ltYWdlKHRoaXMubWFzaywgdGFyZ2V0WCwgdGFyZ2V0WSk7XG5cdFx0dGFyZ2V0Q3R4LnJlc3RvcmUoKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJuIHtlYXNlbGpzLkFscGhhTWFza0ZpbHRlcn1cblx0ICovXG5cdGNsb25lICgpIHtcblx0XHRyZXR1cm4gbmV3IEFscGhhTWFza0ZpbHRlcih0aGlzLm1hc2spO1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0b2RvIGRvY3Ncblx0ICogQHBhcmFtIHsqfSBnbFxuXHQgKiBAcGFyYW0geyp9IHN0YWdlXG5cdCAqIEBwYXJhbSB7Kn0gc2hhZGVyUHJvZ3JhbVxuXHQgKi9cblx0c2hhZGVyUGFyYW1TZXR1cCAoZ2wsIHN0YWdlLCBzaGFkZXJQcm9ncmFtKSB7XG5cdFx0aWYoIXRoaXMuX21hcFRleHR1cmUpIHsgdGhpcy5fbWFwVGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTsgfVxuXG5cdFx0Z2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMSk7XG5cdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy5fbWFwVGV4dHVyZSk7XG5cdFx0c3RhZ2Uuc2V0VGV4dHVyZVBhcmFtcyhnbCk7XG5cdFx0Z2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCB0aGlzLm1hc2spO1xuXG5cdFx0Z2wudW5pZm9ybTFpKFxuXHRcdFx0Z2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHNoYWRlclByb2dyYW0sIFwidUFscGhhU2FtcGxlclwiKSxcblx0XHRcdDFcblx0XHQpO1xuXHR9XG5cbn1cbiIsIi8qKlxuICogQGxpY2Vuc2UgQmx1ckZpbHRlclxuICogVmlzaXQgaHR0cDovL2NyZWF0ZWpzLmNvbS8gZm9yIGRvY3VtZW50YXRpb24sIHVwZGF0ZXMgYW5kIGV4YW1wbGVzLlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNyBnc2tpbm5lci5jb20sIGluYy5cbiAqXG4gKiBCb3hCbHVyIEFsZ29yaXRobSBieSBNYXJpbyBLbGluZ2VtYW5uLCBxdWFzaW1vbmRvLmNvbVxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gKiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxuICogZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0XG4gKiByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSxcbiAqIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiAqIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXG4gKiBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gKiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICogRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTXG4gKiBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICogTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcbiAqIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLFxuICogV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4gKiBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SXG4gKiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gKi9cblxuaW1wb3J0IEZpbHRlciBmcm9tIFwiLi9GaWx0ZXJcIjtcbmltcG9ydCBSZWN0YW5nbGUgZnJvbSBcIi4uL2dlb20vUmVjdGFuZ2xlXCI7XG5cbi8qKlxuICogQXBwbGllcyBhIGJveCBibHVyIHRvIERpc3BsYXlPYmplY3RzLiBOb3RlIHRoYXQgdGhpcyBmaWx0ZXIgaXMgZmFpcmx5IENQVSBpbnRlbnNpdmUsIHBhcnRpY3VsYXJseSBpZiB0aGUgcXVhbGl0eSBpc1xuICogc2V0IGhpZ2hlciB0aGFuIDEuXG4gKlxuICogQG1lbWJlcm9mIGVhc2VsanNcbiAqIEBleHRlbmRzIGVhc2VsanMuRmlsdGVyXG4gKiBAZXhhbXBsZVxuICogbGV0IHNoYXBlID0gbmV3IFNoYXBlKCkuc2V0KHt4OjEwMCx5OjEwMH0pO1xuICogc2hhcGUuZ3JhcGhpY3MuYmVnaW5GaWxsKFwiI2ZmMDAwMFwiKS5kcmF3Q2lyY2xlKDAsMCw1MCk7XG4gKiBsZXQgYmx1ckZpbHRlciA9IG5ldyBCbHVyRmlsdGVyKDUsIDUsIDEpO1xuICogc2hhcGUuZmlsdGVycyA9IFtibHVyRmlsdGVyXTtcbiAqIGxldCBib3VuZHMgPSBibHVyRmlsdGVyLmdldEJvdW5kcygpO1xuICogc2hhcGUuY2FjaGUoLTUwK2JvdW5kcy54LCAtNTArYm91bmRzLnksIDEwMCtib3VuZHMud2lkdGgsIDEwMCtib3VuZHMuaGVpZ2h0KTtcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gW2JsdXJYPTBdIFRoZSBob3Jpem9udGFsIGJsdXIgcmFkaXVzIGluIHBpeGVscy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbYmx1clk9MF0gVGhlIHZlcnRpY2FsIGJsdXIgcmFkaXVzIGluIHBpeGVscy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbcXVhbGl0eT0xXSBUaGUgbnVtYmVyIG9mIGJsdXIgaXRlcmF0aW9ucy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmx1ckZpbHRlciBleHRlbmRzIEZpbHRlciB7XG5cblx0Y29uc3RydWN0b3IgKGJsdXJYID0gMCwgYmx1clkgPSAwLCBxdWFsaXR5ID0gMSkge1xuXHRcdHN1cGVyKCk7XG5cblx0XHQvKipcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICovXG5cdFx0dGhpcy5fYmx1clggPSBibHVyWDtcblx0XHQvKipcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge0FycmF5fVxuXHRcdCAqL1xuXHRcdHRoaXMuX2JsdXJYVGFibGUgPSBbXTtcblx0XHQvKipcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5fbGFzdEJsdXJYID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqL1xuXHRcdHRoaXMuX2JsdXJZID0gYmx1clk7XG5cdFx0LyoqXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHQgKi9cblx0XHR0aGlzLl9ibHVyWVRhYmxlID0gW107XG5cdFx0LyoqXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuX2xhc3RCbHVyWSA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBOdW1iZXIgb2YgYmx1ciBpdGVyYXRpb25zLiBGb3IgZXhhbXBsZSwgYSB2YWx1ZSBvZiAxIHdpbGwgcHJvZHVjZSBhIHJvdWdoIGJsdXIuIEEgdmFsdWUgb2YgMiB3aWxsIHByb2R1Y2UgYVxuXHRcdCAqIHNtb290aGVyIGJsdXIsIGJ1dCB0YWtlIHR3aWNlIGFzIGxvbmcgdG8gcnVuLlxuXHRcdCAqIEBkZWZhdWx0IDFcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqL1xuXHRcdHRoaXMuX3F1YWxpdHkgPSAoaXNOYU4ocXVhbGl0eSkgfHwgcXVhbGl0eSA8IDEpID8gMSA6IHF1YWxpdHk7XG5cdFx0LyoqXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuX2xhc3RRdWFsaXR5ID0gbnVsbDtcblxuXHRcdHRoaXMuRlJBR19TSEFERVJfVEVNUExBVEUgPSBgXG5cdFx0XHR1bmlmb3JtIGZsb2F0IHhXZWlnaHRbe3tibHVyWH19XTtcblx0XHRcdHVuaWZvcm0gZmxvYXQgeVdlaWdodFt7e2JsdXJZfX1dO1xuXHRcdFx0dW5pZm9ybSB2ZWMyIHRleHR1cmVPZmZzZXQ7XG5cdFx0XHR2b2lkIG1haW4gKHZvaWQpIHtcblx0XHRcdFx0dmVjNCBjb2xvciA9IHZlYzQoMC4wKTtcblxuXHRcdFx0XHRmbG9hdCB4QWRqID0gKHt7Ymx1clh9fS4wLTEuMCkvMi4wO1xuXHRcdFx0XHRmbG9hdCB5QWRqID0gKHt7Ymx1cll9fS4wLTEuMCkvMi4wO1xuXHRcdFx0XHR2ZWMyIHNhbXBsZU9mZnNldDtcblxuXHRcdFx0XHRmb3IoaW50IGk9MDsgaTx7e2JsdXJYfX07IGkrKykge1xuXHRcdFx0XHRcdGZvcihpbnQgaj0wOyBqPHt7Ymx1cll9fTsgaisrKSB7XG5cdFx0XHRcdFx0XHRzYW1wbGVPZmZzZXQgPSB2UmVuZGVyQ29vcmQgKyAodGV4dHVyZU9mZnNldCAqIHZlYzIoZmxvYXQoaSkteEFkaiwgZmxvYXQoaikteUFkaikpO1xuXHRcdFx0XHRcdFx0Y29sb3IgKz0gdGV4dHVyZTJEKHVTYW1wbGVyLCBzYW1wbGVPZmZzZXQpICogKHhXZWlnaHRbaV0gKiB5V2VpZ2h0W2pdKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRnbF9GcmFnQ29sb3IgPSBjb2xvci5yZ2JhO1xuXHRcdFx0fVxuXHRcdGA7XG5cdH1cblxuXHQvKipcblx0ICogSG9yaXpvbnRhbCBibHVyIHJhZGl1cyBpbiBwaXhlbHMuXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqL1xuXHRnZXQgYmx1clggKCkgeyByZXR1cm4gdGhpcy5fYmx1clg7IH1cblx0c2V0IGJsdXJYIChibHVyWCkge1xuXHRcdGlmIChpc05hTihibHVyWCkgfHwgYmx1clggPCAwKSB7IGJsdXJYID0gMDsgfVxuXHRcdHRoaXMuX2JsdXJYID0gYmx1clg7XG5cdH1cblxuXHQvKipcblx0ICogVmVydGljYWwgYmx1ciByYWRpdXMgaW4gcGl4ZWxzLlxuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKi9cblx0Z2V0IGJsdXJZICgpIHsgcmV0dXJuIHRoaXMuX2JsdXJZOyB9XG5cdHNldCBibHVyWSAoYmx1clkpIHtcblx0XHRpZiAoaXNOYU4oYmx1clkpIHx8IGJsdXJZIDwgMCkgeyBibHVyWSA9IDA7IH1cblx0XHR0aGlzLl9ibHVyWSA9IGJsdXJZO1xuXHR9XG5cblx0LyoqXG5cdCAqIE51bWJlciBvZiBibHVyIGl0ZXJhdGlvbnMuIEZvciBleGFtcGxlLCBhIHZhbHVlIG9mIDEgd2lsbCBwcm9kdWNlIGEgcm91Z2ggYmx1ci4gQSB2YWx1ZSBvZiAyIHdpbGwgcHJvZHVjZSBhXG5cdCAqIHNtb290aGVyIGJsdXIsIGJ1dCB0YWtlIHR3aWNlIGFzIGxvbmcgdG8gcnVuLlxuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKi9cblx0Z2V0IHF1YWxpdHkgKCkgeyByZXR1cm4gdGhpcy5fcXVhbGl0eSB8IDA7IH1cblx0c2V0IHF1YWxpdHkgKHF1YWxpdHkpIHtcblx0XHRpZiAoaXNOYU4ocXVhbGl0eSkgfHwgcXVhbGl0eSA8IDApIHsgcXVhbGl0eSA9IDA7IH1cblx0XHR0aGlzLl9xdWFsaXR5ID0gcXVhbGl0eTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEB0eXBlIHsqfVxuXHQgKi9cblx0Z2V0IF9idWlsZFNoYWRlciAoKSB7XG5cdFx0Y29uc3QgeENoYW5nZSA9IHRoaXMuX2xhc3RCbHVyWCAhPT0gdGhpcy5fYmx1clg7XG5cdFx0Y29uc3QgeUNoYW5nZSA9IHRoaXMuX2xhc3RCbHVyWSAhPT0gdGhpcy5fYmx1clk7XG5cdFx0Y29uc3QgcUNoYW5nZSA9IHRoaXMuX2xhc3RRdWFsaXR5ICE9PSB0aGlzLl9xdWFsaXR5O1xuXHRcdGlmICh4Q2hhbmdlIHx8IHlDaGFuZ2UgfHwgcUNoYW5nZSkge1xuXHRcdFx0XHRpZiAoeENoYW5nZSB8fCBxQ2hhbmdlKSB7IHRoaXMuX2JsdXJYVGFibGUgPSB0aGlzLl9nZXRUYWJsZSh0aGlzLl9ibHVyWCAqIHRoaXMuX3F1YWxpdHkpOyB9XG5cdFx0XHRcdGlmICh5Q2hhbmdlIHx8IHFDaGFuZ2UpIHsgdGhpcy5fYmx1cllUYWJsZSA9IHRoaXMuX2dldFRhYmxlKHRoaXMuX2JsdXJZICogdGhpcy5fcXVhbGl0eSk7IH1cblx0XHRcdFx0dGhpcy5fdXBkYXRlU2hhZGVyKCk7XG5cdFx0XHRcdHRoaXMuX2xhc3RCbHVyWCA9IHRoaXMuX2JsdXJYO1xuXHRcdFx0XHR0aGlzLl9sYXN0Qmx1clkgPSB0aGlzLl9ibHVyWTtcblx0XHRcdFx0dGhpcy5fbGFzdFF1YWxpdHkgPSB0aGlzLl9xdWFsaXR5O1xuXHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkOyAvLyBmb3JjZSBhIHJlYnVpbGRcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX2NvbXBpbGVkU2hhZGVyO1xuXHR9XG5cdHNldCBfYnVpbHRTaGFkZXIgKHZhbHVlKSB7IHRoaXMuX2NvbXBpbGVkU2hhZGVyID0gdmFsdWU7IH1cblxuXHRzaGFkZXJQYXJhbVNldHVwIChnbCwgc3RhZ2UsIHNoYWRlclByb2dyYW0pIHtcblx0XHQvLyBsb2FkIHRoZSBub3JtYWxpemVkIGdhdXNzaWFuIHdlaWdodCB0YWJsZXNcblx0XHRnbC51bmlmb3JtMWZ2KFxuXHRcdFx0Z2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHNoYWRlclByb2dyYW0sIFwieFdlaWdodFwiKSxcblx0XHRcdHRoaXMuX2JsdXJYVGFibGVcblx0XHQpO1xuXHRcdGdsLnVuaWZvcm0xZnYoXG5cdFx0XHRnbC5nZXRVbmlmb3JtTG9jYXRpb24oc2hhZGVyUHJvZ3JhbSwgXCJ5V2VpZ2h0XCIpLFxuXHRcdFx0dGhpcy5fYmx1cllUYWJsZVxuXHRcdCk7XG5cblx0XHQvLyB3aGF0IGlzIHRoZSBzaXplIG9mIGEgc2luZ2xlIHBpeGVsIGluIC0xLCAxICh3ZWJHTCkgc3BhY2Vcblx0XHRnbC51bmlmb3JtMmYoXG5cdFx0XHRnbC5nZXRVbmlmb3JtTG9jYXRpb24oc2hhZGVyUHJvZ3JhbSwgXCJ0ZXh0dXJlT2Zmc2V0XCIpLFxuXHRcdFx0Mi8oc3RhZ2UuX3ZpZXdwb3J0V2lkdGgqdGhpcy5fcXVhbGl0eSksIDIvKHN0YWdlLl92aWV3cG9ydEhlaWdodCp0aGlzLl9xdWFsaXR5KVxuXHRcdCk7XG5cdH1cblxuXHRnZXRCb3VuZHMgKHJlY3QpIHtcblx0XHRsZXQgeCA9IHRoaXMuYmx1clh8MCwgeSA9IHRoaXMuYmx1cll8IDA7XG5cdFx0aWYgKHggPD0gMCAmJiB5IDw9IDApIHsgcmV0dXJuIHJlY3Q7IH1cblx0XHRsZXQgcSA9IE1hdGgucG93KHRoaXMucXVhbGl0eSwgMC4yKTtcblx0XHRyZXR1cm4gKHJlY3QgfHwgbmV3IFJlY3RhbmdsZSgpKS5wYWQoeSpxKzEseCpxKzEseSpxKzEseCpxKzEpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm4ge2Vhc2VsanMuQmx1ckZpbHRlcn1cblx0ICovXG5cdGNsb25lICgpIHtcblx0XHRyZXR1cm4gbmV3IEJsdXJGaWx0ZXIodGhpcy5ibHVyWCwgdGhpcy5ibHVyWSwgdGhpcy5xdWFsaXR5KTtcblx0fVxuXG5cdF91cGRhdGVTaGFkZXIgKCkge1xuXHRcdGxldCByZXN1bHQgPSB0aGlzLkZSQUdfU0hBREVSX1RFTVBMQVRFO1xuXHRcdHJlc3VsdCA9IHJlc3VsdC5yZXBsYWNlKC97e2JsdXJYfX0vZywgdGhpcy5fYmx1clhUYWJsZS5sZW5ndGgudG9GaXhlZCgwKSk7XG5cdFx0cmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoL3t7Ymx1cll9fS9nLCB0aGlzLl9ibHVyWVRhYmxlLmxlbmd0aC50b0ZpeGVkKDApKTtcblx0XHR0aGlzLkZSQUdfU0hBREVSX0JPRFkgPSByZXN1bHQ7XG5cdH1cblxuXHRfZ2V0VGFibGUgKHNwcmVhZCkge1xuXHRcdGNvbnN0IEVER0UgPSA0LjI7XG5cdFx0aWYgKHNwcmVhZCA8PSAxKSB7IHJldHVybiBbMV07IH1cblxuXHRcdGxldCByZXN1bHQgPSBbXTtcblx0XHRsZXQgY291bnQgPSBNYXRoLmNlaWwoc3ByZWFkKjIpO1xuXHRcdGNvdW50ICs9IChjb3VudCUyKT8wOjE7XG5cdFx0bGV0IGFkanVzdCA9IChjb3VudC8yKXwwO1xuXHRcdGZvciAobGV0IGkgPSAtYWRqdXN0OyBpPD1hZGp1c3Q7IGkrKykge1xuXHRcdFx0bGV0IHggPSAoaS9hZGp1c3QpKkVER0U7XG5cdFx0XHRyZXN1bHQucHVzaCgxL01hdGguc3FydCgyKk1hdGguUEkpICogTWF0aC5wb3coTWF0aC5FLCAtKE1hdGgucG93KHgsMikvNCkpKTtcblx0XHR9XG5cdFx0bGV0IGZhY3RvciA9IHJlc3VsdC5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKTtcblx0XHRyZXR1cm4gcmVzdWx0Lm1hcChjdXJyZW50VmFsdWUgPT4gY3VycmVudFZhbHVlIC8gZmFjdG9yKTtcblx0fVxuXG5cdF9hcHBseUZpbHRlciAoaW1hZ2VEYXRhKSB7XG5cdFx0bGV0IHJhZGl1c1ggPSB0aGlzLl9ibHVyWCA+PiAxO1xuXHRcdGlmIChpc05hTihyYWRpdXNYKSB8fCByYWRpdXNYIDwgMCkgcmV0dXJuIGZhbHNlO1xuXHRcdGxldCByYWRpdXNZID0gdGhpcy5fYmx1clkgPj4gMTtcblx0XHRpZiAoaXNOYU4ocmFkaXVzWSkgfHwgcmFkaXVzWSA8IDApIHJldHVybiBmYWxzZTtcblx0XHRpZiAocmFkaXVzWCA9PT0gMCAmJiByYWRpdXNZID09PSAwKSByZXR1cm4gZmFsc2U7XG5cblx0XHRsZXQgaXRlcmF0aW9ucyA9IHRoaXMucXVhbGl0eTtcblx0XHRpZiAoaXNOYU4oaXRlcmF0aW9ucykgfHwgaXRlcmF0aW9ucyA8IDEpIGl0ZXJhdGlvbnMgPSAxO1xuXHRcdGl0ZXJhdGlvbnMgfD0gMDtcblx0XHRpZiAoaXRlcmF0aW9ucyA+IDMpIGl0ZXJhdGlvbnMgPSAzO1xuXHRcdGlmIChpdGVyYXRpb25zIDwgMSkgaXRlcmF0aW9ucyA9IDE7XG5cblx0XHRsZXQgcHggPSBpbWFnZURhdGEuZGF0YTtcblx0XHRsZXQgeD0wLCB5PTAsIGk9MCwgcD0wLCB5cD0wLCB5aT0wLCB5dz0wLCByPTAsIGc9MCwgYj0wLCBhPTAsIHByPTAsIHBnPTAsIHBiPTAsIHBhPTA7XG5cblx0XHRsZXQgZGl2eCA9IChyYWRpdXNYICsgcmFkaXVzWCArIDEpIHwgMDtcblx0XHRsZXQgZGl2eSA9IChyYWRpdXNZICsgcmFkaXVzWSArIDEpIHwgMDtcblx0XHRsZXQgdyA9IGltYWdlRGF0YS53aWR0aCB8IDA7XG5cdFx0bGV0IGggPSBpbWFnZURhdGEuaGVpZ2h0IHwgMDtcblxuXHRcdGxldCB3MSA9ICh3IC0gMSkgfCAwO1xuXHRcdGxldCBoMSA9IChoIC0gMSkgfCAwO1xuXHRcdGxldCByeHAxID0gKHJhZGl1c1ggKyAxKSB8IDA7XG5cdFx0bGV0IHJ5cDEgPSAocmFkaXVzWSArIDEpIHwgMDtcblxuXHRcdGxldCBzc3ggPSB7cjowLGI6MCxnOjAsYTowfTtcblx0XHRsZXQgc3ggPSBzc3g7XG5cdFx0Zm9yICggaSA9IDE7IGkgPCBkaXZ4OyBpKysgKVxuXHRcdHtcblx0XHRcdHN4ID0gc3gubiA9IHtyOjAsYjowLGc6MCxhOjB9O1xuXHRcdH1cblx0XHRzeC5uID0gc3N4O1xuXG5cdFx0bGV0IHNzeSA9IHtyOjAsYjowLGc6MCxhOjB9O1xuXHRcdGxldCBzeSA9IHNzeTtcblx0XHRmb3IgKCBpID0gMTsgaSA8IGRpdnk7IGkrKyApXG5cdFx0e1xuXHRcdFx0c3kgPSBzeS5uID0ge3I6MCxiOjAsZzowLGE6MH07XG5cdFx0fVxuXHRcdHN5Lm4gPSBzc3k7XG5cblx0XHRsZXQgc2kgPSBudWxsO1xuXG5cblx0XHRsZXQgbXR4ID0gQmx1ckZpbHRlci5NVUxfVEFCTEVbcmFkaXVzWF0gfCAwO1xuXHRcdGxldCBzdHggPSBCbHVyRmlsdGVyLlNIR19UQUJMRVtyYWRpdXNYXSB8IDA7XG5cdFx0bGV0IG10eSA9IEJsdXJGaWx0ZXIuTVVMX1RBQkxFW3JhZGl1c1ldIHwgMDtcblx0XHRsZXQgc3R5ID0gQmx1ckZpbHRlci5TSEdfVEFCTEVbcmFkaXVzWV0gfCAwO1xuXG5cdFx0d2hpbGUgKGl0ZXJhdGlvbnMtLSA+IDApIHtcblxuXHRcdFx0eXcgPSB5aSA9IDA7XG5cdFx0XHRsZXQgbXMgPSBtdHg7XG5cdFx0XHRsZXQgc3MgPSBzdHg7XG5cdFx0XHRmb3IgKHkgPSBoOyAtLXkgPiAtMTspIHtcblx0XHRcdFx0ciA9IHJ4cDEgKiAocHIgPSBweFsoeWkpIHwgMF0pO1xuXHRcdFx0XHRnID0gcnhwMSAqIChwZyA9IHB4Wyh5aSArIDEpIHwgMF0pO1xuXHRcdFx0XHRiID0gcnhwMSAqIChwYiA9IHB4Wyh5aSArIDIpIHwgMF0pO1xuXHRcdFx0XHRhID0gcnhwMSAqIChwYSA9IHB4Wyh5aSArIDMpIHwgMF0pO1xuXG5cdFx0XHRcdHN4ID0gc3N4O1xuXG5cdFx0XHRcdGZvciggaSA9IHJ4cDE7IC0taSA+IC0xOyApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRzeC5yID0gcHI7XG5cdFx0XHRcdFx0c3guZyA9IHBnO1xuXHRcdFx0XHRcdHN4LmIgPSBwYjtcblx0XHRcdFx0XHRzeC5hID0gcGE7XG5cdFx0XHRcdFx0c3ggPSBzeC5uO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Zm9yKCBpID0gMTsgaSA8IHJ4cDE7IGkrKyApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRwID0gKHlpICsgKCh3MSA8IGkgPyB3MSA6IGkpIDw8IDIpKSB8IDA7XG5cdFx0XHRcdFx0ciArPSAoIHN4LnIgPSBweFtwXSk7XG5cdFx0XHRcdFx0ZyArPSAoIHN4LmcgPSBweFtwKzFdKTtcblx0XHRcdFx0XHRiICs9ICggc3guYiA9IHB4W3ArMl0pO1xuXHRcdFx0XHRcdGEgKz0gKCBzeC5hID0gcHhbcCszXSk7XG5cblx0XHRcdFx0XHRzeCA9IHN4Lm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzaSA9IHNzeDtcblx0XHRcdFx0Zm9yICggeCA9IDA7IHggPCB3OyB4KysgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0cHhbeWkrK10gPSAociAqIG1zKSA+Pj4gc3M7XG5cdFx0XHRcdFx0cHhbeWkrK10gPSAoZyAqIG1zKSA+Pj4gc3M7XG5cdFx0XHRcdFx0cHhbeWkrK10gPSAoYiAqIG1zKSA+Pj4gc3M7XG5cdFx0XHRcdFx0cHhbeWkrK10gPSAoYSAqIG1zKSA+Pj4gc3M7XG5cblx0XHRcdFx0XHRwID0gKCh5dyArICgocCA9IHggKyByYWRpdXNYICsgMSkgPCB3MSA/IHAgOiB3MSkpIDw8IDIpO1xuXG5cdFx0XHRcdFx0ciAtPSBzaS5yIC0gKCBzaS5yID0gcHhbcF0pO1xuXHRcdFx0XHRcdGcgLT0gc2kuZyAtICggc2kuZyA9IHB4W3ArMV0pO1xuXHRcdFx0XHRcdGIgLT0gc2kuYiAtICggc2kuYiA9IHB4W3ArMl0pO1xuXHRcdFx0XHRcdGEgLT0gc2kuYSAtICggc2kuYSA9IHB4W3ArM10pO1xuXG5cdFx0XHRcdFx0c2kgPSBzaS5uO1xuXG5cdFx0XHRcdH1cblx0XHRcdFx0eXcgKz0gdztcblx0XHRcdH1cblxuXHRcdFx0bXMgPSBtdHk7XG5cdFx0XHRzcyA9IHN0eTtcblx0XHRcdGZvciAoeCA9IDA7IHggPCB3OyB4KyspIHtcblx0XHRcdFx0eWkgPSAoeCA8PCAyKSB8IDA7XG5cblx0XHRcdFx0ciA9IChyeXAxICogKHByID0gcHhbeWldKSkgfCAwO1xuXHRcdFx0XHRnID0gKHJ5cDEgKiAocGcgPSBweFsoeWkgKyAxKSB8IDBdKSkgfCAwO1xuXHRcdFx0XHRiID0gKHJ5cDEgKiAocGIgPSBweFsoeWkgKyAyKSB8IDBdKSkgfCAwO1xuXHRcdFx0XHRhID0gKHJ5cDEgKiAocGEgPSBweFsoeWkgKyAzKSB8IDBdKSkgfCAwO1xuXG5cdFx0XHRcdHN5ID0gc3N5O1xuXHRcdFx0XHRmb3IoIGkgPSAwOyBpIDwgcnlwMTsgaSsrIClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHN5LnIgPSBwcjtcblx0XHRcdFx0XHRzeS5nID0gcGc7XG5cdFx0XHRcdFx0c3kuYiA9IHBiO1xuXHRcdFx0XHRcdHN5LmEgPSBwYTtcblx0XHRcdFx0XHRzeSA9IHN5Lm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR5cCA9IHc7XG5cblx0XHRcdFx0Zm9yKCBpID0gMTsgaSA8PSByYWRpdXNZOyBpKysgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0eWkgPSAoIHlwICsgeCApIDw8IDI7XG5cblx0XHRcdFx0XHRyICs9ICggc3kuciA9IHB4W3lpXSk7XG5cdFx0XHRcdFx0ZyArPSAoIHN5LmcgPSBweFt5aSsxXSk7XG5cdFx0XHRcdFx0YiArPSAoIHN5LmIgPSBweFt5aSsyXSk7XG5cdFx0XHRcdFx0YSArPSAoIHN5LmEgPSBweFt5aSszXSk7XG5cblx0XHRcdFx0XHRzeSA9IHN5Lm47XG5cblx0XHRcdFx0XHRpZiggaSA8IGgxIClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHR5cCArPSB3O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHlpID0geDtcblx0XHRcdFx0c2kgPSBzc3k7XG5cdFx0XHRcdGlmICggaXRlcmF0aW9ucyA+IDAgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Zm9yICggeSA9IDA7IHkgPCBoOyB5KysgKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHAgPSB5aSA8PCAyO1xuXHRcdFx0XHRcdFx0cHhbcCszXSA9IHBhID0oYSAqIG1zKSA+Pj4gc3M7XG5cdFx0XHRcdFx0XHRpZiAoIHBhID4gMCApXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdHB4W3BdICAgPSAoKHIgKiBtcykgPj4+IHNzICk7XG5cdFx0XHRcdFx0XHRcdHB4W3ArMV0gPSAoKGcgKiBtcykgPj4+IHNzICk7XG5cdFx0XHRcdFx0XHRcdHB4W3ArMl0gPSAoKGIgKiBtcykgPj4+IHNzICk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRweFtwXSA9IHB4W3ArMV0gPSBweFtwKzJdID0gMFxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRwID0gKCB4ICsgKCggKCBwID0geSArIHJ5cDEpIDwgaDEgPyBwIDogaDEgKSAqIHcgKSkgPDwgMjtcblxuXHRcdFx0XHRcdFx0ciAtPSBzaS5yIC0gKCBzaS5yID0gcHhbcF0pO1xuXHRcdFx0XHRcdFx0ZyAtPSBzaS5nIC0gKCBzaS5nID0gcHhbcCsxXSk7XG5cdFx0XHRcdFx0XHRiIC09IHNpLmIgLSAoIHNpLmIgPSBweFtwKzJdKTtcblx0XHRcdFx0XHRcdGEgLT0gc2kuYSAtICggc2kuYSA9IHB4W3ArM10pO1xuXG5cdFx0XHRcdFx0XHRzaSA9IHNpLm47XG5cblx0XHRcdFx0XHRcdHlpICs9IHc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGZvciAoIHkgPSAwOyB5IDwgaDsgeSsrIClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRwID0geWkgPDwgMjtcblx0XHRcdFx0XHRcdHB4W3ArM10gPSBwYSA9KGEgKiBtcykgPj4+IHNzO1xuXHRcdFx0XHRcdFx0aWYgKCBwYSA+IDAgKVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRwYSA9IDI1NSAvIHBhO1xuXHRcdFx0XHRcdFx0XHRweFtwXSAgID0gKChyICogbXMpID4+PiBzcyApICogcGE7XG5cdFx0XHRcdFx0XHRcdHB4W3ArMV0gPSAoKGcgKiBtcykgPj4+IHNzICkgKiBwYTtcblx0XHRcdFx0XHRcdFx0cHhbcCsyXSA9ICgoYiAqIG1zKSA+Pj4gc3MgKSAqIHBhO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0cHhbcF0gPSBweFtwKzFdID0gcHhbcCsyXSA9IDBcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0cCA9ICggeCArICgoICggcCA9IHkgKyByeXAxKSA8IGgxID8gcCA6IGgxICkgKiB3ICkpIDw8IDI7XG5cblx0XHRcdFx0XHRcdHIgLT0gc2kuciAtICggc2kuciA9IHB4W3BdKTtcblx0XHRcdFx0XHRcdGcgLT0gc2kuZyAtICggc2kuZyA9IHB4W3ArMV0pO1xuXHRcdFx0XHRcdFx0YiAtPSBzaS5iIC0gKCBzaS5iID0gcHhbcCsyXSk7XG5cdFx0XHRcdFx0XHRhIC09IHNpLmEgLSAoIHNpLmEgPSBweFtwKzNdKTtcblxuXHRcdFx0XHRcdFx0c2kgPSBzaS5uO1xuXG5cdFx0XHRcdFx0XHR5aSArPSB3O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cbn1cblxuLyoqXG4gKiBBcnJheSBvZiBtdWx0aXBseSB2YWx1ZXMgZm9yIGJsdXIgY2FsY3VsYXRpb25zLlxuICogQHR5cGUge0FycmF5fVxuICogQHByb3RlY3RlZFxuICogQHJlYWRvbmx5XG4gKiBAc3RhdGljXG4gKi9cbkJsdXJGaWx0ZXIuTVVMX1RBQkxFID0gWzEsIDE3MSwgMjA1LCAyOTMsIDU3LCAzNzMsIDc5LCAxMzcsIDI0MSwgMjcsIDM5MSwgMzU3LCA0MSwgMTksIDI4MywgMjY1LCA0OTcsIDQ2OSwgNDQzLCA0MjEsIDI1LCAxOTEsIDM2NSwgMzQ5LCAzMzUsIDE2MSwgMTU1LCAxNDksIDksIDI3OCwgMjY5LCAyNjEsIDUwNSwgMjQ1LCA0NzUsIDIzMSwgNDQ5LCA0MzcsIDIxMywgNDE1LCA0MDUsIDM5NSwgMTkzLCAzNzcsIDM2OSwgMzYxLCAzNTMsIDM0NSwgMTY5LCAzMzEsIDMyNSwgMzE5LCAzMTMsIDMwNywgMzAxLCAzNywgMTQ1LCAyODUsIDI4MSwgNjksIDI3MSwgMjY3LCAyNjMsIDI1OSwgNTA5LCA1MDEsIDQ5MywgMjQzLCA0NzksIDExOCwgNDY1LCA0NTksIDExMywgNDQ2LCA1NSwgNDM1LCA0MjksIDQyMywgMjA5LCA0MTMsIDUxLCA0MDMsIDE5OSwgMzkzLCA5NywgMywgMzc5LCAzNzUsIDM3MSwgMzY3LCAzNjMsIDM1OSwgMzU1LCAzNTEsIDM0NywgNDMsIDg1LCAzMzcsIDMzMywgMTY1LCAzMjcsIDMyMywgNSwgMzE3LCAxNTcsIDMxMSwgNzcsIDMwNSwgMzAzLCA3NSwgMjk3LCAyOTQsIDczLCAyODksIDI4NywgNzEsIDE0MSwgMjc5LCAyNzcsIDI3NSwgNjgsIDEzNSwgNjcsIDEzMywgMzMsIDI2MiwgMjYwLCAxMjksIDUxMSwgNTA3LCA1MDMsIDQ5OSwgNDk1LCA0OTEsIDYxLCAxMjEsIDQ4MSwgNDc3LCAyMzcsIDIzNSwgNDY3LCAyMzIsIDExNSwgNDU3LCAyMjcsIDQ1MSwgNywgNDQ1LCAyMjEsIDQzOSwgMjE4LCA0MzMsIDIxNSwgNDI3LCA0MjUsIDIxMSwgNDE5LCA0MTcsIDIwNywgNDExLCA0MDksIDIwMywgMjAyLCA0MDEsIDM5OSwgMzk2LCAxOTcsIDQ5LCAzODksIDM4NywgMzg1LCAzODMsIDk1LCAxODksIDQ3LCAxODcsIDkzLCAxODUsIDIzLCAxODMsIDkxLCAxODEsIDQ1LCAxNzksIDg5LCAxNzcsIDExLCAxNzUsIDg3LCAxNzMsIDM0NSwgMzQzLCAzNDEsIDMzOSwgMzM3LCAyMSwgMTY3LCA4MywgMzMxLCAzMjksIDMyNywgMTYzLCA4MSwgMzIzLCAzMjEsIDMxOSwgMTU5LCA3OSwgMzE1LCAzMTMsIDM5LCAxNTUsIDMwOSwgMzA3LCAxNTMsIDMwNSwgMzAzLCAxNTEsIDc1LCAyOTksIDE0OSwgMzcsIDI5NSwgMTQ3LCA3MywgMjkxLCAxNDUsIDI4OSwgMjg3LCAxNDMsIDI4NSwgNzEsIDE0MSwgMjgxLCAzNSwgMjc5LCAxMzksIDY5LCAyNzUsIDEzNywgMjczLCAxNywgMjcxLCAxMzUsIDI2OSwgMjY3LCAxMzMsIDI2NSwgMzMsIDI2MywgMTMxLCAyNjEsIDEzMCwgMjU5LCAxMjksIDI1NywgMV07XG4vKipcbiAqIEFycmF5IG9mIHNoaWZ0IHZhbHVlcyBmb3IgYmx1ciBjYWxjdWxhdGlvbnMuXG4gKiBAdHlwZSB7QXJyYXl9XG4gKiBAcHJvdGVjdGVkXG4gKiBAc3RhdGljXG4gKi9cbkJsdXJGaWx0ZXIuU0hHX1RBQkxFID0gWzAsIDksIDEwLCAxMSwgOSwgMTIsIDEwLCAxMSwgMTIsIDksIDEzLCAxMywgMTAsIDksIDEzLCAxMywgMTQsIDE0LCAxNCwgMTQsIDEwLCAxMywgMTQsIDE0LCAxNCwgMTMsIDEzLCAxMywgOSwgMTQsIDE0LCAxNCwgMTUsIDE0LCAxNSwgMTQsIDE1LCAxNSwgMTQsIDE1LCAxNSwgMTUsIDE0LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE0LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxMiwgMTQsIDE1LCAxNSwgMTMsIDE1LCAxNSwgMTUsIDE1LCAxNiwgMTYsIDE2LCAxNSwgMTYsIDE0LCAxNiwgMTYsIDE0LCAxNiwgMTMsIDE2LCAxNiwgMTYsIDE1LCAxNiwgMTMsIDE2LCAxNSwgMTYsIDE0LCA5LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxMywgMTQsIDE2LCAxNiwgMTUsIDE2LCAxNiwgMTAsIDE2LCAxNSwgMTYsIDE0LCAxNiwgMTYsIDE0LCAxNiwgMTYsIDE0LCAxNiwgMTYsIDE0LCAxNSwgMTYsIDE2LCAxNiwgMTQsIDE1LCAxNCwgMTUsIDEzLCAxNiwgMTYsIDE1LCAxNywgMTcsIDE3LCAxNywgMTcsIDE3LCAxNCwgMTUsIDE3LCAxNywgMTYsIDE2LCAxNywgMTYsIDE1LCAxNywgMTYsIDE3LCAxMSwgMTcsIDE2LCAxNywgMTYsIDE3LCAxNiwgMTcsIDE3LCAxNiwgMTcsIDE3LCAxNiwgMTcsIDE3LCAxNiwgMTYsIDE3LCAxNywgMTcsIDE2LCAxNCwgMTcsIDE3LCAxNywgMTcsIDE1LCAxNiwgMTQsIDE2LCAxNSwgMTYsIDEzLCAxNiwgMTUsIDE2LCAxNCwgMTYsIDE1LCAxNiwgMTIsIDE2LCAxNSwgMTYsIDE3LCAxNywgMTcsIDE3LCAxNywgMTMsIDE2LCAxNSwgMTcsIDE3LCAxNywgMTYsIDE1LCAxNywgMTcsIDE3LCAxNiwgMTUsIDE3LCAxNywgMTQsIDE2LCAxNywgMTcsIDE2LCAxNywgMTcsIDE2LCAxNSwgMTcsIDE2LCAxNCwgMTcsIDE2LCAxNSwgMTcsIDE2LCAxNywgMTcsIDE2LCAxNywgMTUsIDE2LCAxNywgMTQsIDE3LCAxNiwgMTUsIDE3LCAxNiwgMTcsIDEzLCAxNywgMTYsIDE3LCAxNywgMTYsIDE3LCAxNCwgMTcsIDE2LCAxNywgMTYsIDE3LCAxNiwgMTcsIDldO1xuIiwiLyoqXG4gKiBAbGljZW5zZSBDb2xvckZpbHRlclxuICogVmlzaXQgaHR0cDovL2NyZWF0ZWpzLmNvbS8gZm9yIGRvY3VtZW50YXRpb24sIHVwZGF0ZXMgYW5kIGV4YW1wbGVzLlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNyBnc2tpbm5lci5jb20sIGluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICogb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cbiAqIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxuICogcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsXG4gKiBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4gKiBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuICogY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAqIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xuICogT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAqIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4gKiBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcbiAqIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuICogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUlxuICogT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICovXG5cbmltcG9ydCBGaWx0ZXIgZnJvbSBcIi4vRmlsdGVyXCI7XG5cbi8qKlxuICogQXBwbGllcyBhIGNvbG9yIHRyYW5zZm9ybSB0byBEaXNwbGF5T2JqZWN0cy5cbiAqXG4gKiBAbWVtYmVyb2YgZWFzZWxqc1xuICogQGV4dGVuZHMgZWFzZWxqcy5GaWx0ZXJcbiAqIEBleGFtcGxlXG4gKiBsZXQgc2hhcGUgPSBuZXcgU2hhcGUoKS5zZXQoeyB4OiAxMDAsIHk6IDEwMCB9KTtcbiAqIHNoYXBlLmdyYXBoaWNzLmJlZ2luRmlsbChcIiNmZjAwMDBcIikuZHJhd0NpcmNsZSgwLDAsNTApO1xuICogc2hhcGUuZmlsdGVycyA9IFsgbmV3IENvbG9yRmlsdGVyKDAsMCwwLDEsIDAsMCwyNTUsMCkgXTtcbiAqIHNoYXBlLmNhY2hlKC01MCwgLTUwLCAxMDAsIDEwMCk7XG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IFtyZWRNdWx0aXBsaWVyPTFdIFRoZSBhbW91bnQgdG8gbXVsdGlwbHkgYWdhaW5zdCB0aGUgcmVkIGNoYW5uZWwuIFRoaXMgaXMgYSByYW5nZSBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAcGFyYW0ge051bWJlcn0gW2dyZWVuTXVsdGlwbGllcj0xXSBUaGUgYW1vdW50IHRvIG11bHRpcGx5IGFnYWluc3QgdGhlIGdyZWVuIGNoYW5uZWwuIFRoaXMgaXMgYSByYW5nZSBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAcGFyYW0ge051bWJlcn0gW2JsdWVNdWx0aXBsaWVyPTFdIFRoZSBhbW91bnQgdG8gbXVsdGlwbHkgYWdhaW5zdCB0aGUgYmx1ZSBjaGFubmVsLiBUaGlzIGlzIGEgcmFuZ2UgYmV0d2VlbiAwIGFuZCAxLlxuICogQHBhcmFtIHtOdW1iZXJ9IFthbHBoYU11bHRpcGxpZXI9MV0gVGhlIGFtb3VudCB0byBtdWx0aXBseSBhZ2FpbnN0IHRoZSBhbHBoYSBjaGFubmVsLiBUaGlzIGlzIGEgcmFuZ2UgYmV0d2VlbiAwIGFuZCAxLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtyZWRPZmZzZXQ9MF0gVGhlIGFtb3VudCB0byBhZGQgdG8gdGhlIHJlZCBjaGFubmVsIGFmdGVyIGl0IGhhcyBiZWVuIG11bHRpcGxpZWQuIFRoaXMgaXMgYSByYW5nZVxuICogYmV0d2VlbiAtMjU1IGFuZCAyNTUuXG4gKiBAcGFyYW0ge051bWJlcn0gW2dyZWVuT2Zmc2V0PTBdIFRoZSBhbW91bnQgdG8gYWRkIHRvIHRoZSBncmVlbiBjaGFubmVsIGFmdGVyIGl0IGhhcyBiZWVuIG11bHRpcGxpZWQuIFRoaXMgaXMgYSByYW5nZVxuICogYmV0d2VlbiAtMjU1IGFuZCAyNTUuXG4gKiBAcGFyYW0ge051bWJlcn0gW2JsdWVPZmZzZXQ9MF0gVGhlIGFtb3VudCB0byBhZGQgdG8gdGhlIGJsdWUgY2hhbm5lbCBhZnRlciBpdCBoYXMgYmVlbiBtdWx0aXBsaWVkLiBUaGlzIGlzIGEgcmFuZ2VcbiAqIGJldHdlZW4gLTI1NSBhbmQgMjU1LlxuICogQHBhcmFtIHtOdW1iZXJ9IFthbHBoYU9mZnNldD0wXSBUaGUgYW1vdW50IHRvIGFkZCB0byB0aGUgYWxwaGEgY2hhbm5lbCBhZnRlciBpdCBoYXMgYmVlbiBtdWx0aXBsaWVkLiBUaGlzIGlzIGEgcmFuZ2VcbiAqIGJldHdlZW4gLTI1NSBhbmQgMjU1LlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb2xvckZpbHRlciBleHRlbmRzIEZpbHRlciB7XG5cblx0Y29uc3RydWN0b3IgKHJlZE11bHRpcGxpZXIgPSAxLCBncmVlbk11bHRpcGxpZXIgPSAxLCBibHVlTXVsdGlwbGllciA9IDEsIGFscGhhTXVsdGlwbGllciA9IDEsIHJlZE9mZnNldCA9IDAsIGdyZWVuT2Zmc2V0ID0gMCwgYmx1ZU9mZnNldCA9IDAsIGFscGhhT2Zmc2V0ID0gMCkge1xuXHRcdHN1cGVyKCk7XG5cblx0XHQvKipcblx0XHQgKiBSZWQgY2hhbm5lbCBtdWx0aXBsaWVyLlxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICovXG5cdFx0dGhpcy5yZWRNdWx0aXBsaWVyID0gcmVkTXVsdGlwbGllcjtcblxuXHRcdC8qKlxuXHRcdCAqIEdyZWVuIGNoYW5uZWwgbXVsdGlwbGllci5cblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqL1xuXHRcdHRoaXMuZ3JlZW5NdWx0aXBsaWVyID0gZ3JlZW5NdWx0aXBsaWVyO1xuXG5cdFx0LyoqXG5cdFx0ICogQmx1ZSBjaGFubmVsIG11bHRpcGxpZXIuXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKi9cblx0XHR0aGlzLmJsdWVNdWx0aXBsaWVyID0gYmx1ZU11bHRpcGxpZXI7XG5cblx0XHQvKipcblx0XHQgKiBBbHBoYSBjaGFubmVsIG11bHRpcGxpZXIuXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKi9cblx0XHR0aGlzLmFscGhhTXVsdGlwbGllciA9IGFscGhhTXVsdGlwbGllcjtcblxuXHRcdC8qKlxuXHRcdCAqIFJlZCBjaGFubmVsIG9mZnNldCAoYWRkZWQgdG8gdmFsdWUpLlxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICovXG5cdFx0dGhpcy5yZWRPZmZzZXQgPSByZWRPZmZzZXQ7XG5cblx0XHQvKipcblx0XHQgKiBHcmVlbiBjaGFubmVsIG9mZnNldCAoYWRkZWQgdG8gdmFsdWUpLlxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICovXG5cdFx0dGhpcy5ncmVlbk9mZnNldCA9IGdyZWVuT2Zmc2V0O1xuXG5cdFx0LyoqXG5cdFx0ICogQmx1ZSBjaGFubmVsIG9mZnNldCAoYWRkZWQgdG8gdmFsdWUpLlxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICovXG5cdFx0dGhpcy5ibHVlT2Zmc2V0ID0gYmx1ZU9mZnNldDtcblxuXHRcdC8qKlxuXHRcdCAqIEFscGhhIGNoYW5uZWwgb2Zmc2V0IChhZGRlZCB0byB2YWx1ZSkuXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKi9cblx0XHR0aGlzLmFscGhhT2Zmc2V0ID0gYWxwaGFPZmZzZXQ7XG5cblx0XHR0aGlzLkZSQUdfU0hBREVSX0JPRFkgPSBgXG5cdFx0XHR1bmlmb3JtIHZlYzQgdUNvbG9yTXVsdGlwbGllcjtcblx0XHRcdHVuaWZvcm0gdmVjNCB1Q29sb3JPZmZzZXQ7XG5cblx0XHRcdHZvaWQgbWFpbiAodm9pZCkge1xuXHRcdFx0XHR2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2UmVuZGVyQ29vcmQpO1xuXG5cdFx0XHRcdGdsX0ZyYWdDb2xvciA9IChjb2xvciAqIHVDb2xvck11bHRpcGxpZXIpICsgdUNvbG9yT2Zmc2V0O1xuXHRcdFx0fVxuXHRcdGA7XG5cblx0fVxuXG5cdHNoYWRlclBhcmFtU2V0dXAgKGdsLCBzdGFnZSwgc2hhZGVyUHJvZ3JhbSkge1xuXHRcdGdsLnVuaWZvcm00Zihcblx0XHRcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbihzaGFkZXJQcm9ncmFtLCBcInVDb2xvck11bHRpcGxpZXJcIiksXG5cdFx0XHR0aGlzLnJlZE11bHRpcGxpZXIsIHRoaXMuZ3JlZW5NdWx0aXBsaWVyLCB0aGlzLmJsdWVNdWx0aXBsaWVyLCB0aGlzLmFscGhhTXVsdGlwbGllclxuXHRcdCk7XG5cblx0XHRnbC51bmlmb3JtNGYoXG5cdFx0XHRnbC5nZXRVbmlmb3JtTG9jYXRpb24oc2hhZGVyUHJvZ3JhbSwgXCJ1Q29sb3JPZmZzZXRcIiksXG5cdFx0XHR0aGlzLnJlZE9mZnNldC8yNTUsIHRoaXMuZ3JlZW5PZmZzZXQvMjU1LCB0aGlzLmJsdWVPZmZzZXQvMjU1LCB0aGlzLmFscGhhT2Zmc2V0LzI1NVxuXHRcdCk7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybiB7ZWFzZWxqcy5Db2xvckZpbHRlcn1cblx0ICovXG5cdGNsb25lICgpIHtcblx0XHRyZXR1cm4gbmV3IENvbG9yRmlsdGVyKFxuXHRcdFx0dGhpcy5yZWRNdWx0aXBsaWVyLCB0aGlzLmdyZWVuTXVsdGlwbGllciwgdGhpcy5ibHVlTXVsdGlwbGllciwgdGhpcy5hbHBoYU11bHRpcGxpZXIsXG5cdFx0XHR0aGlzLnJlZE9mZnNldCwgdGhpcy5ncmVlbk9mZnNldCwgdGhpcy5ibHVlT2Zmc2V0LCB0aGlzLmFscGhhT2Zmc2V0XG5cdFx0KTtcblx0fVxuXG5cdF9hcHBseUZpbHRlciAoaW1hZ2VEYXRhKSB7XG5cdFx0bGV0IGRhdGEgPSBpbWFnZURhdGEuZGF0YTtcblx0XHRjb25zdCBsID0gZGF0YS5sZW5ndGg7XG5cdFx0Zm9yIChsZXQgaT0wOyBpPGw7IGkrPTQpIHtcblx0XHRcdGRhdGFbaV0gPSBkYXRhW2ldKnRoaXMucmVkTXVsdGlwbGllcit0aGlzLnJlZE9mZnNldDtcblx0XHRcdGRhdGFbaSsxXSA9IGRhdGFbaSsxXSp0aGlzLmdyZWVuTXVsdGlwbGllcit0aGlzLmdyZWVuT2Zmc2V0O1xuXHRcdFx0ZGF0YVtpKzJdID0gZGF0YVtpKzJdKnRoaXMuYmx1ZU11bHRpcGxpZXIrdGhpcy5ibHVlT2Zmc2V0O1xuXHRcdFx0ZGF0YVtpKzNdID0gZGF0YVtpKzNdKnRoaXMuYWxwaGFNdWx0aXBsaWVyK3RoaXMuYWxwaGFPZmZzZXQ7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cbn1cbiIsIi8qKlxuICogQGxpY2Vuc2UgQ29sb3JNYXRyaXhcbiAqIFZpc2l0IGh0dHA6Ly9jcmVhdGVqcy5jb20vIGZvciBkb2N1bWVudGF0aW9uLCB1cGRhdGVzIGFuZCBleGFtcGxlcy5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgZ3NraW5uZXIuY29tLCBpbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAqIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXG4gKiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXRcbiAqIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxuICogY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuICogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbiAqIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAqIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gKiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcbiAqIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gKiBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuICogSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXG4gKiBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcbiAqIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKipcbiAqIFByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgZm9yIGFzc2VtYmxpbmcgYSBtYXRyaXggZm9yIHVzZSB3aXRoIHRoZSB7QGxpbmsgZWFzZWxqcy5Db2xvck1hdHJpeEZpbHRlcn0uXG4gKiBNb3N0IG1ldGhvZHMgcmV0dXJuIHRoZSBpbnN0YW5jZSB0byBmYWNpbGl0YXRlIGNoYWluZWQgY2FsbHMuXG4gKlxuICogQG1lbWJlcm9mIGVhc2VsanNcbiAqIEBleGFtcGxlXG4gKiBjb2xvck1hdHJpeC5hZGp1c3RIdWUoMjApLmFkanVzdEJyaWdodG5lc3MoNTApO1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBicmlnaHRuZXNzXG4gKiBAcGFyYW0ge051bWJlcn0gY29udHJhc3RcbiAqIEBwYXJhbSB7TnVtYmVyfSBzYXR1cmF0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gaHVlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbG9yTWF0cml4IHtcblxuXHRjb25zdHJ1Y3RvciAoYnJpZ2h0bmVzcywgY29udHJhc3QsIHNhdHVyYXRpb24sIGh1ZSkge1xuXHRcdHRoaXMuc2V0Q29sb3IoYnJpZ2h0bmVzcywgY29udHJhc3QsIHNhdHVyYXRpb24sIGh1ZSk7XG5cdH1cblxuXHQvKipcblx0ICogUmVzZXRzIHRoZSBpbnN0YW5jZSB3aXRoIHRoZSBzcGVjaWZpZWQgdmFsdWVzLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gYnJpZ2h0bmVzc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gY29udHJhc3Rcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHNhdHVyYXRpb25cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGh1ZVxuXHQgKiBAcmV0dXJuIHtlYXNlbGpzLkNvbG9yTWF0cml4fSBUaGUgQ29sb3JNYXRyaXggaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRzZXRDb2xvciAoYnJpZ2h0bmVzcywgY29udHJhc3QsIHNhdHVyYXRpb24sIGh1ZSkge1xuXHRcdHJldHVybiB0aGlzLnJlc2V0KCkuYWRqdXN0Q29sb3IoYnJpZ2h0bmVzcywgY29udHJhc3QsIHNhdHVyYXRpb24sIGh1ZSk7XG5cdH1cblxuXHQvKipcblx0ICogUmVzZXRzIHRoZSBtYXRyaXggdG8gaWRlbnRpdHkgdmFsdWVzLlxuXHQgKiBAcmV0dXJuIHtlYXNlbGpzLkNvbG9yTWF0cml4fSBUaGUgQ29sb3JNYXRyaXggaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRyZXNldCAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuY29weShDb2xvck1hdHJpeC5JREVOVElUWV9NQVRSSVgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IG1ldGhvZCB0byBhZGp1c3QgYnJpZ2h0bmVzcywgY29udHJhc3QsIHNhdHVyYXRpb24gYW5kIGh1ZS4gRXF1aXZhbGVudCB0byBjYWxsaW5nIGFkanVzdEh1ZShodWUpLCBhZGp1c3RDb250cmFzdChjb250cmFzdCksXG5cdCAqIGFkanVzdEJyaWdodG5lc3MoYnJpZ2h0bmVzcyksIGFkanVzdFNhdHVyYXRpb24oc2F0dXJhdGlvbiksIGluIHRoYXQgb3JkZXIuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBicmlnaHRuZXNzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjb250cmFzdFxuXHQgKiBAcGFyYW0ge051bWJlcn0gc2F0dXJhdGlvblxuXHQgKiBAcGFyYW0ge051bWJlcn0gaHVlXG5cdCAqIEByZXR1cm4ge2Vhc2VsanMuQ29sb3JNYXRyaXh9IFRoZSBDb2xvck1hdHJpeCBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdGFkanVzdENvbG9yIChicmlnaHRuZXNzLCBjb250cmFzdCwgc2F0dXJhdGlvbiwgaHVlKSB7XG5cdFx0cmV0dXJuIHRoaXMuYWRqdXN0QnJpZ2h0bmVzcyhicmlnaHRuZXNzKS5hZGp1c3RDb250cmFzdChjb250cmFzdCkuYWRqdXN0U2F0dXJhdGlvbihzYXR1cmF0aW9uKS5hZGp1c3RIdWUoaHVlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGp1c3RzIHRoZSBicmlnaHRuZXNzIG9mIHBpeGVsIGNvbG9yIGJ5IGFkZGluZyB0aGUgc3BlY2lmaWVkIHZhbHVlIHRvIHRoZSByZWQsIGdyZWVuIGFuZCBibHVlIGNoYW5uZWxzLlxuXHQgKiBQb3NpdGl2ZSB2YWx1ZXMgd2lsbCBtYWtlIHRoZSBpbWFnZSBicmlnaHRlciwgbmVnYXRpdmUgdmFsdWVzIHdpbGwgbWFrZSBpdCBkYXJrZXIuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBBIHZhbHVlIGJldHdlZW4gLTI1NSAmIDI1NSB0aGF0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIFJHQiBjaGFubmVscy5cblx0ICogQHJldHVybiB7ZWFzZWxqcy5Db2xvck1hdHJpeH0gVGhlIENvbG9yTWF0cml4IGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0YWRqdXN0QnJpZ2h0bmVzcyAodmFsdWUpIHtcblx0XHRpZiAodmFsdWUgPT09IDAgfHwgaXNOYU4odmFsdWUpKSB7IHJldHVybiB0aGlzOyB9XG5cdFx0dmFsdWUgPSB0aGlzLl9jbGVhblZhbHVlKHZhbHVlLCAyNTUpO1xuXHRcdHRoaXMuX211bHRpcGx5TWF0cml4KFtcblx0XHRcdDEsMCwwLDAsdmFsdWUsXG5cdFx0XHQwLDEsMCwwLHZhbHVlLFxuXHRcdFx0MCwwLDEsMCx2YWx1ZSxcblx0XHRcdDAsMCwwLDEsMCxcblx0XHRcdDAsMCwwLDAsMVxuXHRcdF0pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkanVzdHMgdGhlIGNvbnRyYXN0IG9mIHBpeGVsIGNvbG9yLlxuXHQgKiBQb3NpdGl2ZSB2YWx1ZXMgd2lsbCBpbmNyZWFzZSBjb250cmFzdCwgbmVnYXRpdmUgdmFsdWVzIHdpbGwgZGVjcmVhc2UgY29udHJhc3QuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBBIHZhbHVlIGJldHdlZW4gLTEwMCAmIDEwMC5cblx0ICogQHJldHVybiB7ZWFzZWxqcy5Db2xvck1hdHJpeH0gVGhlIENvbG9yTWF0cml4IGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0YWRqdXN0Q29udHJhc3QgKHZhbHVlKSB7XG5cdFx0aWYgKHZhbHVlID09PSAwIHx8IGlzTmFOKHZhbHVlKSkgeyByZXR1cm4gdGhpczsgfVxuXHRcdHZhbHVlID0gdGhpcy5fY2xlYW5WYWx1ZSh2YWx1ZSwgMTAwKTtcblx0XHRsZXQgeDtcblx0XHRpZiAodmFsdWU8MCkge1xuXHRcdFx0eCA9IDEyNyt2YWx1ZS8xMDAqMTI3O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR4ID0gdmFsdWUlMTtcblx0XHRcdGlmICh4ID09PSAwKSB7XG5cdFx0XHRcdHggPSBDb2xvck1hdHJpeC5ERUxUQV9JTkRFWFt2YWx1ZV07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR4ID0gQ29sb3JNYXRyaXguREVMVEFfSU5ERVhbKHZhbHVlPDwwKV0qKDEteCkrQ29sb3JNYXRyaXguREVMVEFfSU5ERVhbKHZhbHVlPDwwKSsxXSp4OyAvLyB1c2UgbGluZWFyIGludGVycG9sYXRpb24gZm9yIG1vcmUgZ3JhbnVsYXJpdHkuXG5cdFx0XHR9XG5cdFx0XHR4ID0geCoxMjcrMTI3O1xuXHRcdH1cblx0XHR0aGlzLl9tdWx0aXBseU1hdHJpeChbXG5cdFx0XHR4LzEyNywwLDAsMCwwLjUqKDEyNy14KSxcblx0XHRcdDAseC8xMjcsMCwwLDAuNSooMTI3LXgpLFxuXHRcdFx0MCwwLHgvMTI3LDAsMC41KigxMjcteCksXG5cdFx0XHQwLDAsMCwxLDAsXG5cdFx0XHQwLDAsMCwwLDFcblx0XHRdKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGp1c3RzIHRoZSBjb2xvciBzYXR1cmF0aW9uIG9mIHRoZSBwaXhlbC5cblx0ICogUG9zaXRpdmUgdmFsdWVzIHdpbGwgaW5jcmVhc2Ugc2F0dXJhdGlvbiwgbmVnYXRpdmUgdmFsdWVzIHdpbGwgZGVjcmVhc2Ugc2F0dXJhdGlvbiAodHJlbmQgdG93YXJkcyBncmV5c2NhbGUpLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgQSB2YWx1ZSBiZXR3ZWVuIC0xMDAgJiAxMDAuXG5cdCAqIEByZXR1cm4ge2Vhc2VsanMuQ29sb3JNYXRyaXh9IFRoZSBDb2xvck1hdHJpeCBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdGFkanVzdFNhdHVyYXRpb24gKHZhbHVlKSB7XG5cdFx0aWYgKHZhbHVlID09PSAwIHx8IGlzTmFOKHZhbHVlKSkgeyByZXR1cm4gdGhpczsgfVxuXHRcdHZhbHVlID0gdGhpcy5fY2xlYW5WYWx1ZSh2YWx1ZSwgMTAwKTtcblx0XHRsZXQgeCA9IDErKCh2YWx1ZSA+IDApID8gMyp2YWx1ZS8xMDAgOiB2YWx1ZS8xMDApO1xuXHRcdGxldCBsdW1SID0gMC4zMDg2O1xuXHRcdGxldCBsdW1HID0gMC42MDk0O1xuXHRcdGxldCBsdW1CID0gMC4wODIwO1xuXHRcdHRoaXMuX211bHRpcGx5TWF0cml4KFtcblx0XHRcdGx1bVIqKDEteCkreCxsdW1HKigxLXgpLGx1bUIqKDEteCksMCwwLFxuXHRcdFx0bHVtUiooMS14KSxsdW1HKigxLXgpK3gsbHVtQiooMS14KSwwLDAsXG5cdFx0XHRsdW1SKigxLXgpLGx1bUcqKDEteCksbHVtQiooMS14KSt4LDAsMCxcblx0XHRcdDAsMCwwLDEsMCxcblx0XHRcdDAsMCwwLDAsMVxuXHRcdF0pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblxuXHQvKipcblx0ICogQWRqdXN0cyB0aGUgaHVlIG9mIHRoZSBwaXhlbCBjb2xvci5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIEEgdmFsdWUgYmV0d2VlbiAtMTgwICYgMTgwLlxuXHQgKiBAcmV0dXJuIHtlYXNlbGpzLkNvbG9yTWF0cml4fSBUaGUgQ29sb3JNYXRyaXggaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRhZGp1c3RIdWUgKHZhbHVlKSB7XG5cdFx0aWYgKHZhbHVlID09PSAwIHx8IGlzTmFOKHZhbHVlKSkgeyByZXR1cm4gdGhpczsgfVxuXHRcdHZhbHVlID0gdGhpcy5fY2xlYW5WYWx1ZSh2YWx1ZSwgMTgwKS8xODAqTWF0aC5QSTtcblx0XHRsZXQgY29zVmFsID0gTWF0aC5jb3ModmFsdWUpO1xuXHRcdGxldCBzaW5WYWwgPSBNYXRoLnNpbih2YWx1ZSk7XG5cdFx0bGV0IGx1bVIgPSAwLjIxMztcblx0XHRsZXQgbHVtRyA9IDAuNzE1O1xuXHRcdGxldCBsdW1CID0gMC4wNzI7XG5cdFx0dGhpcy5fbXVsdGlwbHlNYXRyaXgoW1xuXHRcdFx0bHVtUitjb3NWYWwqKDEtbHVtUikrc2luVmFsKigtbHVtUiksbHVtRytjb3NWYWwqKC1sdW1HKStzaW5WYWwqKC1sdW1HKSxsdW1CK2Nvc1ZhbCooLWx1bUIpK3NpblZhbCooMS1sdW1CKSwwLDAsXG5cdFx0XHRsdW1SK2Nvc1ZhbCooLWx1bVIpK3NpblZhbCooMC4xNDMpLGx1bUcrY29zVmFsKigxLWx1bUcpK3NpblZhbCooMC4xNDApLGx1bUIrY29zVmFsKigtbHVtQikrc2luVmFsKigtMC4yODMpLDAsMCxcblx0XHRcdGx1bVIrY29zVmFsKigtbHVtUikrc2luVmFsKigtKDEtbHVtUikpLGx1bUcrY29zVmFsKigtbHVtRykrc2luVmFsKihsdW1HKSxsdW1CK2Nvc1ZhbCooMS1sdW1CKStzaW5WYWwqKGx1bUIpLDAsMCxcblx0XHRcdDAsMCwwLDEsMCxcblx0XHRcdDAsMCwwLDAsMVxuXHRcdF0pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbmNhdGVuYXRlcyAobXVsdGlwbGllcykgdGhlIHNwZWNpZmllZCBtYXRyaXggd2l0aCB0aGlzIG9uZS5cblx0ICogQHBhcmFtIHtBcnJheX0gbWF0cml4IEFuIGFycmF5IG9yIENvbG9yTWF0cml4IGluc3RhbmNlLlxuXHQgKiBAcmV0dXJuIHtlYXNlbGpzLkNvbG9yTWF0cml4fSBUaGUgQ29sb3JNYXRyaXggaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRjb25jYXQgKG1hdHJpeCkge1xuXHRcdG1hdHJpeCA9IHRoaXMuX2ZpeE1hdHJpeChtYXRyaXgpO1xuXHRcdGlmIChtYXRyaXgubGVuZ3RoICE9IENvbG9yTWF0cml4LkxFTkdUSCkgeyByZXR1cm4gdGhpczsgfVxuXHRcdHRoaXMuX211bHRpcGx5TWF0cml4KG1hdHJpeCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybiB7ZWFzZWxqcy5Db2xvck1hdHJpeH0gQSBjbG9uZSBvZiB0aGlzIENvbG9yTWF0cml4LlxuXHQgKi9cblx0Y2xvbmUgKCkge1xuXHRcdHJldHVybiAobmV3IENvbG9yTWF0cml4KCkpLmNvcHkodGhpcyk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJuIGEgbGVuZ3RoIDI1ICg1eDUpIGFycmF5IGluc3RhbmNlIGNvbnRhaW5pbmcgdGhpcyBtYXRyaXgncyB2YWx1ZXMuXG5cdCAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBob2xkaW5nIHRoaXMgbWF0cml4J3MgdmFsdWVzLlxuXHQgKi9cblx0dG9BcnJheSAoKSB7XG5cdFx0Y29uc3QgYXJyID0gW107XG5cdFx0Y29uc3QgbCA9IENvbG9yTWF0cml4LkxFTkdUSDtcblx0XHRmb3IgKGxldCBpPTA7IGk8bDsgaSsrKSB7XG5cdFx0XHRhcnJbaV0gPSB0aGlzW2ldO1xuXHRcdH1cblx0XHRyZXR1cm4gYXJyO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvcHkgdGhlIHNwZWNpZmllZCBtYXRyaXgncyB2YWx1ZXMgdG8gdGhpcyBtYXRyaXguXG5cdCAqIEBwYXJhbSB7QXJyYXkgfCBlYXNlbGpzLkNvbG9yTWF0cml4fSBtYXRyaXggQW4gYXJyYXkgb3IgQ29sb3JNYXRyaXggaW5zdGFuY2UuXG5cdCAqIEByZXR1cm4ge2Vhc2VsanMuQ29sb3JNYXRyaXh9IFRoZSBDb2xvck1hdHJpeCBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdGNvcHkgKG1hdHJpeCkge1xuXHRcdGNvbnN0IGwgPSBDb2xvck1hdHJpeC5MRU5HVEg7XG5cdFx0Zm9yIChsZXQgaT0wO2k8bDtpKyspIHtcblx0XHRcdHRoaXNbaV0gPSBtYXRyaXhbaV07XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxuXHQgKi9cblx0dG9TdHJpbmcgKCkge1xuXHRcdHJldHVybiBgWyR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfV1gO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7QXJyYXl9IG1hdHJpeFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRfbXVsdGlwbHlNYXRyaXggKG1hdHJpeCkge1xuXHRcdGxldCBjb2wgPSBbXTtcblxuXHRcdGZvciAobGV0IGk9MDtpPDU7aSsrKSB7XG5cdFx0XHRmb3IgKGxldCBqPTA7ajw1O2orKykge1xuXHRcdFx0XHRjb2xbal0gPSB0aGlzW2oraSo1XTtcblx0XHRcdH1cblx0XHRcdGZvciAobGV0IGo9MDtqPDU7aisrKSB7XG5cdFx0XHRcdGxldCB2YWw9MDtcblx0XHRcdFx0Zm9yIChsZXQgaz0wO2s8NTtrKyspIHtcblx0XHRcdFx0XHR2YWwgKz0gbWF0cml4W2orayo1XSpjb2xba107XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpc1tqK2kqNV0gPSB2YWw7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIE1ha2Ugc3VyZSB2YWx1ZXMgYXJlIHdpdGhpbiB0aGUgc3BlY2lmaWVkIHJhbmdlLCBodWUgaGFzIGEgbGltaXQgb2YgMTgwLCBicmlnaHRuZXNzIGlzIDI1NSwgb3RoZXJzIGFyZSAxMDAuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBUaGUgcmF3IG51bWJlclxuXHQgKiBAcGFyYW0ge051bWJlcn0gbGltaXQgVGhlIG1heGltdW0gdGhhdCB0aGUgbnVtYmVyIGNhbiBiZS4gVGhlIG1pbmltdW0gaXMgdGhlIGxpbWl0ICogLTEuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdF9jbGVhblZhbHVlICh2YWx1ZSwgbGltaXQpIHtcblx0XHRyZXR1cm4gTWF0aC5taW4obGltaXQsIE1hdGgubWF4KC1saW1pdCwgdmFsdWUpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBNYWtlcyBzdXJlIG1hdHJpeGVzIGFyZSA1eDUgKDI1IGxvbmcpLlxuXHQgKiBAcGFyYW0ge0FycmF5fSBtYXRyaXhcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0X2ZpeE1hdHJpeCAobWF0cml4KSB7XG5cdFx0aWYgKG1hdHJpeCBpbnN0YW5jZW9mIENvbG9yTWF0cml4KSB7IG1hdHJpeCA9IG1hdHJpeC50b0FycmF5KCk7IH1cblx0XHRpZiAobWF0cml4Lmxlbmd0aCA8IENvbG9yTWF0cml4LkxFTkdUSCkge1xuXHRcdFx0bWF0cml4ID0gbWF0cml4LnNsaWNlKDAsIG1hdHJpeC5sZW5ndGgpLmNvbmNhdChDb2xvck1hdHJpeC5JREVOVElUWV9NQVRSSVguc2xpY2UobWF0cml4Lmxlbmd0aCwgQ29sb3JNYXRyaXguTEVOR1RIKSk7XG5cdFx0fSBlbHNlIGlmIChtYXRyaXgubGVuZ3RoID4gQ29sb3JNYXRyaXguTEVOR1RIKSB7XG5cdFx0XHRtYXRyaXggPSBtYXRyaXguc2xpY2UoMCwgQ29sb3JNYXRyaXguTEVOR1RIKTtcblx0XHR9XG5cdFx0cmV0dXJuIG1hdHJpeDtcblx0fVxuXG59XG5cbi8qKlxuICogQXJyYXkgb2YgZGVsdGEgdmFsdWVzIGZvciBjb250cmFzdCBjYWxjdWxhdGlvbnMuXG4gKiBAdHlwZSB7QXJyYXk8TnVtYmVyPn1cbiAqIEBwcm90ZWN0ZWRcbiAqIEByZWFkb25seVxuICogQHN0YXRpY1xuICovXG5Db2xvck1hdHJpeC5ERUxUQV9JTkRFWCA9IE9iamVjdC5mcmVlemUoW1xuIFx0MCwgICAgMC4wMSwgMC4wMiwgMC4wNCwgMC4wNSwgMC4wNiwgMC4wNywgMC4wOCwgMC4xLCAgMC4xMSxcbiBcdDAuMTIsIDAuMTQsIDAuMTUsIDAuMTYsIDAuMTcsIDAuMTgsIDAuMjAsIDAuMjEsIDAuMjIsIDAuMjQsXG4gXHQwLjI1LCAwLjI3LCAwLjI4LCAwLjMwLCAwLjMyLCAwLjM0LCAwLjM2LCAwLjM4LCAwLjQwLCAwLjQyLFxuIFx0MC40NCwgMC40NiwgMC40OCwgMC41LCAgMC41MywgMC41NiwgMC41OSwgMC42MiwgMC42NSwgMC42OCxcbiBcdDAuNzEsIDAuNzQsIDAuNzcsIDAuODAsIDAuODMsIDAuODYsIDAuODksIDAuOTIsIDAuOTUsIDAuOTgsXG4gXHQxLjAsICAxLjA2LCAxLjEyLCAxLjE4LCAxLjI0LCAxLjMwLCAxLjM2LCAxLjQyLCAxLjQ4LCAxLjU0LFxuIFx0MS42MCwgMS42NiwgMS43MiwgMS43OCwgMS44NCwgMS45MCwgMS45NiwgMi4wLCAgMi4xMiwgMi4yNSxcbiBcdDIuMzcsIDIuNTAsIDIuNjIsIDIuNzUsIDIuODcsIDMuMCwgIDMuMiwgIDMuNCwgIDMuNiwgIDMuOCxcbiBcdDQuMCwgIDQuMywgIDQuNywgIDQuOSwgIDUuMCwgIDUuNSwgIDYuMCwgIDYuNSwgIDYuOCwgIDcuMCxcbiBcdDcuMywgIDcuNSwgIDcuOCwgIDguMCwgIDguNCwgIDguNywgIDkuMCwgIDkuNCwgIDkuNiwgIDkuOCxcbiBcdDEwLjBcbl0pO1xuLyoqXG4gKiBJZGVudGl0eSBtYXRyaXggdmFsdWVzLlxuICogQHR5cGUge0FycmF5PE51bWJlcj59XG4gKiBAcHJvdGVjdGVkXG4gKiBAcmVhZG9ubHlcbiAqIEBzdGF0aWNcbiAqL1xuQ29sb3JNYXRyaXguSURFTlRJVFlfTUFUUklYID0gT2JqZWN0LmZyZWV6ZShbXG4gXHQxLDAsMCwwLDAsXG4gXHQwLDEsMCwwLDAsXG4gXHQwLDAsMSwwLDAsXG4gXHQwLDAsMCwxLDAsXG4gXHQwLDAsMCwwLDFcbl0pO1xuLyoqXG4gKiBUaGUgY29uc3RhbnQgbGVuZ3RoIG9mIGEgY29sb3IgbWF0cml4LlxuICogQHR5cGUge051bWJlcn1cbiAqIEBwcm90ZWN0ZWRcbiAqIEByZWFkb25seVxuICogQHN0YXRpY1xuICovXG5Db2xvck1hdHJpeC5MRU5HVEggPSAyNTtcbiIsIi8qKlxuICogQGxpY2Vuc2UgQ29sb3JNYXRyaXhGaWx0ZXJcbiAqIFZpc2l0IGh0dHA6Ly9jcmVhdGVqcy5jb20vIGZvciBkb2N1bWVudGF0aW9uLCB1cGRhdGVzIGFuZCBleGFtcGxlcy5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgZ3NraW5uZXIuY29tLCBpbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAqIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXG4gKiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXRcbiAqIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxuICogY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuICogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbiAqIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAqIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gKiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcbiAqIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gKiBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuICogSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXG4gKiBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcbiAqIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5pbXBvcnQgRmlsdGVyIGZyb20gXCIuL0ZpbHRlclwiO1xuXG4vKipcbiAqIEFsbG93cyB5b3UgdG8gY2Fycnkgb3V0IGNvbXBsZXggY29sb3Igb3BlcmF0aW9ucyBzdWNoIGFzIG1vZGlmeWluZyBzYXR1cmF0aW9uLCBicmlnaHRuZXNzLCBvciBpbnZlcnRpbmcuIFNlZSB0aGVcbiAqIHtAbGluayBlYXNlbGpzLkNvbG9yTWF0cml4fSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBjaGFuZ2luZyBjb2xvcnMuIEZvciBhbiBlYXNpZXIgY29sb3IgdHJhbnNmb3JtLFxuICogY29uc2lkZXIgdGhlIHtAbGluayBlYXNlbGpzLkNvbG9yRmlsdGVyfS5cbiAqXG4gKlxuICogQG1lbWJlcm9mIGVhc2VsanNcbiAqIEBleHRlbmRzIGVhc2VsanMuRmlsdGVyXG4gKiBAZXhhbXBsZVxuICogbGV0IHNoYXBlID0gbmV3IFNoYXBlKCkuc2V0KHsgeDogMTAwLCB5OiAxMDAgfSk7XG4gKiBzaGFwZS5ncmFwaGljcy5iZWdpbkZpbGwoXCIjZmYwMDAwXCIpLmRyYXdDaXJjbGUoMCwgMCwgNTApO1xuICogbGV0IG1hdHJpeCA9IG5ldyBDb2xvck1hdHJpeCgpLmFkanVzdEh1ZSgxODApLmFkanVzdFNhdHVyYXRpb24oMTAwKTtcbiAqIHNoYXBlLmZpbHRlcnMgPSBbIG5ldyBDb2xvck1hdHJpeEZpbHRlcihtYXRyaXgpIF07XG4gKiBzaGFwZS5jYWNoZSgtNTAsIC01MCwgMTAwLCAxMDApO1xuICpcbiAqIEBwYXJhbSB7QXJyYXkgfCBlYXNlbGpzLkNvbG9yTWF0cml4fSBtYXRyaXggQSA0eDUgbWF0cml4IGRlc2NyaWJpbmcgdGhlIGNvbG9yIG9wZXJhdGlvbiB0byBwZXJmb3JtLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb2xvck1hdHJpeEZpbHRlciBleHRlbmRzIEZpbHRlciB7XG5cblx0Y29uc3RydWN0b3IgKG1hdHJpeCkge1xuXHRcdHN1cGVyKCk7XG5cblx0XHQvKipcblx0XHQgKiBBIDR4NSBtYXRyaXggZGVzY3JpYmluZyB0aGUgY29sb3Igb3BlcmF0aW9uIHRvIHBlcmZvcm0uXG5cdFx0ICogQHR5cGUge0FycmF5IHwgZWFzZWxqcy5Db2xvck1hdHJpeH1cblx0XHQgKi9cblx0XHR0aGlzLm1hdHJpeCA9IG1hdHJpeDtcblxuXHRcdHRoaXMuRlJBR19TSEFERVJfQk9EWSA9IGBcblx0XHRcdHVuaWZvcm0gbWF0NCB1Q29sb3JNYXRyaXg7XG5cdFx0XHR1bmlmb3JtIHZlYzQgdUNvbG9yTWF0cml4T2Zmc2V0O1xuXG5cdFx0XHR2b2lkIG1haW4gKHZvaWQpIHtcblx0XHRcdFx0dmVjNCBjb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlJlbmRlckNvb3JkKTtcblxuXHRcdFx0XHRtYXQ0IG0gPSB1Q29sb3JNYXRyaXg7XG5cdFx0XHRcdHZlYzQgbmV3Q29sb3IgPSB2ZWM0KDAsMCwwLDApO1xuXHRcdFx0XHRuZXdDb2xvci5yID0gY29sb3IuciptWzBdWzBdICsgY29sb3IuZyptWzBdWzFdICsgY29sb3IuYiptWzBdWzJdICsgY29sb3IuYSptWzBdWzNdO1xuXHRcdFx0XHRuZXdDb2xvci5nID0gY29sb3IuciptWzFdWzBdICsgY29sb3IuZyptWzFdWzFdICsgY29sb3IuYiptWzFdWzJdICsgY29sb3IuYSptWzFdWzNdO1xuXHRcdFx0XHRuZXdDb2xvci5iID0gY29sb3IuciptWzJdWzBdICsgY29sb3IuZyptWzJdWzFdICsgY29sb3IuYiptWzJdWzJdICsgY29sb3IuYSptWzJdWzNdO1xuXHRcdFx0XHRuZXdDb2xvci5hID0gY29sb3IuciptWzNdWzBdICsgY29sb3IuZyptWzNdWzFdICsgY29sb3IuYiptWzNdWzJdICsgY29sb3IuYSptWzNdWzNdO1xuXG5cdFx0XHRcdGdsX0ZyYWdDb2xvciA9IG5ld0NvbG9yICsgdUNvbG9yTWF0cml4T2Zmc2V0O1xuXHRcdFx0fVxuXHRcdGA7XG5cdH1cblxuXHRzaGFkZXJQYXJhbVNldHVwIChnbCwgc3RhZ2UsIHNoYWRlclByb2dyYW0pIHtcblx0XHRsZXQgbWF0ID0gdGhpcy5tYXRyaXg7XG5cdFx0bGV0IGNvbG9yTWF0cml4ID0gbmV3IEZsb2F0MzJBcnJheShbXG5cdFx0XHRtYXRbMF0sbWF0WzFdLG1hdFsyXSxtYXRbM10sXG5cdFx0XHRtYXRbNV0sbWF0WzZdLG1hdFs3XSxtYXRbOF0sXG5cdFx0XHRtYXRbMTBdLG1hdFsxMV0sbWF0WzEyXSxtYXRbMTNdLFxuXHRcdFx0bWF0WzE1XSxtYXRbMTZdLG1hdFsxN10sbWF0WzE4XVxuXHRcdF0pO1xuXG5cdFx0Z2wudW5pZm9ybU1hdHJpeDRmdihcblx0XHRcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbihzaGFkZXJQcm9ncmFtLCBcInVDb2xvck1hdHJpeFwiKSxcblx0XHRcdGZhbHNlLCBjb2xvck1hdHJpeFxuXHRcdCk7XG5cdFx0Z2wudW5pZm9ybTRmKFxuXHRcdFx0Z2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHNoYWRlclByb2dyYW0sIFwidUNvbG9yTWF0cml4T2Zmc2V0XCIpLFxuXHRcdFx0bWF0WzRdLzI1NSwgbWF0WzldLzI1NSwgbWF0WzE0XS8yNTUsIG1hdFsxOV0vMjU1XG5cdFx0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJuIHtlYXNlbGpzLkNvbG9yTWF0cml4RmlsdGVyfVxuXHQgKi9cblx0Y2xvbmUgKCkge1xuXHRcdHJldHVybiBuZXcgQ29sb3JNYXRyaXhGaWx0ZXIodGhpcy5tYXRyaXgpO1xuXHR9XG5cblx0X2FwcGx5RmlsdGVyIChpbWFnZURhdGEpIHtcblx0XHRsZXQgZGF0YSA9IGltYWdlRGF0YS5kYXRhO1xuXHRcdGNvbnN0IGwgPSBkYXRhLmxlbmd0aDtcblx0XHRsZXQgcixnLGIsYTtcblx0XHRsZXQgbXR4ID0gdGhpcy5tYXRyaXg7XG5cdFx0bGV0IG0wID0gIG10eFswXSwgIG0xID0gIG10eFsxXSwgIG0yID0gIG10eFsyXSwgIG0zID0gIG10eFszXSwgIG00ID0gIG10eFs0XTtcblx0XHRsZXQgbTUgPSAgbXR4WzVdLCAgbTYgPSAgbXR4WzZdLCAgbTcgPSAgbXR4WzddLCAgbTggPSAgbXR4WzhdLCAgbTkgPSAgbXR4WzldO1xuXHRcdGxldCBtMTAgPSBtdHhbMTBdLCBtMTEgPSBtdHhbMTFdLCBtMTIgPSBtdHhbMTJdLCBtMTMgPSBtdHhbMTNdLCBtMTQgPSBtdHhbMTRdO1xuXHRcdGxldCBtMTUgPSBtdHhbMTVdLCBtMTYgPSBtdHhbMTZdLCBtMTcgPSBtdHhbMTddLCBtMTggPSBtdHhbMThdLCBtMTkgPSBtdHhbMTldO1xuXG5cdFx0Zm9yIChsZXQgaT0wOyBpPGw7IGkrPTQpIHtcblx0XHRcdHIgPSBkYXRhW2ldO1xuXHRcdFx0ZyA9IGRhdGFbaSsxXTtcblx0XHRcdGIgPSBkYXRhW2krMl07XG5cdFx0XHRhID0gZGF0YVtpKzNdO1xuXHRcdFx0ZGF0YVtpXSA9IHIqbTArZyptMStiKm0yK2EqbTMrbTQ7IC8vIHJlZFxuXHRcdFx0ZGF0YVtpKzFdID0gciptNStnKm02K2IqbTcrYSptOCttOTsgLy8gZ3JlZW5cblx0XHRcdGRhdGFbaSsyXSA9IHIqbTEwK2cqbTExK2IqbTEyK2EqbTEzK20xNDsgLy8gYmx1ZVxuXHRcdFx0ZGF0YVtpKzNdID0gciptMTUrZyptMTYrYiptMTcrYSptMTgrbTE5OyAvLyBhbHBoYVxuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cbn1cbiIsIi8qXG4qIEBsaWNlbnNlIEJ1dHRvbkhlbHBlclxuKiBWaXNpdCBodHRwOi8vY3JlYXRlanMuY29tLyBmb3IgZG9jdW1lbnRhdGlvbiwgdXBkYXRlcyBhbmQgZXhhbXBsZXMuXG4qXG4qIENvcHlyaWdodCAoYykgMjAxNyBnc2tpbm5lci5jb20sIGluYy5cbipcbiogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiogb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cbiogZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0XG4qIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxuKiBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbiogY29uZGl0aW9uczpcbipcbiogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4qXG4qIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4qIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xuKiBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuKiBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuKiBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcbiogV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4qIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcbiogT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuKi9cblxuLyoqXG4gKiBUaGUgQnV0dG9uSGVscGVyIGlzIGEgaGVscGVyIGNsYXNzIHRvIGNyZWF0ZSBpbnRlcmFjdGl2ZSBidXR0b25zIGZyb20ge0BsaW5rIGVhc2VsanMuTW92aWVDbGlwfSBvclxuICoge0BsaW5rIGVhc2VsanMuU3ByaXRlfSBpbnN0YW5jZXMuIFRoaXMgY2xhc3Mgd2lsbCBpbnRlcmNlcHQgbW91c2UgZXZlbnRzIGZyb20gYW4gb2JqZWN0LCBhbmRcbiAqIGF1dG9tYXRpY2FsbHkgY2FsbCB7QGxpbmsgZWFzZWxqcy5TcHJpdGUjZ290b0FuZFN0b3B9IG9yIHtAbGluayBlYXNsZWpzLlNwcml0ZSNnb3RvQW5kUGxheX0sXG4gKiB0byB0aGUgcmVzcGVjdGl2ZSBhbmltYXRpb24gbGFiZWxzLCBhZGQgYSBwb2ludGVyIGN1cnNvciwgYW5kIGFsbG93cyB0aGUgdXNlciB0byBkZWZpbmUgYSBoaXQgc3RhdGUgZnJhbWUuXG4gKlxuICogVGhlIEJ1dHRvbkhlbHBlciBpbnN0YW5jZSBkb2VzIG5vdCBuZWVkIHRvIGJlIGFkZGVkIHRvIHRoZSBzdGFnZSwgYnV0IGEgcmVmZXJlbmNlIHNob3VsZCBiZSBtYWludGFpbmVkIHRvIHByZXZlbnRcbiAqIGdhcmJhZ2UgY29sbGVjdGlvbi5cbiAqXG4gKiBOb3RlIHRoYXQgb3ZlciBzdGF0ZXMgd2lsbCBub3Qgd29yayB1bmxlc3MgeW91IGNhbGwge0BsaW5rIGVhc2VsanMuU3RhZ2UjZW5hYmxlTW91c2VPdmVyfS5cbiAqXG4gKiBAbWVtYmVyb2YgZWFzZWxqc1xuICogQGV4YW1wbGVcbiAqIGxldCBoZWxwZXIgPSBuZXcgQnV0dG9uSGVscGVyKHNwcml0ZSwgXCJvdXRcIiwgXCJvdmVyXCIsIFwiZG93blwiLCBmYWxzZSwgc3ByaXRlLCBcImhpdFwiKTtcbiAqIHNwcml0ZS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKGV2dCkgPT4ge1xuICogICAvLyBjbGlja2VkXG4gKiB9KSk7XG4gKlxuICogQHBhcmFtIHtlYXNlbGpzLlNwcml0ZSB8IGVhc2VsanMuTW92aWVDbGlwfSB0YXJnZXQgVGhlIGluc3RhbmNlIHRvIG1hbmFnZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3V0TGFiZWw9XCJvdXRcIl0gVGhlIGxhYmVsIG9yIGFuaW1hdGlvbiB0byBnbyB0byB3aGVuIHRoZSB1c2VyIHJvbGxzIG91dCBvZiB0aGUgYnV0dG9uLlxuICogQHBhcmFtIHtTdHJpbmd9IFtvdmVyTGFiZWw9XCJvdmVyXCJdIFRoZSBsYWJlbCBvciBhbmltYXRpb24gdG8gZ28gdG8gd2hlbiB0aGUgdXNlciByb2xscyBvdmVyIHRoZSBidXR0b24uXG4gKiBAcGFyYW0ge1N0cmluZ30gW2Rvd25MYWJlbD1cImRvd25cIl0gVGhlIGxhYmVsIG9yIGFuaW1hdGlvbiB0byBnbyB0byB3aGVuIHRoZSB1c2VyIHByZXNzZXMgdGhlIGJ1dHRvbi5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3BsYXk9ZmFsc2VdIElmIHRoZSBoZWxwZXIgc2hvdWxkIGNhbGwgXCJnb3RvQW5kUGxheVwiIG9yIFwiZ290b0FuZFN0b3BcIiBvbiB0aGUgYnV0dG9uIHdoZW4gY2hhbmdpbmdcbiAqIHN0YXRlcy5cbiAqIEBwYXJhbSB7ZWFzZWxqcy5EaXNwbGF5T2JqZWN0fSBbaGl0QXJlYV0gQW4gb3B0aW9uYWwgaXRlbSB0byB1c2UgYXMgdGhlIGhpdCBzdGF0ZSBmb3IgdGhlIGJ1dHRvbi4gSWYgdGhpcyBpcyBub3QgZGVmaW5lZCxcbiAqIHRoZW4gdGhlIGJ1dHRvbidzIHZpc2libGUgc3RhdGVzIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLiBOb3RlIHRoYXQgdGhlIHNhbWUgaW5zdGFuY2UgYXMgdGhlIFwidGFyZ2V0XCIgYXJndW1lbnQgY2FuIGJlXG4gKiB1c2VkIGZvciB0aGUgaGl0U3RhdGUuXG4gKiBAcGFyYW0ge1N0cmluZ30gW2hpdExhYmVsXSBUaGUgbGFiZWwgb3IgYW5pbWF0aW9uIG9uIHRoZSBoaXRBcmVhIGluc3RhbmNlIHRoYXQgZGVmaW5lcyB0aGUgaGl0QXJlYSBib3VuZHMuIElmIHRoaXMgaXNcbiAqIG51bGwsIHRoZW4gdGhlIGRlZmF1bHQgc3RhdGUgb2YgdGhlIGhpdEFyZWEgd2lsbCBiZSB1c2VkLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCdXR0b25IZWxwZXIge1xuXG5cdGNvbnN0cnVjdG9yICh0YXJnZXQsIG91dExhYmVsID0gXCJvdXRcIiwgb3ZlckxhYmVsID0gXCJvdmVyXCIsIGRvd25MYWJlbCA9IFwiZG93blwiLCBwbGF5ID0gZmFsc2UsIGhpdEFyZWEsIGhpdExhYmVsKSB7XG5cdFx0aWYgKCF0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcikgeyByZXR1cm47IH1cblxuXHRcdC8qKlxuXHRcdCAqIFRoZSB0YXJnZXQgZm9yIHRoaXMgYnV0dG9uIGhlbHBlci5cblx0XHQgKiBAdHlwZSB7ZWFzZWxqcy5Nb3ZpZUNsaXAgfCBlYXNlbGpzLlNwcml0ZX1cblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKi9cblx0XHR0aGlzLnRhcmdldCA9IHRhcmdldDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBsYWJlbCBuYW1lIG9yIGZyYW1lIG51bWJlciB0byBkaXNwbGF5IHdoZW4gdGhlIHVzZXIgbW91c2VzIG91dCBvZiB0aGUgdGFyZ2V0LlxuXHRcdCAqIEBkZWZhdWx0IFwib3ZlclwiXG5cdFx0ICogQHR5cGUge1N0cmluZyB8IE51bWJlcn1cblx0XHQgKi9cblx0XHR0aGlzLm92ZXJMYWJlbCA9IG92ZXJMYWJlbDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBsYWJlbCBuYW1lIG9yIGZyYW1lIG51bWJlciB0byBkaXNwbGF5IHdoZW4gdGhlIHVzZXIgbW91c2VzIG92ZXIgdGhlIHRhcmdldC5cblx0XHQgKiBAZGVmYXVsdCBcIm91dFwiXG5cdFx0ICogQHR5cGUge1N0cmluZyB8IE51bWJlcn1cblx0XHQgKi9cblx0XHR0aGlzLm91dExhYmVsID0gb3V0TGFiZWw7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbGFiZWwgbmFtZSBvciBmcmFtZSBudW1iZXIgdG8gZGlzcGxheSB3aGVuIHRoZSB1c2VyIHByZXNzZXMgb24gdGhlIHRhcmdldC5cblx0XHQgKiBAZGVmYXVsdCBcImRvd25cIlxuXHRcdCAqIEB0eXBlIHtTdHJpbmcgfCBOdW1iZXJ9XG5cdFx0ICovXG5cdFx0dGhpcy5kb3duTGFiZWwgPSBkb3duTGFiZWwgPT0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIElmIHRydWUsIHRoZW4gQnV0dG9uSGVscGVyIHdpbGwgY2FsbCBnb3RvQW5kUGxheSwgaWYgZmFsc2UsIGl0IHdpbGwgdXNlIGdvdG9BbmRTdG9wLlxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICovXG5cdFx0dGhpcy5wbGF5ID0gcGxheTtcblxuXHRcdC8qKlxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLl9pc1ByZXNzZWQgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLl9pc092ZXIgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLl9lbmFibGVkID0gZmFsc2U7XG5cblx0XHR0YXJnZXQubW91c2VDaGlsZHJlbiA9IGZhbHNlOyAvLyBwcmV2ZW50cyBpc3N1ZXMgd2hlbiBjaGlsZHJlbiBhcmUgcmVtb3ZlZCBmcm9tIHRoZSBkaXNwbGF5IGxpc3Qgd2hlbiBzdGF0ZSBjaGFuZ2VzLlxuXHRcdHRoaXMuZW5hYmxlZCA9IHRydWU7XG5cdFx0dGhpcy5oYW5kbGVFdmVudCh7fSk7XG5cdFx0aWYgKGhpdEFyZWEpIHtcblx0XHRcdGlmIChoaXRMYWJlbCkge1xuXHRcdFx0XHRoaXRBcmVhLmFjdGlvbnNFbmFibGVkID0gZmFsc2U7XG5cdFx0XHRcdGhpdEFyZWEuZ290b0FuZFN0b3AmJmhpdEFyZWEuZ290b0FuZFN0b3AoaGl0TGFiZWwpO1xuXHRcdFx0fVxuXHRcdFx0dGFyZ2V0LmhpdEFyZWEgPSBoaXRBcmVhO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBFbmFibGVzIG9yIGRpc2FibGVzIHRoZSBidXR0b24gZnVuY3Rpb25hbGl0eSBvbiB0aGUgdGFyZ2V0LlxuXHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0ICovXG5cdGdldCBlbmFibGVkICgpIHsgcmV0dXJuIHRoaXMuX2VuYWJsZWQ7IH1cblx0c2V0IGVuYWJsZWQgKGVuYWJsZWQpIHtcblx0XHRpZiAoZW5hYmxlZCA9PT0gdGhpcy5fZW5hYmxlZCkgeyByZXR1cm47IH1cblx0XHRsZXQgbyA9IHRoaXMudGFyZ2V0O1xuXHRcdHRoaXMuX2VuYWJsZWQgPSBlbmFibGVkO1xuXHRcdGlmIChlbmFibGVkKSB7XG5cdFx0XHRvLmN1cnNvciA9IFwicG9pbnRlclwiO1xuXHRcdFx0by5hZGRFdmVudExpc3RlbmVyKFwicm9sbG92ZXJcIiwgdGhpcyk7XG5cdFx0XHRvLmFkZEV2ZW50TGlzdGVuZXIoXCJyb2xsb3V0XCIsIHRoaXMpO1xuXHRcdFx0by5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIHRoaXMpO1xuXHRcdFx0by5hZGRFdmVudExpc3RlbmVyKFwicHJlc3N1cFwiLCB0aGlzKTtcblx0XHRcdGlmIChvLl9yZXNldCkgeyBvLl9fcmVzZXQgPSBvLl9yZXNldDsgby5fcmVzZXQgPSB0aGlzLl9yZXNldDt9XG5cdFx0fSBlbHNlIHtcblx0XHRcdG8uY3Vyc29yID0gbnVsbDtcblx0XHRcdG8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJvbGxvdmVyXCIsIHRoaXMpO1xuXHRcdFx0by5yZW1vdmVFdmVudExpc3RlbmVyKFwicm9sbG91dFwiLCB0aGlzKTtcblx0XHRcdG8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB0aGlzKTtcblx0XHRcdG8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInByZXNzdXBcIiwgdGhpcyk7XG5cdFx0XHRpZiAoby5fX3Jlc2V0KSB7IG8uX3Jlc2V0ID0gby5fX3Jlc2V0OyBkZWxldGUoby5fX3Jlc2V0KTsgfVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZS5cblx0ICovXG5cdHRvU3RyaW5nICgpIHtcblx0XHRyZXR1cm4gYFske3RoaXMuY29uc3RydWN0b3IubmFtZX1dYDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gZXZ0IFRoZSBtb3VzZSBldmVudCB0byBoYW5kbGUuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdGhhbmRsZUV2ZW50IChldnQpIHtcblx0XHRsZXQgbGFiZWwsIHQgPSB0aGlzLnRhcmdldCwgdHlwZSA9IGV2dC50eXBlO1xuXHRcdGlmICh0eXBlID09PSBcIm1vdXNlZG93blwiKSB7XG5cdFx0XHR0aGlzLl9pc1ByZXNzZWQgPSB0cnVlO1xuXHRcdFx0bGFiZWwgPSB0aGlzLmRvd25MYWJlbDtcblx0XHR9IGVsc2UgaWYgKHR5cGUgPT09IFwicHJlc3N1cFwiKSB7XG5cdFx0XHR0aGlzLl9pc1ByZXNzZWQgPSBmYWxzZTtcblx0XHRcdGxhYmVsID0gdGhpcy5faXNPdmVyID8gdGhpcy5vdmVyTGFiZWwgOiB0aGlzLm91dExhYmVsO1xuXHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gXCJyb2xsb3ZlclwiKSB7XG5cdFx0XHR0aGlzLl9pc092ZXIgPSB0cnVlO1xuXHRcdFx0bGFiZWwgPSB0aGlzLl9pc1ByZXNzZWQgPyB0aGlzLmRvd25MYWJlbCA6IHRoaXMub3ZlckxhYmVsO1xuXHRcdH0gZWxzZSB7IC8vIHJvbGxvdXQgYW5kIGRlZmF1bHRcblx0XHRcdHRoaXMuX2lzT3ZlciA9IGZhbHNlO1xuXHRcdFx0bGFiZWwgPSB0aGlzLl9pc1ByZXNzZWQgPyB0aGlzLm92ZXJMYWJlbCA6IHRoaXMub3V0TGFiZWw7XG5cdFx0fVxuXHRcdGlmICh0aGlzLnBsYXkpIHtcblx0XHRcdHQuZ290b0FuZFBsYXkmJnQuZ290b0FuZFBsYXkobGFiZWwpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0LmdvdG9BbmRTdG9wJiZ0LmdvdG9BbmRTdG9wKGxhYmVsKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogSW5qZWN0ZWQgaW50byB0YXJnZXQuIFByZXNlcnZlcyB0aGUgcGF1c2VkIHN0YXRlIHRocm91Z2ggYSByZXNldC5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0X3Jlc2V0ICgpIHtcblx0XHQvLyBUT0RPOiBleHBsb3JlIGJldHRlciB3YXlzIHRvIGhhbmRsZSB0aGlzIGlzc3VlLiBUaGlzIGlzIGhhY2t5ICYgZGlzcnVwdHMgb2JqZWN0IHNpZ25hdHVyZXMuXG5cdFx0bGV0IHAgPSB0aGlzLnBhdXNlZDtcblx0XHR0aGlzLl9fcmVzZXQoKTtcblx0XHR0aGlzLnBhdXNlZCA9IHA7XG5cdH1cblxufVxuIiwiLyoqXG4gKiBAbGljZW5zZSBUb3VjaFxuICogVmlzaXQgaHR0cDovL2NyZWF0ZWpzLmNvbS8gZm9yIGRvY3VtZW50YXRpb24sIHVwZGF0ZXMgYW5kIGV4YW1wbGVzLlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNyBnc2tpbm5lci5jb20sIGluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICogb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cbiAqIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxuICogcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsXG4gKiBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4gKiBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuICogY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAqIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xuICogT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAqIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4gKiBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcbiAqIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuICogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUlxuICogT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qKlxuICogR2xvYmFsIHV0aWxpdHkgZm9yIHdvcmtpbmcgd2l0aCBtdWx0aS10b3VjaCBlbmFibGVkIGRldmljZXMgaW4gRWFzZWxKUy4gQ3VycmVudGx5IHN1cHBvcnRzIFczQyBUb3VjaCBBUEkgKGlPUyBhbmRcbiAqIG1vZGVybiBBbmRyb2lkIGJyb3dzZXIpIGFuZCB0aGUgUG9pbnRlciBBUEkgKElFKSwgaW5jbHVkaW5nIG1zLXByZWZpeGVkIGV2ZW50cyBpbiBJRTEwLCBhbmQgdW5wcmVmaXhlZCBpbiBJRTExLlxuICpcbiAqIEVuc3VyZSB0aGF0IHlvdSB7eyNjcm9zc0xpbmsgXCJUb3VjaC9kaXNhYmxlXCJ9fXt7L2Nyb3NzTGlua319IHRvdWNoIHdoZW4gY2xlYW5pbmcgdXAgeW91ciBhcHBsaWNhdGlvbi4gWW91IGRvIG5vdCBoYXZlXG4gKiB0byBjaGVjayBpZiB0b3VjaCBpcyBzdXBwb3J0ZWQgdG8gZW5hYmxlIGl0LCBhcyBpdCB3aWxsIGZhaWwgZ3JhY2VmdWxseSBpZiBpdCBpcyBub3Qgc3VwcG9ydGVkLlxuICpcbiAqIDxzdHJvbmc+Tm90ZTo8L3N0cm9uZz4gSXQgaXMgaW1wb3J0YW50IHRvIGRpc2FibGUgVG91Y2ggb24gYSBzdGFnZSB0aGF0IHlvdSBhcmUgbm8gbG9uZ2VyIHVzaW5nOlxuICpcbiAqIEBtZW1iZXJvZiBlYXNlbGpzXG4gKiBAbmFtZSBlYXNlbGpzLlRvdWNoXG4gKiBAZXhhbXBsZVxuICogbGV0IHN0YWdlID0gbmV3IFN0YWdlKFwiY2FudmFzSWRcIik7XG4gKiBUb3VjaC5lbmFibGUoc3RhZ2UpO1xuICovXG5leHBvcnQgZGVmYXVsdCB7XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYHRydWVgIGlmIHRvdWNoIGlzIHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBicm93c2VyLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBJbmRpY2F0ZXMgd2hldGhlciB0b3VjaCBpcyBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnQgYnJvd3Nlci5cblx0ICovXG5cdGlzU3VwcG9ydGVkICgpIHtcblx0XHRyZXR1cm5cdCEhKCgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpIC8vIGlPUyAmIEFuZHJvaWRcblx0XHRcdHx8ICh3aW5kb3cuTVNQb2ludGVyRXZlbnQgJiYgd2luZG93Lm5hdmlnYXRvci5tc01heFRvdWNoUG9pbnRzID4gMCkgLy8gSUUxMFxuXHRcdFx0fHwgKHdpbmRvdy5Qb2ludGVyRXZlbnQgJiYgd2luZG93Lm5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDApKTsgLy8gSUUxMStcblx0fSxcblxuXHQvKipcblx0ICogRW5hYmxlcyB0b3VjaCBpbnRlcmFjdGlvbiBmb3IgdGhlIHNwZWNpZmllZCBFYXNlbEpTIHtAbGluayBlYXNlbGpzLlN0YWdlfS4gQ3VycmVudGx5IHN1cHBvcnRzIGlPU1xuXHQgKiAoYW5kIGNvbXBhdGlibGUgYnJvd3NlcnMsIHN1Y2ggYXMgbW9kZXJuIEFuZHJvaWQgYnJvd3NlcnMpLCBhbmQgSUUxMC8xMS4gU3VwcG9ydHMgYm90aCBzaW5nbGUgdG91Y2ggYW5kXG5cdCAqIG11bHRpLXRvdWNoIG1vZGVzLiBFeHRlbmRzIHRoZSBFYXNlbEpTIHtAbGluayBlYXNlbGpzLk1vdXNlRXZlbnR9IG1vZGVsLCBidXQgd2l0aG91dCBzdXBwb3J0IGZvclxuXHQgKiBkb3VibGUgY2xpY2sgb3Igb3Zlci9vdXQgZXZlbnRzLlxuXHQgKiBAcGFyYW0ge2Vhc2VsanMuU3RhZ2V9IHN0YWdlIFRoZSBTdGFnZSB0byBlbmFibGUgdG91Y2ggb24uXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NpbmdsZVRvdWNoPWZhbHNlXSBJZiBgdHJ1ZWAsIG9ubHkgYSBzaW5nbGUgdG91Y2ggd2lsbCBiZSBhY3RpdmUgYXQgYSB0aW1lLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFthbGxvd0RlZmF1bHQ9ZmFsc2VdIElmIGB0cnVlYCwgdGhlbiBkZWZhdWx0IGdlc3R1cmUgYWN0aW9ucyAoZXguIHNjcm9sbGluZywgem9vbWluZykgd2lsbCBiZVxuXHQgKiBhbGxvd2VkIHdoZW4gdGhlIHVzZXIgaXMgaW50ZXJhY3Rpbmcgd2l0aCB0aGUgdGFyZ2V0IGNhbnZhcy5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdG91Y2ggd2FzIHN1Y2Nlc3NmdWxseSBlbmFibGVkIG9uIHRoZSB0YXJnZXQgc3RhZ2UuXG5cdCAqL1xuXHRlbmFibGUgKHN0YWdlLCBzaW5nbGVUb3VjaCA9IGZhbHNlLCBhbGxvd0RlZmF1bHQgPSBmYWxzZSkge1xuXHRcdGlmICghc3RhZ2UgfHwgIXN0YWdlLmNhbnZhcyB8fCAhdGhpcy5pc1N1cHBvcnRlZCgpKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdGlmIChzdGFnZS5fX3RvdWNoKSB7IHJldHVybiB0cnVlOyB9XG5cblx0XHQvLyBpbmplY3QgcmVxdWlyZWQgcHJvcGVydGllcyBvbiBzdGFnZTpcblx0XHRzdGFnZS5fX3RvdWNoID0ge3BvaW50ZXJzOnt9LCBtdWx0aXRvdWNoOiFzaW5nbGVUb3VjaCwgcHJldmVudERlZmF1bHQ6IWFsbG93RGVmYXVsdCwgY291bnQ6MH07XG5cblx0XHQvLyBub3RlIHRoYXQgaW4gdGhlIGZ1dHVyZSB3ZSBtYXkgbmVlZCB0byBkaXNhYmxlIHRoZSBzdGFuZGFyZCBtb3VzZSBldmVudCBtb2RlbCBiZWZvcmUgYWRkaW5nXG5cdFx0Ly8gdGhlc2UgdG8gcHJldmVudCBkdXBsaWNhdGUgY2FsbHMuIEl0IGRvZXNuJ3Qgc2VlbSB0byBiZSBhbiBpc3N1ZSB3aXRoIGlPUyBkZXZpY2VzIHRob3VnaC5cblx0XHRpZiAoJ29udG91Y2hzdGFydCcgaW4gd2luZG93KSB7IHRoaXMuX0lPU19lbmFibGUoc3RhZ2UpOyB9XG5cdFx0ZWxzZSBpZiAod2luZG93LlBvaW50ZXJFdmVudCB8fCB3aW5kb3cuTVNQb2ludGVyRXZlbnQpIHsgdGhpcy5fSUVfZW5hYmxlKHN0YWdlKTsgfVxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIGFsbCBsaXN0ZW5lcnMgdGhhdCB3ZXJlIHNldCB1cCB3aGVuIGNhbGxpbmcgYFRvdWNoLmVuYWJsZSgpYCBvbiBhIHN0YWdlLlxuXHQgKiBAcGFyYW0ge2Vhc2VsanMuU3RhZ2V9IHN0YWdlIFRoZSBTdGFnZSB0byBkaXNhYmxlIHRvdWNoIG9uLlxuXHQgKi9cblx0ZGlzYWJsZSAoc3RhZ2UpIHtcblx0XHRpZiAoIXN0YWdlKSB7IHJldHVybjsgfVxuXHRcdGlmICgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpIHsgdGhpcy5fSU9TX2Rpc2FibGUoc3RhZ2UpOyB9XG5cdFx0ZWxzZSBpZiAod2luZG93LlBvaW50ZXJFdmVudCB8fCB3aW5kb3cuTVNQb2ludGVyRXZlbnQpIHsgdGhpcy5fSUVfZGlzYWJsZShzdGFnZSk7IH1cblx0XHRkZWxldGUgc3RhZ2UuX190b3VjaDtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtlYXNlbGpzLlN0YWdlfSBzdGFnZVxuXHQgKi9cblx0X0lPU19lbmFibGUgKHN0YWdlKSB7XG5cdFx0bGV0IGNhbnZhcyA9IHN0YWdlLmNhbnZhcztcblx0XHRsZXQgZiA9IHN0YWdlLl9fdG91Y2guZiA9IGUgPT4gdGhpcy5fSU9TX2hhbmRsZUV2ZW50KHN0YWdlLCBlKTtcblx0XHRjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgZiwgZmFsc2UpO1xuXHRcdGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIGYsIGZhbHNlKTtcblx0XHRjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIGYsIGZhbHNlKTtcblx0XHRjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoY2FuY2VsXCIsIGYsIGZhbHNlKTtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtlYXNlbGpzLlN0YWdlfSBzdGFnZVxuXHQgKi9cblx0X0lPU19kaXNhYmxlIChzdGFnZSkge1xuXHRcdGxldCBjYW52YXMgPSBzdGFnZS5jYW52YXM7XG5cdFx0aWYgKCFjYW52YXMpIHsgcmV0dXJuOyB9XG5cdFx0bGV0IGYgPSBzdGFnZS5fX3RvdWNoLmY7XG5cdFx0Y2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIGYsIGZhbHNlKTtcblx0XHRjYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCBmLCBmYWxzZSk7XG5cdFx0Y2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCBmLCBmYWxzZSk7XG5cdFx0Y2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGNhbmNlbFwiLCBmLCBmYWxzZSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7ZWFzZWxqcy5TdGFnZX0gc3RhZ2Vcblx0ICogQHBhcmFtIHtPYmplY3R9IGUgVGhlIGV2ZW50IHRvIGhhbmRsZVxuXHQgKi9cblx0X0lPU19oYW5kbGVFdmVudCAoc3RhZ2UsIGUpIHtcblx0XHRpZiAoIXN0YWdlKSB7IHJldHVybjsgfVxuXHRcdGlmIChzdGFnZS5fX3RvdWNoLnByZXZlbnREZWZhdWx0KSB7IGUucHJldmVudERlZmF1bHQmJmUucHJldmVudERlZmF1bHQoKTsgfVxuXHRcdGxldCB0b3VjaGVzID0gZS5jaGFuZ2VkVG91Y2hlcztcblx0XHRsZXQgdHlwZSA9IGUudHlwZTtcblx0XHRjb25zdCBsID0gdG91Y2hlcy5sZW5ndGg7XG5cdFx0Zm9yIChsZXQgdG91Y2ggb2YgdG91Y2hlcykge1xuXHRcdFx0bGV0IGlkID0gdG91Y2guaWRlbnRpZmllcjtcblx0XHRcdGlmICh0b3VjaC50YXJnZXQgIT0gc3RhZ2UuY2FudmFzKSB7IGNvbnRpbnVlOyB9XG5cblx0XHRcdGlmICh0eXBlID09PSBcInRvdWNoc3RhcnRcIikge1xuXHRcdFx0XHR0aGlzLl9oYW5kbGVTdGFydChzdGFnZSwgaWQsIGUsIHRvdWNoLnBhZ2VYLCB0b3VjaC5wYWdlWSk7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT09IFwidG91Y2htb3ZlXCIpIHtcblx0XHRcdFx0dGhpcy5faGFuZGxlTW92ZShzdGFnZSwgaWQsIGUsIHRvdWNoLnBhZ2VYLCB0b3VjaC5wYWdlWSk7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT09IFwidG91Y2hlbmRcIiB8fCB0eXBlID09PSBcInRvdWNoY2FuY2VsXCIpIHtcblx0XHRcdFx0dGhpcy5faGFuZGxlRW5kKHN0YWdlLCBpZCwgZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge2Vhc2VsanMuU3RhZ2V9IHN0YWdlXG5cdCAqL1xuXHRfSUVfZW5hYmxlIChzdGFnZSkge1xuXHRcdGxldCBjYW52YXMgPSBzdGFnZS5jYW52YXM7XG5cdFx0bGV0IGYgPSBzdGFnZS5fX3RvdWNoLmYgPSBlID0+IHRoaXMuX0lFX2hhbmRsZUV2ZW50KHN0YWdlLGUpO1xuXG5cdFx0aWYgKHdpbmRvdy5Qb2ludGVyRXZlbnQgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Y2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJNU1BvaW50ZXJEb3duXCIsIGYsIGZhbHNlKTtcblx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiTVNQb2ludGVyTW92ZVwiLCBmLCBmYWxzZSk7XG5cdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIk1TUG9pbnRlclVwXCIsIGYsIGZhbHNlKTtcblx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiTVNQb2ludGVyQ2FuY2VsXCIsIGYsIGZhbHNlKTtcblx0XHRcdGlmIChzdGFnZS5fX3RvdWNoLnByZXZlbnREZWZhdWx0KSB7IGNhbnZhcy5zdHlsZS5tc1RvdWNoQWN0aW9uID0gXCJub25lXCI7IH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCBmLCBmYWxzZSk7XG5cdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIGYsIGZhbHNlKTtcblx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIGYsIGZhbHNlKTtcblx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmNhbmNlbFwiLCBmLCBmYWxzZSk7XG5cdFx0XHRpZiAoc3RhZ2UuX190b3VjaC5wcmV2ZW50RGVmYXVsdCkgeyBjYW52YXMuc3R5bGUudG91Y2hBY3Rpb24gPSBcIm5vbmVcIjsgfVxuXG5cdFx0fVxuXHRcdHN0YWdlLl9fdG91Y2guYWN0aXZlSURzID0ge307XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7ZWFzZWxqcy5TdGFnZX0gc3RhZ2Vcblx0ICovXG5cdF9JRV9kaXNhYmxlIChzdGFnZSkge1xuXHRcdGxldCBmID0gc3RhZ2UuX190b3VjaC5mO1xuXG5cdFx0aWYgKHdpbmRvdy5Qb2ludGVyRXZlbnQgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJNU1BvaW50ZXJNb3ZlXCIsIGYsIGZhbHNlKTtcblx0XHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiTVNQb2ludGVyVXBcIiwgZiwgZmFsc2UpO1xuXHRcdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJNU1BvaW50ZXJDYW5jZWxcIiwgZiwgZmFsc2UpO1xuXHRcdFx0aWYgKHN0YWdlLmNhbnZhcykge1xuXHRcdFx0XHRzdGFnZS5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIk1TUG9pbnRlckRvd25cIiwgZiwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIGYsIGZhbHNlKTtcblx0XHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIGYsIGZhbHNlKTtcblx0XHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcmNhbmNlbFwiLCBmLCBmYWxzZSk7XG5cdFx0XHRpZiAoc3RhZ2UuY2FudmFzKSB7XG5cdFx0XHRcdHN0YWdlLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgZiwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtlYXNlbGpzLlN0YWdlfSBzdGFnZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gZSBUaGUgZXZlbnQgdG8gaGFuZGxlLlxuXHQgKi9cblx0X0lFX2hhbmRsZUV2ZW50IChzdGFnZSwgZSkge1xuXHRcdGlmICghc3RhZ2UpIHsgcmV0dXJuOyB9XG5cdFx0aWYgKHN0YWdlLl9fdG91Y2gucHJldmVudERlZmF1bHQpIHsgZS5wcmV2ZW50RGVmYXVsdCAmJiBlLnByZXZlbnREZWZhdWx0KCk7IH1cblx0XHRsZXQgdHlwZSA9IGUudHlwZTtcblx0XHRsZXQgaWQgPSBlLnBvaW50ZXJJZDtcblx0XHRsZXQgaWRzID0gc3RhZ2UuX190b3VjaC5hY3RpdmVJRHM7XG5cblx0XHRpZiAodHlwZSA9PT0gXCJNU1BvaW50ZXJEb3duXCIgfHwgdHlwZSA9PT0gXCJwb2ludGVyZG93blwiKSB7XG5cdFx0XHRpZiAoZS5zcmNFbGVtZW50ICE9IHN0YWdlLmNhbnZhcykgeyByZXR1cm47IH1cblx0XHRcdGlkc1tpZF0gPSB0cnVlO1xuXHRcdFx0dGhpcy5faGFuZGxlU3RhcnQoc3RhZ2UsIGlkLCBlLCBlLnBhZ2VYLCBlLnBhZ2VZKTtcblx0XHR9IGVsc2UgaWYgKGlkc1tpZF0pIHsgLy8gaXQncyBhbiBpZCB3ZSdyZSB3YXRjaGluZ1xuXHRcdFx0aWYgKHR5cGUgPT09IFwiTVNQb2ludGVyTW92ZVwiIHx8IHR5cGUgPT09IFwicG9pbnRlcm1vdmVcIikge1xuXHRcdFx0XHR0aGlzLl9oYW5kbGVNb3ZlKHN0YWdlLCBpZCwgZSwgZS5wYWdlWCwgZS5wYWdlWSk7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT09IFwiTVNQb2ludGVyVXBcIiB8fCB0eXBlID09PSBcIk1TUG9pbnRlckNhbmNlbFwiXG5cdFx0XHRcdFx0fHwgdHlwZSA9PT0gXCJwb2ludGVydXBcIiB8fCB0eXBlID09PSBcInBvaW50ZXJjYW5jZWxcIikge1xuXHRcdFx0XHRkZWxldGUoaWRzW2lkXSk7XG5cdFx0XHRcdHRoaXMuX2hhbmRsZUVuZChzdGFnZSwgaWQsIGUpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtlYXNlbGpzLlN0YWdlfSBzdGFnZVxuXHQgKiBAcGFyYW0ge1N0cmluZyB8IE51bWJlcn0gaWRcblx0ICogQHBhcmFtIHtPYmplY3R9IGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICovXG5cdF9oYW5kbGVTdGFydCAoc3RhZ2UsIGlkLCBlLCB4LCB5KSB7XG5cdFx0bGV0IHByb3BzID0gc3RhZ2UuX190b3VjaDtcblx0XHRpZiAoIXByb3BzLm11bHRpdG91Y2ggJiYgcHJvcHMuY291bnQpIHsgcmV0dXJuOyB9XG5cdFx0bGV0IGlkcyA9IHByb3BzLnBvaW50ZXJzO1xuXHRcdGlmIChpZHNbaWRdKSB7IHJldHVybjsgfVxuXHRcdGlkc1tpZF0gPSB0cnVlO1xuXHRcdHByb3BzLmNvdW50Kys7XG5cdFx0c3RhZ2UuX2hhbmRsZVBvaW50ZXJEb3duKGlkLCBlLCB4LCB5KTtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtlYXNlbGpzLlN0YWdlfSBzdGFnZVxuXHQgKiBAcGFyYW0ge1N0cmluZyB8IE51bWJlcn0gaWRcblx0ICogQHBhcmFtIHtPYmplY3R9IGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICovXG5cdF9oYW5kbGVNb3ZlIChzdGFnZSwgaWQsIGUsIHgsIHkpIHtcblx0XHRpZiAoIXN0YWdlLl9fdG91Y2gucG9pbnRlcnNbaWRdKSB7IHJldHVybjsgfVxuXHRcdHN0YWdlLl9oYW5kbGVQb2ludGVyTW92ZShpZCwgZSwgeCwgeSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7ZWFzZWxqcy5TdGFnZX0gc3RhZ2Vcblx0ICogQHBhcmFtIHtTdHJpbmcgfCBOdW1iZXJ9IGlkXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBlXG5cdCAqL1xuXHRfaGFuZGxlRW5kIChzdGFnZSwgaWQsIGUpIHtcblx0XHQvLyBUT0RPOiBjYW5jZWwgc2hvdWxkIGJlIGhhbmRsZWQgZGlmZmVyZW50bHkgZm9yIHByb3BlciBVSSAoZXguIGFuIHVwIHdvdWxkIHRyaWdnZXIgYSBjbGljaywgYSBjYW5jZWwgd291bGQgbW9yZSBjbG9zZWx5IHJlc2VtYmxlIGFuIG91dCkuXG5cdFx0bGV0IHByb3BzID0gc3RhZ2UuX190b3VjaDtcblx0XHRsZXQgaWRzID0gcHJvcHMucG9pbnRlcnM7XG5cdFx0aWYgKCFpZHNbaWRdKSB7IHJldHVybjsgfVxuXHRcdHByb3BzLmNvdW50LS07XG5cdFx0c3RhZ2UuX2hhbmRsZVBvaW50ZXJVcChpZCwgZSwgdHJ1ZSk7XG5cdFx0ZGVsZXRlKGlkc1tpZF0pO1xuXHR9XG5cbn1cbiIsIi8qKlxuICogQGxpY2Vuc2UgU3ByaXRlU2hlZXRCdWlsZGVyXG4gKiBWaXNpdCBodHRwOi8vY3JlYXRlanMuY29tLyBmb3IgZG9jdW1lbnRhdGlvbiwgdXBkYXRlcyBhbmQgZXhhbXBsZXMuXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IGdza2lubmVyLmNvbSwgaW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gKiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxuICogZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0XG4gKiByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSxcbiAqIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiAqIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXG4gKiBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gKiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICogRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTXG4gKiBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICogTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcbiAqIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLFxuICogV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4gKiBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SXG4gKiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gKi9cblxuaW1wb3J0IHsgRXZlbnREaXNwYXRjaGVyLCBFdmVudCB9IGZyb20gXCJAY3JlYXRlanMvY29yZVwiO1xuaW1wb3J0IFJlY3RhbmdsZSBmcm9tIFwiLi4vZ2VvbS9SZWN0YW5nbGVcIjtcbmltcG9ydCBTcHJpdGVTaGVldCBmcm9tIFwiLi4vZGlzcGxheS9TcHJpdGVTaGVldFwiO1xuXG4vKipcbiAqIFRoZSBTcHJpdGVTaGVldEJ1aWxkZXIgYWxsb3dzIHlvdSB0byBnZW5lcmF0ZSB7QGxpbmsgZWFzZWxqcy5TcHJpdGVTaGVldH0gaW5zdGFuY2VzIGF0IHJ1biB0aW1lXG4gKiBmcm9tIGFueSBkaXNwbGF5IG9iamVjdC4gVGhpcyBjYW4gYWxsb3cgeW91IHRvIG1haW50YWluIHlvdXIgYXNzZXRzIGFzIHZlY3RvciBncmFwaGljcyAoZm9yIGxvdyBmaWxlIHNpemUpLCBhbmRcbiAqIHJlbmRlciB0aGVtIGF0IHJ1biB0aW1lIGFzIFNwcml0ZVNoZWV0cyBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlLlxuICpcbiAqIFNwcml0ZVNoZWV0cyBjYW4gYmUgYnVpbHQgZWl0aGVyIHN5bmNocm9ub3VzbHksIG9yIGFzeW5jaHJvbm91c2x5LCBzbyB0aGF0IGxhcmdlIFNwcml0ZVNoZWV0cyBjYW4gYmUgZ2VuZXJhdGVkXG4gKiB3aXRob3V0IGxvY2tpbmcgdGhlIFVJLlxuICpcbiAqIE5vdGUgdGhhdCB0aGUgXCJpbWFnZXNcIiB1c2VkIGluIHRoZSBnZW5lcmF0ZWQgU3ByaXRlU2hlZXQgYXJlIGFjdHVhbGx5IGNhbnZhcyBlbGVtZW50cywgYW5kIHRoYXQgdGhleSB3aWxsIGJlXG4gKiBzaXplZCB0byB0aGUgbmVhcmVzdCBwb3dlciBvZiAyIHVwIHRvIHRoZSB2YWx1ZSBvZiB7QGxpbmsgZWFzZWxqcy5TcHJpdGVTaGVldEJ1aWxkZXIjbWF4V2lkdGh9XG4gKiBvciB7QGxpbmsgZWFzZWxqcy5TcHJpdGVTaGVldEJ1aWxkZXIjbWF4SGVpZ2h0fS5cbiAqXG4gKiBAbWVtYmVyb2YgZWFzZWxqc1xuICogQGV4dGVuZHMgY29yZS5FdmVudERpc3BhdGNoZXJcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gW2ZyYW1lcmF0ZT0wXSBUaGUge3sjY3Jvc3NMaW5rIFwiU3ByaXRlU2hlZXQvZnJhbWVyYXRlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IG9mXG4gKiB7QGxpbmsgZWFzZWxqcy5TcHJpdGVTaGVldH0gaW5zdGFuY2VzIHRoYXQgYXJlIGNyZWF0ZWQuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNwcml0ZVNoZWV0QnVpbGRlciBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlciB7XG5cblx0Y29uc3RydWN0b3IgKGZyYW1lcmF0ZSA9IDApIHtcblx0XHRzdXBlcigpO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIG1heGltdW0gd2lkdGggZm9yIHRoZSBpbWFnZXMgKG5vdCBpbmRpdmlkdWFsIGZyYW1lcykgaW4gdGhlIGdlbmVyYXRlZCBTcHJpdGVTaGVldC4gSXQgaXMgcmVjb21tZW5kZWQgdG9cblx0XHQgKiB1c2UgYSBwb3dlciBvZiAyIGZvciB0aGlzIHZhbHVlIChleC4gMTAyNCwgMjA0OCwgNDA5NikuIElmIHRoZSBmcmFtZXMgY2Fubm90IGFsbCBmaXQgd2l0aGluIHRoZSBtYXhcblx0XHQgKiBkaW1lbnNpb25zLCB0aGVuIGFkZGl0aW9uYWwgaW1hZ2VzIHdpbGwgYmUgY3JlYXRlZCBhcyBuZWVkZWQuXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAyMDQ4XG5cdFx0Ki9cblx0XHR0aGlzLm1heFdpZHRoID0gMjA0ODtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBtYXhpbXVtIGhlaWdodCBmb3IgdGhlIGltYWdlcyAobm90IGluZGl2aWR1YWwgZnJhbWVzKSBpbiB0aGUgZ2VuZXJhdGVkIFNwcml0ZVNoZWV0LiBJdCBpcyByZWNvbW1lbmRlZCB0b1xuXHRcdCAqIHVzZSBhIHBvd2VyIG9mIDIgZm9yIHRoaXMgdmFsdWUgKGV4LiAxMDI0LCAyMDQ4LCA0MDk2KS4gSWYgdGhlIGZyYW1lcyBjYW5ub3QgYWxsIGZpdCB3aXRoaW4gdGhlIG1heFxuXHRcdCAqIGRpbWVuc2lvbnMsIHRoZW4gYWRkaXRpb25hbCBpbWFnZXMgd2lsbCBiZSBjcmVhdGVkIGFzIG5lZWRlZC5cblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDIwNDhcblx0XHQgKi9cblx0XHR0aGlzLm1heEhlaWdodCA9IDIwNDg7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgU3ByaXRlU2hlZXQgdGhhdCB3YXMgZ2VuZXJhdGVkLiBUaGlzIHdpbGwgYmUgbnVsbCBiZWZvcmUgYSBidWlsZCBpcyBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5LlxuXHRcdCAqIEB0eXBlIHtlYXNlbGpzLlNwcml0ZVNoZWV0fVxuXHRcdCAqL1xuXHRcdHRoaXMuc3ByaXRlU2hlZXQgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHNjYWxlIHRvIGFwcGx5IHdoZW4gZHJhd2luZyBhbGwgZnJhbWVzIHRvIHRoZSBTcHJpdGVTaGVldC4gVGhpcyBpcyBtdWx0aXBsaWVkIGFnYWluc3QgYW55IHNjYWxlIHNwZWNpZmllZFxuXHRcdCAqIGluIHRoZSBhZGRGcmFtZSBjYWxsLiBUaGlzIGNhbiBiZSB1c2VkLCBmb3IgZXhhbXBsZSwgdG8gZ2VuZXJhdGUgYSBTcHJpdGVTaGVldCBhdCBydW4gdGltZSB0aGF0IGlzIHRhaWxvcmVkXG5cdFx0ICogdG8gdGhlIGEgc3BlY2lmaWMgZGV2aWNlIHJlc29sdXRpb24gKGV4LiB0YWJsZXQgdnMgbW9iaWxlKS5cblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDFcblx0XHQgKi9cblx0XHR0aGlzLnNjYWxlID0gMTtcblxuXHRcdC8qKlxuXHRcdCogVGhlIHBhZGRpbmcgdG8gdXNlIGJldHdlZW4gZnJhbWVzLiBUaGlzIGlzIGhlbHBmdWwgdG8gcHJlc2VydmUgYW50aWFsaWFzaW5nIG9uIGRyYXduIHZlY3RvciBjb250ZW50LlxuXHRcdCogQHR5cGUge051bWJlcn1cblx0XHQqIEBkZWZhdWx0IDFcblx0XHQqL1xuXHRcdHRoaXMucGFkZGluZyA9IDE7XG5cblx0XHQvKipcblx0XHQgKiBBIG51bWJlciBmcm9tIDAuMDEgdG8gMC45OSB0aGF0IGluZGljYXRlcyB3aGF0IHBlcmNlbnRhZ2Ugb2YgdGltZSB0aGUgYnVpbGRlciBjYW4gdXNlLiBUaGlzIGNhbiBiZVxuXHRcdCAqIHRob3VnaHQgb2YgYXMgdGhlIG51bWJlciBvZiBzZWNvbmRzIHBlciBzZWNvbmQgdGhlIGJ1aWxkZXIgd2lsbCB1c2UuIEZvciBleGFtcGxlLCB3aXRoIGEgdGltZVNsaWNlIHZhbHVlIG9mIDAuMyxcblx0XHQgKiB0aGUgYnVpbGRlciB3aWxsIHJ1biAyMCB0aW1lcyBwZXIgc2Vjb25kLCB1c2luZyBhcHByb3hpbWF0ZWx5IDE1bXMgcGVyIGJ1aWxkICgzMCUgb2YgYXZhaWxhYmxlIHRpbWUsIG9yIDAuM3MgcGVyIHNlY29uZCkuXG5cdFx0ICogRGVmYXVsdHMgdG8gMC4zLlxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMC4zXG5cdFx0ICovXG5cdFx0dGhpcy50aW1lU2xpY2UgPSAwLjM7XG5cblx0XHQvKipcblx0XHQgKiBBIHZhbHVlIGJldHdlZW4gMCBhbmQgMSB0aGF0IGluZGljYXRlcyB0aGUgcHJvZ3Jlc3Mgb2YgYSBidWlsZCwgb3IgLTEgaWYgYSBidWlsZCBoYXMgbm90XG5cdFx0ICogYmVlbiBpbml0aWF0ZWQuXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAtMVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqL1xuXHRcdHRoaXMucHJvZ3Jlc3MgPSAtMTtcblxuXHRcdC8qKlxuXHRcdCAqIEEge0BsaW5rIGVhc2VsanMuU3ByaXRlU2hlZXQjZnJhbWVyYXRlfSB2YWx1ZSB0aGF0IHdpbGwgYmUgcGFzc2VkIHRvIG5ldyBTcHJpdGVTaGVldCBpbnN0YW5jZXMgdGhhdCBhcmVcblx0XHQgKiBjcmVhdGVkLiBJZiBubyBmcmFtZXJhdGUgaXMgc3BlY2lmaWVkIChvciBpdCBpcyAwKSwgdGhlbiBTcHJpdGVTaGVldHMgd2lsbCB1c2UgdGhlIHtAbGluayBjb3JlLlRpY2tlcn0gZnJhbWVyYXRlLlxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqL1xuXHRcdHRoaXMuZnJhbWVyYXRlID0gZnJhbWVyYXRlO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHQgKi9cblx0XHR0aGlzLl9mcmFtZXMgPSBbXTtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7QXJyYXl9XG5cdFx0ICovXG5cdFx0dGhpcy5fYW5pbWF0aW9ucyA9IHt9O1xuXG5cdFx0LyoqXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHQgKi9cblx0XHR0aGlzLl9kYXRhID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqL1xuXHRcdHRoaXMuX25leHRGcmFtZUluZGV4ID0gMDtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqL1xuXHRcdHRoaXMuX2luZGV4ID0gMDtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqL1xuXHRcdHRoaXMuX3RpbWVySUQgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICovXG5cdFx0dGhpcy5fc2NhbGUgPSAxO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBmcmFtZSB0byB0aGUge0BsaW5rIGVhc2VsanMuU3ByaXRlU2hlZXR9LiBOb3RlIHRoYXQgdGhlIGZyYW1lIHdpbGwgbm90IGJlIGRyYXduIHVudGlsIHlvdVxuXHQgKiBjYWxsIHtAbGluayBlYXNlbGpzLlNwcml0ZVNoZWV0QnVpbGRlciNidWlsZH0gbWV0aG9kLiBUaGUgb3B0aW9uYWwgc2V0dXAgcGFyYW1zIGFsbG93IHlvdSB0byBoYXZlXG5cdCAqIGEgZnVuY3Rpb24gcnVuIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgZHJhdyBvY2N1cnMuIEZvciBleGFtcGxlLCB0aGlzIGFsbG93cyB5b3UgdG8gYWRkIGEgc2luZ2xlIHNvdXJjZSBtdWx0aXBsZVxuXHQgKiB0aW1lcywgYnV0IG1hbmlwdWxhdGUgaXQgb3IgaXRzIGNoaWxkcmVuIHRvIGNoYW5nZSBpdCB0byBnZW5lcmF0ZSBkaWZmZXJlbnQgZnJhbWVzLlxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgdGhlIHNvdXJjZSdzIHRyYW5zZm9ybWF0aW9ucyAoeCwgeSwgc2NhbGUsIHJvdGF0ZSwgYWxwaGEpIHdpbGwgYmUgaWdub3JlZCwgZXhjZXB0IGZvciByZWdYL1kuIFRvIGFwcGx5XG5cdCAqIHRyYW5zZm9ybXMgdG8gYSBzb3VyY2Ugb2JqZWN0IGFuZCBoYXZlIHRoZW0gY2FwdHVyZWQgaW4gdGhlIFNwcml0ZVNoZWV0LCBzaW1wbHkgcGxhY2UgaXQgaW50byBhIHtAbGluayBlYXNlbGpzLkNvbnRhaW5lcn1cblx0ICogYW5kIHBhc3MgaW4gdGhlIENvbnRhaW5lciBhcyB0aGUgc291cmNlLlxuXHQgKiBAcGFyYW0ge2Vhc2VsanMuRGlzcGxheU9iamVjdH0gc291cmNlIFRoZSBzb3VyY2Uge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdFwifX17ey9jcm9zc0xpbmt9fSAgdG8gZHJhdyBhcyB0aGUgZnJhbWUuXG5cdCAqIEBwYXJhbSB7ZWFzZWxqcy5SZWN0YW5nbGV9IFtzb3VyY2VSZWN0XSBBIHt7I2Nyb3NzTGluayBcIlJlY3RhbmdsZVwifX17ey9jcm9zc0xpbmt9fSBkZWZpbmluZyB0aGUgcG9ydGlvbiBvZiB0aGVcblx0ICogc291cmNlIHRvIGRyYXcgdG8gdGhlIGZyYW1lLiBJZiBub3Qgc3BlY2lmaWVkLCBpdCB3aWxsIGxvb2sgZm9yIGEgYGdldEJvdW5kc2AgbWV0aG9kLCBib3VuZHMgcHJvcGVydHksIG9yXG5cdCAqIGBub21pbmFsQm91bmRzYCBwcm9wZXJ0eSBvbiB0aGUgc291cmNlIHRvIHVzZS4gSWYgb25lIGlzIG5vdCBmb3VuZCwgdGhlIGZyYW1lIHdpbGwgYmUgc2tpcHBlZC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtzY2FsZT0xXSBPcHRpb25hbC4gVGhlIHNjYWxlIHRvIGRyYXcgdGhpcyBmcmFtZSBhdC4gRGVmYXVsdCBpcyAxLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc2V0dXBGdW5jdGlvbl0gQSBmdW5jdGlvbiB0byBjYWxsIGltbWVkaWF0ZWx5IGJlZm9yZSBkcmF3aW5nIHRoaXMgZnJhbWUuIEl0IHdpbGwgYmUgY2FsbGVkIHdpdGggdHdvIHBhcmFtZXRlcnM6IHRoZSBzb3VyY2UsIGFuZCBzZXR1cERhdGEuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbc2V0dXBEYXRhXSBBcmJpdHJhcnkgc2V0dXAgZGF0YSB0byBwYXNzIHRvIHNldHVwRnVuY3Rpb24gYXMgdGhlIHNlY29uZCBwYXJhbWV0ZXIuXG5cdCAqIEByZXR1cm4ge051bWJlcn0gVGhlIGluZGV4IG9mIHRoZSBmcmFtZSB0aGF0IHdhcyBqdXN0IGFkZGVkLCBvciBudWxsIGlmIGEgc291cmNlUmVjdCBjb3VsZCBub3QgYmUgZGV0ZXJtaW5lZC5cblx0ICovXG5cdGFkZEZyYW1lIChzb3VyY2UsIHNvdXJjZVJlY3QsIHNjYWxlID0gMSwgc2V0dXBGdW5jdGlvbiwgc2V0dXBEYXRhKSB7XG5cdFx0aWYgKHRoaXMuX2RhdGEpIHsgdGhyb3cgU3ByaXRlU2hlZXRCdWlsZGVyLkVSUl9SVU5OSU5HOyB9XG5cdFx0bGV0IHJlY3QgPSBzb3VyY2VSZWN0fHxzb3VyY2UuYm91bmRzfHxzb3VyY2Uubm9taW5hbEJvdW5kc3x8KHNvdXJjZS5nZXRCb3VuZHMmJnNvdXJjZS5nZXRCb3VuZHMoKSk7XG5cdFx0aWYgKCFyZWN0KSB7IHJldHVybiBudWxsOyB9XG5cdFx0cmV0dXJuIHRoaXMuX2ZyYW1lcy5wdXNoKHsgc291cmNlLCBzb3VyY2VSZWN0OiByZWN0LCBzY2FsZSwgZnVuY3Q6IHNldHVwRnVuY3Rpb24sIGRhdGE6IHNldHVwRGF0YSwgaW5kZXg6IHRoaXMuX2ZyYW1lcy5sZW5ndGgsIGhlaWdodDogcmVjdC5oZWlnaHQqc2NhbGUgfSkgLSAxO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYW4gYW5pbWF0aW9uIHRoYXQgd2lsbCBiZSBpbmNsdWRlZCBpbiB0aGUgY3JlYXRlZCB7QGxpbmsgZWFzZWxqcy5TcHJpdGVTaGVldH0uXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBuYW1lIGZvciB0aGUgYW5pbWF0aW9uLlxuXHQgKiBAcGFyYW0ge0FycmF5fSBmcmFtZXMgQW4gYXJyYXkgb2YgZnJhbWUgaW5kZXhlcyB0aGF0IGNvbXByaXNlIHRoZSBhbmltYXRpb24uIEV4LiBbMyw2LDVdIHdvdWxkIGRlc2NyaWJlIGFuIGFuaW1hdGlvblxuXHQgKiB0aGF0IHBsYXllZCBmcmFtZSBpbmRleGVzIDMsIDYsIGFuZCA1IGluIHRoYXQgb3JkZXIuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbbmV4dF0gU3BlY2lmaWVzIHRoZSBuYW1lIG9mIHRoZSBhbmltYXRpb24gdG8gY29udGludWUgdG8gYWZ0ZXIgdGhpcyBhbmltYXRpb24gZW5kcy4gWW91IGNhblxuXHQgKiBhbHNvIHBhc3MgZmFsc2UgdG8gaGF2ZSB0aGUgYW5pbWF0aW9uIHN0b3Agd2hlbiBpdCBlbmRzLiBCeSBkZWZhdWx0IGl0IHdpbGwgbG9vcCB0byB0aGUgc3RhcnQgb2YgdGhlIHNhbWUgYW5pbWF0aW9uLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3NwZWVkXSBTcGVjaWZpZXMgYSBmcmFtZSBhZHZhbmNlIHNwZWVkIGZvciB0aGlzIGFuaW1hdGlvbi4gRm9yIGV4YW1wbGUsIGEgdmFsdWUgb2YgMC41IHdvdWxkXG5cdCAqIGNhdXNlIHRoZSBhbmltYXRpb24gdG8gYWR2YW5jZSBldmVyeSBzZWNvbmQgdGljay4gTm90ZSB0aGF0IGVhcmxpZXIgdmVyc2lvbnMgdXNlZCBgZnJlcXVlbmN5YCBpbnN0ZWFkLCB3aGljaCBoYWRcblx0ICogdGhlIG9wcG9zaXRlIGVmZmVjdC5cblx0ICovXG5cdGFkZEFuaW1hdGlvbiAobmFtZSwgZnJhbWVzLCBuZXh0LCBzcGVlZCkge1xuXHRcdGlmICh0aGlzLl9kYXRhKSB7IHRocm93IFNwcml0ZVNoZWV0QnVpbGRlci5FUlJfUlVOTklORzsgfVxuXHRcdHRoaXMuX2FuaW1hdGlvbnNbbmFtZV0gPSB7IGZyYW1lcywgbmV4dCwgc3BlZWQgfTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGlzIHdpbGwgdGFrZSBhIHtAbGluayBlYXNlbGpzLk1vdmllQ2xpcH0gaW5zdGFuY2UsIGFuZCBhZGQgaXRzIGZyYW1lcyBhbmQgbGFiZWxzIHRvIHRoaXNcblx0ICogYnVpbGRlci4gTGFiZWxzIHdpbGwgYmUgYWRkZWQgYXMgYW4gYW5pbWF0aW9uIHJ1bm5pbmcgZnJvbSB0aGUgbGFiZWwgaW5kZXggdG8gdGhlIG5leHQgbGFiZWwuIEZvciBleGFtcGxlLCBpZlxuXHQgKiB0aGVyZSBpcyBhIGxhYmVsIG5hbWVkIFwiZm9vXCIgYXQgZnJhbWUgMCBhbmQgYSBsYWJlbCBuYW1lZCBcImJhclwiIGF0IGZyYW1lIDEwLCBpbiBhIE1vdmllQ2xpcCB3aXRoIDE1IGZyYW1lcywgaXRcblx0ICogd2lsbCBhZGQgYW4gYW5pbWF0aW9uIG5hbWVkIFwiZm9vXCIgdGhhdCBydW5zIGZyb20gZnJhbWUgaW5kZXggMCB0byA5LCBhbmQgYW4gYW5pbWF0aW9uIG5hbWVkIFwiYmFyXCIgdGhhdCBydW5zIGZyb21cblx0ICogZnJhbWUgaW5kZXggMTAgdG8gMTQuXG5cdCAqXG5cdCAqIE5vdGUgdGhhdCB0aGlzIHdpbGwgaXRlcmF0ZSB0aHJvdWdoIHRoZSBmdWxsIE1vdmllQ2xpcCB3aXRoIHtAbGluayBlYXNlbGpzLk1vdmllQ2xpcCNhY3Rpb25zRW5hYmxlZH1cblx0ICogc2V0IHRvIGBmYWxzZWAsIGVuZGluZyBvbiB0aGUgbGFzdCBmcmFtZS5cblx0ICogQHBhcmFtIHtlYXNlbGpzLk1vdmllQ2xpcH0gc291cmNlIFRoZSBzb3VyY2UgTW92aWVDbGlwIGluc3RhbmNlIHRvIGFkZCB0byB0aGUgU3ByaXRlU2hlZXQuXG5cdCAqIEBwYXJhbSB7ZWFzZWxqcy5SZWN0YW5nbGV9IFtzb3VyY2VSZWN0XSBBIFJlY3RhbmdsZSBkZWZpbmluZyB0aGUgcG9ydGlvbiBvZiB0aGUgc291cmNlIHRvXG5cdCAqIGRyYXcgdG8gdGhlIGZyYW1lLiBJZiBub3Qgc3BlY2lmaWVkLCBpdCB3aWxsIGxvb2sgZm9yIGEge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9nZXRCb3VuZHNcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogbWV0aG9kLCBgZnJhbWVCb3VuZHNgIEFycmF5LCBgYm91bmRzYCBwcm9wZXJ0eSwgb3IgYG5vbWluYWxCb3VuZHNgIHByb3BlcnR5IG9uIHRoZSBzb3VyY2UgdG8gdXNlLiBJZiBvbmUgaXMgbm90XG5cdCAqIGZvdW5kLCB0aGUgTW92aWVDbGlwIHdpbGwgYmUgc2tpcHBlZC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtzY2FsZT0xXSBUaGUgc2NhbGUgdG8gZHJhdyB0aGUgbW92aWUgY2xpcCBhdC5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gW3NldHVwRnVuY3Rpb25dIEEgZnVuY3Rpb24gdG8gY2FsbCBpbW1lZGlhdGVseSBiZWZvcmUgZHJhd2luZyBlYWNoIGZyYW1lLiBJdCB3aWxsIGJlIGNhbGxlZFxuXHQgKiB3aXRoIHRocmVlIHBhcmFtZXRlcnM6IHRoZSBzb3VyY2UsIHNldHVwRGF0YSwgYW5kIHRoZSBmcmFtZSBpbmRleC5cblx0ICogQHBhcmFtIHtPYmplY3R9IFtzZXR1cERhdGFdIEFyYml0cmFyeSBzZXR1cCBkYXRhIHRvIHBhc3MgdG8gc2V0dXBGdW5jdGlvbiBhcyB0aGUgc2Vjb25kIHBhcmFtZXRlci5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gW2xhYmVsRnVuY3Rpb25dIFRoaXMgbWV0aG9kIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoIE1vdmllQ2xpcCBsYWJlbCB0aGF0IGlzIGFkZGVkIHdpdGggZm91clxuXHQgKiBwYXJhbWV0ZXJzOiB0aGUgbGFiZWwgbmFtZSwgdGhlIHNvdXJjZSBNb3ZpZUNsaXAgaW5zdGFuY2UsIHRoZSBzdGFydGluZyBmcmFtZSBpbmRleCAoaW4gdGhlIG1vdmllY2xpcCB0aW1lbGluZSlcblx0ICogYW5kIHRoZSBlbmQgaW5kZXguIEl0IG11c3QgcmV0dXJuIGEgbmV3IG5hbWUgZm9yIHRoZSBsYWJlbC9hbmltYXRpb24sIG9yIGBmYWxzZWAgdG8gZXhjbHVkZSB0aGUgbGFiZWwuXG5cdCAqL1xuXHRhZGRNb3ZpZUNsaXAgKHNvdXJjZSwgc291cmNlUmVjdCwgc2NhbGUgPSAxLCBzZXR1cEZ1bmN0aW9uLCBzZXR1cERhdGEsIGxhYmVsRnVuY3Rpb24pIHtcblx0XHRpZiAodGhpcy5fZGF0YSkgeyB0aHJvdyBTcHJpdGVTaGVldEJ1aWxkZXIuRVJSX1JVTk5JTkc7IH1cblx0XHRsZXQgcmVjdHMgPSBzb3VyY2UuZnJhbWVCb3VuZHM7XG5cdFx0bGV0IHJlY3QgPSBzb3VyY2VSZWN0fHxzb3VyY2UuYm91bmRzfHxzb3VyY2Uubm9taW5hbEJvdW5kc3x8KHNvdXJjZS5nZXRCb3VuZHMmJnNvdXJjZS5nZXRCb3VuZHMoKSk7XG5cdFx0aWYgKCFyZWN0ICYmICFyZWN0cykgeyByZXR1cm47IH1cblxuXHRcdGxldCBiYXNlRnJhbWVJbmRleCA9IHRoaXMuX2ZyYW1lcy5sZW5ndGg7XG5cdFx0Y29uc3QgZHVyYXRpb24gPSBzb3VyY2UudGltZWxpbmUuZHVyYXRpb247XG5cdFx0Zm9yIChsZXQgaT0wOyBpPGR1cmF0aW9uOyBpKyspIHtcblx0XHRcdGxldCByID0gKHJlY3RzJiZyZWN0c1tpXSkgPyByZWN0c1tpXSA6IHJlY3Q7XG5cdFx0XHR0aGlzLmFkZEZyYW1lKHNvdXJjZSwgciwgc2NhbGUsIHRoaXMuX3NldHVwTW92aWVDbGlwRnJhbWUsIHtpLCBmOnNldHVwRnVuY3Rpb24sIGQ6c2V0dXBEYXRhfSk7XG5cdFx0fVxuXHRcdGNvbnN0IGxhYmVscyA9IHNvdXJjZS50aW1lbGluZS5fbGFiZWxzO1xuXHRcdGxldCBsYmxzID0gW107XG5cdFx0Zm9yIChsZXQgbiBpbiBsYWJlbHMpIHtcblx0XHRcdGxibHMucHVzaCh7aW5kZXg6bGFiZWxzW25dLCBsYWJlbDpufSk7XG5cdFx0fVxuXHRcdGlmIChsYmxzLmxlbmd0aCkge1xuXHRcdFx0bGJscy5zb3J0KChhLCBiKSA9PiBhLmluZGV4LWIuaW5kZXgpO1xuXHRcdFx0Zm9yIChsZXQgaT0wLGw9bGJscy5sZW5ndGg7IGk8bDsgaSsrKSB7XG5cdFx0XHRcdGxldCBsYWJlbCA9IGxibHNbaV0ubGFiZWw7XG5cdFx0XHRcdGxldCBzdGFydCA9IGJhc2VGcmFtZUluZGV4K2xibHNbaV0uaW5kZXg7XG5cdFx0XHRcdGxldCBlbmQgPSBiYXNlRnJhbWVJbmRleCsoKGkgPT09IGwtMSkgPyBkdXJhdGlvbiA6IGxibHNbaSsxXS5pbmRleCk7XG5cdFx0XHRcdGxldCBmcmFtZXMgPSBbXTtcblx0XHRcdFx0Zm9yIChsZXQgaT1zdGFydDsgaTxlbmQ7IGkrKykgeyBmcmFtZXMucHVzaChpKTsgfVxuXHRcdFx0XHRpZiAobGFiZWxGdW5jdGlvbikge1xuXHRcdFx0XHRcdGxhYmVsID0gbGFiZWxGdW5jdGlvbihsYWJlbCwgc291cmNlLCBzdGFydCwgZW5kKTtcblx0XHRcdFx0XHRpZiAoIWxhYmVsKSB7IGNvbnRpbnVlOyB9XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5hZGRBbmltYXRpb24obGFiZWwsIGZyYW1lcywgdHJ1ZSk7IC8vIGZvciBub3csIHRoaXMgbG9vcHMgYWxsIGFuaW1hdGlvbnMuXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEJ1aWxkcyBhIHtAbGluayBlYXNlbGpzLlNwcml0ZVNoZWV0fSBpbnN0YW5jZSBiYXNlZCBvbiB0aGUgY3VycmVudCBmcmFtZXMuXG5cdCAqIEByZXR1cm4ge2Vhc2VsanMuU3ByaXRlU2hlZXR9IFRoZSBjcmVhdGVkIFNwcml0ZVNoZWV0IGluc3RhbmNlLCBvciBudWxsIGlmIGEgYnVpbGQgaXMgYWxyZWFkeSBydW5uaW5nIG9yIGFuIGVycm9yXG5cdCAqIG9jY3VycmVkLlxuXHQgKi9cblx0YnVpbGQgKCkge1xuXHRcdGlmICh0aGlzLl9kYXRhKSB7IHRocm93IFNwcml0ZVNoZWV0QnVpbGRlci5FUlJfUlVOTklORzsgfVxuXHRcdHRoaXMuX3N0YXJ0QnVpbGQoKTtcblx0XHR3aGlsZSAodGhpcy5fZHJhd05leHQoKSkge31cblx0XHR0aGlzLl9lbmRCdWlsZCgpO1xuXHRcdHJldHVybiB0aGlzLnNwcml0ZVNoZWV0O1xuXHR9XG5cblx0LyoqXG5cdCAqIEFzeW5jaHJvbm91c2x5IGJ1aWxkcyBhIHtAbGluayBlYXNlbGpzLlNwcml0ZVNoZWV0fSBpbnN0YW5jZSBiYXNlZCBvbiB0aGUgY3VycmVudCBmcmFtZXMuIEl0IHdpbGxcblx0ICogcnVuIDIwIHRpbWVzIHBlciBzZWNvbmQsIHVzaW5nIGFuIGFtb3VudCBvZiB0aW1lIGRlZmluZWQgYnkgYHRpbWVTbGljZWAuIFdoZW4gaXQgaXMgY29tcGxldGUgaXQgd2lsbCBjYWxsIHRoZVxuXHQgKiBzcGVjaWZpZWQgY2FsbGJhY2suXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbdGltZVNsaWNlXSBTZXRzIHRoZSB0aW1lU2xpY2UgcHJvcGVydHkgb24gdGhpcyBpbnN0YW5jZS5cblx0ICovXG5cdGJ1aWxkQXN5bmMgKHRpbWVTbGljZSkge1xuXHRcdGlmICh0aGlzLl9kYXRhKSB7IHRocm93IFNwcml0ZVNoZWV0QnVpbGRlci5FUlJfUlVOTklORzsgfVxuXHRcdHRoaXMudGltZVNsaWNlID0gdGltZVNsaWNlO1xuXHRcdHRoaXMuX3N0YXJ0QnVpbGQoKTtcblx0XHR0aGlzLl90aW1lcklEID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLl9ydW4oKSwgNTAtTWF0aC5tYXgoMC4wMSwgTWF0aC5taW4oMC45OSwgdGhpcy50aW1lU2xpY2V8fDAuMykpKjUwKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTdG9wcyB0aGUgY3VycmVudCBhc3luY2hyb25vdXMgYnVpbGQuXG5cdCAqL1xuXHRzdG9wQXN5bmMgKCkge1xuXHRcdGNsZWFyVGltZW91dCh0aGlzLl90aW1lcklEKTtcblx0XHR0aGlzLl9kYXRhID0gbnVsbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuXHQgKiBAb3ZlcnJpZGVcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXG5cdCAqL1xuXHR0b1N0cmluZyAoKSB7XG5cdFx0cmV0dXJuIGBbJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9XWA7XG5cdH1cblxuXHQvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0X3N0YXJ0QnVpbGQgKCkge1xuXHRcdGxldCBwYWQgPSB0aGlzLnBhZGRpbmd8fDA7XG5cdFx0dGhpcy5wcm9ncmVzcyA9IDA7XG5cdFx0dGhpcy5zcHJpdGVTaGVldCA9IG51bGw7XG5cdFx0dGhpcy5faW5kZXggPSAwO1xuXHRcdHRoaXMuX3NjYWxlID0gdGhpcy5zY2FsZTtcblx0XHRsZXQgZGF0YUZyYW1lcyA9IFtdO1xuXHRcdHRoaXMuX2RhdGEgPSB7XG5cdFx0XHRpbWFnZXM6IFtdLFxuXHRcdFx0ZnJhbWVzOiBkYXRhRnJhbWVzLFxuXHRcdFx0ZnJhbWVyYXRlOiB0aGlzLmZyYW1lcmF0ZSxcblx0XHRcdGFuaW1hdGlvbnM6IHRoaXMuX2FuaW1hdGlvbnMgLy8gVE9ETzogc2hvdWxkIHdlIFwiY2xvbmVcIiBfYW5pbWF0aW9ucyBpbiBjYXNlIHNvbWVvbmUgYWRkcyBtb3JlIGFuaW1hdGlvbnMgYWZ0ZXIgYSBidWlsZD9cblx0XHR9O1xuXG5cdFx0bGV0IGZyYW1lcyA9IHRoaXMuX2ZyYW1lcy5zbGljZSgpO1xuXHRcdGZyYW1lcy5zb3J0KChhLCBiKSA9PiAoYS5oZWlnaHQ8PWIuaGVpZ2h0KSA/IC0xIDogMSk7XG5cblx0XHRpZiAoZnJhbWVzW2ZyYW1lcy5sZW5ndGgtMV0uaGVpZ2h0K3BhZCoyID4gdGhpcy5tYXhIZWlnaHQpIHsgdGhyb3cgU3ByaXRlU2hlZXRCdWlsZGVyLkVSUl9ESU1FTlNJT05TOyB9XG5cdFx0bGV0IHk9MCwgeD0wO1xuXHRcdGxldCBpbWcgPSAwO1xuXHRcdHdoaWxlIChmcmFtZXMubGVuZ3RoKSB7XG5cdFx0XHRsZXQgbyA9IHRoaXMuX2ZpbGxSb3coZnJhbWVzLCB5LCBpbWcsIGRhdGFGcmFtZXMsIHBhZCk7XG5cdFx0XHRpZiAoby53ID4geCkgeyB4ID0gby53OyB9XG5cdFx0XHR5ICs9IG8uaDtcblx0XHRcdGlmICghby5oIHx8ICFmcmFtZXMubGVuZ3RoKSB7XG5cdFx0XHRcdGxldCBjYW52YXMgPSB3aW5kb3cuY3JlYXRlanMmJmNyZWF0ZWpzLmNyZWF0ZUNhbnZhcz9jcmVhdGVqcy5jcmVhdGVDYW52YXMoKTpkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuXHRcdFx0XHRjYW52YXMud2lkdGggPSB0aGlzLl9nZXRTaXplKHgsdGhpcy5tYXhXaWR0aCk7XG5cdFx0XHRcdGNhbnZhcy5oZWlnaHQgPSB0aGlzLl9nZXRTaXplKHksdGhpcy5tYXhIZWlnaHQpO1xuXHRcdFx0XHR0aGlzLl9kYXRhLmltYWdlc1tpbWddID0gY2FudmFzO1xuXHRcdFx0XHRpZiAoIW8uaCkge1xuXHRcdFx0XHRcdHg9eT0wO1xuXHRcdFx0XHRcdGltZysrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEByZXR1cm4ge051bWJlcn0gVGhlIHdpZHRoICYgaGVpZ2h0IG9mIHRoZSByb3cuXG5cdCAqL1xuXHRfc2V0dXBNb3ZpZUNsaXBGcmFtZSAoc291cmNlLCBkYXRhKSB7XG5cdFx0bGV0IGFlID0gc291cmNlLmFjdGlvbnNFbmFibGVkO1xuXHRcdHNvdXJjZS5hY3Rpb25zRW5hYmxlZCA9IGZhbHNlO1xuXHRcdHNvdXJjZS5nb3RvQW5kU3RvcChkYXRhLmkpO1xuXHRcdHNvdXJjZS5hY3Rpb25zRW5hYmxlZCA9IGFlO1xuXHRcdGRhdGEuZiYmZGF0YS5mKHNvdXJjZSwgZGF0YS5kLCBkYXRhLmkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHJldHVybiB7TnVtYmVyfSBUaGUgd2lkdGggJiBoZWlnaHQgb2YgdGhlIHJvdy5cblx0ICovXG5cdF9nZXRTaXplIChzaXplLCBtYXgpIHtcblx0XHRsZXQgcG93ID0gNDtcblx0XHR3aGlsZSAoTWF0aC5wb3coMiwgKytwb3cpIDwgc2l6ZSkge31cblx0XHRyZXR1cm4gTWF0aC5taW4obWF4LCBNYXRoLnBvdygyLCBwb3cpKTtcblx0fTtcblxuXHQvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge0FycmF5fSBmcmFtZXNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fSBpbWdcblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGFGcmFtZXNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBhZFxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSB3aWR0aCAmIGhlaWdodCBvZiB0aGUgcm93LlxuXHQgKi9cblx0X2ZpbGxSb3cgKGZyYW1lcywgeSwgaW1nLCBkYXRhRnJhbWVzLCBwYWQpIHtcblx0XHRsZXQgdyA9IHRoaXMubWF4V2lkdGg7XG5cdFx0bGV0IG1heEggPSB0aGlzLm1heEhlaWdodDtcblx0XHR5ICs9IHBhZDtcblx0XHRsZXQgaCA9IG1heEgteTtcblx0XHRsZXQgeCA9IHBhZDtcblx0XHRsZXQgaGVpZ2h0ID0gMDtcblx0XHRmb3IgKGxldCBpPWZyYW1lcy5sZW5ndGgtMTsgaT49MDsgaS0tKSB7XG5cdFx0XHRsZXQgZnJhbWUgPSBmcmFtZXNbaV07XG5cdFx0XHRsZXQgc2MgPSB0aGlzLl9zY2FsZSpmcmFtZS5zY2FsZTtcblx0XHRcdGxldCByZWN0ID0gZnJhbWUuc291cmNlUmVjdDtcblx0XHRcdGxldCBzb3VyY2UgPSBmcmFtZS5zb3VyY2U7XG5cdFx0XHRsZXQgcnggPSBNYXRoLmZsb29yKHNjKnJlY3QueC1wYWQpO1xuXHRcdFx0bGV0IHJ5ID0gTWF0aC5mbG9vcihzYypyZWN0LnktcGFkKTtcblx0XHRcdGxldCByaCA9IE1hdGguY2VpbChzYypyZWN0LmhlaWdodCtwYWQqMik7XG5cdFx0XHRsZXQgcncgPSBNYXRoLmNlaWwoc2MqcmVjdC53aWR0aCtwYWQqMik7XG5cdFx0XHRpZiAocncgPiB3KSB7IHRocm93IFNwcml0ZVNoZWV0QnVpbGRlci5FUlJfRElNRU5TSU9OUzsgfVxuXHRcdFx0aWYgKHJoID4gaCB8fCB4K3J3ID4gdykgeyBjb250aW51ZTsgfVxuXHRcdFx0ZnJhbWUuaW1nID0gaW1nO1xuXHRcdFx0ZnJhbWUucmVjdCA9IG5ldyBSZWN0YW5nbGUoeCx5LHJ3LHJoKTtcblx0XHRcdGhlaWdodCA9IGhlaWdodCB8fCByaDtcblx0XHRcdGZyYW1lcy5zcGxpY2UoaSwxKTtcblx0XHRcdGRhdGFGcmFtZXNbZnJhbWUuaW5kZXhdID0gW3gseSxydyxyaCxpbWcsTWF0aC5yb3VuZCgtcngrc2Mqc291cmNlLnJlZ1gtcGFkKSxNYXRoLnJvdW5kKC1yeStzYypzb3VyY2UucmVnWS1wYWQpXTtcblx0XHRcdHggKz0gcnc7XG5cdFx0fVxuXHRcdHJldHVybiB7dzp4LCBoOmhlaWdodH07XG5cdH1cblxuXHQvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0X2VuZEJ1aWxkICgpIHtcblx0XHR0aGlzLnNwcml0ZVNoZWV0ID0gbmV3IFNwcml0ZVNoZWV0KHRoaXMuX2RhdGEpO1xuXHRcdHRoaXMuX2RhdGEgPSBudWxsO1xuXHRcdHRoaXMucHJvZ3Jlc3MgPSAxO1xuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChcImNvbXBsZXRlXCIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdF9ydW4gKCkge1xuXHRcdGxldCB0cyA9IE1hdGgubWF4KDAuMDEsIE1hdGgubWluKDAuOTksIHRoaXMudGltZVNsaWNlfHwwLjMpKSo1MDtcblx0XHRsZXQgdCA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkrdHM7XG5cdFx0bGV0IGNvbXBsZXRlID0gZmFsc2U7XG5cdFx0d2hpbGUgKHQgPiAobmV3IERhdGUoKSkuZ2V0VGltZSgpKSB7XG5cdFx0XHRpZiAoIXRoaXMuX2RyYXdOZXh0KCkpIHsgY29tcGxldGUgPSB0cnVlOyBicmVhazsgfVxuXHRcdH1cblx0XHRpZiAoY29tcGxldGUpIHtcblx0XHRcdHRoaXMuX2VuZEJ1aWxkKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3RpbWVySUQgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuX3J1bigpLCA1MC10cyk7XG5cdFx0fVxuXHRcdGxldCBwID0gdGhpcy5wcm9ncmVzcyA9IHRoaXMuX2luZGV4L3RoaXMuX2ZyYW1lcy5sZW5ndGg7XG5cdFx0aWYgKHRoaXMuaGFzRXZlbnRMaXN0ZW5lcihcInByb2dyZXNzXCIpKSB7XG5cdFx0XHRsZXQgZXZ0ID0gbmV3IEV2ZW50KFwicHJvZ3Jlc3NcIik7XG5cdFx0XHRldnQucHJvZ3Jlc3MgPSBwO1xuXHRcdFx0dGhpcy5kaXNwYXRjaEV2ZW50KGV2dCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyBmYWxzZSBpZiB0aGlzIGlzIHRoZSBsYXN0IGRyYXcuXG5cdCAqL1xuXHRfZHJhd05leHQgKCkge1xuXHRcdGxldCBmcmFtZSA9IHRoaXMuX2ZyYW1lc1t0aGlzLl9pbmRleF07XG5cdFx0bGV0IHNjID0gZnJhbWUuc2NhbGUqdGhpcy5fc2NhbGU7XG5cdFx0bGV0IHJlY3QgPSBmcmFtZS5yZWN0O1xuXHRcdGxldCBzb3VyY2VSZWN0ID0gZnJhbWUuc291cmNlUmVjdDtcblx0XHRsZXQgY2FudmFzID0gdGhpcy5fZGF0YS5pbWFnZXNbZnJhbWUuaW1nXTtcblx0XHRsZXQgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcblx0XHRmcmFtZS5mdW5jdCYmZnJhbWUuZnVuY3QoZnJhbWUuc291cmNlLCBmcmFtZS5kYXRhKTtcblx0XHRjdHguc2F2ZSgpO1xuXHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRjdHgucmVjdChyZWN0LngsIHJlY3QueSwgcmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpO1xuXHRcdGN0eC5jbGlwKCk7XG5cdFx0Y3R4LnRyYW5zbGF0ZShNYXRoLmNlaWwocmVjdC54LXNvdXJjZVJlY3QueCpzYyksIE1hdGguY2VpbChyZWN0Lnktc291cmNlUmVjdC55KnNjKSk7XG5cdFx0Y3R4LnNjYWxlKHNjLHNjKTtcblx0XHRmcmFtZS5zb3VyY2UuZHJhdyhjdHgpOyAvLyBkaXNwbGF5IG9iamVjdCB3aWxsIGRyYXcgaXRzZWxmLlxuXHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0cmV0dXJuICgrK3RoaXMuX2luZGV4KSA8IHRoaXMuX2ZyYW1lcy5sZW5ndGg7XG5cdH1cblxufVxuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEByZWFkb25seVxuICogQHByb3RlY3RlZFxuICogQHR5cGUge1N0cmluZ31cbiAqL1xuU3ByaXRlU2hlZXRCdWlsZGVyLkVSUl9ESU1FTlNJT05TID0gXCJmcmFtZSBkaW1lbnNpb25zIGV4Y2VlZCBtYXggc3ByaXRlc2hlZXQgZGltZW5zaW9uc1wiO1xuLyoqXG4gKiBAc3RhdGljXG4gKiBAcmVhZG9ubHlcbiAqIEBwcm90ZWN0ZWRcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKi9cblNwcml0ZVNoZWV0QnVpbGRlci5FUlJfUlVOTklORyA9IFwiYSBidWlsZCBpcyBhbHJlYWR5IHJ1bm5pbmdcIjtcblxuLyoqXG4gKiBEaXNwYXRjaGVkIHdoZW4gYSBidWlsZCBjb21wbGV0ZXMuXG4gKiBAZXZlbnQgZWFzZWxqcy5TcHJpdGVTaGVldEJ1aWxkZXIjY29tcGxldGVcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSB0YXJnZXQgVGhlIG9iamVjdCB0aGF0IGRpc3BhdGNoZWQgdGhlIGV2ZW50LlxuICogQHByb3BlcnR5IHtTdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGUuXG4gKiBAc2luY2UgMC42LjBcbiAqL1xuXG4vKipcbiAqIERpc3BhdGNoZWQgd2hlbiBhbiBhc3luY2hyb25vdXMgYnVpbGQgaGFzIHByb2dyZXNzLlxuICogQGV2ZW50IGVhc2VsanMuU3ByaXRlU2hlZXRCdWlsZGVyI3Byb2dyZXNzXG4gKiBAcHJvcGVydHkge09iamVjdH0gdGFyZ2V0IFRoZSBvYmplY3QgdGhhdCBkaXNwYXRjaGVkIHRoZSBldmVudC5cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlLlxuICogQHByb3BlcnR5IHtOdW1iZXJ9IHByb2dyZXNzIFRoZSBjdXJyZW50IHByb2dyZXNzIHZhbHVlICgwLTEpLlxuICogQHNpbmNlIDAuNi4wXG4gKi9cbiIsIi8qXG4qIEBsaWNlbnNlIFNwcml0ZVNoZWV0VXRpbHNcbiogVmlzaXQgaHR0cDovL2NyZWF0ZWpzLmNvbS8gZm9yIGRvY3VtZW50YXRpb24sIHVwZGF0ZXMgYW5kIGV4YW1wbGVzLlxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTcgZ3NraW5uZXIuY29tLCBpbmMuXG4qXG4qIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4qIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXG4qIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxuKiByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSxcbiogY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4qIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXG4qIGNvbmRpdGlvbnM6XG4qXG4qIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4qIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuKlxuKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuKiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcbiogT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiogTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcbiogSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXG4qIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuKiBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SXG4qIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiovXG5cbmltcG9ydCBjcmVhdGVDYW52YXMgZnJvbSBcIi4vQ2FudmFzXCI7XG5cbi8qKlxuICogVGhlIFNwcml0ZVNoZWV0VXRpbHMgY2xhc3MgaXMgYSBjb2xsZWN0aW9uIG9mIHN0YXRpYyBtZXRob2RzIGZvciB3b3JraW5nIHdpdGgge3sjY3Jvc3NMaW5rIFwiU3ByaXRlU2hlZXRcIn19e3svY3Jvc3NMaW5rfX1zLlxuICogQSBzcHJpdGUgc2hlZXQgaXMgYSBzZXJpZXMgb2YgaW1hZ2VzICh1c3VhbGx5IGFuaW1hdGlvbiBmcmFtZXMpIGNvbWJpbmVkIGludG8gYSBzaW5nbGUgaW1hZ2Ugb24gYSByZWd1bGFyIGdyaWQuIEZvclxuICogZXhhbXBsZSwgYW4gYW5pbWF0aW9uIGNvbnNpc3Rpbmcgb2YgOCAxMDB4MTAwIGltYWdlcyBjb3VsZCBiZSBjb21iaW5lZCBpbnRvIGEgNDAweDIwMCBzcHJpdGUgc2hlZXQgKDQgZnJhbWVzIGFjcm9zc1xuICogYnkgMiBoaWdoKS4gVGhlIFNwcml0ZVNoZWV0VXRpbHMgY2xhc3MgdXNlcyBhIHN0YXRpYyBpbnRlcmZhY2UgYW5kIHNob3VsZCBub3QgYmUgaW5zdGFudGlhdGVkLlxuICpcbiAqIEBtZW1iZXJvZiBlYXNlbGpzXG4gKiBAbmFtZSBlYXNlbGpzLlNwcml0ZVNoZWV0VXRpbHNcbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuXG5cdC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEB0eXBlIHtIVE1MQ2FudmFzRWxlbWVudCB8IE9iamVjdH1cblx0ICovXG5cdF93b3JraW5nQ2FudmFzOiBjcmVhdGVDYW52YXMoKSxcblxuXHQvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAdHlwZSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfVxuXHQgKi9cblx0Z2V0IF93b3JraW5nQ29udGV4dCAoKSB7IHJldHVybiB0aGlzLl93b3JraW5nQ2FudmFzLmdldENvbnRleHQoXCIyZFwiKTsgfSxcblxuXHQvKipcblx0ICogUmV0dXJucyBhIHNpbmdsZSBmcmFtZSBvZiB0aGUgc3BlY2lmaWVkIHNwcml0ZSBzaGVldCBhcyBhIG5ldyBQTkcgaW1hZ2UuIEFuIGV4YW1wbGUgb2Ygd2hlbiB0aGlzIG1heSBiZSB1c2VmdWwgaXNcblx0ICogdG8gdXNlIGEgc3ByaXRlc2hlZXQgZnJhbWUgYXMgdGhlIHNvdXJjZSBmb3IgYSBiaXRtYXAgZmlsbC5cblx0ICpcblx0ICogPHN0cm9uZz5XQVJOSU5HOjwvc3Ryb25nPiBJbiBhbG1vc3QgYWxsIGNhc2VzIGl0IGlzIGJldHRlciB0byBkaXNwbGF5IGEgc2luZ2xlIGZyYW1lIHVzaW5nIGEge0BsaW5rIGVhc2VsanMuU3ByaXRlfVxuXHQgKiB3aXRoIGEge0BsaW5rIGVhc2VsanMuU3ByaXRlI2dvdG9BbmRTdG9wfSBjYWxsIHRoYW4gaXQgaXMgdG8gc2xpY2Ugb3V0IGEgZnJhbWUgdXNpbmcgdGhpc1xuXHQgKiBtZXRob2QgYW5kIGRpc3BsYXkgaXQgd2l0aCBhIEJpdG1hcCBpbnN0YW5jZS4gWW91IGNhbiBhbHNvIGNyb3AgYW4gaW1hZ2UgdXNpbmcgdGhlIHtAbGluayBlYXNlbGpzLkJpdG1hcCNzb3VyY2VSZWN0fVxuXHQgKiBwcm9wZXJ0eSBvZiB7QGxpbmsgZWFzZWxqcy5CaXRtYXB9LlxuXHQgKlxuXHQgKiBUaGUgZXh0cmFjdEZyYW1lIG1ldGhvZCBtYXkgY2F1c2UgY3Jvc3MtZG9tYWluIHdhcm5pbmdzIHNpbmNlIGl0IGFjY2Vzc2VzIHBpeGVscyBkaXJlY3RseSBvbiB0aGUgY2FudmFzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge2Vhc2VsanMuU3ByaXRlU2hlZXR9IHNwcml0ZVNoZWV0IFRoZSBTcHJpdGVTaGVldCBpbnN0YW5jZSB0byBleHRyYWN0IGEgZnJhbWUgZnJvbS5cblx0ICogQHBhcmFtIHtOdW1iZXIgfCBTdHJpbmd9IGZyYW1lT3JBbmltYXRpb24gVGhlIGZyYW1lIG51bWJlciBvciBhbmltYXRpb24gbmFtZSB0byBleHRyYWN0LiBJZiBhbiBhbmltYXRpb25cblx0ICogbmFtZSBpcyBzcGVjaWZpZWQsIG9ubHkgdGhlIGZpcnN0IGZyYW1lIG9mIHRoZSBhbmltYXRpb24gd2lsbCBiZSBleHRyYWN0ZWQuXG5cdCAqIEByZXR1cm4ge0hUTUxJbWFnZUVsZW1lbnR9IGEgc2luZ2xlIGZyYW1lIG9mIHRoZSBzcGVjaWZpZWQgc3ByaXRlIHNoZWV0IGFzIGEgbmV3IFBORyBpbWFnZS5cblx0ICovXG5cdGV4dHJhY3RGcmFtZSAoc3ByaXRlU2hlZXQsIGZyYW1lT3JBbmltYXRpb24pIHtcblx0XHRpZiAoaXNOYU4oZnJhbWVPckFuaW1hdGlvbikpIHtcblx0XHRcdGZyYW1lT3JBbmltYXRpb24gPSBzcHJpdGVTaGVldC5nZXRBbmltYXRpb24oZnJhbWVPckFuaW1hdGlvbikuZnJhbWVzWzBdO1xuXHRcdH1cblx0XHRsZXQgZGF0YSA9IHNwcml0ZVNoZWV0LmdldEZyYW1lKGZyYW1lT3JBbmltYXRpb24pO1xuXHRcdGlmICghZGF0YSkgeyByZXR1cm4gbnVsbDsgfVxuXHRcdGxldCByID0gZGF0YS5yZWN0O1xuXHRcdGxldCBjYW52YXMgPSB0aGlzLl93b3JraW5nQ2FudmFzO1xuXHRcdGNhbnZhcy53aWR0aCA9IHIud2lkdGg7XG5cdFx0Y2FudmFzLmhlaWdodCA9IHIuaGVpZ2h0O1xuXHRcdHRoaXMuX3dvcmtpbmdDb250ZXh0LmRyYXdJbWFnZShkYXRhLmltYWdlLCByLngsIHIueSwgci53aWR0aCwgci5oZWlnaHQsIDAsIDAsIHIud2lkdGgsIHIuaGVpZ2h0KTtcblx0XHRsZXQgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcblx0XHRpbWcuc3JjID0gY2FudmFzLnRvRGF0YVVSTChcImltYWdlL3BuZ1wiKTtcblx0XHRyZXR1cm4gaW1nO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwYXJhbSB7ZWFzZWxqcy5TcHJpdGVTaGVldH0gc3ByaXRlU2hlZXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB2XG5cdCAqL1xuXHRfZmxpcCAoc3ByaXRlU2hlZXQsIGNvdW50LCBoLCB2KSB7XG5cdFx0bGV0IGltZ3MgPSBzcHJpdGVTaGVldC5faW1hZ2VzO1xuXHRcdGxldCBjYW52YXMgPSB0aGlzLl93b3JraW5nQ2FudmFzO1xuXHRcdGxldCBjdHggPSB0aGlzLl93b3JraW5nQ29udGV4dDtcblx0XHRjb25zdCBpbCA9IGltZ3MubGVuZ3RoL2NvdW50O1xuXHRcdGZvciAobGV0IGk9MDsgaTxpbDsgaSsrKSB7XG5cdFx0XHRsZXQgc3JjID0gaW1nc1tpXTtcblx0XHRcdHNyYy5fX3RtcCA9IGk7IC8vIGEgYml0IGhhY2t5LCBidXQgZmFzdGVyIHRoYW4gZG9pbmcgaW5kZXhPZiBiZWxvdy5cblx0XHRcdGN0eC5zZXRUcmFuc2Zvcm0oMSwwLDAsMSwwLDApO1xuXHRcdFx0Y3R4LmNsZWFyUmVjdCgwLDAsY2FudmFzLndpZHRoKzEsY2FudmFzLmhlaWdodCsxKTtcblx0XHRcdGNhbnZhcy53aWR0aCA9IHNyYy53aWR0aDtcblx0XHRcdGNhbnZhcy5oZWlnaHQgPSBzcmMuaGVpZ2h0O1xuXHRcdFx0Y3R4LnNldFRyYW5zZm9ybShoPy0xOjEsIDAsIDAsIHY/LTE6MSwgaD9zcmMud2lkdGg6MCwgdj9zcmMuaGVpZ2h0OjApO1xuXHRcdFx0Y3R4LmRyYXdJbWFnZShzcmMsMCwwKTtcblx0XHRcdGxldCBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuXHRcdFx0aW1nLnNyYyA9IGNhbnZhcy50b0RhdGFVUkwoXCJpbWFnZS9wbmdcIik7XG5cdFx0XHQvLyB3b3JrIGFyb3VuZCBhIHN0cmFuZ2UgYnVnIGluIFNhZmFyaTpcblx0XHRcdGltZy53aWR0aCA9IChzcmMud2lkdGh8fHNyYy5uYXR1cmFsV2lkdGgpO1xuXHRcdFx0aW1nLmhlaWdodCA9IChzcmMuaGVpZ2h0fHxzcmMubmF0dXJhbEhlaWdodCk7XG5cdFx0XHRpbWdzLnB1c2goaW1nKTtcblx0XHR9XG5cblx0XHRsZXQgZnJhbWVzID0gc3ByaXRlU2hlZXQuX2ZyYW1lcztcblx0XHRjb25zdCBmbCA9IGZyYW1lcy5sZW5ndGgvY291bnQ7XG5cdFx0Zm9yIChsZXQgaT0wOyBpPGZsOyBpKyspIHtcblx0XHRcdGxldCBzcmMgPSBmcmFtZXNbaV07XG5cdFx0XHRsZXQgcmVjdCA9IHNyYy5yZWN0LmNsb25lKCk7XG5cdFx0XHRsZXQgaW1nID0gaW1nc1tzcmMuaW1hZ2UuX190bXAraWwqY291bnRdO1xuXG5cdFx0XHRsZXQgZnJhbWUgPSB7aW1hZ2U6aW1nLHJlY3QscmVnWDpzcmMucmVnWCxyZWdZOnNyYy5yZWdZfTtcblx0XHRcdGlmIChoKSB7XG5cdFx0XHRcdHJlY3QueCA9IChpbWcud2lkdGh8fGltZy5uYXR1cmFsV2lkdGgpLXJlY3QueC1yZWN0LndpZHRoOyAvLyB1cGRhdGUgcmVjdFxuXHRcdFx0XHRmcmFtZS5yZWdYID0gcmVjdC53aWR0aC1zcmMucmVnWDsgLy8gdXBkYXRlIHJlZ2lzdHJhdGlvbiBwb2ludFxuXHRcdFx0fVxuXHRcdFx0aWYgKHYpIHtcblx0XHRcdFx0cmVjdC55ID0gKGltZy5oZWlnaHR8fGltZy5uYXR1cmFsSGVpZ2h0KS1yZWN0LnktcmVjdC5oZWlnaHQ7ICAvLyB1cGRhdGUgcmVjdFxuXHRcdFx0XHRmcmFtZS5yZWdZID0gcmVjdC5oZWlnaHQtc3JjLnJlZ1k7IC8vIHVwZGF0ZSByZWdpc3RyYXRpb24gcG9pbnRcblx0XHRcdH1cblx0XHRcdGZyYW1lcy5wdXNoKGZyYW1lKTtcblx0XHR9XG5cblx0XHRsZXQgc2Z4ID0gYF8ke2g/XCJoXCI6XCJcIn0ke3Y/XCJ2XCI6XCJcIn1gO1xuXHRcdGxldCBuYW1lcyA9IHNwcml0ZVNoZWV0Ll9hbmltYXRpb25zO1xuXHRcdGxldCBkYXRhID0gc3ByaXRlU2hlZXQuX2RhdGE7XG5cdFx0Y29uc3QgYWwgPSBuYW1lcy5sZW5ndGgvY291bnQ7XG5cdFx0Zm9yIChsZXQgaT0wOyBpPGFsOyBpKyspIHtcblx0XHRcdGxldCBuYW1lID0gbmFtZXNbaV07XG5cdFx0XHRsZXQgc3JjID0gZGF0YVtuYW1lXTtcblx0XHRcdGxldCBhbmltID0ge25hbWU6bmFtZStzZngsc3BlZWQ6c3JjLnNwZWVkLG5leHQ6c3JjLm5leHQsZnJhbWVzOltdfTtcblx0XHRcdGlmIChzcmMubmV4dCkgeyBhbmltLm5leHQgKz0gc2Z4OyB9XG5cdFx0XHRsZXQgZnJhbWVzID0gc3JjLmZyYW1lcztcblx0XHRcdGZvciAobGV0IGk9MCxsPWZyYW1lcy5sZW5ndGg7aTxsO2krKykge1xuXHRcdFx0XHRhbmltLmZyYW1lcy5wdXNoKGZyYW1lc1tpXStmbCpjb3VudCk7XG5cdFx0XHR9XG5cdFx0XHRkYXRhW2FuaW0ubmFtZV0gPSBhbmltO1xuXHRcdFx0bmFtZXMucHVzaChhbmltLm5hbWUpO1xuXHRcdH1cblx0fVxuXG59XG4iLCIvKipcbiAqIEBsaWNlbnNlIFdlYkdMSW5zcGVjdG9yXG4gKiBWaXNpdCBodHRwOi8vY3JlYXRlanMuY29tLyBmb3IgZG9jdW1lbnRhdGlvbiwgdXBkYXRlcyBhbmQgZXhhbXBsZXMuXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IGdza2lubmVyLmNvbSwgaW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gKiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxuICogZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0XG4gKiByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSxcbiAqIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiAqIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXG4gKiBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gKiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICogRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTXG4gKiBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICogTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcbiAqIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLFxuICogV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4gKiBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SXG4gKiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gKi9cblxuaW1wb3J0IHsgRXZlbnREaXNwYXRjaGVyIH0gZnJvbSBcIkBjcmVhdGVqcy9jb3JlXCI7XG5cbiAvKipcbiAgKiBBIHV0aWxpdHkgYW5kIGhlbHBlciBjbGFzcyBkZXNpZ25lZCB0byB3b3JrIHdpdGgge3sjY3Jvc3NMaW5rIFwiU3RhZ2VHTFwifX17ey9jcm9zc0xpbmt9fSB0byBoZWxwIGludmVzdGlnYXRlIGFuZFxuICAqIHRlc3QgcGVyZm9ybWFuY2Ugb3IgZGlzcGxheSBwcm9ibGVtcy4gSXQgY29udGFpbnMgbG9nZ2luZyBmdW5jdGlvbnMgdG8gYW5hbHl6ZSBiZWhhdmlvdXIgYW5kIHBlcmZvcm1hbmNlIHRlc3RpbmdcbiAgKiB1dGlsaXRpZXMuXG4gICpcbiAgKiBAbWVtYmVyb2YgZWFzZWxqc1xuICAqIEBleHRlbmRzIGNvcmUuRXZlbnREaXNwYXRjaGVyXG4gICpcbiAgKiBAcGFyYW0ge1N0YWdlR0x9IHN0YWdlIFRoZSBkZWZhdWx0IHN0YWdlIHRvIHVzZSB3aGVuIG5vbmUgaXMgc3VwcGxpZWQuXG4gICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXZWJHTEluc3BlY3RvciBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlciB7XG5cblx0Y29uc3RydWN0b3IgKHN0YWdlKSB7XG5cdFx0c3VwZXIoKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBpbnRlcm5hbCByZWZlcmVuY2UgdG8gdGhlIGRlZmF1bHQgc3RhZ2UgdGhpcyBJbnNwZWN0b3IgaXMgZm9yLlxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7ZWFzZWxqcy5TdGFnZUdMfVxuXHRcdCAqL1xuXHRcdHRoaXMuX3N0YWdlID0gc3RhZ2U7XG5cdH1cblxuXHQvKipcblx0ICogVXRpbGl0eSBmdW5jdGlvbiBmb3IgdXNlIHdpdGgge0BsaW5rIGVhc2VsanMuV2ViR0xJbnNwZWN0b3IjbG9nRGVwdGh9LiBMb2dzIGFuIGl0ZW0ncyBwb3NpdGlvbiBhbmQgcmVnaXN0cmF0aW9uLlxuXHQgKiBVc2VmdWwgdG8gc2VlIGlmIHNvbWV0aGluZyBpcyBiZWluZyBmb3JjZWQgb2ZmIHNjcmVlbiBvciBoYXMgYW4gaW50ZWdlciBwb3NpdGlvbi5cblx0ICogQHBhcmFtIHtlYXNlbGpzLkRpc3BsYXlPYmplY3R9IGl0ZW0gVGhlIGl0ZW0gd2UncmUgY3VycmVudGx5IGxvZ2dpbmcgYWJvdXQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbcHJlcGVuZF0gVGhlIHN0cmluZyB0byBzaG93IGJlZm9yZSB0aGUgaXRlbSwgdXN1YWxseSBmb3JtYXR0aW5nIGZvciBhIHRyZWUgdmlldy5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGRpc3BQcm9wcyAoaXRlbSwgcHJlcGVuZCA9IFwiXCIpIHtcblx0XHRsZXQgcCA9IGBcXHRQOiAke2l0ZW0ueC50b0ZpeGVkKDIpfXgke2l0ZW0ueS50b0ZpeGVkKDIpfVxcdGA7XG5cdFx0bGV0IHIgPSBgXFx0UjogJHtpdGVtLnJlZ1gudG9GaXhlZCgyKX14JHtpdGVtLnJlZ1kudG9GaXhlZCgyKX1cXHRgO1xuXHRcdFdlYkdMSW5zcGVjdG9yLl9sb2cocHJlcGVuZCwgYCR7aXRlbS50b1N0cmluZygpfVxcdGAsIHAsIHIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIExvZyB3aXRoIGFsdGVybmF0ZU91dHB1dCBpZiBhdmFpbGFibGUsIGRlZmF1bHRpbmcgdG8gdGhlIGNvbnNvbGUuXG5cdCAqIEBwYXJhbSB7Li4uKn0gaW5mbyBUaGUgaW5mbyB0byBsb2cuXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBfbG9nICguLi5pbmZvKSB7XG5cdFx0aWYgKFdlYkdMSW5zcGVjdG9yLmFsdGVybmF0ZU91dHB1dCkge1xuXHRcdFx0V2ViR0xJbnNwZWN0b3IuYWx0ZXJuYXRlT3V0cHV0LmxvZyguLi5pbmZvKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc29sZS5sb2coLi4uaW5mbyk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFBlcmZvcm0gYWxsIG9mIHRoZSBsb2dnaW5nIHJlcG9ydHMgYXQgb25jZS5cblx0ICogQHBhcmFtIHtlYXNlbGpzLlN0YWdlR0x9IFtzdGFnZV0gVGhlIHN0YWdlIHRvIGxvZyBpbmZvcm1hdGlvbiBmb3IuXG5cdCAqL1xuXHRsb2cgKHN0YWdlKSB7XG5cdFx0aWYgKCFzdGFnZSkgeyBzdGFnZSA9IHRoaXMuX3N0YWdlOyB9XG5cdFx0V2ViR0xJbnNwZWN0b3IuX2xvZyhgQmF0Y2hlcyBQZXIgRHJhdzogJHsoc3RhZ2UuX2JhdGNoSUQvc3RhZ2UuX2RyYXdJRCkudG9GaXhlZCg0KX1gKTtcblx0XHR0aGlzLmxvZ0NvbnRleHRJbmZvKHN0YWdlLl93ZWJHTENvbnRleHQpO1xuXHRcdHRoaXMubG9nRGVwdGgoc3RhZ2UuY2hpbGRyZW4sIFwiXCIpO1xuXHRcdHRoaXMubG9nVGV4dHVyZUZpbGwoc3RhZ2UpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlcGxhY2UgdGhlIHN0YWdlJ3MgRHJhdyBjb21tYW5kIHdpdGggYW4gZW1wdHkgZHJhdyBjb21tYW5kLiBUaGlzIGlzIHVzZWZ1bCBmb3IgdGVzdGluZyBwZXJmb3JtYW5jZSwgYW5kIGlnbm9yaW5nIHJlbmRlcmluZy5cblx0ICogQHBhcmFtIHtTdGFnZUdMfSBbc3RhZ2U9XSBUaGUgc3RhZ2UgdG8gbG9nIGluZm9ybWF0aW9uIGZvci5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbZW5hYmxlZF0gRm9yY2UgZW5hYmxlZC4gSWYgbGVmdCB1bmRlZmluZWQsIGl0IHdpbGwgdG9nZ2xlLlxuXHQgKi9cblx0dG9nZ2xlR1BVRHJhdyAoc3RhZ2UsIGVuYWJsZWQpIHtcblx0XHRpZiAoIXN0YWdlKSB7IHN0YWdlID0gdGhpcy5fc3RhZ2U7IH1cblxuXHRcdGlmIChlbmFibGVkID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGVuYWJsZWQgPSAhIXN0YWdlLl9kcmF3QnVmZmVyc187XG5cdFx0fVxuXG5cdFx0aWYgKGVuYWJsZWQgJiYgc3RhZ2UuX2RyYXdCdWZmZXJzXykge1xuXHRcdFx0c3RhZ2UuX2RyYXdCdWZmZXJzID0gc3RhZ2UuX2RyYXdCdWZmZXJzXztcblx0XHRcdHN0YWdlLl9kcmF3QnVmZmVyc18gPSB1bmRlZmluZWQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0YWdlLl9kcmF3QnVmZmVyc18gPSBzdGFnZS5fZHJhd0J1ZmZlcnM7XG5cdFx0XHRzdGFnZS5fZHJhd0J1ZmZlcnMgPSBmdW5jdGlvbiBfaW5zcGVjdG9yRHJhd0J1ZmZlcnMgKGdsKSB7XG5cdFx0XHRcdGlmICh0aGlzLnZvY2FsRGVidWcpIHtcblx0XHRcdFx0XHRXZWJHTEluc3BlY3Rvci5fbG9nKGBCbGFua0RyYXdbJHt0aGlzLl9kcmF3SUR9OiR7dGhpcy5fYmF0Y2hJRH1dIDogJHt0aGlzLmJhdGNoUmVhc29ufWApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZWN1cnNpdmVseSB3YWxrIHRoZSBlbnRpcmUgZGlzcGxheSB0cmVlLCBsb2cgdGhlIGF0dGFjaGVkIGl0ZW1zLCBhbmQgZGlzcGxheSBpdCBpbiBhIHRyZWUgdmlldy5cblx0ICogQHBhcmFtIHtBcnJheX0gW2NoaWxkcmVuXSBUaGUgY2hpbGRyZW4gYXJyYXkgdG8gd2FsayB0aHJvdWdoLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW3ByZXBlbmRdIFdoYXQgdG8gcHJlcGVuZCB0byB0aGlzIG91dHB1dCBmcm9tIHRoaXMgcG9pbnQgb253YXJkcy5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gW2xvZ0Z1bmNdIEN1c3RvbSBsb2dnaW5nIGZ1bmN0aW9uLCBtYWlubHkgZm9yIGZpbHRlcmluZyBvciBmb3JtYXR0aW5nIG91dHB1dC5cblx0ICovXG5cdGxvZ0RlcHRoIChjaGlsZHJlbiwgcHJlcGVuZCA9IFwiXCIsIGxvZ0Z1bmMgPSBXZWJHTEluc3BlY3Rvci5fbG9nKSB7XG5cdFx0aWYgKCFjaGlsZHJlbikgeyBjaGlsZHJlbiA9IHRoaXMuX3N0YWdlLmNoaWxkcmVuOyB9XG5cdFx0Y29uc3QgbCA9IGNoaWxkcmVuLmxlbmd0aDtcblx0XHRmb3IgKGxldCBpPTA7IGk8bDsgaSsrKSB7XG5cdFx0XHRsZXQgY2hpbGQgPSBjaGlsZHJlbltpXTtcblx0XHRcdGxvZ0Z1bmMoYCR7cHJlcGVuZH0tYCwgY2hpbGQpO1xuXHRcdFx0aWYgKGNoaWxkLmNoaWxkcmVuICYmIGNoaWxkLmNoaWxkcmVuLmxlbmd0aCkge1xuXHRcdFx0XHR0aGlzLmxvZ0RlcHRoKGNoaWxkLmNoaWxkcmVuLCBgfCR7cHJlcGVuZH1gLCBsb2dGdW5jKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogRXhhbWluZSB0aGUgY29udGV4dCBhbmQgcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCBpdHMgY2FwYWJpbGl0aWVzLlxuXHQgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gW2dsXSBUaGUgV2ViR0wgY29udGV4dCB0byBpbnNwZWN0LlxuXHQgKi9cblx0bG9nQ29udGV4dEluZm8gKGdsKSB7XG5cdFx0aWYgKCFnbCkgeyBnbCA9IHRoaXMuX3N0YWdlLl93ZWJHTENvbnRleHQ7IH1cblx0XHRsZXQgZGF0YSA9IGBcblx0XHRcdD09IExPRzpcXG5cblx0XHRcdE1heCB0ZXh0dXJlcyBwZXIgZHJhdzogJHtnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX1RFWFRVUkVfSU1BR0VfVU5JVFMpfVxcblxuXHRcdFx0TWF4IHRleHR1cmVzIGFjdGl2ZTogJHtnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX0NPTUJJTkVEX1RFWFRVUkVfSU1BR0VfVU5JVFMpfVxcblxuXHRcdFx0XFxuXG5cdFx0XHRNYXggdGV4dHVyZSBzaXplOiAke2dsLmdldFBhcmFtZXRlcihnbC5NQVhfVEVYVFVSRV9TSVpFKS8yfVxcblxuXHRcdFx0TWF4IGNhY2hlIHNpemU6ICR7Z2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9SRU5ERVJCVUZGRVJfU0laRSkvMn1cXG5cblx0XHRcdFxcblxuXHRcdFx0TWF4IGF0dHJpYnV0ZXMgcGVyIHZlcnRleDogJHtnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX1ZFUlRFWF9BVFRSSUJTKX1cXG5cblx0XHRcdFdlYkdMIFZlcnNpb24gc3RyaW5nOiAke2dsLmdldFBhcmFtZXRlcihnbC5WRVJTSU9OKX1cXG5cblx0XHRcdD09PT09PVxuXHRcdGA7XG5cdFx0V2ViR0xJbnNwZWN0b3IuX2xvZyhkYXRhKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTaW11bGF0ZSByZW5kZXJzIGFuZCB3YXRjaCB3aGF0IGhhcHBlbnMgZm9yIHRleHR1cmVzIG1vdmluZyBhcm91bmQgYmV0d2VlbiBkcmF3IGNhbGxzLiBBIHRleHR1cmUgbW92aW5nIGJldHdlZW5cblx0ICogc2xvdHMgbWVhbnMgaXQgd2FzIHJlbW92ZWQgYW5kIHRoZW4gcmUtYWRkZWQgdG8gZHJhdyBjYWxscy4gUGVyZm9ybWFuY2UgbWF5IGJlIGJldHRlciBpZiBpdCB3YXMgYWxsb3dlZCB0byBzdGF5XG5cdCAqIGluIHBsYWNlLlxuXHQgKiBAcGFyYW0ge1N0YWdlR0x9IFtzdGFnZV0gVGhlIHN0YWdlIHRvIGxvZyBpbmZvcm1hdGlvbiBmb3IuXG5cdCAqL1xuXHRsb2dUZXh0dXJlRmlsbCAoc3RhZ2UpIHtcblx0XHRpZiAoIXN0YWdlKSB7IHN0YWdlID0gdGhpcy5fc3RhZ2U7IH1cblxuXHRcdGxldCBkaWN0ID0gc3RhZ2UuX3RleHR1cmVEaWN0aW9uYXJ5O1xuXHRcdGxldCBjb3VudCA9IHN0YWdlLl9iYXRjaFRleHR1cmVDb3VudDtcblx0XHRXZWJHTEluc3BlY3Rvci5fbG9nKGAke3RleHR1cmVNYXh9OiAke2NvdW50fWApO1xuXHRcdGxldCBvdXRwdXQgPSBbXTtcblx0XHRmb3IgKGxldCBuIGluIGRpY3QpIHtcblx0XHRcdGxldCBzdHIgPSBuLnJlcGxhY2Uod2luZG93LmxvY2F0aW9uLm9yaWdpbiwgXCJcIik7XG5cdFx0XHRsZXQgdGV4ID0gZGljdFtuXTtcblx0XHRcdGxldCBzaGlmdGVkID0gdGV4Ll9sYXN0QWN0aXZlSW5kZXg/dGV4Ll9sYXN0QWN0aXZlSW5kZXggPT09IHRleC5fYWN0aXZlSW5kZXg6ZmFsc2U7XG5cdFx0XHRvdXRwdXQucHVzaCh7c3JjLCBlbGVtZW50OnRleCwgc2hpZnRlZH0pO1xuXHRcdFx0dGV4Ll9sYXN0QWN0aXZlSW5kZXggPSB0ZXguX2FjdGl2ZUluZGV4O1xuXHRcdH1cblxuXHRcdG91dHB1dC5zb3J0KChhLGIpID0+IHtcblx0XHRcdGlmIChhLmVsZW1lbnQuX2RyYXdJRCA9PT0gc3RhZ2UuX2RyYXdJRCkgeyByZXR1cm4gMTsgfVxuXHRcdFx0aWYgKGEuZWxlbWVudC5fZHJhd0lEIDwgYi5lbGVtZW50Ll9kcmF3SUQpIHsgcmV0dXJuIC0xOyB9XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9KTtcblxuXHRcdGNvbnN0IGwgPSBvdXRwdXQubGVuZ3RoO1xuXHRcdGZvciAobGV0IGk9MDsgaTxsOyBpKyspIHtcblx0XHRcdGxldCBvdXQgPSBvdXRwdXRbaV07XG5cdFx0XHRsZXQgYWN0aXZlID0gb3V0LmVsZW1lbnQuX2RyYXdJRCA9PT0gc3RhZ2UuX2RyYXdJRDtcblx0XHRcdFdlYkdMSW5zcGVjdG9yLl9sb2coYFske291dC5zcmN9XSAke2FjdGl2ZT9cIkFDVElWRVwiOlwic3RhbGVcIn0gJHtvdXQuc2hpZnRlZD9cInN0ZWFkeVwiOlwiRFJJRlRcIn1gLCBvdXQuZWxlbWVudCk7XG5cdFx0fVxuXHR9XG5cbn1cblxuLyoqXG4gKiBBbHRlcm5hdGUgb3V0cHV0IGZvciBkZWJ1Z2dpbmcgc2l0dWF0aW9ucyB3aGVyZSBcImNvbnNvbGVcIiBpcyBub3QgYXZhaWxhYmxlLCBpLmUuIE1vYmlsZSBvciByZW1vdGUgZGVidWdnaW5nLlxuICogRXhwZWN0cyBvYmplY3Qgd2l0aCBhIFwibG9nXCIgZnVuY3Rpb24gdGhhdCB0YWtlcyBhbnkgbnVtYmVyIG9mIHBhcmFtcy5cbiAqIEB0eXBlIHtDb25zb2xlfVxuICogQGRlZmF1bHQgbnVsbFxuICogQHN0YXRpY1xuICogQHByb3RlY3RlZFxuICovXG5XZWJHTEluc3BlY3Rvci5hbHRlcm5hdGVPdXRwdXQgPSBudWxsO1xuIiwiLyoqXG4gKiBUaGUgY29yZSBjbGFzc2VzIG9mIEVhc2VsSlMuXG4gKiBAbmFtZXNwYWNlIGVhc2VsanNcbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgU3RhZ2UsIFNoYXBlIH0gZnJvbSBcIkBjcmVhdGVqcy9lYXNlbGpzXCI7XG4gKiBjb25zdCBzdGFnZSA9IG5ldyBTdGFnZShcIm15Q2FudmFzXCIpO1xuICogY29uc3Qgc2hhcGUgPSBuZXcgU2hhcGUoKTtcbiAqIHNoYXBlLmdyYXBoaWNzLmJlZ2luRmlsbChcInJlZFwiKS5kcmF3Q2lyY2xlKDAsIDAsIDUwKTtcbiAqIHN0YWdlLmFkZENoaWxkKHNoYXBlKTtcbiAqIHN0YWdlLnVwZGF0ZSgpO1xuICovXG5cbi8qKlxuICogUkVBRE1FOiBFeHBvcnQgT3JkZXJcbiAqXG4gKiBEdWUgdG8gc29tZSBjbGFzc2VzIGhhdmluZyBjaXJjdWxhciBpbXBvcnQgYmluZGluZ3MgKHdoZXRoZXIgYXQgdGhlIHRvcCBvZiB0aGUgaW1wb3J0IGNoYWluIG9yIGRlZXBlciBpbiksXG4gKiBzb21lIGV4cG9ydHMgaGVyZSBhcmUgaW4gcmV2ZXJzZSBvcmRlciAoc3VjaCBhcyBDb250YWluZXIgYmVpbmcgZXhwb3J0ZWQgYmVmb3JlIERpc3BsYXlPYmplY3QpLlxuICogVGhpcyBpcyBleHBsYWluZWQgaGVyZTogaHR0cHM6Ly9naXRodWIuY29tL3JvbGx1cC9yb2xsdXAvaXNzdWVzLzg0NSNpc3N1ZWNvbW1lbnQtMjQwMjc3MTk0XG4gKi9cblxuLy8gY29yZVxuZXhwb3J0IHsgRXZlbnQsIEV2ZW50RGlzcGF0Y2hlciwgVGlja2VyIH0gZnJvbSBcIkBjcmVhdGVqcy9jb3JlXCI7XG5cbi8vIGRpc3BsYXlcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU3RhZ2VHTCB9IGZyb20gXCIuL2Rpc3BsYXkvU3RhZ2VHTFwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTdGFnZSB9IGZyb20gXCIuL2Rpc3BsYXkvU3RhZ2VcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQ29udGFpbmVyIH0gZnJvbSBcIi4vZGlzcGxheS9Db250YWluZXJcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRGlzcGxheU9iamVjdCB9IGZyb20gXCIuL2Rpc3BsYXkvRGlzcGxheU9iamVjdFwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBCaXRtYXAgfSBmcm9tIFwiLi9kaXNwbGF5L0JpdG1hcFwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBCaXRtYXBUZXh0IH0gZnJvbSBcIi4vZGlzcGxheS9CaXRtYXBUZXh0XCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIERPTUVsZW1lbnQgfSBmcm9tIFwiLi9kaXNwbGF5L0RPTUVsZW1lbnRcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgR3JhcGhpY3MgfSBmcm9tIFwiLi9kaXNwbGF5L0dyYXBoaWNzXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIE1vdmllQ2xpcCB9IGZyb20gXCIuL2Rpc3BsYXkvTW92aWVDbGlwXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFNoYWRvdyB9IGZyb20gXCIuL2Rpc3BsYXkvU2hhZG93XCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFNoYXBlIH0gZnJvbSBcIi4vZGlzcGxheS9TaGFwZVwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTcHJpdGUgfSBmcm9tIFwiLi9kaXNwbGF5L1Nwcml0ZVwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTcHJpdGVTaGVldCB9IGZyb20gXCIuL2Rpc3BsYXkvU3ByaXRlU2hlZXRcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgVGV4dCB9IGZyb20gXCIuL2Rpc3BsYXkvVGV4dFwiO1xuLy8gZXZlbnRzXG5leHBvcnQgeyBkZWZhdWx0IGFzIE1vdXNlRXZlbnQgfSBmcm9tIFwiLi9ldmVudHMvTW91c2VFdmVudFwiO1xuLy8gZmlsdGVyc1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBBbHBoYU1hcEZpbHRlciB9IGZyb20gXCIuL2ZpbHRlcnMvQWxwaGFNYXBGaWx0ZXJcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQWxwaGFNYXNrRmlsdGVyIH0gZnJvbSBcIi4vZmlsdGVycy9BbHBoYU1hc2tGaWx0ZXJcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQml0bWFwQ2FjaGUgfSBmcm9tIFwiLi9maWx0ZXJzL0JpdG1hcENhY2hlXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEJsdXJGaWx0ZXIgfSBmcm9tIFwiLi9maWx0ZXJzL0JsdXJGaWx0ZXJcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQ29sb3JGaWx0ZXIgfSBmcm9tIFwiLi9maWx0ZXJzL0NvbG9yRmlsdGVyXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIENvbG9yTWF0cml4IH0gZnJvbSBcIi4vZmlsdGVycy9Db2xvck1hdHJpeFwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBDb2xvck1hdHJpeEZpbHRlciB9IGZyb20gXCIuL2ZpbHRlcnMvQ29sb3JNYXRyaXhGaWx0ZXJcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRmlsdGVyIH0gZnJvbSBcIi4vZmlsdGVycy9GaWx0ZXJcIjtcbi8vIGdlb21cbmV4cG9ydCB7IGRlZmF1bHQgYXMgRGlzcGxheVByb3BzIH0gZnJvbSBcIi4vZ2VvbS9EaXNwbGF5UHJvcHNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTWF0cml4MkQgfSBmcm9tIFwiLi9nZW9tL01hdHJpeDJEXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFBvaW50IH0gZnJvbSBcIi4vZ2VvbS9Qb2ludFwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBSZWN0YW5nbGUgfSBmcm9tIFwiLi9nZW9tL1JlY3RhbmdsZVwiO1xuLy8gdWlcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQnV0dG9uSGVscGVyIH0gZnJvbSBcIi4vdWkvQnV0dG9uSGVscGVyXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFRvdWNoIH0gZnJvbSBcIi4vdWkvVG91Y2hcIjtcbi8vIHV0aWxzXG5leHBvcnQgeyBkZWZhdWx0IGFzIFNwcml0ZVNoZWV0QnVpbGRlciB9IGZyb20gXCIuL3V0aWxzL1Nwcml0ZVNoZWV0QnVpbGRlclwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTcHJpdGVTaGVldFV0aWxzIH0gZnJvbSBcIi4vdXRpbHMvU3ByaXRlU2hlZXRVdGlsc1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1aWQgfSBmcm9tIFwiLi91dGlscy91aWRcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgY3JlYXRlQ2FudmFzIH0gZnJvbSBcIi4vdXRpbHMvQ2FudmFzXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFdlYkdMSW5zcGVjdG9yIH0gZnJvbSBcIi4vdXRpbHMvV2ViR0xJbnNwZWN0b3JcIjtcbiIsImltcG9ydCAge1NoYXBlLCBTdGFnZX0gZnJvbSBcIkBjcmVhdGVqcy9lYXNlbGpzXCI7XG5pbXBvcnQgIHtUd2Vlbn0gZnJvbSBcIkBjcmVhdGVqcy90d2VlbmpzXCI7XG5cbmNvbnN0IHN0YWdlID0gbmV3IFN0YWdlKCdteUNhbnZhcycpO1xuXG5jb25zdCBjaXJjbGUgPSBuZXcgU2hhcGUoKTtcblxuY2lyY2xlLmdyYXBoaWNzLmJlZ2luRmlsbCgnRGFya1JlZCcpLmRyYXdDaXJjbGUoMCwwLDUwKTtcbnN0YWdlLmFkZENoaWxkKGNpcmNsZSk7XG5jaXJjbGUueCA9IDMwMDtcbmNpcmNsZS55ID0gMjAwO1xuXG5Ud2Vlbi5nZXQoY2lyY2xlLCB7bG9vcDogdHJ1ZX0pXG4gICAgLndhaXQoMzAwKVxuICAgIC50byh7eDogNzQwLCB5OiA0MDAsIHNjYWxlOiAyfSwgNzAwKVxuICAgIC50byh7eDogNDAwLCB5OiAwLCBzY2FsZTogMS40fSwgMTIwMClcbiAgICAudG8oe3g6IDUwMCwgeTogMzAwLCBzY2FsZTogM30sIDEyMDApXG4gICAgLnRvKHt4OiAzMDAsIHk6IDIwMCwgc2NhbGU6IDF9LCA3MDApO1xuXG51cGRhdGUoKTtcblxuLy8g5q+O44OV44Os44O844Og44K544OG44O844K444KS6Ieq5YuV5pu05paw44GZ44KLXG5mdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgc3RhZ2UudXBkYXRlKCk7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHVwZGF0ZSgpKTtcbn0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0\n')}]);